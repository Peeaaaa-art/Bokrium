(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component2.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component2(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config2) {
          if (hasOwnProperty2.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
          self2 = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            void 0,
            void 0,
            oldElement._owner,
            oldElement.props,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape2(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape2("" + element.key)) : index.toString(36);
        }
        function noop$1() {
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error2) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error2);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren2(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 1, payload._result = moduleObject;
              },
              function(error2) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 2, payload._result = error2;
              }
            );
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
          }
          if (1 === payload._status)
            return ctor = payload._result, void 0 === ctor && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ), "default" in ctor || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ), ctor.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function noop2() {
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error2) {
                ReactSharedInternals.thrownErrors.push(error2);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error2) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error2);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component2.prototype.isReactComponent = {};
        Component2.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component2.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        }, fnName;
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component2.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component2.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          V: null,
          actQueue: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty2 = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
              error: error2
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error2);
            return;
          }
          console.error(error2);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        exports.Children = {
          map: mapChildren2,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren2(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren2(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren2(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Component = Component2;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error2) {
            ReactSharedInternals.thrownErrors.push(error2);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error2) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error2 = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error2)) : reject(error2);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn2) {
          return function() {
            return fn2.apply(null, arguments);
          };
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config2, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config2) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty2.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config2,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config2.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
            for (propName in config2)
              !hasOwnProperty2.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            void 0,
            void 0,
            owner,
            props,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config2, children) {
          for (var i = 2; i < arguments.length; i++) {
            var node = arguments[i];
            isValidElement(node) && node._store && (node._store.validated = 1);
          }
          i = {};
          node = null;
          if (null != config2)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), node = "" + config2.key), config2)
              hasOwnProperty2.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config2[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          node && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type,
            node,
            void 0,
            void 0,
            getOwner(),
            i,
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render2) {
          null != render2 && render2.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render2 ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render2 ? "null" : typeof render2
          ) : 0 !== render2.length && 2 !== render2.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render2.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render2 && null != render2.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType2 = { $$typeof: REACT_FORWARD_REF_TYPE, render: render2 }, ownName;
          Object.defineProperty(elementType2, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render2.name || render2.displayName || (Object.defineProperty(render2, "name", { value: name }), render2.displayName = name);
            }
          });
          return elementType2;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: { _status: -1, _result: ctor },
            _init: lazyInitializer
          };
        };
        exports.memo = function(type, compare) {
          null == type && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
          } catch (error2) {
            reportGlobalError(error2);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context2) {
          var dispatcher = resolveDispatcher();
          Context2.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context2);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, createDeps, update) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          var dispatcher = resolveDispatcher();
          if ("function" === typeof update)
            throw Error(
              "useEffect CRUD overload is not enabled in this build of React."
            );
          return dispatcher.useEffect(create, createDeps);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first2 = heap[0], last = heap.pop();
          if (last !== first2) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left2 = heap[leftIndex], rightIndex = leftIndex + 1, right2 = heap[rightIndex];
              if (0 > compare(left2, last))
                rightIndex < length && 0 > compare(right2, left2) ? (heap[index] = right2, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left2, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right2, last))
                heap[index] = right2, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first2;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop2() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React4 = require_react(), Internals = {
          d: {
            f: noop2,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop2,
            C: noop2,
            L: noop2,
            m: noop2,
            X: noop2,
            S: noop2,
            M: noop2
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn2) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn2)
              return fn2();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn2, a) {
          return fn2(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnForMissingKey() {
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop$2() {
        }
        function setToSortedString(set) {
          var array = [];
          set.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return (type.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i = type.length - 1; 0 <= i; i--)
                  if ("string" === typeof type[i].name) return type[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function markCommitStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
        }
        function markComponentRenderStarted(fiber) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
        }
        function markComponentRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
        }
        function markRenderStarted(lanes) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
        }
        function markRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
        }
        function markStateUpdateScheduled(fiber, lane) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
        }
        function getLabelForLane(lane) {
          if (lane & 1) return "SyncHydrationLane";
          if (lane & 2) return "Sync";
          if (lane & 4) return "InputContinuousHydration";
          if (lane & 8) return "InputContinuous";
          if (lane & 16) return "DefaultHydration";
          if (lane & 32) return "Default";
          if (lane & 128) return "TransitionHydration";
          if (lane & 4194048) return "Transition";
          if (lane & 62914560) return "Retry";
          if (lane & 67108864) return "SelectiveHydration";
          if (lane & 134217728) return "IdleHydration";
          if (lane & 268435456) return "Idle";
          if (lane & 536870912) return "Offscreen";
          if (lane & 1073741824) return "Deferred";
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 4194048;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
          root2 = root2.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn2) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn2();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode2 = targetNode.parentNode; parentNode2; ) {
            if (targetInst = parentNode2[internalContainerInstanceKey] || parentNode2[internalInstanceKey]) {
              parentNode2 = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode2 && null !== parentNode2.child)
                for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                  if (parentNode2 = targetNode[internalInstanceKey])
                    return parentNode2;
                  targetNode = getParentSuspenseInstance(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode2;
            parentNode2 = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) return "";
          var frame = componentFrameCache.get(fn2);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn2, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn2.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn2()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn2.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn2.displayName));
                        "function" === typeof fn2 && componentFrameCache.set(fn2, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn2 && componentFrameCache.set(fn2, sampleLines);
          return sampleLines;
        }
        function formatOwnerStack(error2) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error2 = error2.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error2.startsWith("Error: react-stack-top-frame\n") && (error2 = error2.slice(29));
          prevPrepareStackTrace = error2.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error2 = error2.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error2.indexOf("react-stack-bottom-frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error2.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error2 = error2.slice(0, prevPrepareStackTrace);
          else return "";
          return error2;
        }
        function describeFiber(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            do {
              info += describeFiber(workInProgress2);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info, env = entry.env;
                    var JSCompiler_inline_result = describeBuiltInComponentFrame(
                      entry.name + (env ? " [" + env + "]" : "")
                    );
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn2) {
          return (fn2 = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(fn2) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          checkFormFieldValueStringCoercion(node[valueField]);
          var currentValue = "" + node[valueField];
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get2 = descriptor.get, set = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          node._valueTracker || (node._valueTracker = trackValueOnNode(node));
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc3) {
          doc3 = doc3 || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc3) return null;
          try {
            return doc3.activeElement || doc3.body;
          } catch (e) {
            return doc3.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput2(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
              return;
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
        }
        function setDefaultValue(node, type, value) {
          "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React4.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = true;
                setDefaultSelected && (node[i].defaultSelected = true);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i.length; node++)
            serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize2(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style3, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize2(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style3[styleName] = ("" + value).trim()) : style3[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty2.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry2) {
          if (hasOwnProperty2.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry2) {
            tagName = eventRegistry2.possibleRegistrationNames;
            if (eventRegistry2.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry2 = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry2)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry2
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry2) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry2) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn2, a, b) {
          if (isInsideEventHandler) return fn2(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn2(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn2 = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn2))
                for (a = 0; a < fn2.length; a++) restoreStateOfTarget(fn2[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start3, startValue = startText, startLength = startValue.length, end2, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start3 = 0; start3 < startLength && startValue[start3] === endValue[start3]; start3++) ;
          var minEnd = startLength - start3;
          for (end2 = 1; end2 <= minEnd && startValue[startLength - end2] === endValue[endLength - end2]; end2++) ;
          return fallbackText = endValue.slice(start3, 1 < end2 ? 1 - end2 : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root2, offset2) {
          var node = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root2 + node.textContent.length;
              if (root2 <= offset2 && nodeEnd >= offset2)
                return { node, offset: offset2 - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc3 = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc3) || (doc3 = activeElement, "selectionStart" in doc3 && hasSelectionCapabilities(doc3) ? doc3 = { start: doc3.selectionStart, end: doc3.selectionEnd } : (doc3 = (doc3.ownerDocument && doc3.ownerDocument.defaultView || window).getSelection(), doc3 = {
            anchorNode: doc3.anchorNode,
            anchorOffset: doc3.anchorOffset,
            focusNode: doc3.focusNode,
            focusOffset: doc3.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc3) || (lastSelection = doc3, doc3 = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc3.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc3 }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case 0:
            case 15:
            case 1:
              candidateType = type;
              break;
            case 11:
              candidateType = type.render;
          }
          if (null === resolveFamily)
            throw Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = false;
          type = false;
          null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (1 === tag ? type = true : needsRender = true)));
          null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = true);
          type && (fiber._debugNeedsRemount = true);
          if (type || needsRender)
            alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
          null === child || type || scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
          null !== sibling && scheduleFibersWithFamiliesRecursively(
            sibling,
            updatedFamilies,
            staleFamilies
          );
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component2) {
          Component2 = Component2.prototype;
          return !(!Component2 || !Component2.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput2(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              track(didHydrate);
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              ), track(didHydrate);
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error2) {
          null === hydrationErrors ? hydrationErrors = [error2] : hydrationErrors.push(error2);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache2) {
          cache2.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache2.refCount++;
        }
        function releaseCache(cache2) {
          cache2.refCount--;
          0 > cache2.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache2.refCount && scheduleCallback$2(NormalPriority, function() {
            cache2.controller.abort();
          });
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
          }
        }
        function startEffectTimer() {
          profilerStartTime = now();
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error2) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error2;
              for (error2 = 0; error2 < listeners.length; error2++)
                (0, listeners[error2])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function noop$3() {
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$3, noop$3), thenable = index);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$3, noop$3);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error2) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error2;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component2) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component2))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component2, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component2,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component2,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState$1
          }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter$1 = 0;
          thenableState$1 = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
            thenableIndexCounter$1 = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component2, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter$1 = localIdCounter = 0;
          thenableState$1 = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          thenable = trackUsedThenable(thenableState$1, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch2 = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch2];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              createEffectInstance(),
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch2 = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch2;
          return [initialState.memoizedState, dispatch2];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error2) {
              onActionError(actionQueue, node, error2);
            } finally {
              ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error2) {
              return onActionError(actionQueue, node, error2);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error2) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error2, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch2 = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch2, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch2 = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch2, false];
        }
        function pushSimpleEffect(tag, inst, create, createDeps) {
          tag = {
            tag,
            create,
            deps: createDeps,
            inst,
            next: null
          };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
          return tag;
        }
        function createEffectInstance() {
          return { destroy: void 0, resource: void 0 };
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
          var hook = mountWorkInProgressHook();
          createDeps = void 0 === createDeps ? null : createDeps;
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            createEffectInstance(),
            create,
            createDeps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, createDeps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error2) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error2 },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop$2 : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
          dispatchSetStateInternal(
            formFiber,
            resetStateQueue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start3 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start3
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start3 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start3
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "\xBB";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + treeId.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider);
                fiber = createUpdate(lane);
                var root2 = enqueueUpdate(provider, fiber, lane);
                null !== root2 && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                provider = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                fiber.payload = { cache: provider };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args);
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error2) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
          markStateUpdateScheduled(fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys2 = Object.keys(element.props), i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          return trackUsedThenable(thenableState, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType2 = element.type;
            if (elementType2 === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType2 || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType2 && null !== elementType2 && elementType2.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType2) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushOffscreenSuspenseHandler(fiber) {
          if (22 === fiber.tag) {
            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
              var current2 = fiber.alternate;
              null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
            }
          } else reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component2, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component2 = Component2.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component2)
              void 0 === newProps[_propName] && (newProps[_propName] = Component2[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error2) {
          reportGlobalError(error2);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error2) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error2 && null !== error2 && "string" === typeof error2.environmentName) {
            var JSCompiler_inline_result = error2.environmentName;
            error2 = [
              "%o\n\n%s\n\n%s\n",
              error2,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error2[0] ? error2.splice(
              0,
              1,
              badgeFormat + error2[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error2.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error2.unshift(console);
            JSCompiler_inline_result = bind2.apply(console.error, error2);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error2,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error2) {
          reportGlobalError(error2);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error2 = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error2);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error2, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error2 = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error2);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error2 = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error2] : workInProgressRootConcurrentErrors.push(error2);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error2 = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error2 && "function" === typeof error2.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error2))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
          Component2 = Component2.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component2,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
          if (null === current2) {
            var type = Component2.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component2.compare)
              return Component2 = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component2, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component2,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component2.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component2 = Component2.compare;
            Component2 = null !== Component2 ? Component2 : shallowEqual;
            if (Component2(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component2,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextChildren = workInProgress2.child = current2.child;
                for (prevState = 0; null !== nextChildren; )
                  prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                workInProgress2.childLanes = prevState & ~nextProps;
              } else workInProgress2.childLanes = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                nextProps,
                renderLanes2
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          return null;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
          if (Component2.prototype && "function" === typeof Component2.prototype.render) {
            var componentName2 = getComponentNameFromType(Component2) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component2.contextTypes && (componentName2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          Component2 = renderWithHooks(
            current2,
            workInProgress2,
            Component2,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component2, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component2,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component2 = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component2 && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component2.contextType;
            "contextType" in Component2 && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component2) && (didWarnAboutInvalidateContextType.add(Component2), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component2) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component2(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component2(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component2.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component2) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component2.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component2) || "Component";
                var newApiName = "function" === typeof Component2.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component2) || "Component";
            _instance.render || (Component2.prototype && "function" === typeof Component2.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component2.childContextTypes && !didWarnAboutChildContextTypes.has(Component2) && (didWarnAboutChildContextTypes.add(Component2), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component2.contextTypes && !didWarnAboutContextTypes$1.has(Component2) && (didWarnAboutContextTypes$1.add(Component2), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component2.prototype && Component2.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component2) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component2) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component2), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component2)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component2.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component2.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component2.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component2) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component2.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component2,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component2.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component2, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component2.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component2.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component2,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component2,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component2, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component2.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component2.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component2,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component2,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component2.getDerivedStateFromError)
              Component2 = null, profilerStartTime = -1;
            else {
              markComponentRenderStarted(workInProgress2);
              Component2 = callRenderInDEV(lane);
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  callRenderInDEV(lane);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              markComponentRenderStopped();
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component2,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component2, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component2) {
          Component2 && Component2.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component2.displayName || Component2.name || "Component"
          );
          "function" === typeof Component2.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component2.contextType && null !== Component2.contextType && (Component2 = getComponentNameFromType(Component2) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component2] || (console.error(
            "%s: Function components do not support contextType.",
            Component2
          ), didWarnAboutContextTypeOnFunctionComponent[Component2] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2451;
          var JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_componentStack_2453 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              if (isHydrating) {
                var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
                var JSCompiler_temp;
                if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
                  c: {
                    var instance = JSCompiler_object_inline_message_2450;
                    for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
                      if (!JSCompiler_temp) {
                        JSCompiler_temp = null;
                        break c;
                      }
                      instance = getNextHydratable(instance.nextSibling);
                      if (null === instance) {
                        JSCompiler_temp = null;
                        break c;
                      }
                    }
                    JSCompiler_temp = instance;
                  }
                  null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                  }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
                  JSCompiler_temp = !JSCompiler_temp;
                }
                JSCompiler_temp && (warnNonHydratedInstance(
                  workInProgress2,
                  JSCompiler_object_inline_message_2450
                ), throwOnHydrationMismatch(workInProgress2));
              }
              JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
              if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450))
                return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
              popSuspenseHandler(workInProgress2);
            }
            JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
            JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
            if (JSCompiler_object_inline_componentStack_2453)
              return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2450
                },
                JSCompiler_object_inline_componentStack_2453
              ), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2452,
                JSCompiler_object_inline_componentStack_2453,
                renderLanes2,
                null
              ), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              JSCompiler_object_inline_message_2450
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
            if (didSuspend)
              workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "visible",
                  children: JSCompiler_object_inline_stack_2452.children
                },
                JSCompiler_object_inline_message_2450
              ), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_message_2450,
                renderLanes2,
                null
              ), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(
                workInProgress2,
                current2.child,
                null,
                renderLanes2
              ), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453);
            else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
              JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
              if (JSCompiler_object_inline_digest_2451) {
                JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
                var message = JSCompiler_object_inline_digest_2451.msg;
                instance = JSCompiler_object_inline_digest_2451.stck;
                var componentStack = JSCompiler_object_inline_digest_2451.cstck;
              }
              JSCompiler_object_inline_message_2450 = message;
              JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = instance;
              JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
              JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error(
                "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
              );
              JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
              JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
              JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = {
                value: JSCompiler_object_inline_componentStack_2453,
                source: null,
                stack: JSCompiler_object_inline_digest_2451
              };
              "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_stack_2452
              );
              queueHydrationError(JSCompiler_object_inline_stack_2452);
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else if (didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
              JSCompiler_object_inline_digest_2451 = workInProgressRoot;
              if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(
                JSCompiler_object_inline_stack_2452
              ), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
                throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2451,
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), SelectiveHydrationException;
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2450.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_stack_2452.children
              ), workInProgress2.flags |= 4096);
            return workInProgress2;
          }
          if (JSCompiler_object_inline_componentStack_2453)
            return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(
              JSCompiler_temp,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2452.children
              }
            ), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(
              instance,
              JSCompiler_object_inline_componentStack_2453
            ) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
              JSCompiler_object_inline_componentStack_2453,
              JSCompiler_object_inline_message_2450,
              renderLanes2,
              null
            ), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
              baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
              cachePool: JSCompiler_temp
            }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2451,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2452.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          offscreenProps.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          };
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
          nextProps = nextProps.children;
          if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
            if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            tailMode
          )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            tailMode
          )));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
            if (isArrayImpl(nextProps))
              for (var i = 0; i < nextProps.length; i++) {
                if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
              }
            else if (i = getIteratorFn(nextProps), "function" === typeof i) {
              if (i = i.call(nextProps))
                for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          nextProps = suspenseStackCursor.current;
          if (0 !== (nextProps & ForceSuspenseFallback))
            nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
          else {
            if (null !== current2 && 0 !== (current2.flags & 128))
              a: for (current2 = workInProgress2.child; null !== current2; ) {
                if (13 === current2.tag)
                  null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
                    current2,
                    renderLanes2,
                    workInProgress2
                  );
                else if (19 === current2.tag)
                  scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
                else if (null !== current2.child) {
                  current2.child.return = current2;
                  current2 = current2.child;
                  continue;
                }
                if (current2 === workInProgress2) break a;
                for (; null === current2.sibling; ) {
                  if (null === current2.return || current2.return === workInProgress2)
                    break a;
                  current2 = current2.return;
                }
                current2.sibling.return = current2.return;
                current2 = current2.sibling;
              }
            nextProps &= SubtreeSuspenseContextMask;
          }
          push(suspenseStackCursor, nextProps, workInProgress2);
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode
              );
              break;
            case "backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode
              );
              break;
            case "together":
              initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
            case 23:
              return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                current2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    current2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = current2; current2; )
                      current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = null != returnFiber ? validateTextNesting(
                current2,
                returnFiber.tag,
                renderLanes2.ancestorInfo.implicitRootScope
              ) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
                mode: returnFiber.mode,
                children: returnFiber.children
              }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
                returnFiber,
                renderLanes2
              ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
            case 22:
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
            resource = suspenseHandlerStackCursor.current;
            if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
            workInProgress2.flags |= 8192;
          }
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 31:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              return renderLanes2 = workInProgress2.memoizedState, null === current2 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              var _type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              renderLanes2 = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                _type = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _type);
                else {
                  current2 = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(renderLanes2, _type.ancestorInfo);
                  _type = _type.context;
                  current2 = getOwnerDocumentFromRootContainer(current2);
                  switch (_type) {
                    case HostContextNamespaceSvg:
                      current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                      break;
                    case HostContextNamespaceMath:
                      current2 = current2.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes2
                      );
                      break;
                    default:
                      switch (renderLanes2) {
                        case "svg":
                          current2 = current2.createElementNS(
                            SVG_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "math":
                          current2 = current2.createElementNS(
                            MATH_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "script":
                          current2 = current2.createElement("div");
                          current2.innerHTML = "<script><\/script>";
                          current2 = current2.removeChild(current2.firstChild);
                          break;
                        case "select":
                          current2 = "string" === typeof newProps.is ? current2.createElement("select", { is: newProps.is }) : current2.createElement("select");
                          newProps.multiple ? current2.multiple = true : newProps.size && (current2.size = newProps.size);
                          break;
                        default:
                          current2 = "string" === typeof newProps.is ? current2.createElement(renderLanes2, {
                            is: newProps.is
                          }) : current2.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            renderLanes2
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current2) || hasOwnProperty2.call(
                            warnedUnknownTags,
                            renderLanes2
                          ) || (warnedUnknownTags[renderLanes2] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            renderLanes2
                          )));
                      }
                  }
                  current2[internalInstanceKey] = workInProgress2;
                  current2[internalPropsKey] = newProps;
                  a: for (_type = workInProgress2.child; null !== _type; ) {
                    if (5 === _type.tag || 6 === _type.tag)
                      current2.appendChild(_type.stateNode);
                    else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                      _type.child.return = _type;
                      _type = _type.child;
                      continue;
                    }
                    if (_type === workInProgress2) break a;
                    for (; null === _type.sibling; ) {
                      if (null === _type.return || _type.return === workInProgress2)
                        break a;
                      _type = _type.return;
                    }
                    _type.sibling.return = _type.return;
                    _type = _type.sibling;
                  }
                  workInProgress2.stateNode = current2;
                  a: switch (setInitialProperties(current2, renderLanes2, newProps), renderLanes2) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      current2 = !!newProps.autoFocus;
                      break a;
                    case "img":
                      current2 = true;
                      break a;
                    default:
                      current2 = false;
                  }
                  current2 && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              workInProgress2.flags &= -16777217;
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  _type = !didSuspendOrErrorDEV;
                  newProps = null;
                  var returnFiber = hydrationParentFiber;
                  if (null !== returnFiber)
                    switch (returnFiber.tag) {
                      case 3:
                        _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                        break;
                      case 27:
                      case 5:
                        newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = _type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2);
                } else
                  _type = renderLanes2.ancestorInfo.current, null != _type && validateTextNesting(
                    newProps,
                    _type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                _type = popHydrationState(workInProgress2);
                if (null !== newProps && null !== newProps.dehydrated) {
                  if (null === current2) {
                    if (!_type)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    _type = workInProgress2.memoizedState;
                    _type = null !== _type ? _type.dehydrated : null;
                    if (!_type)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    _type[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  _type = false;
                } else
                  _type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = _type), _type = true;
                if (!_type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              _type = workInProgress2.memoizedState;
              if (null === _type) return bubbleProperties(workInProgress2), null;
              newProps = 0 !== (workInProgress2.flags & 128);
              returnFiber = _type.rendering;
              if (null === returnFiber)
                if (newProps) cutOffTailIfNeeded(_type, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      returnFiber = findFirstSuspended(current2);
                      if (null !== returnFiber) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(_type, false);
                        current2 = returnFiber.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!newProps)
                  if (current2 = findFirstSuspended(returnFiber), null !== current2) {
                    if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
              }
              if (null !== _type.tail)
                return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                  finishedWork
                ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                  finishedWork
                ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                    finishedWork
                  ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                    finishedWork
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps,
              finishedWork.elementType === finishedWork.type
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error2) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error2);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error2) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error2);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(
            finishedWork.memoizedProps.id,
            current2,
            effectDuration,
            commitStartTime2
          );
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start3 = -1, end2 = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode2 = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start3 = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end2 = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode2 = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root2) break b;
                      parentNode2 === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start3 = length);
                      parentNode2 === focusNode && ++indexWithinFocus === selection && (end2 = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode2;
                      parentNode2 = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start3 || -1 === end2 ? null : { start: start3, end: end2 };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              null === current2 && flags & 4 && commitHostMount(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error2) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error2
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error2) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error2
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              offscreenSubtreeWasHidden || commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13878)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
              break;
            case 26:
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4)
                if (root2 = null !== current2 ? current2.memoizedState : null, flags = finishedWork.memoizedState, null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        root2 = hoistableRoot.ownerDocument || hoistableRoot;
                        b: switch (flags) {
                          case "title":
                            hoistableRoot = root2.getElementsByTagName("title")[0];
                            if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                              hoistableRoot = root2.createElement(flags), root2.head.insertBefore(
                                hoistableRoot,
                                root2.querySelector("head > title")
                              );
                            setInitialProperties(hoistableRoot, flags, current2);
                            hoistableRoot[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(hoistableRoot);
                            flags = hoistableRoot;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              root2
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && hoistableRoot.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && hoistableRoot.getAttribute("title") === (null == current2.title ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              root2
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), hoistableRoot.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (null == current2.name ? null : current2.name) && hoistableRoot.getAttribute("property") === (null == current2.property ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  root2 !== flags ? (null === root2 ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root2.count--, null === flags ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              break;
            case 27:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(finishedWork, resetTextContent, root2);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (root2 = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                root2,
                null !== current2 ? current2.memoizedProps : root2
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    root2,
                    current2,
                    flags
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              break;
            case 3:
              hoistableRoot = pushNestedEffectDurations();
              tagCaches = null;
              maybeNodes = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = maybeNodes;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(hoistableRoot);
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              hoistableRoot = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root2;
                      try {
                        maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error2) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          i,
                          wasHidden.memoizedProps
                        );
                      } catch (error2) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error2);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current2 === root2 && (current2 = null);
                    root2 = root2.return;
                  }
                  current2 === root2 && (current2 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions
              ), parentFiber = parentFiber.sibling;
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
              break;
            case 13:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 23:
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              var _current = finishedWork.alternate;
              null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256)
              ));
              flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
          }
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitCachePassiveMountEffect(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
              }
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(fiber);
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(fiber);
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(fiber);
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber;
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                var sibling = current2.sibling, returnFiber = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
          var suspenseHandler = suspenseHandlerStackCursor.current;
          null !== suspenseHandler && (suspenseHandler.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if (0 !== (executionContext & RenderContext) && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
          do {
            if (exitStatus === RootInProgress) {
              workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
              break;
            } else {
              forceSync = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                exitStatus = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (exitStatus === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  lanes = errorRetryLanes;
                  a: {
                    exitStatus = root2;
                    var errorRetryLanes$jscomp$0 = errorRetryLanes;
                    errorRetryLanes = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(
                      exitStatus,
                      errorRetryLanes$jscomp$0
                    ).flags |= 256);
                    errorRetryLanes$jscomp$0 = renderRootSync(
                      exitStatus,
                      errorRetryLanes$jscomp$0,
                      false
                    );
                    if (errorRetryLanes$jscomp$0 !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                        workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                        exitStatus = RootSuspendedWithDelay;
                        break a;
                      }
                      exitStatus = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = errorRetryLanes;
                      null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        exitStatus
                      ));
                    }
                    exitStatus = errorRetryLanes$jscomp$0;
                  }
                  renderWasConcurrent = false;
                  if (exitStatus !== RootErrored) continue;
                }
              }
              if (exitStatus === RootFatalErrored) {
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                shouldTimeSlice = root2;
                switch (exitStatus) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    shouldTimeSlice,
                    forceSync,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                    shouldTimeSlice.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        shouldTimeSlice,
                        forceSync,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        exitStatus,
                        THROTTLED_COMMIT,
                        renderStartTime,
                        0
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    exitStatus,
                    IMMEDIATE_COMMIT,
                    renderStartTime,
                    0
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.timeoutHandle = noTimeout;
          suspendedCommitReason = finishedWork.subtreeFlags;
          if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
            if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop2 }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
              root2.cancelPendingCommit = suspendedCommitReason(
                commitRoot.bind(
                  null,
                  root2,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  SUSPENDED_COMMIT,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error2) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function prepareFreshStack(root2, lanes) {
          var timeoutHandle = root2.timeoutHandle;
          timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
          timeoutHandle = root2.cancelPendingCommit;
          null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          var allEntangledLanes = root2.entangledLanes;
          if (0 !== allEntangledLanes)
            for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
              var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
              lanes |= root2[index];
              allEntangledLanes &= ~lane;
            }
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          lanes = getCurrentTime();
          1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
          ReactStrictModeWarnings.discardPendingWarnings();
          return timeoutHandle;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          if (null === erroredWork)
            workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
          else
            switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
              case SuspendedOnError:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
                break;
              case SuspendedOnData:
              case SuspendedOnAction:
              case SuspendedOnImmediate:
              case SuspendedOnDeprecatedThrowPromise:
              case SuspendedAndReadyToContinue:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
            }
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          markRenderStarted(lanes);
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          markRenderStopped();
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          markRenderStarted(lanes);
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : 1) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress)
            return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
          markRenderStopped();
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState = null;
          thenableIndexCounter = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error2) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error2;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
          root2.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
          if (null === finishedWork) markCommitStopped();
          else {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root2.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root2,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root2;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              flushPassiveEffects(true);
              return null;
            })) : (root2.callbackNode = null, root2.callbackPriority = 0);
            commitStartTime = now();
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root2, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root2;
                commitMutationEffectsOnFiber(finishedWork, root2);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start3 = priorSelectionRange.start, end2 = priorSelectionRange.end;
                    void 0 === end2 && (end2 = start3);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start3, priorFocusedElem.selectionEnd = Math.min(
                        end2,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc3 = priorFocusedElem.ownerDocument || document, win = doc3 && doc3.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc3.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc3 = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc3.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc3.length; priorFocusedElem++) {
                    var info = doc3[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root2.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
            if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root2, commitLayoutEffectOnFiber(
                  root2,
                  finishedWork.alternate,
                  finishedWork
                ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = root2.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2);
            rootDidHavePassiveEffects = lanesToEventPriority(lanes);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (rootDidHavePassiveEffects) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            isDevToolsPresent && root2.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== recoverableErrors) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = root2.onRecoverableError;
                for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
                  var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(root2);
            remainingLanes = root2.pendingLanes;
            0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
            flushSyncWorkAcrossRoots_impl(0, false);
            markCommitStopped();
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects(wasDelayedCommit) {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects(wasDelayedCommit);
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            priority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(
              root$jscomp$0,
              root$jscomp$0.current,
              lanes,
              priority
            );
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            var stateNode = root$jscomp$0.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
          sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error2) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error2
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error2, sourceFiber);
                  error2 = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error2, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error2,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error2
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber,
                (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0,
                      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
          for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next;
          }
          flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root2.callbackNode = null, root2.callbackPriority = 0, null;
          var originalCallbackNode = root2.callbackNode;
          if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter2) {
          var temp = submitter2.ownerDocument.createElement("input");
          temp.name = submitter2.name;
          temp.value = submitter2.value;
          form.id && temp.setAttribute("form", form.id);
          submitter2.parentNode.insertBefore(temp, submitter2);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter2 = nativeEvent.submitter;
            submitter2 && (domEventName = (domEventName = submitter2[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter2.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter2 = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter2 ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter2
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter2 ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter2
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error2) {
            reportGlobalError(error2);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent3;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END2:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = SyntheticEventCtor;
                        reactEventName = reactEventType;
                        instance = 0;
                        for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                          instance++;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
                          lastHostComponent++;
                        for (; 0 < instance - lastHostComponent; )
                          inCapturePhase = getParent(inCapturePhase), instance--;
                        for (; 0 < lastHostComponent - instance; )
                          reactEventName = getParent(reactEventName), lastHostComponent--;
                        for (; instance--; ) {
                          if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                            break b;
                          inCapturePhase = getParent(inCapturePhase);
                          reactEventName = getParent(reactEventName);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry2 = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry2);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function noop$1() {
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput2(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              track(domElement);
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              track(domElement);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function handleErrorInNextTick(error2) {
          setTimeout(function() {
            throw error2;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function isSingletonScope(type) {
          return "head" === type;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA) {
                if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                  node = possiblePreambleContribution;
                  var ownerDocument = parentInstance.ownerDocument;
                  node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
                  node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
                  if (node & PREAMBLE_CONTRIBUTION_HEAD)
                    for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                      var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                      ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                      ownerDocument = nextNode$jscomp$0;
                    }
                }
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                }
                depth--;
              } else
                node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
            else possiblePreambleContribution = 0;
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA) return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          suspenseInstance = suspenseInstance.nextSibling;
          for (var depth = 0; suspenseInstance; ) {
            if (8 === suspenseInstance.nodeType) {
              var data = suspenseInstance.data;
              if (data === SUSPENSE_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(suspenseInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
            }
            suspenseInstance = suspenseInstance.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else data === SUSPENSE_END_DATA && depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty2.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty2.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty2.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache2 = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache2);
          } else
            caches = tagCaches, cache2 = caches.get(ownerDocument), cache2 || (cache2 = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache2));
          if (cache2.has(type)) return cache2;
          cache2.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache2.get(nodeKey);
              existing ? existing.push(node) : cache2.set(nodeKey, [node]);
            }
          }
          return cache2;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function noop2() {
        }
        function suspendResource(hoistableRoot, resource, props) {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady() {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          isDevToolsPresent && (tag |= ProfileMode);
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function getLaneLabelMap() {
          for (var map2 = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
            var label = getLabelForLane(lane);
            map2.set(lane, label);
            lane *= 2;
          }
          return map2;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent3(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent3(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent3(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    if (13 === nearestMounted.tag) {
                      var lane = requestUpdateLane(nearestMounted);
                      lane = getBumpedLaneForHydrationByLane(lane);
                      var root2 = enqueueConcurrentRenderForLane(
                        nearestMounted,
                        lane
                      );
                      null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                      markRetryLaneIfNotHydrated(nearestMounted, lane);
                    }
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React4 = require_react(), ReactDOM2 = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty2 = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style2 = {};
        canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END2 = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(createDeps);
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        var callComponent = {
          "react-stack-bottom-frame": function(Component2, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component2(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
          "react-stack-bottom-frame": function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
          "react-stack-bottom-frame": function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
          "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
          "react-stack-bottom-frame": function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
          "react-stack-bottom-frame": function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
          "react-stack-bottom-frame": function(effect5) {
            null != effect5.resourceKind && console.error(
              "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
              effect5.resourceKind
            );
            var create = effect5.create;
            effect5 = effect5.inst;
            create = create();
            return effect5.destroy = create;
          }
        }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
          "react-stack-bottom-frame": function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
        }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
          "react-stack-bottom-frame": function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
          }
        }, reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
              error: error2
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error2);
            return;
          }
          console.error(error2);
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache2 = readContext(CacheContext), cacheForType = cache2.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache2.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END2, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind2 = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root2.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React4.version;
          if ("19.1.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!function() {
          var internals = {
            bundleType: 1,
            version: "19.1.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.1.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          internals.getLaneLabelMap = getLaneLabelMap;
          internals.injectProfilingHooks = injectProfilingHooks;
          return injectInternals(internals);
        }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            null
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            formState
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map2) => listeners.concat(Array.from(map2.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches2 = source.match(descriptorPattern) || [];
    let eventName = matches2[2];
    let keyFilter = matches2[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches2[4]),
      eventName,
      eventOptions: matches2[7] ? parseEventOptions(matches2[7]) : {},
      identifier: matches2[5],
      methodName: matches2[6],
      keyFilter: matches2[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift2] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift2;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches2 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches2.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches2)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches2);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map2, key, value) {
    fetch2(map2, key).add(value);
  }
  function del(map2, key, value) {
    fetch2(map2, key).delete(value);
    prune(map2, key);
  }
  function fetch2(map2, key) {
    let values = map2.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map2.set(key, values);
    }
    return values;
  }
  function prune(map2, key) {
    const values = map2.get(key);
    if (values != null && values.size == 0) {
      map2.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches2 = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches2 && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches2;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches2 = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches2);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches2 = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches2 && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches2 && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_, index) => [left2[index], right2[index]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a2;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a2 = this.tokenListObserver) === null || _a2 === void 0 ? void 0 : _a2.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a2;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a2 = this.tokenListObserver) === null || _a2 === void 0 ? void 0 : _a2.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a2;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a2 = this.selectorObserverMap.get(outletName)) === null || _a2 === void 0 ? void 0 : _a2.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a2;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a2 = this.selectorObserverMap.get(outletName)) === null || _a2 === void 0 ? void 0 : _a2.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    start() {
      return __async(this, null, function* () {
        yield domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
      });
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a2;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a2 = window.onerror) === null || _a2 === void 0 ? void 0 : _a2.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // node_modules/ts-custom-error/dist/custom-error.mjs
  function fixProto(target, prototype) {
    var setPrototypeOf = Object.setPrototypeOf;
    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
  }
  function fixStack(target, fn2) {
    if (fn2 === void 0) {
      fn2 = target.constructor;
    }
    var captureStackTrace = Error.captureStackTrace;
    captureStackTrace && captureStackTrace(target, fn2);
  }
  var __extends = /* @__PURE__ */ function() {
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) {
          if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        }
      };
      return _extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      _extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var CustomError = function(_super) {
    __extends(CustomError2, _super);
    function CustomError2(message, options) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message, options) || this;
      Object.defineProperty(_this, "name", {
        value: _newTarget.name,
        enumerable: false,
        configurable: true
      });
      fixProto(_this, _newTarget.prototype);
      fixStack(_this);
      return _this;
    }
    return CustomError2;
  }(Error);

  // node_modules/@zxing/library/esm/core/Exception.js
  var __extends2 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var Exception = (
    /** @class */
    function(_super) {
      __extends2(Exception2, _super);
      function Exception2(message) {
        if (message === void 0) {
          message = void 0;
        }
        var _this = _super.call(this, message) || this;
        _this.message = message;
        return _this;
      }
      Exception2.prototype.getKind = function() {
        var ex = this.constructor;
        return ex.kind;
      };
      Exception2.kind = "Exception";
      return Exception2;
    }(CustomError)
  );
  var Exception_default = Exception;

  // node_modules/@zxing/library/esm/core/ArgumentException.js
  var __extends3 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ArgumentException = (
    /** @class */
    function(_super) {
      __extends3(ArgumentException2, _super);
      function ArgumentException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ArgumentException2.kind = "ArgumentException";
      return ArgumentException2;
    }(Exception_default)
  );
  var ArgumentException_default = ArgumentException;

  // node_modules/@zxing/library/esm/core/IllegalArgumentException.js
  var __extends4 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var IllegalArgumentException = (
    /** @class */
    function(_super) {
      __extends4(IllegalArgumentException2, _super);
      function IllegalArgumentException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IllegalArgumentException2.kind = "IllegalArgumentException";
      return IllegalArgumentException2;
    }(Exception_default)
  );
  var IllegalArgumentException_default = IllegalArgumentException;

  // node_modules/@zxing/library/esm/core/BinaryBitmap.js
  var BinaryBitmap = (
    /** @class */
    function() {
      function BinaryBitmap2(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
          throw new IllegalArgumentException_default("Binarizer must be non-null.");
        }
      }
      BinaryBitmap2.prototype.getWidth = function() {
        return this.binarizer.getWidth();
      };
      BinaryBitmap2.prototype.getHeight = function() {
        return this.binarizer.getHeight();
      };
      BinaryBitmap2.prototype.getBlackRow = function(y, row) {
        return this.binarizer.getBlackRow(y, row);
      };
      BinaryBitmap2.prototype.getBlackMatrix = function() {
        if (this.matrix === null || this.matrix === void 0) {
          this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
      };
      BinaryBitmap2.prototype.isCropSupported = function() {
        return this.binarizer.getLuminanceSource().isCropSupported();
      };
      BinaryBitmap2.prototype.crop = function(left2, top2, width, height) {
        var newSource = this.binarizer.getLuminanceSource().crop(left2, top2, width, height);
        return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
      };
      BinaryBitmap2.prototype.isRotateSupported = function() {
        return this.binarizer.getLuminanceSource().isRotateSupported();
      };
      BinaryBitmap2.prototype.rotateCounterClockwise = function() {
        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
      };
      BinaryBitmap2.prototype.rotateCounterClockwise45 = function() {
        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
      };
      BinaryBitmap2.prototype.toString = function() {
        try {
          return this.getBlackMatrix().toString();
        } catch (e) {
          return "";
        }
      };
      return BinaryBitmap2;
    }()
  );
  var BinaryBitmap_default = BinaryBitmap;

  // node_modules/@zxing/library/esm/core/ChecksumException.js
  var __extends5 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ChecksumException = (
    /** @class */
    function(_super) {
      __extends5(ChecksumException2, _super);
      function ChecksumException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ChecksumException2.getChecksumInstance = function() {
        return new ChecksumException2();
      };
      ChecksumException2.kind = "ChecksumException";
      return ChecksumException2;
    }(Exception_default)
  );
  var ChecksumException_default = ChecksumException;

  // node_modules/@zxing/library/esm/core/Binarizer.js
  var Binarizer = (
    /** @class */
    function() {
      function Binarizer2(source) {
        this.source = source;
      }
      Binarizer2.prototype.getLuminanceSource = function() {
        return this.source;
      };
      Binarizer2.prototype.getWidth = function() {
        return this.source.getWidth();
      };
      Binarizer2.prototype.getHeight = function() {
        return this.source.getHeight();
      };
      return Binarizer2;
    }()
  );
  var Binarizer_default = Binarizer;

  // node_modules/@zxing/library/esm/core/util/System.js
  var System = (
    /** @class */
    function() {
      function System2() {
      }
      System2.arraycopy = function(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      };
      System2.currentTimeMillis = function() {
        return Date.now();
      };
      return System2;
    }()
  );
  var System_default = System;

  // node_modules/@zxing/library/esm/core/IndexOutOfBoundsException.js
  var __extends6 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var IndexOutOfBoundsException = (
    /** @class */
    function(_super) {
      __extends6(IndexOutOfBoundsException2, _super);
      function IndexOutOfBoundsException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IndexOutOfBoundsException2.kind = "IndexOutOfBoundsException";
      return IndexOutOfBoundsException2;
    }(Exception_default)
  );
  var IndexOutOfBoundsException_default = IndexOutOfBoundsException;

  // node_modules/@zxing/library/esm/core/ArrayIndexOutOfBoundsException.js
  var __extends7 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ArrayIndexOutOfBoundsException = (
    /** @class */
    function(_super) {
      __extends7(ArrayIndexOutOfBoundsException2, _super);
      function ArrayIndexOutOfBoundsException2(index, message) {
        if (index === void 0) {
          index = void 0;
        }
        if (message === void 0) {
          message = void 0;
        }
        var _this = _super.call(this, message) || this;
        _this.index = index;
        _this.message = message;
        return _this;
      }
      ArrayIndexOutOfBoundsException2.kind = "ArrayIndexOutOfBoundsException";
      return ArrayIndexOutOfBoundsException2;
    }(IndexOutOfBoundsException_default)
  );
  var ArrayIndexOutOfBoundsException_default = ArrayIndexOutOfBoundsException;

  // node_modules/@zxing/library/esm/core/util/Arrays.js
  var __values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Arrays = (
    /** @class */
    function() {
      function Arrays2() {
      }
      Arrays2.fill = function(a, val) {
        for (var i = 0, len = a.length; i < len; i++)
          a[i] = val;
      };
      Arrays2.fillWithin = function(a, fromIndex, toIndex, val) {
        Arrays2.rangeCheck(a.length, fromIndex, toIndex);
        for (var i = fromIndex; i < toIndex; i++)
          a[i] = val;
      };
      Arrays2.rangeCheck = function(arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
          throw new IllegalArgumentException_default("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
        }
        if (fromIndex < 0) {
          throw new ArrayIndexOutOfBoundsException_default(fromIndex);
        }
        if (toIndex > arrayLength) {
          throw new ArrayIndexOutOfBoundsException_default(toIndex);
        }
      };
      Arrays2.asList = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return args;
      };
      Arrays2.create = function(rows, cols, value) {
        var arr = Array.from({ length: rows });
        return arr.map(function(x) {
          return Array.from({ length: cols }).fill(value);
        });
      };
      Arrays2.createInt32Array = function(rows, cols, value) {
        var arr = Array.from({ length: rows });
        return arr.map(function(x) {
          return Int32Array.from({ length: cols }).fill(value);
        });
      };
      Arrays2.equals = function(first2, second) {
        if (!first2) {
          return false;
        }
        if (!second) {
          return false;
        }
        if (!first2.length) {
          return false;
        }
        if (!second.length) {
          return false;
        }
        if (first2.length !== second.length) {
          return false;
        }
        for (var i = 0, length_1 = first2.length; i < length_1; i++) {
          if (first2[i] !== second[i]) {
            return false;
          }
        }
        return true;
      };
      Arrays2.hashCode = function(a) {
        var e_1, _a2;
        if (a === null) {
          return 0;
        }
        var result = 1;
        try {
          for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
            var element = a_1_1.value;
            result = 31 * result + element;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (a_1_1 && !a_1_1.done && (_a2 = a_1.return)) _a2.call(a_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return result;
      };
      Arrays2.fillUint8Array = function(a, value) {
        for (var i = 0; i !== a.length; i++) {
          a[i] = value;
        }
      };
      Arrays2.copyOf = function(original, newLength) {
        return original.slice(0, newLength);
      };
      Arrays2.copyOfUint8Array = function(original, newLength) {
        if (original.length <= newLength) {
          var newArray = new Uint8Array(newLength);
          newArray.set(original);
          return newArray;
        }
        return original.slice(0, newLength);
      };
      Arrays2.copyOfRange = function(original, from2, to) {
        var newLength = to - from2;
        var copy2 = new Int32Array(newLength);
        System_default.arraycopy(original, from2, copy2, 0, newLength);
        return copy2;
      };
      Arrays2.binarySearch = function(ar, el, comparator) {
        if (void 0 === comparator) {
          comparator = Arrays2.numberComparator;
        }
        var m = 0;
        var n = ar.length - 1;
        while (m <= n) {
          var k = n + m >> 1;
          var cmp2 = comparator(el, ar[k]);
          if (cmp2 > 0) {
            m = k + 1;
          } else if (cmp2 < 0) {
            n = k - 1;
          } else {
            return k;
          }
        }
        return -m - 1;
      };
      Arrays2.numberComparator = function(a, b) {
        return a - b;
      };
      return Arrays2;
    }()
  );
  var Arrays_default = Arrays;

  // node_modules/@zxing/library/esm/core/util/Integer.js
  var Integer = (
    /** @class */
    function() {
      function Integer2() {
      }
      Integer2.numberOfTrailingZeros = function(i) {
        var y;
        if (i === 0)
          return 32;
        var n = 31;
        y = i << 16;
        if (y !== 0) {
          n -= 16;
          i = y;
        }
        y = i << 8;
        if (y !== 0) {
          n -= 8;
          i = y;
        }
        y = i << 4;
        if (y !== 0) {
          n -= 4;
          i = y;
        }
        y = i << 2;
        if (y !== 0) {
          n -= 2;
          i = y;
        }
        return n - (i << 1 >>> 31);
      };
      Integer2.numberOfLeadingZeros = function(i) {
        if (i === 0) {
          return 32;
        }
        var n = 1;
        if (i >>> 16 === 0) {
          n += 16;
          i <<= 16;
        }
        if (i >>> 24 === 0) {
          n += 8;
          i <<= 8;
        }
        if (i >>> 28 === 0) {
          n += 4;
          i <<= 4;
        }
        if (i >>> 30 === 0) {
          n += 2;
          i <<= 2;
        }
        n -= i >>> 31;
        return n;
      };
      Integer2.toHexString = function(i) {
        return i.toString(16);
      };
      Integer2.toBinaryString = function(intNumber) {
        return String(parseInt(String(intNumber), 2));
      };
      Integer2.bitCount = function(i) {
        i = i - (i >>> 1 & 1431655765);
        i = (i & 858993459) + (i >>> 2 & 858993459);
        i = i + (i >>> 4) & 252645135;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 63;
      };
      Integer2.truncDivision = function(dividend, divisor) {
        return Math.trunc(dividend / divisor);
      };
      Integer2.parseInt = function(num, radix) {
        if (radix === void 0) {
          radix = void 0;
        }
        return parseInt(num, radix);
      };
      Integer2.MIN_VALUE_32_BITS = -2147483648;
      Integer2.MAX_VALUE = Number.MAX_SAFE_INTEGER;
      return Integer2;
    }()
  );
  var Integer_default = Integer;

  // node_modules/@zxing/library/esm/core/common/BitArray.js
  var BitArray = (
    /** @class */
    function() {
      function BitArray2(size, bits) {
        if (void 0 === size) {
          this.size = 0;
          this.bits = new Int32Array(1);
        } else {
          this.size = size;
          if (void 0 === bits || null === bits) {
            this.bits = BitArray2.makeArray(size);
          } else {
            this.bits = bits;
          }
        }
      }
      BitArray2.prototype.getSize = function() {
        return this.size;
      };
      BitArray2.prototype.getSizeInBytes = function() {
        return Math.floor((this.size + 7) / 8);
      };
      BitArray2.prototype.ensureCapacity = function(size) {
        if (size > this.bits.length * 32) {
          var newBits = BitArray2.makeArray(size);
          System_default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
          this.bits = newBits;
        }
      };
      BitArray2.prototype.get = function(i) {
        return (this.bits[Math.floor(i / 32)] & 1 << (i & 31)) !== 0;
      };
      BitArray2.prototype.set = function(i) {
        this.bits[Math.floor(i / 32)] |= 1 << (i & 31);
      };
      BitArray2.prototype.flip = function(i) {
        this.bits[Math.floor(i / 32)] ^= 1 << (i & 31);
      };
      BitArray2.prototype.getNextSet = function(from2) {
        var size = this.size;
        if (from2 >= size) {
          return size;
        }
        var bits = this.bits;
        var bitsOffset = Math.floor(from2 / 32);
        var currentBits = bits[bitsOffset];
        currentBits &= ~((1 << (from2 & 31)) - 1);
        var length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size;
          }
          currentBits = bits[bitsOffset];
        }
        var result = bitsOffset * 32 + Integer_default.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
      };
      BitArray2.prototype.getNextUnset = function(from2) {
        var size = this.size;
        if (from2 >= size) {
          return size;
        }
        var bits = this.bits;
        var bitsOffset = Math.floor(from2 / 32);
        var currentBits = ~bits[bitsOffset];
        currentBits &= ~((1 << (from2 & 31)) - 1);
        var length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size;
          }
          currentBits = ~bits[bitsOffset];
        }
        var result = bitsOffset * 32 + Integer_default.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
      };
      BitArray2.prototype.setBulk = function(i, newBits) {
        this.bits[Math.floor(i / 32)] = newBits;
      };
      BitArray2.prototype.setRange = function(start3, end2) {
        if (end2 < start3 || start3 < 0 || end2 > this.size) {
          throw new IllegalArgumentException_default();
        }
        if (end2 === start3) {
          return;
        }
        end2--;
        var firstInt = Math.floor(start3 / 32);
        var lastInt = Math.floor(end2 / 32);
        var bits = this.bits;
        for (var i = firstInt; i <= lastInt; i++) {
          var firstBit = i > firstInt ? 0 : start3 & 31;
          var lastBit = i < lastInt ? 31 : end2 & 31;
          var mask = (2 << lastBit) - (1 << firstBit);
          bits[i] |= mask;
        }
      };
      BitArray2.prototype.clear = function() {
        var max2 = this.bits.length;
        var bits = this.bits;
        for (var i = 0; i < max2; i++) {
          bits[i] = 0;
        }
      };
      BitArray2.prototype.isRange = function(start3, end2, value) {
        if (end2 < start3 || start3 < 0 || end2 > this.size) {
          throw new IllegalArgumentException_default();
        }
        if (end2 === start3) {
          return true;
        }
        end2--;
        var firstInt = Math.floor(start3 / 32);
        var lastInt = Math.floor(end2 / 32);
        var bits = this.bits;
        for (var i = firstInt; i <= lastInt; i++) {
          var firstBit = i > firstInt ? 0 : start3 & 31;
          var lastBit = i < lastInt ? 31 : end2 & 31;
          var mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
          if ((bits[i] & mask) !== (value ? mask : 0)) {
            return false;
          }
        }
        return true;
      };
      BitArray2.prototype.appendBit = function(bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
          this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
        }
        this.size++;
      };
      BitArray2.prototype.appendBits = function(value, numBits) {
        if (numBits < 0 || numBits > 32) {
          throw new IllegalArgumentException_default("Num bits must be between 0 and 32");
        }
        this.ensureCapacity(this.size + numBits);
        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
          this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
        }
      };
      BitArray2.prototype.appendBitArray = function(other) {
        var otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        for (var i = 0; i < otherSize; i++) {
          this.appendBit(other.get(i));
        }
      };
      BitArray2.prototype.xor = function(other) {
        if (this.size !== other.size) {
          throw new IllegalArgumentException_default("Sizes don't match");
        }
        var bits = this.bits;
        for (var i = 0, length_1 = bits.length; i < length_1; i++) {
          bits[i] ^= other.bits[i];
        }
      };
      BitArray2.prototype.toBytes = function(bitOffset, array, offset2, numBytes) {
        for (var i = 0; i < numBytes; i++) {
          var theByte = 0;
          for (var j = 0; j < 8; j++) {
            if (this.get(bitOffset)) {
              theByte |= 1 << 7 - j;
            }
            bitOffset++;
          }
          array[offset2 + i] = /*(byte)*/
          theByte;
        }
      };
      BitArray2.prototype.getBitArray = function() {
        return this.bits;
      };
      BitArray2.prototype.reverse = function() {
        var newBits = new Int32Array(this.bits.length);
        var len = Math.floor((this.size - 1) / 32);
        var oldBitsLen = len + 1;
        var bits = this.bits;
        for (var i = 0; i < oldBitsLen; i++) {
          var x = bits[i];
          x = x >> 1 & 1431655765 | (x & 1431655765) << 1;
          x = x >> 2 & 858993459 | (x & 858993459) << 2;
          x = x >> 4 & 252645135 | (x & 252645135) << 4;
          x = x >> 8 & 16711935 | (x & 16711935) << 8;
          x = x >> 16 & 65535 | (x & 65535) << 16;
          newBits[len - i] = /*(int)*/
          x;
        }
        if (this.size !== oldBitsLen * 32) {
          var leftOffset = oldBitsLen * 32 - this.size;
          var currentInt = newBits[0] >>> leftOffset;
          for (var i = 1; i < oldBitsLen; i++) {
            var nextInt = newBits[i];
            currentInt |= nextInt << 32 - leftOffset;
            newBits[i - 1] = currentInt;
            currentInt = nextInt >>> leftOffset;
          }
          newBits[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits;
      };
      BitArray2.makeArray = function(size) {
        return new Int32Array(Math.floor((size + 31) / 32));
      };
      BitArray2.prototype.equals = function(o) {
        if (!(o instanceof BitArray2)) {
          return false;
        }
        var other = o;
        return this.size === other.size && Arrays_default.equals(this.bits, other.bits);
      };
      BitArray2.prototype.hashCode = function() {
        return 31 * this.size + Arrays_default.hashCode(this.bits);
      };
      BitArray2.prototype.toString = function() {
        var result = "";
        for (var i = 0, size = this.size; i < size; i++) {
          if ((i & 7) === 0) {
            result += " ";
          }
          result += this.get(i) ? "X" : ".";
        }
        return result;
      };
      BitArray2.prototype.clone = function() {
        return new BitArray2(this.size, this.bits.slice());
      };
      BitArray2.prototype.toArray = function() {
        var result = [];
        for (var i = 0, size = this.size; i < size; i++) {
          result.push(this.get(i));
        }
        return result;
      };
      return BitArray2;
    }()
  );
  var BitArray_default = BitArray;

  // node_modules/@zxing/library/esm/core/DecodeHintType.js
  var DecodeHintType;
  (function(DecodeHintType2) {
    DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
    DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
    DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
    DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
    DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
    DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
    DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
    DecodeHintType2[DecodeHintType2["ENABLE_CODE_39_EXTENDED_MODE"] = 7] = "ENABLE_CODE_39_EXTENDED_MODE";
    DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 8] = "ASSUME_GS1";
    DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 9] = "RETURN_CODABAR_START_END";
    DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 10] = "NEED_RESULT_POINT_CALLBACK";
    DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 11] = "ALLOWED_EAN_EXTENSIONS";
  })(DecodeHintType || (DecodeHintType = {}));
  var DecodeHintType_default = DecodeHintType;

  // node_modules/@zxing/library/esm/core/FormatException.js
  var __extends8 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var FormatException = (
    /** @class */
    function(_super) {
      __extends8(FormatException2, _super);
      function FormatException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FormatException2.getFormatInstance = function() {
        return new FormatException2();
      };
      FormatException2.kind = "FormatException";
      return FormatException2;
    }(Exception_default)
  );
  var FormatException_default = FormatException;

  // node_modules/@zxing/library/esm/core/common/CharacterSetECI.js
  var __values2 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var CharacterSetValueIdentifiers;
  (function(CharacterSetValueIdentifiers2) {
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
    CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
  })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
  var CharacterSetECI = (
    /** @class */
    function() {
      function CharacterSetECI2(valueIdentifier, valuesParam, name) {
        var e_1, _a2;
        var otherEncodingNames = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          otherEncodingNames[_i - 3] = arguments[_i];
        }
        this.valueIdentifier = valueIdentifier;
        this.name = name;
        if (typeof valuesParam === "number") {
          this.values = Int32Array.from([valuesParam]);
        } else {
          this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI2.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI2.NAME_TO_ECI.set(name, this);
        var values = this.values;
        for (var i = 0, length_1 = values.length; i !== length_1; i++) {
          var v = values[i];
          CharacterSetECI2.VALUES_TO_ECI.set(v, this);
        }
        try {
          for (var otherEncodingNames_1 = __values2(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {
            var otherName = otherEncodingNames_1_1.value;
            CharacterSetECI2.NAME_TO_ECI.set(otherName, this);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a2 = otherEncodingNames_1.return)) _a2.call(otherEncodingNames_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
      CharacterSetECI2.prototype.getValueIdentifier = function() {
        return this.valueIdentifier;
      };
      CharacterSetECI2.prototype.getName = function() {
        return this.name;
      };
      CharacterSetECI2.prototype.getValue = function() {
        return this.values[0];
      };
      CharacterSetECI2.getCharacterSetECIByValue = function(value) {
        if (value < 0 || value >= 900) {
          throw new FormatException_default("incorect value");
        }
        var characterSet = CharacterSetECI2.VALUES_TO_ECI.get(value);
        if (void 0 === characterSet) {
          throw new FormatException_default("incorect value");
        }
        return characterSet;
      };
      CharacterSetECI2.getCharacterSetECIByName = function(name) {
        var characterSet = CharacterSetECI2.NAME_TO_ECI.get(name);
        if (void 0 === characterSet) {
          throw new FormatException_default("incorect value");
        }
        return characterSet;
      };
      CharacterSetECI2.prototype.equals = function(o) {
        if (!(o instanceof CharacterSetECI2)) {
          return false;
        }
        var other = o;
        return this.getName() === other.getName();
      };
      CharacterSetECI2.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI2.VALUES_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI2.NAME_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI2.Cp437 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
      CharacterSetECI2.ISO8859_1 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
      CharacterSetECI2.ISO8859_2 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
      CharacterSetECI2.ISO8859_3 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
      CharacterSetECI2.ISO8859_4 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
      CharacterSetECI2.ISO8859_5 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
      CharacterSetECI2.ISO8859_6 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
      CharacterSetECI2.ISO8859_7 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
      CharacterSetECI2.ISO8859_8 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
      CharacterSetECI2.ISO8859_9 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
      CharacterSetECI2.ISO8859_10 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
      CharacterSetECI2.ISO8859_11 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
      CharacterSetECI2.ISO8859_13 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
      CharacterSetECI2.ISO8859_14 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
      CharacterSetECI2.ISO8859_15 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
      CharacterSetECI2.ISO8859_16 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
      CharacterSetECI2.SJIS = new CharacterSetECI2(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
      CharacterSetECI2.Cp1250 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
      CharacterSetECI2.Cp1251 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
      CharacterSetECI2.Cp1252 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
      CharacterSetECI2.Cp1256 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
      CharacterSetECI2.UnicodeBigUnmarked = new CharacterSetECI2(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
      CharacterSetECI2.UTF8 = new CharacterSetECI2(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
      CharacterSetECI2.ASCII = new CharacterSetECI2(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
      CharacterSetECI2.Big5 = new CharacterSetECI2(CharacterSetValueIdentifiers.Big5, 28, "Big5");
      CharacterSetECI2.GB18030 = new CharacterSetECI2(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
      CharacterSetECI2.EUC_KR = new CharacterSetECI2(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
      return CharacterSetECI2;
    }()
  );
  var CharacterSetECI_default = CharacterSetECI;

  // node_modules/@zxing/library/esm/core/UnsupportedOperationException.js
  var __extends9 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var UnsupportedOperationException = (
    /** @class */
    function(_super) {
      __extends9(UnsupportedOperationException2, _super);
      function UnsupportedOperationException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UnsupportedOperationException2.kind = "UnsupportedOperationException";
      return UnsupportedOperationException2;
    }(Exception_default)
  );
  var UnsupportedOperationException_default = UnsupportedOperationException;

  // node_modules/@zxing/library/esm/core/util/StringEncoding.js
  var StringEncoding = (
    /** @class */
    function() {
      function StringEncoding2() {
      }
      StringEncoding2.decode = function(bytes, encoding) {
        var encodingName = this.encodingName(encoding);
        if (this.customDecoder) {
          return this.customDecoder(bytes, encodingName);
        }
        if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
          return this.decodeFallback(bytes, encodingName);
        }
        return new TextDecoder(encodingName).decode(bytes);
      };
      StringEncoding2.shouldDecodeOnFallback = function(encodingName) {
        return !StringEncoding2.isBrowser() && encodingName === "ISO-8859-1";
      };
      StringEncoding2.encode = function(s, encoding) {
        var encodingName = this.encodingName(encoding);
        if (this.customEncoder) {
          return this.customEncoder(s, encodingName);
        }
        if (typeof TextEncoder === "undefined") {
          return this.encodeFallback(s);
        }
        return new TextEncoder().encode(s);
      };
      StringEncoding2.isBrowser = function() {
        return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
      };
      StringEncoding2.encodingName = function(encoding) {
        return typeof encoding === "string" ? encoding : encoding.getName();
      };
      StringEncoding2.encodingCharacterSet = function(encoding) {
        if (encoding instanceof CharacterSetECI_default) {
          return encoding;
        }
        return CharacterSetECI_default.getCharacterSetECIByName(encoding);
      };
      StringEncoding2.decodeFallback = function(bytes, encoding) {
        var characterSet = this.encodingCharacterSet(encoding);
        if (StringEncoding2.isDecodeFallbackSupported(characterSet)) {
          var s = "";
          for (var i = 0, length_1 = bytes.length; i < length_1; i++) {
            var h = bytes[i].toString(16);
            if (h.length < 2) {
              h = "0" + h;
            }
            s += "%" + h;
          }
          return decodeURIComponent(s);
        }
        if (characterSet.equals(CharacterSetECI_default.UnicodeBigUnmarked)) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        }
        throw new UnsupportedOperationException_default("Encoding " + this.encodingName(encoding) + " not supported by fallback.");
      };
      StringEncoding2.isDecodeFallbackSupported = function(characterSet) {
        return characterSet.equals(CharacterSetECI_default.UTF8) || characterSet.equals(CharacterSetECI_default.ISO8859_1) || characterSet.equals(CharacterSetECI_default.ASCII);
      };
      StringEncoding2.encodeFallback = function(s) {
        var encodedURIstring = btoa(unescape(encodeURIComponent(s)));
        var charList = encodedURIstring.split("");
        var uintArray = [];
        for (var i = 0; i < charList.length; i++) {
          uintArray.push(charList[i].charCodeAt(0));
        }
        return new Uint8Array(uintArray);
      };
      return StringEncoding2;
    }()
  );
  var StringEncoding_default = StringEncoding;

  // node_modules/@zxing/library/esm/core/common/StringUtils.js
  var StringUtils = (
    /** @class */
    function() {
      function StringUtils2() {
      }
      StringUtils2.castAsNonUtf8Char = function(code, encoding) {
        if (encoding === void 0) {
          encoding = null;
        }
        var e = encoding ? encoding.getName() : this.ISO88591;
        return StringEncoding_default.decode(new Uint8Array([code]), e);
      };
      StringUtils2.guessEncoding = function(bytes, hints) {
        if (hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType_default.CHARACTER_SET)) {
          return hints.get(DecodeHintType_default.CHARACTER_SET).toString();
        }
        var length = bytes.length;
        var canBeISO88591 = true;
        var canBeShiftJIS = true;
        var canBeUTF8 = true;
        var utf8BytesLeft = 0;
        var utf2BytesChars = 0;
        var utf3BytesChars = 0;
        var utf4BytesChars = 0;
        var sjisBytesLeft = 0;
        var sjisKatakanaChars = 0;
        var sjisCurKatakanaWordLength = 0;
        var sjisCurDoubleBytesWordLength = 0;
        var sjisMaxKatakanaWordLength = 0;
        var sjisMaxDoubleBytesWordLength = 0;
        var isoHighOther = 0;
        var utf8bom = bytes.length > 3 && bytes[0] === /*(byte) */
        239 && bytes[1] === /*(byte) */
        187 && bytes[2] === /*(byte) */
        191;
        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
          var value = bytes[i] & 255;
          if (canBeUTF8) {
            if (utf8BytesLeft > 0) {
              if ((value & 128) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft--;
              }
            } else if ((value & 128) !== 0) {
              if ((value & 64) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft++;
                if ((value & 32) === 0) {
                  utf2BytesChars++;
                } else {
                  utf8BytesLeft++;
                  if ((value & 16) === 0) {
                    utf3BytesChars++;
                  } else {
                    utf8BytesLeft++;
                    if ((value & 8) === 0) {
                      utf4BytesChars++;
                    } else {
                      canBeUTF8 = false;
                    }
                  }
                }
              }
            }
          }
          if (canBeISO88591) {
            if (value > 127 && value < 160) {
              canBeISO88591 = false;
            } else if (value > 159) {
              if (value < 192 || value === 215 || value === 247) {
                isoHighOther++;
              }
            }
          }
          if (canBeShiftJIS) {
            if (sjisBytesLeft > 0) {
              if (value < 64 || value === 127 || value > 252) {
                canBeShiftJIS = false;
              } else {
                sjisBytesLeft--;
              }
            } else if (value === 128 || value === 160 || value > 239) {
              canBeShiftJIS = false;
            } else if (value > 160 && value < 224) {
              sjisKatakanaChars++;
              sjisCurDoubleBytesWordLength = 0;
              sjisCurKatakanaWordLength++;
              if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
              }
            } else if (value > 127) {
              sjisBytesLeft++;
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength++;
              if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
              }
            } else {
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength = 0;
            }
          }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
          canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
          canBeShiftJIS = false;
        }
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
          return StringUtils2.UTF8;
        }
        if (canBeShiftJIS && (StringUtils2.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
          return StringUtils2.SHIFT_JIS;
        }
        if (canBeISO88591 && canBeShiftJIS) {
          return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils2.SHIFT_JIS : StringUtils2.ISO88591;
        }
        if (canBeISO88591) {
          return StringUtils2.ISO88591;
        }
        if (canBeShiftJIS) {
          return StringUtils2.SHIFT_JIS;
        }
        if (canBeUTF8) {
          return StringUtils2.UTF8;
        }
        return StringUtils2.PLATFORM_DEFAULT_ENCODING;
      };
      StringUtils2.format = function(append2) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (args[++i] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          var base2 = p3 ? parseInt(p3.substr(1)) : void 0;
          var val;
          switch (p4) {
            case "s":
              val = args[i];
              break;
            case "c":
              val = args[i][0];
              break;
            case "f":
              val = parseFloat(args[i]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(args[i]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(args[i]).toExponential(exp);
              break;
            case "x":
              val = parseInt(args[i]).toString(base2 ? base2 : 16);
              break;
            case "d":
              val = parseFloat(parseInt(args[i], base2 ? base2 : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base2);
          var size = parseInt(p1);
          var ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return append2.replace(regex, callback);
      };
      StringUtils2.getBytes = function(str, encoding) {
        return StringEncoding_default.encode(str, encoding);
      };
      StringUtils2.getCharCode = function(str, index) {
        if (index === void 0) {
          index = 0;
        }
        return str.charCodeAt(index);
      };
      StringUtils2.getCharAt = function(charCode) {
        return String.fromCharCode(charCode);
      };
      StringUtils2.SHIFT_JIS = CharacterSetECI_default.SJIS.getName();
      StringUtils2.GB2312 = "GB2312";
      StringUtils2.ISO88591 = CharacterSetECI_default.ISO8859_1.getName();
      StringUtils2.EUC_JP = "EUC_JP";
      StringUtils2.UTF8 = CharacterSetECI_default.UTF8.getName();
      StringUtils2.PLATFORM_DEFAULT_ENCODING = StringUtils2.UTF8;
      StringUtils2.ASSUME_SHIFT_JIS = false;
      return StringUtils2;
    }()
  );
  var StringUtils_default = StringUtils;

  // node_modules/@zxing/library/esm/core/util/StringBuilder.js
  var StringBuilder = (
    /** @class */
    function() {
      function StringBuilder2(value) {
        if (value === void 0) {
          value = "";
        }
        this.value = value;
      }
      StringBuilder2.prototype.enableDecoding = function(encoding) {
        this.encoding = encoding;
        return this;
      };
      StringBuilder2.prototype.append = function(s) {
        if (typeof s === "string") {
          this.value += s.toString();
        } else if (this.encoding) {
          this.value += StringUtils_default.castAsNonUtf8Char(s, this.encoding);
        } else {
          this.value += String.fromCharCode(s);
        }
        return this;
      };
      StringBuilder2.prototype.appendChars = function(str, offset2, len) {
        for (var i = offset2; offset2 < offset2 + len; i++) {
          this.append(str[i]);
        }
        return this;
      };
      StringBuilder2.prototype.length = function() {
        return this.value.length;
      };
      StringBuilder2.prototype.charAt = function(n) {
        return this.value.charAt(n);
      };
      StringBuilder2.prototype.deleteCharAt = function(n) {
        this.value = this.value.substr(0, n) + this.value.substring(n + 1);
      };
      StringBuilder2.prototype.setCharAt = function(n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
      };
      StringBuilder2.prototype.substring = function(start3, end2) {
        return this.value.substring(start3, end2);
      };
      StringBuilder2.prototype.setLengthToZero = function() {
        this.value = "";
      };
      StringBuilder2.prototype.toString = function() {
        return this.value;
      };
      StringBuilder2.prototype.insert = function(n, c) {
        this.value = this.value.substring(0, n) + c + this.value.substring(n);
      };
      return StringBuilder2;
    }()
  );
  var StringBuilder_default = StringBuilder;

  // node_modules/@zxing/library/esm/core/common/BitMatrix.js
  var BitMatrix = (
    /** @class */
    function() {
      function BitMatrix2(width, height, rowSize, bits) {
        this.width = width;
        this.height = height;
        this.rowSize = rowSize;
        this.bits = bits;
        if (void 0 === height || null === height) {
          height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
          throw new IllegalArgumentException_default("Both dimensions must be greater than 0");
        }
        if (void 0 === rowSize || null === rowSize) {
          rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (void 0 === bits || null === bits) {
          this.bits = new Int32Array(this.rowSize * this.height);
        }
      }
      BitMatrix2.parseFromBooleanArray = function(image) {
        var height = image.length;
        var width = image[0].length;
        var bits = new BitMatrix2(width, height);
        for (var i = 0; i < height; i++) {
          var imageI = image[i];
          for (var j = 0; j < width; j++) {
            if (imageI[j]) {
              bits.set(j, i);
            }
          }
        }
        return bits;
      };
      BitMatrix2.parseFromString = function(stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
          throw new IllegalArgumentException_default("stringRepresentation cannot be null");
        }
        var bits = new Array(stringRepresentation.length);
        var bitsPos = 0;
        var rowStartPos = 0;
        var rowLength = -1;
        var nRows = 0;
        var pos = 0;
        while (pos < stringRepresentation.length) {
          if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
            if (bitsPos > rowStartPos) {
              if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
              } else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException_default("row lengths do not match");
              }
              rowStartPos = bitsPos;
              nRows++;
            }
            pos++;
          } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
            pos += setString.length;
            bits[bitsPos] = true;
            bitsPos++;
          } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
            pos += unsetString.length;
            bits[bitsPos] = false;
            bitsPos++;
          } else {
            throw new IllegalArgumentException_default("illegal character encountered: " + stringRepresentation.substring(pos));
          }
        }
        if (bitsPos > rowStartPos) {
          if (rowLength === -1) {
            rowLength = bitsPos - rowStartPos;
          } else if (bitsPos - rowStartPos !== rowLength) {
            throw new IllegalArgumentException_default("row lengths do not match");
          }
          nRows++;
        }
        var matrix = new BitMatrix2(rowLength, nRows);
        for (var i = 0; i < bitsPos; i++) {
          if (bits[i]) {
            matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
          }
        }
        return matrix;
      };
      BitMatrix2.prototype.get = function(x, y) {
        var offset2 = y * this.rowSize + Math.floor(x / 32);
        return (this.bits[offset2] >>> (x & 31) & 1) !== 0;
      };
      BitMatrix2.prototype.set = function(x, y) {
        var offset2 = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset2] |= 1 << (x & 31) & 4294967295;
      };
      BitMatrix2.prototype.unset = function(x, y) {
        var offset2 = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset2] &= ~(1 << (x & 31) & 4294967295);
      };
      BitMatrix2.prototype.flip = function(x, y) {
        var offset2 = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset2] ^= 1 << (x & 31) & 4294967295;
      };
      BitMatrix2.prototype.xor = function(mask) {
        if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
          throw new IllegalArgumentException_default("input matrix dimensions do not match");
        }
        var rowArray = new BitArray_default(Math.floor(this.width / 32) + 1);
        var rowSize = this.rowSize;
        var bits = this.bits;
        for (var y = 0, height = this.height; y < height; y++) {
          var offset2 = y * rowSize;
          var row = mask.getRow(y, rowArray).getBitArray();
          for (var x = 0; x < rowSize; x++) {
            bits[offset2 + x] ^= row[x];
          }
        }
      };
      BitMatrix2.prototype.clear = function() {
        var bits = this.bits;
        var max2 = bits.length;
        for (var i = 0; i < max2; i++) {
          bits[i] = 0;
        }
      };
      BitMatrix2.prototype.setRegion = function(left2, top2, width, height) {
        if (top2 < 0 || left2 < 0) {
          throw new IllegalArgumentException_default("Left and top must be nonnegative");
        }
        if (height < 1 || width < 1) {
          throw new IllegalArgumentException_default("Height and width must be at least 1");
        }
        var right2 = left2 + width;
        var bottom2 = top2 + height;
        if (bottom2 > this.height || right2 > this.width) {
          throw new IllegalArgumentException_default("The region must fit inside the matrix");
        }
        var rowSize = this.rowSize;
        var bits = this.bits;
        for (var y = top2; y < bottom2; y++) {
          var offset2 = y * rowSize;
          for (var x = left2; x < right2; x++) {
            bits[offset2 + Math.floor(x / 32)] |= 1 << (x & 31) & 4294967295;
          }
        }
      };
      BitMatrix2.prototype.getRow = function(y, row) {
        if (row === null || row === void 0 || row.getSize() < this.width) {
          row = new BitArray_default(this.width);
        } else {
          row.clear();
        }
        var rowSize = this.rowSize;
        var bits = this.bits;
        var offset2 = y * rowSize;
        for (var x = 0; x < rowSize; x++) {
          row.setBulk(x * 32, bits[offset2 + x]);
        }
        return row;
      };
      BitMatrix2.prototype.setRow = function(y, row) {
        System_default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
      };
      BitMatrix2.prototype.rotate180 = function() {
        var width = this.getWidth();
        var height = this.getHeight();
        var topRow = new BitArray_default(width);
        var bottomRow = new BitArray_default(width);
        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {
          topRow = this.getRow(i, topRow);
          bottomRow = this.getRow(height - 1 - i, bottomRow);
          topRow.reverse();
          bottomRow.reverse();
          this.setRow(i, bottomRow);
          this.setRow(height - 1 - i, topRow);
        }
      };
      BitMatrix2.prototype.getEnclosingRectangle = function() {
        var width = this.width;
        var height = this.height;
        var rowSize = this.rowSize;
        var bits = this.bits;
        var left2 = width;
        var top2 = height;
        var right2 = -1;
        var bottom2 = -1;
        for (var y = 0; y < height; y++) {
          for (var x32 = 0; x32 < rowSize; x32++) {
            var theBits = bits[y * rowSize + x32];
            if (theBits !== 0) {
              if (y < top2) {
                top2 = y;
              }
              if (y > bottom2) {
                bottom2 = y;
              }
              if (x32 * 32 < left2) {
                var bit = 0;
                while ((theBits << 31 - bit & 4294967295) === 0) {
                  bit++;
                }
                if (x32 * 32 + bit < left2) {
                  left2 = x32 * 32 + bit;
                }
              }
              if (x32 * 32 + 31 > right2) {
                var bit = 31;
                while (theBits >>> bit === 0) {
                  bit--;
                }
                if (x32 * 32 + bit > right2) {
                  right2 = x32 * 32 + bit;
                }
              }
            }
          }
        }
        if (right2 < left2 || bottom2 < top2) {
          return null;
        }
        return Int32Array.from([left2, top2, right2 - left2 + 1, bottom2 - top2 + 1]);
      };
      BitMatrix2.prototype.getTopLeftOnBit = function() {
        var rowSize = this.rowSize;
        var bits = this.bits;
        var bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
          bitsOffset++;
        }
        if (bitsOffset === bits.length) {
          return null;
        }
        var y = bitsOffset / rowSize;
        var x = bitsOffset % rowSize * 32;
        var theBits = bits[bitsOffset];
        var bit = 0;
        while ((theBits << 31 - bit & 4294967295) === 0) {
          bit++;
        }
        x += bit;
        return Int32Array.from([x, y]);
      };
      BitMatrix2.prototype.getBottomRightOnBit = function() {
        var rowSize = this.rowSize;
        var bits = this.bits;
        var bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
          bitsOffset--;
        }
        if (bitsOffset < 0) {
          return null;
        }
        var y = Math.floor(bitsOffset / rowSize);
        var x = Math.floor(bitsOffset % rowSize) * 32;
        var theBits = bits[bitsOffset];
        var bit = 31;
        while (theBits >>> bit === 0) {
          bit--;
        }
        x += bit;
        return Int32Array.from([x, y]);
      };
      BitMatrix2.prototype.getWidth = function() {
        return this.width;
      };
      BitMatrix2.prototype.getHeight = function() {
        return this.height;
      };
      BitMatrix2.prototype.getRowSize = function() {
        return this.rowSize;
      };
      BitMatrix2.prototype.equals = function(o) {
        if (!(o instanceof BitMatrix2)) {
          return false;
        }
        var other = o;
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays_default.equals(this.bits, other.bits);
      };
      BitMatrix2.prototype.hashCode = function() {
        var hash3 = this.width;
        hash3 = 31 * hash3 + this.width;
        hash3 = 31 * hash3 + this.height;
        hash3 = 31 * hash3 + this.rowSize;
        hash3 = 31 * hash3 + Arrays_default.hashCode(this.bits);
        return hash3;
      };
      BitMatrix2.prototype.toString = function(setString, unsetString, lineSeparator) {
        if (setString === void 0) {
          setString = "X ";
        }
        if (unsetString === void 0) {
          unsetString = "  ";
        }
        if (lineSeparator === void 0) {
          lineSeparator = "\n";
        }
        return this.buildToString(setString, unsetString, lineSeparator);
      };
      BitMatrix2.prototype.buildToString = function(setString, unsetString, lineSeparator) {
        var result = new StringBuilder_default();
        for (var y = 0, height = this.height; y < height; y++) {
          for (var x = 0, width = this.width; x < width; x++) {
            result.append(this.get(x, y) ? setString : unsetString);
          }
          result.append(lineSeparator);
        }
        return result.toString();
      };
      BitMatrix2.prototype.clone = function() {
        return new BitMatrix2(this.width, this.height, this.rowSize, this.bits.slice());
      };
      return BitMatrix2;
    }()
  );
  var BitMatrix_default = BitMatrix;

  // node_modules/@zxing/library/esm/core/NotFoundException.js
  var __extends10 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var NotFoundException = (
    /** @class */
    function(_super) {
      __extends10(NotFoundException2, _super);
      function NotFoundException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NotFoundException2.getNotFoundInstance = function() {
        return new NotFoundException2();
      };
      NotFoundException2.kind = "NotFoundException";
      return NotFoundException2;
    }(Exception_default)
  );
  var NotFoundException_default = NotFoundException;

  // node_modules/@zxing/library/esm/core/common/GlobalHistogramBinarizer.js
  var __extends11 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var GlobalHistogramBinarizer = (
    /** @class */
    function(_super) {
      __extends11(GlobalHistogramBinarizer2, _super);
      function GlobalHistogramBinarizer2(source) {
        var _this = _super.call(this, source) || this;
        _this.luminances = GlobalHistogramBinarizer2.EMPTY;
        _this.buckets = new Int32Array(GlobalHistogramBinarizer2.LUMINANCE_BUCKETS);
        return _this;
      }
      GlobalHistogramBinarizer2.prototype.getBlackRow = function(y, row) {
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        if (row === void 0 || row === null || row.getSize() < width) {
          row = new BitArray_default(width);
        } else {
          row.clear();
        }
        this.initArrays(width);
        var localLuminances = source.getRow(y, this.luminances);
        var localBuckets = this.buckets;
        for (var x = 0; x < width; x++) {
          localBuckets[(localLuminances[x] & 255) >> GlobalHistogramBinarizer2.LUMINANCE_SHIFT]++;
        }
        var blackPoint = GlobalHistogramBinarizer2.estimateBlackPoint(localBuckets);
        if (width < 3) {
          for (var x = 0; x < width; x++) {
            if ((localLuminances[x] & 255) < blackPoint) {
              row.set(x);
            }
          }
        } else {
          var left2 = localLuminances[0] & 255;
          var center = localLuminances[1] & 255;
          for (var x = 1; x < width - 1; x++) {
            var right2 = localLuminances[x + 1] & 255;
            if ((center * 4 - left2 - right2) / 2 < blackPoint) {
              row.set(x);
            }
            left2 = center;
            center = right2;
          }
        }
        return row;
      };
      GlobalHistogramBinarizer2.prototype.getBlackMatrix = function() {
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        var height = source.getHeight();
        var matrix = new BitMatrix_default(width, height);
        this.initArrays(width);
        var localBuckets = this.buckets;
        for (var y = 1; y < 5; y++) {
          var row = Math.floor(height * y / 5);
          var localLuminances_1 = source.getRow(row, this.luminances);
          var right2 = Math.floor(width * 4 / 5);
          for (var x = Math.floor(width / 5); x < right2; x++) {
            var pixel = localLuminances_1[x] & 255;
            localBuckets[pixel >> GlobalHistogramBinarizer2.LUMINANCE_SHIFT]++;
          }
        }
        var blackPoint = GlobalHistogramBinarizer2.estimateBlackPoint(localBuckets);
        var localLuminances = source.getMatrix();
        for (var y = 0; y < height; y++) {
          var offset2 = y * width;
          for (var x = 0; x < width; x++) {
            var pixel = localLuminances[offset2 + x] & 255;
            if (pixel < blackPoint) {
              matrix.set(x, y);
            }
          }
        }
        return matrix;
      };
      GlobalHistogramBinarizer2.prototype.createBinarizer = function(source) {
        return new GlobalHistogramBinarizer2(source);
      };
      GlobalHistogramBinarizer2.prototype.initArrays = function(luminanceSize) {
        if (this.luminances.length < luminanceSize) {
          this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        var buckets = this.buckets;
        for (var x = 0; x < GlobalHistogramBinarizer2.LUMINANCE_BUCKETS; x++) {
          buckets[x] = 0;
        }
      };
      GlobalHistogramBinarizer2.estimateBlackPoint = function(buckets) {
        var numBuckets = buckets.length;
        var maxBucketCount = 0;
        var firstPeak = 0;
        var firstPeakSize = 0;
        for (var x = 0; x < numBuckets; x++) {
          if (buckets[x] > firstPeakSize) {
            firstPeak = x;
            firstPeakSize = buckets[x];
          }
          if (buckets[x] > maxBucketCount) {
            maxBucketCount = buckets[x];
          }
        }
        var secondPeak = 0;
        var secondPeakScore = 0;
        for (var x = 0; x < numBuckets; x++) {
          var distanceToBiggest = x - firstPeak;
          var score = buckets[x] * distanceToBiggest * distanceToBiggest;
          if (score > secondPeakScore) {
            secondPeak = x;
            secondPeakScore = score;
          }
        }
        if (firstPeak > secondPeak) {
          var temp = firstPeak;
          firstPeak = secondPeak;
          secondPeak = temp;
        }
        if (secondPeak - firstPeak <= numBuckets / 16) {
          throw new NotFoundException_default();
        }
        var bestValley = secondPeak - 1;
        var bestValleyScore = -1;
        for (var x = secondPeak - 1; x > firstPeak; x--) {
          var fromFirst = x - firstPeak;
          var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
          if (score > bestValleyScore) {
            bestValley = x;
            bestValleyScore = score;
          }
        }
        return bestValley << GlobalHistogramBinarizer2.LUMINANCE_SHIFT;
      };
      GlobalHistogramBinarizer2.LUMINANCE_BITS = 5;
      GlobalHistogramBinarizer2.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer2.LUMINANCE_BITS;
      GlobalHistogramBinarizer2.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer2.LUMINANCE_BITS;
      GlobalHistogramBinarizer2.EMPTY = Uint8ClampedArray.from([0]);
      return GlobalHistogramBinarizer2;
    }(Binarizer_default)
  );
  var GlobalHistogramBinarizer_default = GlobalHistogramBinarizer;

  // node_modules/@zxing/library/esm/core/common/HybridBinarizer.js
  var __extends12 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var HybridBinarizer = (
    /** @class */
    function(_super) {
      __extends12(HybridBinarizer2, _super);
      function HybridBinarizer2(source) {
        var _this = _super.call(this, source) || this;
        _this.matrix = null;
        return _this;
      }
      HybridBinarizer2.prototype.getBlackMatrix = function() {
        if (this.matrix !== null) {
          return this.matrix;
        }
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        var height = source.getHeight();
        if (width >= HybridBinarizer2.MINIMUM_DIMENSION && height >= HybridBinarizer2.MINIMUM_DIMENSION) {
          var luminances = source.getMatrix();
          var subWidth = width >> HybridBinarizer2.BLOCK_SIZE_POWER;
          if ((width & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
            subWidth++;
          }
          var subHeight = height >> HybridBinarizer2.BLOCK_SIZE_POWER;
          if ((height & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
            subHeight++;
          }
          var blackPoints = HybridBinarizer2.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
          var newMatrix = new BitMatrix_default(width, height);
          HybridBinarizer2.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
          this.matrix = newMatrix;
        } else {
          this.matrix = _super.prototype.getBlackMatrix.call(this);
        }
        return this.matrix;
      };
      HybridBinarizer2.prototype.createBinarizer = function(source) {
        return new HybridBinarizer2(source);
      };
      HybridBinarizer2.calculateThresholdForBlock = function(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
        var maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
        var maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
        for (var y = 0; y < subHeight; y++) {
          var yoffset = y << HybridBinarizer2.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          var top_1 = HybridBinarizer2.cap(y, 2, subHeight - 3);
          for (var x = 0; x < subWidth; x++) {
            var xoffset = x << HybridBinarizer2.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            var left2 = HybridBinarizer2.cap(x, 2, subWidth - 3);
            var sum = 0;
            for (var z = -2; z <= 2; z++) {
              var blackRow = blackPoints[top_1 + z];
              sum += blackRow[left2 - 2] + blackRow[left2 - 1] + blackRow[left2] + blackRow[left2 + 1] + blackRow[left2 + 2];
            }
            var average = sum / 25;
            HybridBinarizer2.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
          }
        }
      };
      HybridBinarizer2.cap = function(value, min2, max2) {
        return value < min2 ? min2 : value > max2 ? max2 : value;
      };
      HybridBinarizer2.thresholdBlock = function(luminances, xoffset, yoffset, threshold, stride, matrix) {
        for (var y = 0, offset2 = yoffset * stride + xoffset; y < HybridBinarizer2.BLOCK_SIZE; y++, offset2 += stride) {
          for (var x = 0; x < HybridBinarizer2.BLOCK_SIZE; x++) {
            if ((luminances[offset2 + x] & 255) <= threshold) {
              matrix.set(xoffset + x, yoffset + y);
            }
          }
        }
      };
      HybridBinarizer2.calculateBlackPoints = function(luminances, subWidth, subHeight, width, height) {
        var maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
        var maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
        var blackPoints = new Array(subHeight);
        for (var y = 0; y < subHeight; y++) {
          blackPoints[y] = new Int32Array(subWidth);
          var yoffset = y << HybridBinarizer2.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          for (var x = 0; x < subWidth; x++) {
            var xoffset = x << HybridBinarizer2.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            var sum = 0;
            var min2 = 255;
            var max2 = 0;
            for (var yy = 0, offset2 = yoffset * width + xoffset; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset2 += width) {
              for (var xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
                var pixel = luminances[offset2 + xx] & 255;
                sum += pixel;
                if (pixel < min2) {
                  min2 = pixel;
                }
                if (pixel > max2) {
                  max2 = pixel;
                }
              }
              if (max2 - min2 > HybridBinarizer2.MIN_DYNAMIC_RANGE) {
                for (yy++, offset2 += width; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset2 += width) {
                  for (var xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
                    sum += luminances[offset2 + xx] & 255;
                  }
                }
              }
            }
            var average = sum >> HybridBinarizer2.BLOCK_SIZE_POWER * 2;
            if (max2 - min2 <= HybridBinarizer2.MIN_DYNAMIC_RANGE) {
              average = min2 / 2;
              if (y > 0 && x > 0) {
                var averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;
                if (min2 < averageNeighborBlackPoint) {
                  average = averageNeighborBlackPoint;
                }
              }
            }
            blackPoints[y][x] = average;
          }
        }
        return blackPoints;
      };
      HybridBinarizer2.BLOCK_SIZE_POWER = 3;
      HybridBinarizer2.BLOCK_SIZE = 1 << HybridBinarizer2.BLOCK_SIZE_POWER;
      HybridBinarizer2.BLOCK_SIZE_MASK = HybridBinarizer2.BLOCK_SIZE - 1;
      HybridBinarizer2.MINIMUM_DIMENSION = HybridBinarizer2.BLOCK_SIZE * 5;
      HybridBinarizer2.MIN_DYNAMIC_RANGE = 24;
      return HybridBinarizer2;
    }(GlobalHistogramBinarizer_default)
  );
  var HybridBinarizer_default = HybridBinarizer;

  // node_modules/@zxing/library/esm/core/LuminanceSource.js
  var LuminanceSource = (
    /** @class */
    function() {
      function LuminanceSource2(width, height) {
        this.width = width;
        this.height = height;
      }
      LuminanceSource2.prototype.getWidth = function() {
        return this.width;
      };
      LuminanceSource2.prototype.getHeight = function() {
        return this.height;
      };
      LuminanceSource2.prototype.isCropSupported = function() {
        return false;
      };
      LuminanceSource2.prototype.crop = function(left2, top2, width, height) {
        throw new UnsupportedOperationException_default("This luminance source does not support cropping.");
      };
      LuminanceSource2.prototype.isRotateSupported = function() {
        return false;
      };
      LuminanceSource2.prototype.rotateCounterClockwise = function() {
        throw new UnsupportedOperationException_default("This luminance source does not support rotation by 90 degrees.");
      };
      LuminanceSource2.prototype.rotateCounterClockwise45 = function() {
        throw new UnsupportedOperationException_default("This luminance source does not support rotation by 45 degrees.");
      };
      LuminanceSource2.prototype.toString = function() {
        var row = new Uint8ClampedArray(this.width);
        var result = new StringBuilder_default();
        for (var y = 0; y < this.height; y++) {
          var sourceRow = this.getRow(y, row);
          for (var x = 0; x < this.width; x++) {
            var luminance = sourceRow[x] & 255;
            var c = void 0;
            if (luminance < 64) {
              c = "#";
            } else if (luminance < 128) {
              c = "+";
            } else if (luminance < 192) {
              c = ".";
            } else {
              c = " ";
            }
            result.append(c);
          }
          result.append("\n");
        }
        return result.toString();
      };
      return LuminanceSource2;
    }()
  );
  var LuminanceSource_default = LuminanceSource;

  // node_modules/@zxing/library/esm/core/InvertedLuminanceSource.js
  var __extends13 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var InvertedLuminanceSource = (
    /** @class */
    function(_super) {
      __extends13(InvertedLuminanceSource2, _super);
      function InvertedLuminanceSource2(delegate) {
        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;
        _this.delegate = delegate;
        return _this;
      }
      InvertedLuminanceSource2.prototype.getRow = function(y, row) {
        var sourceRow = this.delegate.getRow(y, row);
        var width = this.getWidth();
        for (var i = 0; i < width; i++) {
          sourceRow[i] = /*(byte)*/
          255 - (sourceRow[i] & 255);
        }
        return sourceRow;
      };
      InvertedLuminanceSource2.prototype.getMatrix = function() {
        var matrix = this.delegate.getMatrix();
        var length = this.getWidth() * this.getHeight();
        var invertedMatrix = new Uint8ClampedArray(length);
        for (var i = 0; i < length; i++) {
          invertedMatrix[i] = /*(byte)*/
          255 - (matrix[i] & 255);
        }
        return invertedMatrix;
      };
      InvertedLuminanceSource2.prototype.isCropSupported = function() {
        return this.delegate.isCropSupported();
      };
      InvertedLuminanceSource2.prototype.crop = function(left2, top2, width, height) {
        return new InvertedLuminanceSource2(this.delegate.crop(left2, top2, width, height));
      };
      InvertedLuminanceSource2.prototype.isRotateSupported = function() {
        return this.delegate.isRotateSupported();
      };
      InvertedLuminanceSource2.prototype.invert = function() {
        return this.delegate;
      };
      InvertedLuminanceSource2.prototype.rotateCounterClockwise = function() {
        return new InvertedLuminanceSource2(this.delegate.rotateCounterClockwise());
      };
      InvertedLuminanceSource2.prototype.rotateCounterClockwise45 = function() {
        return new InvertedLuminanceSource2(this.delegate.rotateCounterClockwise45());
      };
      return InvertedLuminanceSource2;
    }(LuminanceSource_default)
  );
  var InvertedLuminanceSource_default = InvertedLuminanceSource;

  // node_modules/@zxing/library/esm/browser/HTMLCanvasElementLuminanceSource.js
  var __extends14 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var HTMLCanvasElementLuminanceSource = (
    /** @class */
    function(_super) {
      __extends14(HTMLCanvasElementLuminanceSource3, _super);
      function HTMLCanvasElementLuminanceSource3(canvas, doAutoInvert) {
        if (doAutoInvert === void 0) {
          doAutoInvert = false;
        }
        var _this = _super.call(this, canvas.width, canvas.height) || this;
        _this.canvas = canvas;
        _this.tempCanvasElement = null;
        _this.buffer = HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData(canvas, doAutoInvert);
        return _this;
      }
      HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData = function(canvas, doAutoInvert) {
        if (doAutoInvert === void 0) {
          doAutoInvert = false;
        }
        var imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource3.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height, doAutoInvert);
      };
      HTMLCanvasElementLuminanceSource3.toGrayscaleBuffer = function(imageBuffer, width, height, doAutoInvert) {
        if (doAutoInvert === void 0) {
          doAutoInvert = false;
        }
        var grayscaleBuffer = new Uint8ClampedArray(width * height);
        HTMLCanvasElementLuminanceSource3.FRAME_INDEX = !HTMLCanvasElementLuminanceSource3.FRAME_INDEX;
        if (HTMLCanvasElementLuminanceSource3.FRAME_INDEX || !doAutoInvert) {
          for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
            var gray = void 0;
            var alpha = imageBuffer[i + 3];
            if (alpha === 0) {
              gray = 255;
            } else {
              var pixelR = imageBuffer[i];
              var pixelG = imageBuffer[i + 1];
              var pixelB = imageBuffer[i + 2];
              gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
            }
            grayscaleBuffer[j] = gray;
          }
        } else {
          for (var i = 0, j = 0, length_2 = imageBuffer.length; i < length_2; i += 4, j++) {
            var gray = void 0;
            var alpha = imageBuffer[i + 3];
            if (alpha === 0) {
              gray = 255;
            } else {
              var pixelR = imageBuffer[i];
              var pixelG = imageBuffer[i + 1];
              var pixelB = imageBuffer[i + 2];
              gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
            }
            grayscaleBuffer[j] = 255 - gray;
          }
        }
        return grayscaleBuffer;
      };
      HTMLCanvasElementLuminanceSource3.prototype.getRow = function(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
        }
        var width = this.getWidth();
        var start3 = y * width;
        if (row === null) {
          row = this.buffer.slice(start3, start3 + width);
        } else {
          if (row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          row.set(this.buffer.slice(start3, start3 + width));
        }
        return row;
      };
      HTMLCanvasElementLuminanceSource3.prototype.getMatrix = function() {
        return this.buffer;
      };
      HTMLCanvasElementLuminanceSource3.prototype.isCropSupported = function() {
        return true;
      };
      HTMLCanvasElementLuminanceSource3.prototype.crop = function(left2, top2, width, height) {
        _super.prototype.crop.call(this, left2, top2, width, height);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.isRotateSupported = function() {
        return true;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotateCounterClockwise = function() {
        this.rotate(-90);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotateCounterClockwise45 = function() {
        this.rotate(-45);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.getTempCanvasElement = function() {
        if (null === this.tempCanvasElement) {
          var tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
          tempCanvasElement.width = this.canvas.width;
          tempCanvasElement.height = this.canvas.height;
          this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotate = function(angle) {
        var tempCanvasElement = this.getTempCanvasElement();
        var tempContext = tempCanvasElement.getContext("2d");
        var angleRadians = angle * HTMLCanvasElementLuminanceSource3.DEGREE_TO_RADIANS;
        var width = this.canvas.width;
        var height = this.canvas.height;
        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.invert = function() {
        return new InvertedLuminanceSource_default(this);
      };
      HTMLCanvasElementLuminanceSource3.DEGREE_TO_RADIANS = Math.PI / 180;
      HTMLCanvasElementLuminanceSource3.FRAME_INDEX = true;
      return HTMLCanvasElementLuminanceSource3;
    }(LuminanceSource_default)
  );

  // node_modules/@zxing/library/esm/browser/VideoInputDevice.js
  var VideoInputDevice = (
    /** @class */
    function() {
      function VideoInputDevice2(deviceId, label, groupId) {
        this.deviceId = deviceId;
        this.label = label;
        this.kind = "videoinput";
        this.groupId = groupId || void 0;
      }
      VideoInputDevice2.prototype.toJSON = function() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label
        };
      };
      return VideoInputDevice2;
    }()
  );

  // node_modules/@zxing/library/esm/browser/BrowserCodeReader.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __values3 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var BrowserCodeReader = (
    /** @class */
    function() {
      function BrowserCodeReader3(reader, timeBetweenScansMillis, _hints) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
        this._hints = _hints;
        this._stopContinuousDecode = false;
        this._stopAsyncDecode = false;
        this._timeBetweenDecodingAttempts = 0;
      }
      Object.defineProperty(BrowserCodeReader3.prototype, "hasNavigator", {
        /**
         * If navigator is present.
         */
        get: function() {
          return typeof navigator !== "undefined";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BrowserCodeReader3.prototype, "isMediaDevicesSuported", {
        /**
         * If mediaDevices under navigator is supported.
         */
        get: function() {
          return this.hasNavigator && !!navigator.mediaDevices;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BrowserCodeReader3.prototype, "canEnumerateDevices", {
        /**
         * If enumerateDevices under navigator is supported.
         */
        get: function() {
          return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BrowserCodeReader3.prototype, "timeBetweenDecodingAttempts", {
        /** Time between two decoding tries in milli seconds. */
        get: function() {
          return this._timeBetweenDecodingAttempts;
        },
        /**
         * Change the time span the decoder waits between two decoding tries.
         *
         * @param {number} millis Time between two decoding tries in milli seconds.
         */
        set: function(millis) {
          this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BrowserCodeReader3.prototype, "hints", {
        /**
         * Sets the hints.
         */
        get: function() {
          return this._hints;
        },
        /**
         * Sets the hints.
         */
        set: function(hints) {
          this._hints = hints || null;
        },
        enumerable: false,
        configurable: true
      });
      BrowserCodeReader3.prototype.listVideoInputDevices = function() {
        return __awaiter(this, void 0, void 0, function() {
          var devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;
          var e_1, _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!this.hasNavigator) {
                  throw new Error("Can't enumerate devices, navigator is not present.");
                }
                if (!this.canEnumerateDevices) {
                  throw new Error("Can't enumerate devices, method not supported.");
                }
                return [4, navigator.mediaDevices.enumerateDevices()];
              case 1:
                devices = _b.sent();
                videoDevices = [];
                try {
                  for (devices_1 = __values3(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {
                    device = devices_1_1.value;
                    kind = device.kind === "video" ? "videoinput" : device.kind;
                    if (kind !== "videoinput") {
                      continue;
                    }
                    deviceId = device.deviceId || device.id;
                    label = device.label || "Video device " + (videoDevices.length + 1);
                    groupId = device.groupId;
                    videoDevice = { deviceId, label, kind, groupId };
                    videoDevices.push(videoDevice);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (devices_1_1 && !devices_1_1.done && (_a2 = devices_1.return)) _a2.call(devices_1);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                return [2, videoDevices];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.getVideoInputDevices = function() {
        return __awaiter(this, void 0, void 0, function() {
          var devices;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.listVideoInputDevices()];
              case 1:
                devices = _a2.sent();
                return [2, devices.map(function(d) {
                  return new VideoInputDevice(d.deviceId, d.label);
                })];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.findDeviceById = function(deviceId) {
        return __awaiter(this, void 0, void 0, function() {
          var devices;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.listVideoInputDevices()];
              case 1:
                devices = _a2.sent();
                if (!devices) {
                  return [2, null];
                }
                return [2, devices.find(function(x) {
                  return x.deviceId === deviceId;
                })];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromInputVideoDevice = function(deviceId, videoSource) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.decodeOnceFromVideoDevice(deviceId, videoSource)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromVideoDevice = function(deviceId, videoSource) {
        return __awaiter(this, void 0, void 0, function() {
          var videoConstraints, constraints;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.reset();
                if (!deviceId) {
                  videoConstraints = { facingMode: "environment" };
                } else {
                  videoConstraints = { deviceId: { exact: deviceId } };
                }
                constraints = { video: videoConstraints };
                return [4, this.decodeOnceFromConstraints(constraints, videoSource)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromConstraints = function(constraints, videoSource) {
        return __awaiter(this, void 0, void 0, function() {
          var stream;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, navigator.mediaDevices.getUserMedia(constraints)];
              case 1:
                stream = _a2.sent();
                return [4, this.decodeOnceFromStream(stream, videoSource)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromStream = function(stream, videoSource) {
        return __awaiter(this, void 0, void 0, function() {
          var video, result;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.reset();
                return [4, this.attachStreamToVideo(stream, videoSource)];
              case 1:
                video = _a2.sent();
                return [4, this.decodeOnce(video)];
              case 2:
                result = _a2.sent();
                return [2, result];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromInputVideoDeviceContinuously = function(deviceId, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.decodeFromVideoDevice(deviceId, videoSource, callbackFn)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromVideoDevice = function(deviceId, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function() {
          var videoConstraints, constraints;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!deviceId) {
                  videoConstraints = { facingMode: "environment" };
                } else {
                  videoConstraints = { deviceId: { exact: deviceId } };
                }
                constraints = { video: videoConstraints };
                return [4, this.decodeFromConstraints(constraints, videoSource, callbackFn)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromConstraints = function(constraints, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function() {
          var stream;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, navigator.mediaDevices.getUserMedia(constraints)];
              case 1:
                stream = _a2.sent();
                return [4, this.decodeFromStream(stream, videoSource, callbackFn)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromStream = function(stream, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function() {
          var video;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.reset();
                return [4, this.attachStreamToVideo(stream, videoSource)];
              case 1:
                video = _a2.sent();
                return [4, this.decodeContinuously(video, callbackFn)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.stopAsyncDecode = function() {
        this._stopAsyncDecode = true;
      };
      BrowserCodeReader3.prototype.stopContinuousDecode = function() {
        this._stopContinuousDecode = true;
      };
      BrowserCodeReader3.prototype.attachStreamToVideo = function(stream, videoSource) {
        return __awaiter(this, void 0, void 0, function() {
          var videoElement;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                videoElement = this.prepareVideoElement(videoSource);
                this.addVideoSource(videoElement, stream);
                this.videoElement = videoElement;
                this.stream = stream;
                return [4, this.playVideoOnLoadAsync(videoElement)];
              case 1:
                _a2.sent();
                return [2, videoElement];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.playVideoOnLoadAsync = function(videoElement) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          return _this.playVideoOnLoad(videoElement, function() {
            return resolve();
          });
        });
      };
      BrowserCodeReader3.prototype.playVideoOnLoad = function(element, callbackFn) {
        var _this = this;
        this.videoEndedListener = function() {
          return _this.stopStreams();
        };
        this.videoCanPlayListener = function() {
          return _this.tryPlayVideo(element);
        };
        element.addEventListener("ended", this.videoEndedListener);
        element.addEventListener("canplay", this.videoCanPlayListener);
        element.addEventListener("playing", callbackFn);
        this.tryPlayVideo(element);
      };
      BrowserCodeReader3.prototype.isVideoPlaying = function(video) {
        return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
      };
      BrowserCodeReader3.prototype.tryPlayVideo = function(videoElement) {
        return __awaiter(this, void 0, void 0, function() {
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (this.isVideoPlaying(videoElement)) {
                  console.warn("Trying to play video that is already playing.");
                  return [
                    2
                    /*return*/
                  ];
                }
                _b.label = 1;
              case 1:
                _b.trys.push([1, 3, , 4]);
                return [4, videoElement.play()];
              case 2:
                _b.sent();
                return [3, 4];
              case 3:
                _a2 = _b.sent();
                console.warn("It was not possible to play the video.");
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.getMediaElement = function(mediaElementId, type) {
        var mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
          throw new ArgumentException_default("element with id '" + mediaElementId + "' not found");
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
          throw new ArgumentException_default("element with id '" + mediaElementId + "' must be an " + type + " element");
        }
        return mediaElement;
      };
      BrowserCodeReader3.prototype.decodeFromImage = function(source, url) {
        if (!source && !url) {
          throw new ArgumentException_default("either imageElement with a src set or an url must be provided");
        }
        if (url && !source) {
          return this.decodeFromImageUrl(url);
        }
        return this.decodeFromImageElement(source);
      };
      BrowserCodeReader3.prototype.decodeFromVideo = function(source, url) {
        if (!source && !url) {
          throw new ArgumentException_default("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrl(url);
        }
        return this.decodeFromVideoElement(source);
      };
      BrowserCodeReader3.prototype.decodeFromVideoContinuously = function(source, url, callbackFn) {
        if (void 0 === source && void 0 === url) {
          throw new ArgumentException_default("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrlContinuously(url, callbackFn);
        }
        return this.decodeFromVideoElementContinuously(source, callbackFn);
      };
      BrowserCodeReader3.prototype.decodeFromImageElement = function(source) {
        if (!source) {
          throw new ArgumentException_default("An image element must be provided.");
        }
        this.reset();
        var element = this.prepareImageElement(source);
        this.imageElement = element;
        var task;
        if (this.isImageLoaded(element)) {
          task = this.decodeOnce(element, false, true);
        } else {
          task = this._decodeOnLoadImage(element);
        }
        return task;
      };
      BrowserCodeReader3.prototype.decodeFromVideoElement = function(source) {
        var element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideo(element);
      };
      BrowserCodeReader3.prototype.decodeFromVideoElementContinuously = function(source, callbackFn) {
        var element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideoContinuously(element, callbackFn);
      };
      BrowserCodeReader3.prototype._decodeFromVideoElementSetup = function(source) {
        if (!source) {
          throw new ArgumentException_default("A video element must be provided.");
        }
        this.reset();
        var element = this.prepareVideoElement(source);
        this.videoElement = element;
        return element;
      };
      BrowserCodeReader3.prototype.decodeFromImageUrl = function(url) {
        if (!url) {
          throw new ArgumentException_default("An URL must be provided.");
        }
        this.reset();
        var element = this.prepareImageElement();
        this.imageElement = element;
        var decodeTask = this._decodeOnLoadImage(element);
        element.src = url;
        return decodeTask;
      };
      BrowserCodeReader3.prototype.decodeFromVideoUrl = function(url) {
        if (!url) {
          throw new ArgumentException_default("An URL must be provided.");
        }
        this.reset();
        var element = this.prepareVideoElement();
        var decodeTask = this.decodeFromVideoElement(element);
        element.src = url;
        return decodeTask;
      };
      BrowserCodeReader3.prototype.decodeFromVideoUrlContinuously = function(url, callbackFn) {
        if (!url) {
          throw new ArgumentException_default("An URL must be provided.");
        }
        this.reset();
        var element = this.prepareVideoElement();
        var decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
        element.src = url;
        return decodeTask;
      };
      BrowserCodeReader3.prototype._decodeOnLoadImage = function(element) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.imageLoadedListener = function() {
            return _this.decodeOnce(element, false, true).then(resolve, reject);
          };
          element.addEventListener("load", _this.imageLoadedListener);
        });
      };
      BrowserCodeReader3.prototype._decodeOnLoadVideo = function(videoElement) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.playVideoOnLoadAsync(videoElement)];
              case 1:
                _a2.sent();
                return [4, this.decodeOnce(videoElement)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype._decodeOnLoadVideoContinuously = function(videoElement, callbackFn) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.playVideoOnLoadAsync(videoElement)];
              case 1:
                _a2.sent();
                this.decodeContinuously(videoElement, callbackFn);
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.isImageLoaded = function(img) {
        if (!img.complete) {
          return false;
        }
        if (img.naturalWidth === 0) {
          return false;
        }
        return true;
      };
      BrowserCodeReader3.prototype.prepareImageElement = function(imageSource) {
        var imageElement;
        if (typeof imageSource === "undefined") {
          imageElement = document.createElement("img");
          imageElement.width = 200;
          imageElement.height = 200;
        }
        if (typeof imageSource === "string") {
          imageElement = this.getMediaElement(imageSource, "img");
        }
        if (imageSource instanceof HTMLImageElement) {
          imageElement = imageSource;
        }
        return imageElement;
      };
      BrowserCodeReader3.prototype.prepareVideoElement = function(videoSource) {
        var videoElement;
        if (!videoSource && typeof document !== "undefined") {
          videoElement = document.createElement("video");
          videoElement.width = 200;
          videoElement.height = 200;
        }
        if (typeof videoSource === "string") {
          videoElement = this.getMediaElement(videoSource, "video");
        }
        if (videoSource instanceof HTMLVideoElement) {
          videoElement = videoSource;
        }
        videoElement.setAttribute("autoplay", "true");
        videoElement.setAttribute("muted", "true");
        videoElement.setAttribute("playsinline", "true");
        return videoElement;
      };
      BrowserCodeReader3.prototype.decodeOnce = function(element, retryIfNotFound, retryIfChecksumOrFormatError) {
        var _this = this;
        if (retryIfNotFound === void 0) {
          retryIfNotFound = true;
        }
        if (retryIfChecksumOrFormatError === void 0) {
          retryIfChecksumOrFormatError = true;
        }
        this._stopAsyncDecode = false;
        var loop = function(resolve, reject) {
          if (_this._stopAsyncDecode) {
            reject(new NotFoundException_default("Video stream has ended before any code could be detected."));
            _this._stopAsyncDecode = void 0;
            return;
          }
          try {
            var result = _this.decode(element);
            resolve(result);
          } catch (e) {
            var ifNotFound = retryIfNotFound && e instanceof NotFoundException_default;
            var isChecksumOrFormatError = e instanceof ChecksumException_default || e instanceof FormatException_default;
            var ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
            if (ifNotFound || ifChecksumOrFormat) {
              return setTimeout(loop, _this._timeBetweenDecodingAttempts, resolve, reject);
            }
            reject(e);
          }
        };
        return new Promise(function(resolve, reject) {
          return loop(resolve, reject);
        });
      };
      BrowserCodeReader3.prototype.decodeContinuously = function(element, callbackFn) {
        var _this = this;
        this._stopContinuousDecode = false;
        var loop = function() {
          if (_this._stopContinuousDecode) {
            _this._stopContinuousDecode = void 0;
            return;
          }
          try {
            var result = _this.decode(element);
            callbackFn(result, null);
            setTimeout(loop, _this.timeBetweenScansMillis);
          } catch (e) {
            callbackFn(null, e);
            var isChecksumOrFormatError = e instanceof ChecksumException_default || e instanceof FormatException_default;
            var isNotFound = e instanceof NotFoundException_default;
            if (isChecksumOrFormatError || isNotFound) {
              setTimeout(loop, _this._timeBetweenDecodingAttempts);
            }
          }
        };
        loop();
      };
      BrowserCodeReader3.prototype.decode = function(element) {
        var binaryBitmap = this.createBinaryBitmap(element);
        return this.decodeBitmap(binaryBitmap);
      };
      BrowserCodeReader3.prototype.createBinaryBitmap = function(mediaElement) {
        var ctx = this.getCaptureCanvasContext(mediaElement);
        var doAutoInvert = false;
        if (mediaElement instanceof HTMLVideoElement) {
          this.drawFrameOnCanvas(mediaElement);
          doAutoInvert = true;
        } else {
          this.drawImageOnCanvas(mediaElement);
        }
        var canvas = this.getCaptureCanvas(mediaElement);
        var luminanceSource = new HTMLCanvasElementLuminanceSource(canvas, doAutoInvert);
        var hybridBinarizer = new HybridBinarizer_default(luminanceSource);
        return new BinaryBitmap_default(hybridBinarizer);
      };
      BrowserCodeReader3.prototype.getCaptureCanvasContext = function(mediaElement) {
        if (!this.captureCanvasContext) {
          var elem = this.getCaptureCanvas(mediaElement);
          var ctx = void 0;
          try {
            ctx = elem.getContext("2d", { willReadFrequently: true });
          } catch (e) {
            ctx = elem.getContext("2d");
          }
          this.captureCanvasContext = ctx;
        }
        return this.captureCanvasContext;
      };
      BrowserCodeReader3.prototype.getCaptureCanvas = function(mediaElement) {
        if (!this.captureCanvas) {
          var elem = this.createCaptureCanvas(mediaElement);
          this.captureCanvas = elem;
        }
        return this.captureCanvas;
      };
      BrowserCodeReader3.prototype.drawFrameOnCanvas = function(srcElement, dimensions, canvasElementContext) {
        if (dimensions === void 0) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.videoWidth,
            sHeight: srcElement.videoHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.videoWidth,
            dHeight: srcElement.videoHeight
          };
        }
        if (canvasElementContext === void 0) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
      };
      BrowserCodeReader3.prototype.drawImageOnCanvas = function(srcElement, dimensions, canvasElementContext) {
        if (dimensions === void 0) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.naturalWidth,
            sHeight: srcElement.naturalHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.naturalWidth,
            dHeight: srcElement.naturalHeight
          };
        }
        if (canvasElementContext === void 0) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
      };
      BrowserCodeReader3.prototype.decodeBitmap = function(binaryBitmap) {
        return this.reader.decode(binaryBitmap, this._hints);
      };
      BrowserCodeReader3.prototype.createCaptureCanvas = function(mediaElement) {
        if (typeof document === "undefined") {
          this._destroyCaptureCanvas();
          return null;
        }
        var canvasElement = document.createElement("canvas");
        var width;
        var height;
        if (typeof mediaElement !== "undefined") {
          if (mediaElement instanceof HTMLVideoElement) {
            width = mediaElement.videoWidth;
            height = mediaElement.videoHeight;
          } else if (mediaElement instanceof HTMLImageElement) {
            width = mediaElement.naturalWidth || mediaElement.width;
            height = mediaElement.naturalHeight || mediaElement.height;
          }
        }
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
      };
      BrowserCodeReader3.prototype.stopStreams = function() {
        if (this.stream) {
          this.stream.getVideoTracks().forEach(function(t) {
            return t.stop();
          });
          this.stream = void 0;
        }
        if (this._stopAsyncDecode === false) {
          this.stopAsyncDecode();
        }
        if (this._stopContinuousDecode === false) {
          this.stopContinuousDecode();
        }
      };
      BrowserCodeReader3.prototype.reset = function() {
        this.stopStreams();
        this._destroyVideoElement();
        this._destroyImageElement();
        this._destroyCaptureCanvas();
      };
      BrowserCodeReader3.prototype._destroyVideoElement = function() {
        if (!this.videoElement) {
          return;
        }
        if (typeof this.videoEndedListener !== "undefined") {
          this.videoElement.removeEventListener("ended", this.videoEndedListener);
        }
        if (typeof this.videoPlayingEventListener !== "undefined") {
          this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
        }
        if (typeof this.videoCanPlayListener !== "undefined") {
          this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
        }
        this.cleanVideoSource(this.videoElement);
        this.videoElement = void 0;
      };
      BrowserCodeReader3.prototype._destroyImageElement = function() {
        if (!this.imageElement) {
          return;
        }
        if (void 0 !== this.imageLoadedListener) {
          this.imageElement.removeEventListener("load", this.imageLoadedListener);
        }
        this.imageElement.src = void 0;
        this.imageElement.removeAttribute("src");
        this.imageElement = void 0;
      };
      BrowserCodeReader3.prototype._destroyCaptureCanvas = function() {
        this.captureCanvasContext = void 0;
        this.captureCanvas = void 0;
      };
      BrowserCodeReader3.prototype.addVideoSource = function(videoElement, stream) {
        try {
          videoElement.srcObject = stream;
        } catch (err) {
          videoElement.src = URL.createObjectURL(stream);
        }
      };
      BrowserCodeReader3.prototype.cleanVideoSource = function(videoElement) {
        try {
          videoElement.srcObject = null;
        } catch (err) {
          videoElement.src = "";
        }
        this.videoElement.removeAttribute("src");
      };
      return BrowserCodeReader3;
    }()
  );

  // node_modules/@zxing/library/esm/core/Result.js
  var Result = (
    /** @class */
    function() {
      function Result3(text, rawBytes, numBits, resultPoints, format, timestamp) {
        if (numBits === void 0) {
          numBits = rawBytes == null ? 0 : 8 * rawBytes.length;
        }
        if (timestamp === void 0) {
          timestamp = System_default.currentTimeMillis();
        }
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits;
        this.resultPoints = resultPoints;
        this.format = format;
        this.timestamp = timestamp;
        this.text = text;
        this.rawBytes = rawBytes;
        if (void 0 === numBits || null === numBits) {
          this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
        } else {
          this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format;
        this.resultMetadata = null;
        if (void 0 === timestamp || null === timestamp) {
          this.timestamp = System_default.currentTimeMillis();
        } else {
          this.timestamp = timestamp;
        }
      }
      Result3.prototype.getText = function() {
        return this.text;
      };
      Result3.prototype.getRawBytes = function() {
        return this.rawBytes;
      };
      Result3.prototype.getNumBits = function() {
        return this.numBits;
      };
      Result3.prototype.getResultPoints = function() {
        return this.resultPoints;
      };
      Result3.prototype.getBarcodeFormat = function() {
        return this.format;
      };
      Result3.prototype.getResultMetadata = function() {
        return this.resultMetadata;
      };
      Result3.prototype.putMetadata = function(type, value) {
        if (this.resultMetadata === null) {
          this.resultMetadata = /* @__PURE__ */ new Map();
        }
        this.resultMetadata.set(type, value);
      };
      Result3.prototype.putAllMetadata = function(metadata) {
        if (metadata !== null) {
          if (this.resultMetadata === null) {
            this.resultMetadata = metadata;
          } else {
            this.resultMetadata = new Map(metadata);
          }
        }
      };
      Result3.prototype.addResultPoints = function(newPoints) {
        var oldPoints = this.resultPoints;
        if (oldPoints === null) {
          this.resultPoints = newPoints;
        } else if (newPoints !== null && newPoints.length > 0) {
          var allPoints = new Array(oldPoints.length + newPoints.length);
          System_default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
          System_default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
          this.resultPoints = allPoints;
        }
      };
      Result3.prototype.getTimestamp = function() {
        return this.timestamp;
      };
      Result3.prototype.toString = function() {
        return this.text;
      };
      return Result3;
    }()
  );
  var Result_default = Result;

  // node_modules/@zxing/library/esm/core/BarcodeFormat.js
  var BarcodeFormat;
  (function(BarcodeFormat2) {
    BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
    BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
    BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
    BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
    BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
    BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
    BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
    BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
    BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
    BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
    BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
    BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
    BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
    BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
    BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
    BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
    BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
  })(BarcodeFormat || (BarcodeFormat = {}));
  var BarcodeFormat_default = BarcodeFormat;

  // node_modules/@zxing/library/esm/core/ResultMetadataType.js
  var ResultMetadataType;
  (function(ResultMetadataType2) {
    ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
    ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
    ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
    ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
    ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
    ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
    ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
    ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
    ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
    ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
    ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
  })(ResultMetadataType || (ResultMetadataType = {}));
  var ResultMetadataType_default = ResultMetadataType;

  // node_modules/@zxing/library/esm/core/common/DecoderResult.js
  var DecoderResult = (
    /** @class */
    function() {
      function DecoderResult2(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {
        if (structuredAppendSequenceNumber === void 0) {
          structuredAppendSequenceNumber = -1;
        }
        if (structuredAppendParity === void 0) {
          structuredAppendParity = -1;
        }
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
        this.structuredAppendParity = structuredAppendParity;
        this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
      }
      DecoderResult2.prototype.getRawBytes = function() {
        return this.rawBytes;
      };
      DecoderResult2.prototype.getNumBits = function() {
        return this.numBits;
      };
      DecoderResult2.prototype.setNumBits = function(numBits) {
        this.numBits = numBits;
      };
      DecoderResult2.prototype.getText = function() {
        return this.text;
      };
      DecoderResult2.prototype.getByteSegments = function() {
        return this.byteSegments;
      };
      DecoderResult2.prototype.getECLevel = function() {
        return this.ecLevel;
      };
      DecoderResult2.prototype.getErrorsCorrected = function() {
        return this.errorsCorrected;
      };
      DecoderResult2.prototype.setErrorsCorrected = function(errorsCorrected) {
        this.errorsCorrected = errorsCorrected;
      };
      DecoderResult2.prototype.getErasures = function() {
        return this.erasures;
      };
      DecoderResult2.prototype.setErasures = function(erasures) {
        this.erasures = erasures;
      };
      DecoderResult2.prototype.getOther = function() {
        return this.other;
      };
      DecoderResult2.prototype.setOther = function(other) {
        this.other = other;
      };
      DecoderResult2.prototype.hasStructuredAppend = function() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
      };
      DecoderResult2.prototype.getStructuredAppendParity = function() {
        return this.structuredAppendParity;
      };
      DecoderResult2.prototype.getStructuredAppendSequenceNumber = function() {
        return this.structuredAppendSequenceNumber;
      };
      return DecoderResult2;
    }()
  );
  var DecoderResult_default = DecoderResult;

  // node_modules/@zxing/library/esm/core/common/reedsolomon/AbstractGenericGF.js
  var AbstractGenericGF = (
    /** @class */
    function() {
      function AbstractGenericGF2() {
      }
      AbstractGenericGF2.prototype.exp = function(a) {
        return this.expTable[a];
      };
      AbstractGenericGF2.prototype.log = function(a) {
        if (a === 0) {
          throw new IllegalArgumentException_default();
        }
        return this.logTable[a];
      };
      AbstractGenericGF2.addOrSubtract = function(a, b) {
        return a ^ b;
      };
      return AbstractGenericGF2;
    }()
  );
  var AbstractGenericGF_default = AbstractGenericGF;

  // node_modules/@zxing/library/esm/core/common/reedsolomon/GenericGFPoly.js
  var GenericGFPoly = (
    /** @class */
    function() {
      function GenericGFPoly2(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException_default();
        }
        this.field = field;
        var coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          var firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = Int32Array.from([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System_default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      GenericGFPoly2.prototype.getCoefficients = function() {
        return this.coefficients;
      };
      GenericGFPoly2.prototype.getDegree = function() {
        return this.coefficients.length - 1;
      };
      GenericGFPoly2.prototype.isZero = function() {
        return this.coefficients[0] === 0;
      };
      GenericGFPoly2.prototype.getCoefficient = function(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      };
      GenericGFPoly2.prototype.evaluateAt = function(a) {
        if (a === 0) {
          return this.getCoefficient(0);
        }
        var coefficients = this.coefficients;
        var result;
        if (a === 1) {
          result = 0;
          for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {
            var coefficient = coefficients[i];
            result = AbstractGenericGF_default.addOrSubtract(result, coefficient);
          }
          return result;
        }
        result = coefficients[0];
        var size = coefficients.length;
        var field = this.field;
        for (var i = 1; i < size; i++) {
          result = AbstractGenericGF_default.addOrSubtract(field.multiply(a, result), coefficients[i]);
        }
        return result;
      };
      GenericGFPoly2.prototype.addOrSubtract = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        var smallerCoefficients = this.coefficients;
        var largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          var temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        var sumDiff = new Int32Array(largerCoefficients.length);
        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        System_default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (var i = lengthDiff; i < largerCoefficients.length; i++) {
          sumDiff[i] = AbstractGenericGF_default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new GenericGFPoly2(this.field, sumDiff);
      };
      GenericGFPoly2.prototype.multiply = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero() || other.isZero()) {
          return this.field.getZero();
        }
        var aCoefficients = this.coefficients;
        var aLength = aCoefficients.length;
        var bCoefficients = other.coefficients;
        var bLength = bCoefficients.length;
        var product = new Int32Array(aLength + bLength - 1);
        var field = this.field;
        for (var i = 0; i < aLength; i++) {
          var aCoeff = aCoefficients[i];
          for (var j = 0; j < bLength; j++) {
            product[i + j] = AbstractGenericGF_default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new GenericGFPoly2(field, product);
      };
      GenericGFPoly2.prototype.multiplyScalar = function(scalar) {
        if (scalar === 0) {
          return this.field.getZero();
        }
        if (scalar === 1) {
          return this;
        }
        var size = this.coefficients.length;
        var field = this.field;
        var product = new Int32Array(size);
        var coefficients = this.coefficients;
        for (var i = 0; i < size; i++) {
          product[i] = field.multiply(coefficients[i], scalar);
        }
        return new GenericGFPoly2(field, product);
      };
      GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException_default();
        }
        if (coefficient === 0) {
          return this.field.getZero();
        }
        var coefficients = this.coefficients;
        var size = coefficients.length;
        var product = new Int32Array(size + degree);
        var field = this.field;
        for (var i = 0; i < size; i++) {
          product[i] = field.multiply(coefficients[i], coefficient);
        }
        return new GenericGFPoly2(field, product);
      };
      GenericGFPoly2.prototype.divide = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
        }
        if (other.isZero()) {
          throw new IllegalArgumentException_default("Divide by 0");
        }
        var field = this.field;
        var quotient = field.getZero();
        var remainder = this;
        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
          var degreeDifference = remainder.getDegree() - other.getDegree();
          var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
          var term = other.multiplyByMonomial(degreeDifference, scale);
          var iterationQuotient = field.buildMonomial(degreeDifference, scale);
          quotient = quotient.addOrSubtract(iterationQuotient);
          remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
      };
      GenericGFPoly2.prototype.toString = function() {
        var result = "";
        for (var degree = this.getDegree(); degree >= 0; degree--) {
          var coefficient = this.getCoefficient(degree);
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result += " - ";
              coefficient = -coefficient;
            } else {
              if (result.length > 0) {
                result += " + ";
              }
            }
            if (degree === 0 || coefficient !== 1) {
              var alphaPower = this.field.log(coefficient);
              if (alphaPower === 0) {
                result += "1";
              } else if (alphaPower === 1) {
                result += "a";
              } else {
                result += "a^";
                result += alphaPower;
              }
            }
            if (degree !== 0) {
              if (degree === 1) {
                result += "x";
              } else {
                result += "x^";
                result += degree;
              }
            }
          }
        }
        return result;
      };
      return GenericGFPoly2;
    }()
  );
  var GenericGFPoly_default = GenericGFPoly;

  // node_modules/@zxing/library/esm/core/ArithmeticException.js
  var __extends15 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ArithmeticException = (
    /** @class */
    function(_super) {
      __extends15(ArithmeticException2, _super);
      function ArithmeticException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ArithmeticException2.kind = "ArithmeticException";
      return ArithmeticException2;
    }(Exception_default)
  );
  var ArithmeticException_default = ArithmeticException;

  // node_modules/@zxing/library/esm/core/common/reedsolomon/GenericGF.js
  var __extends16 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var GenericGF = (
    /** @class */
    function(_super) {
      __extends16(GenericGF2, _super);
      function GenericGF2(primitive, size, generatorBase) {
        var _this = _super.call(this) || this;
        _this.primitive = primitive;
        _this.size = size;
        _this.generatorBase = generatorBase;
        var expTable = new Int32Array(size);
        var x = 1;
        for (var i = 0; i < size; i++) {
          expTable[i] = x;
          x *= 2;
          if (x >= size) {
            x ^= primitive;
            x &= size - 1;
          }
        }
        _this.expTable = expTable;
        var logTable = new Int32Array(size);
        for (var i = 0; i < size - 1; i++) {
          logTable[expTable[i]] = i;
        }
        _this.logTable = logTable;
        _this.zero = new GenericGFPoly_default(_this, Int32Array.from([0]));
        _this.one = new GenericGFPoly_default(_this, Int32Array.from([1]));
        return _this;
      }
      GenericGF2.prototype.getZero = function() {
        return this.zero;
      };
      GenericGF2.prototype.getOne = function() {
        return this.one;
      };
      GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException_default();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        var coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly_default(this, coefficients);
      };
      GenericGF2.prototype.inverse = function(a) {
        if (a === 0) {
          throw new ArithmeticException_default();
        }
        return this.expTable[this.size - this.logTable[a] - 1];
      };
      GenericGF2.prototype.multiply = function(a, b) {
        if (a === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
      };
      GenericGF2.prototype.getSize = function() {
        return this.size;
      };
      GenericGF2.prototype.getGeneratorBase = function() {
        return this.generatorBase;
      };
      GenericGF2.prototype.toString = function() {
        return "GF(0x" + Integer_default.toHexString(this.primitive) + "," + this.size + ")";
      };
      GenericGF2.prototype.equals = function(o) {
        return o === this;
      };
      GenericGF2.AZTEC_DATA_12 = new GenericGF2(4201, 4096, 1);
      GenericGF2.AZTEC_DATA_10 = new GenericGF2(1033, 1024, 1);
      GenericGF2.AZTEC_DATA_6 = new GenericGF2(67, 64, 1);
      GenericGF2.AZTEC_PARAM = new GenericGF2(19, 16, 1);
      GenericGF2.QR_CODE_FIELD_256 = new GenericGF2(285, 256, 0);
      GenericGF2.DATA_MATRIX_FIELD_256 = new GenericGF2(301, 256, 1);
      GenericGF2.AZTEC_DATA_8 = GenericGF2.DATA_MATRIX_FIELD_256;
      GenericGF2.MAXICODE_FIELD_64 = GenericGF2.AZTEC_DATA_6;
      return GenericGF2;
    }(AbstractGenericGF_default)
  );
  var GenericGF_default = GenericGF;

  // node_modules/@zxing/library/esm/core/ReedSolomonException.js
  var __extends17 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ReedSolomonException = (
    /** @class */
    function(_super) {
      __extends17(ReedSolomonException2, _super);
      function ReedSolomonException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ReedSolomonException2.kind = "ReedSolomonException";
      return ReedSolomonException2;
    }(Exception_default)
  );
  var ReedSolomonException_default = ReedSolomonException;

  // node_modules/@zxing/library/esm/core/IllegalStateException.js
  var __extends18 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var IllegalStateException = (
    /** @class */
    function(_super) {
      __extends18(IllegalStateException2, _super);
      function IllegalStateException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IllegalStateException2.kind = "IllegalStateException";
      return IllegalStateException2;
    }(Exception_default)
  );
  var IllegalStateException_default = IllegalStateException;

  // node_modules/@zxing/library/esm/core/common/reedsolomon/ReedSolomonDecoder.js
  var ReedSolomonDecoder = (
    /** @class */
    function() {
      function ReedSolomonDecoder2(field) {
        this.field = field;
      }
      ReedSolomonDecoder2.prototype.decode = function(received, twoS) {
        var field = this.field;
        var poly = new GenericGFPoly_default(field, received);
        var syndromeCoefficients = new Int32Array(twoS);
        var noError = true;
        for (var i = 0; i < twoS; i++) {
          var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
          syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
          if (evalResult !== 0) {
            noError = false;
          }
        }
        if (noError) {
          return;
        }
        var syndrome = new GenericGFPoly_default(field, syndromeCoefficients);
        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
        var sigma = sigmaOmega[0];
        var omega = sigmaOmega[1];
        var errorLocations = this.findErrorLocations(sigma);
        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (var i = 0; i < errorLocations.length; i++) {
          var position = received.length - 1 - field.log(errorLocations[i]);
          if (position < 0) {
            throw new ReedSolomonException_default("Bad error location");
          }
          received[position] = GenericGF_default.addOrSubtract(received[position], errorMagnitudes[i]);
        }
      };
      ReedSolomonDecoder2.prototype.runEuclideanAlgorithm = function(a, b, R) {
        if (a.getDegree() < b.getDegree()) {
          var temp = a;
          a = b;
          b = temp;
        }
        var field = this.field;
        var rLast = a;
        var r = b;
        var tLast = field.getZero();
        var t = field.getOne();
        while (r.getDegree() >= (R / 2 | 0)) {
          var rLastLast = rLast;
          var tLastLast = tLast;
          rLast = r;
          tLast = t;
          if (rLast.isZero()) {
            throw new ReedSolomonException_default("r_{i-1} was zero");
          }
          r = rLastLast;
          var q = field.getZero();
          var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          var dltInverse = field.inverse(denominatorLeadingTerm);
          while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
            var degreeDiff = r.getDegree() - rLast.getDegree();
            var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
            q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
            r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t = q.multiply(tLast).addOrSubtract(tLastLast);
          if (r.getDegree() >= rLast.getDegree()) {
            throw new IllegalStateException_default("Division algorithm failed to reduce polynomial?");
          }
        }
        var sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw new ReedSolomonException_default("sigmaTilde(0) was zero");
        }
        var inverse = field.inverse(sigmaTildeAtZero);
        var sigma = t.multiplyScalar(inverse);
        var omega = r.multiplyScalar(inverse);
        return [sigma, omega];
      };
      ReedSolomonDecoder2.prototype.findErrorLocations = function(errorLocator) {
        var numErrors = errorLocator.getDegree();
        if (numErrors === 1) {
          return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        var result = new Int32Array(numErrors);
        var e = 0;
        var field = this.field;
        for (var i = 1; i < field.getSize() && e < numErrors; i++) {
          if (errorLocator.evaluateAt(i) === 0) {
            result[e] = field.inverse(i);
            e++;
          }
        }
        if (e !== numErrors) {
          throw new ReedSolomonException_default("Error locator degree does not match number of roots");
        }
        return result;
      };
      ReedSolomonDecoder2.prototype.findErrorMagnitudes = function(errorEvaluator, errorLocations) {
        var s = errorLocations.length;
        var result = new Int32Array(s);
        var field = this.field;
        for (var i = 0; i < s; i++) {
          var xiInverse = field.inverse(errorLocations[i]);
          var denominator = 1;
          for (var j = 0; j < s; j++) {
            if (i !== j) {
              var term = field.multiply(errorLocations[j], xiInverse);
              var termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
              denominator = field.multiply(denominator, termPlus1);
            }
          }
          result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
          if (field.getGeneratorBase() !== 0) {
            result[i] = field.multiply(result[i], xiInverse);
          }
        }
        return result;
      };
      return ReedSolomonDecoder2;
    }()
  );
  var ReedSolomonDecoder_default = ReedSolomonDecoder;

  // node_modules/@zxing/library/esm/core/aztec/decoder/Decoder.js
  var Table;
  (function(Table4) {
    Table4[Table4["UPPER"] = 0] = "UPPER";
    Table4[Table4["LOWER"] = 1] = "LOWER";
    Table4[Table4["MIXED"] = 2] = "MIXED";
    Table4[Table4["DIGIT"] = 3] = "DIGIT";
    Table4[Table4["PUNCT"] = 4] = "PUNCT";
    Table4[Table4["BINARY"] = 5] = "BINARY";
  })(Table || (Table = {}));
  var Decoder = (
    /** @class */
    function() {
      function Decoder4() {
      }
      Decoder4.prototype.decode = function(detectorResult) {
        this.ddata = detectorResult;
        var matrix = detectorResult.getBits();
        var rawbits = this.extractBits(matrix);
        var correctedBits = this.correctBits(rawbits);
        var rawBytes = Decoder4.convertBoolArrayToByteArray(correctedBits);
        var result = Decoder4.getEncodedData(correctedBits);
        var decoderResult = new DecoderResult_default(rawBytes, result, null, null);
        decoderResult.setNumBits(correctedBits.length);
        return decoderResult;
      };
      Decoder4.highLevelDecode = function(correctedBits) {
        return this.getEncodedData(correctedBits);
      };
      Decoder4.getEncodedData = function(correctedBits) {
        var endIndex = correctedBits.length;
        var latchTable = Table.UPPER;
        var shiftTable = Table.UPPER;
        var result = "";
        var index = 0;
        while (index < endIndex) {
          if (shiftTable === Table.BINARY) {
            if (endIndex - index < 5) {
              break;
            }
            var length_1 = Decoder4.readCode(correctedBits, index, 5);
            index += 5;
            if (length_1 === 0) {
              if (endIndex - index < 11) {
                break;
              }
              length_1 = Decoder4.readCode(correctedBits, index, 11) + 31;
              index += 11;
            }
            for (var charCount = 0; charCount < length_1; charCount++) {
              if (endIndex - index < 8) {
                index = endIndex;
                break;
              }
              var code = Decoder4.readCode(correctedBits, index, 8);
              result += /*(char)*/
              StringUtils_default.castAsNonUtf8Char(code);
              index += 8;
            }
            shiftTable = latchTable;
          } else {
            var size = shiftTable === Table.DIGIT ? 4 : 5;
            if (endIndex - index < size) {
              break;
            }
            var code = Decoder4.readCode(correctedBits, index, size);
            index += size;
            var str = Decoder4.getCharacter(shiftTable, code);
            if (str.startsWith("CTRL_")) {
              latchTable = shiftTable;
              shiftTable = Decoder4.getTable(str.charAt(5));
              if (str.charAt(6) === "L") {
                latchTable = shiftTable;
              }
            } else {
              result += str;
              shiftTable = latchTable;
            }
          }
        }
        return result;
      };
      Decoder4.getTable = function(t) {
        switch (t) {
          case "L":
            return Table.LOWER;
          case "P":
            return Table.PUNCT;
          case "M":
            return Table.MIXED;
          case "D":
            return Table.DIGIT;
          case "B":
            return Table.BINARY;
          case "U":
          default:
            return Table.UPPER;
        }
      };
      Decoder4.getCharacter = function(table, code) {
        switch (table) {
          case Table.UPPER:
            return Decoder4.UPPER_TABLE[code];
          case Table.LOWER:
            return Decoder4.LOWER_TABLE[code];
          case Table.MIXED:
            return Decoder4.MIXED_TABLE[code];
          case Table.PUNCT:
            return Decoder4.PUNCT_TABLE[code];
          case Table.DIGIT:
            return Decoder4.DIGIT_TABLE[code];
          default:
            throw new IllegalStateException_default("Bad table");
        }
      };
      Decoder4.prototype.correctBits = function(rawbits) {
        var gf;
        var codewordSize;
        if (this.ddata.getNbLayers() <= 2) {
          codewordSize = 6;
          gf = GenericGF_default.AZTEC_DATA_6;
        } else if (this.ddata.getNbLayers() <= 8) {
          codewordSize = 8;
          gf = GenericGF_default.AZTEC_DATA_8;
        } else if (this.ddata.getNbLayers() <= 22) {
          codewordSize = 10;
          gf = GenericGF_default.AZTEC_DATA_10;
        } else {
          codewordSize = 12;
          gf = GenericGF_default.AZTEC_DATA_12;
        }
        var numDataCodewords = this.ddata.getNbDatablocks();
        var numCodewords = rawbits.length / codewordSize;
        if (numCodewords < numDataCodewords) {
          throw new FormatException_default();
        }
        var offset2 = rawbits.length % codewordSize;
        var dataWords = new Int32Array(numCodewords);
        for (var i = 0; i < numCodewords; i++, offset2 += codewordSize) {
          dataWords[i] = Decoder4.readCode(rawbits, offset2, codewordSize);
        }
        try {
          var rsDecoder = new ReedSolomonDecoder_default(gf);
          rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
        } catch (ex) {
          throw new FormatException_default(ex);
        }
        var mask = (1 << codewordSize) - 1;
        var stuffedBits = 0;
        for (var i = 0; i < numDataCodewords; i++) {
          var dataWord = dataWords[i];
          if (dataWord === 0 || dataWord === mask) {
            throw new FormatException_default();
          } else if (dataWord === 1 || dataWord === mask - 1) {
            stuffedBits++;
          }
        }
        var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
        var index = 0;
        for (var i = 0; i < numDataCodewords; i++) {
          var dataWord = dataWords[i];
          if (dataWord === 1 || dataWord === mask - 1) {
            correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
            index += codewordSize - 1;
          } else {
            for (var bit = codewordSize - 1; bit >= 0; --bit) {
              correctedBits[index++] = (dataWord & 1 << bit) !== 0;
            }
          }
        }
        return correctedBits;
      };
      Decoder4.prototype.extractBits = function(matrix) {
        var compact = this.ddata.isCompact();
        var layers = this.ddata.getNbLayers();
        var baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        var alignmentMap = new Int32Array(baseMatrixSize);
        var rawbits = new Array(this.totalBitsInLayer(layers, compact));
        if (compact) {
          for (var i = 0; i < alignmentMap.length; i++) {
            alignmentMap[i] = i;
          }
        } else {
          var matrixSize = baseMatrixSize + 1 + 2 * Integer_default.truncDivision(Integer_default.truncDivision(baseMatrixSize, 2) - 1, 15);
          var origCenter = baseMatrixSize / 2;
          var center = Integer_default.truncDivision(matrixSize, 2);
          for (var i = 0; i < origCenter; i++) {
            var newOffset = i + Integer_default.truncDivision(i, 15);
            alignmentMap[origCenter - i - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i] = center + newOffset + 1;
          }
        }
        for (var i = 0, rowOffset = 0; i < layers; i++) {
          var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
          var low = i * 2;
          var high = baseMatrixSize - 1 - low;
          for (var j = 0; j < rowSize; j++) {
            var columnOffset = j * 2;
            for (var k = 0; k < 2; k++) {
              rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
              rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
              rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
              rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
            }
          }
          rowOffset += rowSize * 8;
        }
        return rawbits;
      };
      Decoder4.readCode = function(rawbits, startIndex, length) {
        var res = 0;
        for (var i = startIndex; i < startIndex + length; i++) {
          res <<= 1;
          if (rawbits[i]) {
            res |= 1;
          }
        }
        return res;
      };
      Decoder4.readByte = function(rawbits, startIndex) {
        var n = rawbits.length - startIndex;
        if (n >= 8) {
          return Decoder4.readCode(rawbits, startIndex, 8);
        }
        return Decoder4.readCode(rawbits, startIndex, n) << 8 - n;
      };
      Decoder4.convertBoolArrayToByteArray = function(boolArr) {
        var byteArr = new Uint8Array((boolArr.length + 7) / 8);
        for (var i = 0; i < byteArr.length; i++) {
          byteArr[i] = Decoder4.readByte(boolArr, 8 * i);
        }
        return byteArr;
      };
      Decoder4.prototype.totalBitsInLayer = function(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      };
      Decoder4.UPPER_TABLE = [
        "CTRL_PS",
        " ",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "CTRL_LL",
        "CTRL_ML",
        "CTRL_DL",
        "CTRL_BS"
      ];
      Decoder4.LOWER_TABLE = [
        "CTRL_PS",
        " ",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "CTRL_US",
        "CTRL_ML",
        "CTRL_DL",
        "CTRL_BS"
      ];
      Decoder4.MIXED_TABLE = [
        "CTRL_PS",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x07",
        "\b",
        "	",
        "\n",
        "\v",
        "\f",
        "\r",
        "\x1B",
        "",
        "",
        "",
        "",
        "@",
        "\\",
        "^",
        "_",
        "`",
        "|",
        "~",
        "\x7F",
        "CTRL_LL",
        "CTRL_UL",
        "CTRL_PL",
        "CTRL_BS"
      ];
      Decoder4.PUNCT_TABLE = [
        "",
        "\r",
        "\r\n",
        ". ",
        ", ",
        ": ",
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "{",
        "}",
        "CTRL_UL"
      ];
      Decoder4.DIGIT_TABLE = [
        "CTRL_PS",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        ",",
        ".",
        "CTRL_UL",
        "CTRL_US"
      ];
      return Decoder4;
    }()
  );
  var Decoder_default = Decoder;

  // node_modules/@zxing/library/esm/core/common/detector/MathUtils.js
  var MathUtils = (
    /** @class */
    function() {
      function MathUtils2() {
      }
      MathUtils2.round = function(d) {
        if (isNaN(d))
          return 0;
        if (d <= Number.MIN_SAFE_INTEGER)
          return Number.MIN_SAFE_INTEGER;
        if (d >= Number.MAX_SAFE_INTEGER)
          return Number.MAX_SAFE_INTEGER;
        return (
          /*(int) */
          d + (d < 0 ? -0.5 : 0.5) | 0
        );
      };
      MathUtils2.distance = function(aX, aY, bX, bY) {
        var xDiff = aX - bX;
        var yDiff = aY - bY;
        return (
          /*(float) */
          Math.sqrt(xDiff * xDiff + yDiff * yDiff)
        );
      };
      MathUtils2.sum = function(array) {
        var count = 0;
        for (var i = 0, length_1 = array.length; i !== length_1; i++) {
          var a = array[i];
          count += a;
        }
        return count;
      };
      return MathUtils2;
    }()
  );
  var MathUtils_default = MathUtils;

  // node_modules/@zxing/library/esm/core/util/Float.js
  var Float = (
    /** @class */
    function() {
      function Float2() {
      }
      Float2.floatToIntBits = function(f) {
        return f;
      };
      Float2.MAX_VALUE = Number.MAX_SAFE_INTEGER;
      return Float2;
    }()
  );
  var Float_default = Float;

  // node_modules/@zxing/library/esm/core/ResultPoint.js
  var ResultPoint = (
    /** @class */
    function() {
      function ResultPoint2(x, y) {
        this.x = x;
        this.y = y;
      }
      ResultPoint2.prototype.getX = function() {
        return this.x;
      };
      ResultPoint2.prototype.getY = function() {
        return this.y;
      };
      ResultPoint2.prototype.equals = function(other) {
        if (other instanceof ResultPoint2) {
          var otherPoint = other;
          return this.x === otherPoint.x && this.y === otherPoint.y;
        }
        return false;
      };
      ResultPoint2.prototype.hashCode = function() {
        return 31 * Float_default.floatToIntBits(this.x) + Float_default.floatToIntBits(this.y);
      };
      ResultPoint2.prototype.toString = function() {
        return "(" + this.x + "," + this.y + ")";
      };
      ResultPoint2.orderBestPatterns = function(patterns) {
        var zeroOneDistance = this.distance(patterns[0], patterns[1]);
        var oneTwoDistance = this.distance(patterns[1], patterns[2]);
        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        var pointA;
        var pointB;
        var pointC;
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
          pointB = patterns[0];
          pointA = patterns[1];
          pointC = patterns[2];
        } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
          pointB = patterns[1];
          pointA = patterns[0];
          pointC = patterns[2];
        } else {
          pointB = patterns[2];
          pointA = patterns[0];
          pointC = patterns[1];
        }
        if (this.crossProductZ(pointA, pointB, pointC) < 0) {
          var temp = pointA;
          pointA = pointC;
          pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
      };
      ResultPoint2.distance = function(pattern1, pattern2) {
        return MathUtils_default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
      };
      ResultPoint2.crossProductZ = function(pointA, pointB, pointC) {
        var bX = pointB.x;
        var bY = pointB.y;
        return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
      };
      return ResultPoint2;
    }()
  );
  var ResultPoint_default = ResultPoint;

  // node_modules/@zxing/library/esm/core/common/DetectorResult.js
  var DetectorResult = (
    /** @class */
    function() {
      function DetectorResult2(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      DetectorResult2.prototype.getBits = function() {
        return this.bits;
      };
      DetectorResult2.prototype.getPoints = function() {
        return this.points;
      };
      return DetectorResult2;
    }()
  );
  var DetectorResult_default = DetectorResult;

  // node_modules/@zxing/library/esm/core/aztec/AztecDetectorResult.js
  var __extends19 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AztecDetectorResult = (
    /** @class */
    function(_super) {
      __extends19(AztecDetectorResult2, _super);
      function AztecDetectorResult2(bits, points, compact, nbDatablocks, nbLayers) {
        var _this = _super.call(this, bits, points) || this;
        _this.compact = compact;
        _this.nbDatablocks = nbDatablocks;
        _this.nbLayers = nbLayers;
        return _this;
      }
      AztecDetectorResult2.prototype.getNbLayers = function() {
        return this.nbLayers;
      };
      AztecDetectorResult2.prototype.getNbDatablocks = function() {
        return this.nbDatablocks;
      };
      AztecDetectorResult2.prototype.isCompact = function() {
        return this.compact;
      };
      return AztecDetectorResult2;
    }(DetectorResult_default)
  );
  var AztecDetectorResult_default = AztecDetectorResult;

  // node_modules/@zxing/library/esm/core/common/detector/WhiteRectangleDetector.js
  var WhiteRectangleDetector = (
    /** @class */
    function() {
      function WhiteRectangleDetector2(image, initSize, x, y) {
        this.image = image;
        this.height = image.getHeight();
        this.width = image.getWidth();
        if (void 0 === initSize || null === initSize) {
          initSize = WhiteRectangleDetector2.INIT_SIZE;
        }
        if (void 0 === x || null === x) {
          x = image.getWidth() / 2 | 0;
        }
        if (void 0 === y || null === y) {
          y = image.getHeight() / 2 | 0;
        }
        var halfsize = initSize / 2 | 0;
        this.leftInit = x - halfsize;
        this.rightInit = x + halfsize;
        this.upInit = y - halfsize;
        this.downInit = y + halfsize;
        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
          throw new NotFoundException_default();
        }
      }
      WhiteRectangleDetector2.prototype.detect = function() {
        var left2 = this.leftInit;
        var right2 = this.rightInit;
        var up = this.upInit;
        var down = this.downInit;
        var sizeExceeded = false;
        var aBlackPointFoundOnBorder = true;
        var atLeastOneBlackPointFoundOnBorder = false;
        var atLeastOneBlackPointFoundOnRight = false;
        var atLeastOneBlackPointFoundOnBottom = false;
        var atLeastOneBlackPointFoundOnLeft = false;
        var atLeastOneBlackPointFoundOnTop = false;
        var width = this.width;
        var height = this.height;
        while (aBlackPointFoundOnBorder) {
          aBlackPointFoundOnBorder = false;
          var rightBorderNotWhite = true;
          while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right2 < width) {
            rightBorderNotWhite = this.containsBlackPoint(up, down, right2, false);
            if (rightBorderNotWhite) {
              right2++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnRight = true;
            } else if (!atLeastOneBlackPointFoundOnRight) {
              right2++;
            }
          }
          if (right2 >= width) {
            sizeExceeded = true;
            break;
          }
          var bottomBorderNotWhite = true;
          while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
            bottomBorderNotWhite = this.containsBlackPoint(left2, right2, down, true);
            if (bottomBorderNotWhite) {
              down++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnBottom = true;
            } else if (!atLeastOneBlackPointFoundOnBottom) {
              down++;
            }
          }
          if (down >= height) {
            sizeExceeded = true;
            break;
          }
          var leftBorderNotWhite = true;
          while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left2 >= 0) {
            leftBorderNotWhite = this.containsBlackPoint(up, down, left2, false);
            if (leftBorderNotWhite) {
              left2--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnLeft = true;
            } else if (!atLeastOneBlackPointFoundOnLeft) {
              left2--;
            }
          }
          if (left2 < 0) {
            sizeExceeded = true;
            break;
          }
          var topBorderNotWhite = true;
          while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
            topBorderNotWhite = this.containsBlackPoint(left2, right2, up, true);
            if (topBorderNotWhite) {
              up--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnTop = true;
            } else if (!atLeastOneBlackPointFoundOnTop) {
              up--;
            }
          }
          if (up < 0) {
            sizeExceeded = true;
            break;
          }
          if (aBlackPointFoundOnBorder) {
            atLeastOneBlackPointFoundOnBorder = true;
          }
        }
        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
          var maxSize = right2 - left2;
          var z = null;
          for (var i = 1; z === null && i < maxSize; i++) {
            z = this.getBlackPointOnSegment(left2, down - i, left2 + i, down);
          }
          if (z == null) {
            throw new NotFoundException_default();
          }
          var t = null;
          for (var i = 1; t === null && i < maxSize; i++) {
            t = this.getBlackPointOnSegment(left2, up + i, left2 + i, up);
          }
          if (t == null) {
            throw new NotFoundException_default();
          }
          var x = null;
          for (var i = 1; x === null && i < maxSize; i++) {
            x = this.getBlackPointOnSegment(right2, up + i, right2 - i, up);
          }
          if (x == null) {
            throw new NotFoundException_default();
          }
          var y = null;
          for (var i = 1; y === null && i < maxSize; i++) {
            y = this.getBlackPointOnSegment(right2, down - i, right2 - i, down);
          }
          if (y == null) {
            throw new NotFoundException_default();
          }
          return this.centerEdges(y, z, x, t);
        } else {
          throw new NotFoundException_default();
        }
      };
      WhiteRectangleDetector2.prototype.getBlackPointOnSegment = function(aX, aY, bX, bY) {
        var dist = MathUtils_default.round(MathUtils_default.distance(aX, aY, bX, bY));
        var xStep = (bX - aX) / dist;
        var yStep = (bY - aY) / dist;
        var image = this.image;
        for (var i = 0; i < dist; i++) {
          var x = MathUtils_default.round(aX + i * xStep);
          var y = MathUtils_default.round(aY + i * yStep);
          if (image.get(x, y)) {
            return new ResultPoint_default(x, y);
          }
        }
        return null;
      };
      WhiteRectangleDetector2.prototype.centerEdges = function(y, z, x, t) {
        var yi = y.getX();
        var yj = y.getY();
        var zi = z.getX();
        var zj = z.getY();
        var xi = x.getX();
        var xj = x.getY();
        var ti = t.getX();
        var tj = t.getY();
        var CORR = WhiteRectangleDetector2.CORR;
        if (yi < this.width / 2) {
          return [
            new ResultPoint_default(ti - CORR, tj + CORR),
            new ResultPoint_default(zi + CORR, zj + CORR),
            new ResultPoint_default(xi - CORR, xj - CORR),
            new ResultPoint_default(yi + CORR, yj - CORR)
          ];
        } else {
          return [
            new ResultPoint_default(ti + CORR, tj + CORR),
            new ResultPoint_default(zi + CORR, zj - CORR),
            new ResultPoint_default(xi - CORR, xj + CORR),
            new ResultPoint_default(yi - CORR, yj - CORR)
          ];
        }
      };
      WhiteRectangleDetector2.prototype.containsBlackPoint = function(a, b, fixed, horizontal) {
        var image = this.image;
        if (horizontal) {
          for (var x = a; x <= b; x++) {
            if (image.get(x, fixed)) {
              return true;
            }
          }
        } else {
          for (var y = a; y <= b; y++) {
            if (image.get(fixed, y)) {
              return true;
            }
          }
        }
        return false;
      };
      WhiteRectangleDetector2.INIT_SIZE = 10;
      WhiteRectangleDetector2.CORR = 1;
      return WhiteRectangleDetector2;
    }()
  );
  var WhiteRectangleDetector_default = WhiteRectangleDetector;

  // node_modules/@zxing/library/esm/core/common/GridSampler.js
  var GridSampler = (
    /** @class */
    function() {
      function GridSampler2() {
      }
      GridSampler2.checkAndNudgePoints = function(image, points) {
        var width = image.getWidth();
        var height = image.getHeight();
        var nudged = true;
        for (var offset2 = 0; offset2 < points.length && nudged; offset2 += 2) {
          var x = Math.floor(points[offset2]);
          var y = Math.floor(points[offset2 + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException_default();
          }
          nudged = false;
          if (x === -1) {
            points[offset2] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset2] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset2 + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset2 + 1] = height - 1;
            nudged = true;
          }
        }
        nudged = true;
        for (var offset2 = points.length - 2; offset2 >= 0 && nudged; offset2 -= 2) {
          var x = Math.floor(points[offset2]);
          var y = Math.floor(points[offset2 + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException_default();
          }
          nudged = false;
          if (x === -1) {
            points[offset2] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset2] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset2 + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset2 + 1] = height - 1;
            nudged = true;
          }
        }
      };
      return GridSampler2;
    }()
  );
  var GridSampler_default = GridSampler;

  // node_modules/@zxing/library/esm/core/common/PerspectiveTransform.js
  var PerspectiveTransform = (
    /** @class */
    function() {
      function PerspectiveTransform2(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
        this.a11 = a11;
        this.a21 = a21;
        this.a31 = a31;
        this.a12 = a12;
        this.a22 = a22;
        this.a32 = a32;
        this.a13 = a13;
        this.a23 = a23;
        this.a33 = a33;
      }
      PerspectiveTransform2.quadrilateralToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
        var qToS = PerspectiveTransform2.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        var sToQ = PerspectiveTransform2.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
      };
      PerspectiveTransform2.prototype.transformPoints = function(points) {
        var max2 = points.length;
        var a11 = this.a11;
        var a12 = this.a12;
        var a13 = this.a13;
        var a21 = this.a21;
        var a22 = this.a22;
        var a23 = this.a23;
        var a31 = this.a31;
        var a32 = this.a32;
        var a33 = this.a33;
        for (var i = 0; i < max2; i += 2) {
          var x = points[i];
          var y = points[i + 1];
          var denominator = a13 * x + a23 * y + a33;
          points[i] = (a11 * x + a21 * y + a31) / denominator;
          points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
        }
      };
      PerspectiveTransform2.prototype.transformPointsWithValues = function(xValues, yValues) {
        var a11 = this.a11;
        var a12 = this.a12;
        var a13 = this.a13;
        var a21 = this.a21;
        var a22 = this.a22;
        var a23 = this.a23;
        var a31 = this.a31;
        var a32 = this.a32;
        var a33 = this.a33;
        var n = xValues.length;
        for (var i = 0; i < n; i++) {
          var x = xValues[i];
          var y = yValues[i];
          var denominator = a13 * x + a23 * y + a33;
          xValues[i] = (a11 * x + a21 * y + a31) / denominator;
          yValues[i] = (a12 * x + a22 * y + a32) / denominator;
        }
      };
      PerspectiveTransform2.squareToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3) {
        var dx3 = x0 - x1 + x2 - x3;
        var dy3 = y0 - y1 + y2 - y3;
        if (dx3 === 0 && dy3 === 0) {
          return new PerspectiveTransform2(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
        } else {
          var dx1 = x1 - x2;
          var dx2 = x3 - x2;
          var dy1 = y1 - y2;
          var dy2 = y3 - y2;
          var denominator = dx1 * dy2 - dx2 * dy1;
          var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
          var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
          return new PerspectiveTransform2(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
        }
      };
      PerspectiveTransform2.quadrilateralToSquare = function(x0, y0, x1, y1, x2, y2, x3, y3) {
        return PerspectiveTransform2.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
      };
      PerspectiveTransform2.prototype.buildAdjoint = function() {
        return new PerspectiveTransform2(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
      };
      PerspectiveTransform2.prototype.times = function(other) {
        return new PerspectiveTransform2(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
      };
      return PerspectiveTransform2;
    }()
  );
  var PerspectiveTransform_default = PerspectiveTransform;

  // node_modules/@zxing/library/esm/core/common/DefaultGridSampler.js
  var __extends20 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var DefaultGridSampler = (
    /** @class */
    function(_super) {
      __extends20(DefaultGridSampler2, _super);
      function DefaultGridSampler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DefaultGridSampler2.prototype.sampleGrid = function(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
        var transform = PerspectiveTransform_default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
      };
      DefaultGridSampler2.prototype.sampleGridWithTransform = function(image, dimensionX, dimensionY, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
          throw new NotFoundException_default();
        }
        var bits = new BitMatrix_default(dimensionX, dimensionY);
        var points = new Float32Array(2 * dimensionX);
        for (var y = 0; y < dimensionY; y++) {
          var max2 = points.length;
          var iValue = y + 0.5;
          for (var x = 0; x < max2; x += 2) {
            points[x] = x / 2 + 0.5;
            points[x + 1] = iValue;
          }
          transform.transformPoints(points);
          GridSampler_default.checkAndNudgePoints(image, points);
          try {
            for (var x = 0; x < max2; x += 2) {
              if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                bits.set(x / 2, y);
              }
            }
          } catch (aioobe) {
            throw new NotFoundException_default();
          }
        }
        return bits;
      };
      return DefaultGridSampler2;
    }(GridSampler_default)
  );
  var DefaultGridSampler_default = DefaultGridSampler;

  // node_modules/@zxing/library/esm/core/common/GridSamplerInstance.js
  var GridSamplerInstance = (
    /** @class */
    function() {
      function GridSamplerInstance2() {
      }
      GridSamplerInstance2.setGridSampler = function(newGridSampler) {
        GridSamplerInstance2.gridSampler = newGridSampler;
      };
      GridSamplerInstance2.getInstance = function() {
        return GridSamplerInstance2.gridSampler;
      };
      GridSamplerInstance2.gridSampler = new DefaultGridSampler_default();
      return GridSamplerInstance2;
    }()
  );
  var GridSamplerInstance_default = GridSamplerInstance;

  // node_modules/@zxing/library/esm/core/aztec/detector/Detector.js
  var Point = (
    /** @class */
    function() {
      function Point2(x, y) {
        this.x = x;
        this.y = y;
      }
      Point2.prototype.toResultPoint = function() {
        return new ResultPoint_default(this.getX(), this.getY());
      };
      Point2.prototype.getX = function() {
        return this.x;
      };
      Point2.prototype.getY = function() {
        return this.y;
      };
      return Point2;
    }()
  );
  var Detector = (
    /** @class */
    function() {
      function Detector5(image) {
        this.EXPECTED_CORNER_BITS = new Int32Array([
          3808,
          476,
          2107,
          1799
        ]);
        this.image = image;
      }
      Detector5.prototype.detect = function() {
        return this.detectMirror(false);
      };
      Detector5.prototype.detectMirror = function(isMirror) {
        var pCenter = this.getMatrixCenter();
        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);
        if (isMirror) {
          var temp = bullsEyeCorners[0];
          bullsEyeCorners[0] = bullsEyeCorners[2];
          bullsEyeCorners[2] = temp;
        }
        this.extractParameters(bullsEyeCorners);
        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
        var corners = this.getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult_default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
      };
      Detector5.prototype.extractParameters = function(bullsEyeCorners) {
        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
          throw new NotFoundException_default();
        }
        var length = 2 * this.nbCenterLayers;
        var sides = new Int32Array([
          this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
          this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
          this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
          this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
          // Top
        ]);
        this.shift = this.getRotation(sides, length);
        var parameterData = 0;
        for (var i = 0; i < 4; i++) {
          var side = sides[(this.shift + i) % 4];
          if (this.compact) {
            parameterData <<= 7;
            parameterData += side >> 1 & 127;
          } else {
            parameterData <<= 10;
            parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
          }
        }
        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);
        if (this.compact) {
          this.nbLayers = (correctedData >> 6) + 1;
          this.nbDataBlocks = (correctedData & 63) + 1;
        } else {
          this.nbLayers = (correctedData >> 11) + 1;
          this.nbDataBlocks = (correctedData & 2047) + 1;
        }
      };
      Detector5.prototype.getRotation = function(sides, length) {
        var cornerBits = 0;
        sides.forEach(function(side, idx, arr) {
          var t = (side >> length - 2 << 1) + (side & 1);
          cornerBits = (cornerBits << 3) + t;
        });
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        for (var shift2 = 0; shift2 < 4; shift2++) {
          if (Integer_default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift2]) <= 2) {
            return shift2;
          }
        }
        throw new NotFoundException_default();
      };
      Detector5.prototype.getCorrectedParameterData = function(parameterData, compact) {
        var numCodewords;
        var numDataCodewords;
        if (compact) {
          numCodewords = 7;
          numDataCodewords = 2;
        } else {
          numCodewords = 10;
          numDataCodewords = 4;
        }
        var numECCodewords = numCodewords - numDataCodewords;
        var parameterWords = new Int32Array(numCodewords);
        for (var i = numCodewords - 1; i >= 0; --i) {
          parameterWords[i] = parameterData & 15;
          parameterData >>= 4;
        }
        try {
          var rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.AZTEC_PARAM);
          rsDecoder.decode(parameterWords, numECCodewords);
        } catch (ignored) {
          throw new NotFoundException_default();
        }
        var result = 0;
        for (var i = 0; i < numDataCodewords; i++) {
          result = (result << 4) + parameterWords[i];
        }
        return result;
      };
      Detector5.prototype.getBullsEyeCorners = function(pCenter) {
        var pina = pCenter;
        var pinb = pCenter;
        var pinc = pCenter;
        var pind = pCenter;
        var color = true;
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          var pouta = this.getFirstDifferent(pina, color, 1, -1);
          var poutb = this.getFirstDifferent(pinb, color, 1, 1);
          var poutc = this.getFirstDifferent(pinc, color, -1, 1);
          var poutd = this.getFirstDifferent(pind, color, -1, -1);
          if (this.nbCenterLayers > 2) {
            var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
            if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
              break;
            }
          }
          pina = pouta;
          pinb = poutb;
          pinc = poutc;
          pind = poutd;
          color = !color;
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
          throw new NotFoundException_default();
        }
        this.compact = this.nbCenterLayers === 5;
        var pinax = new ResultPoint_default(pina.getX() + 0.5, pina.getY() - 0.5);
        var pinbx = new ResultPoint_default(pinb.getX() + 0.5, pinb.getY() + 0.5);
        var pincx = new ResultPoint_default(pinc.getX() - 0.5, pinc.getY() + 0.5);
        var pindx = new ResultPoint_default(pind.getX() - 0.5, pind.getY() - 0.5);
        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
      };
      Detector5.prototype.getMatrixCenter = function() {
        var pointA;
        var pointB;
        var pointC;
        var pointD;
        try {
          var cornerPoints = new WhiteRectangleDetector_default(this.image).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e) {
          var cx_1 = this.image.getWidth() / 2;
          var cy_1 = this.image.getHeight() / 2;
          pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();
        }
        var cx = MathUtils_default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        var cy = MathUtils_default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        try {
          var cornerPoints = new WhiteRectangleDetector_default(this.image, 15, cx, cy).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e) {
          pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        cx = MathUtils_default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        cy = MathUtils_default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        return new Point(cx, cy);
      };
      Detector5.prototype.getMatrixCornerPoints = function(bullsEyeCorners) {
        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
      };
      Detector5.prototype.sampleGrid = function(image, topLeft, topRight, bottomRight, bottomLeft) {
        var sampler = GridSamplerInstance_default.getInstance();
        var dimension = this.getDimension();
        var low = dimension / 2 - this.nbCenterLayers;
        var high = dimension / 2 + this.nbCenterLayers;
        return sampler.sampleGrid(
          image,
          dimension,
          dimension,
          low,
          low,
          // topleft
          high,
          low,
          // topright
          high,
          high,
          // bottomright
          low,
          high,
          // bottomleft
          topLeft.getX(),
          topLeft.getY(),
          topRight.getX(),
          topRight.getY(),
          bottomRight.getX(),
          bottomRight.getY(),
          bottomLeft.getX(),
          bottomLeft.getY()
        );
      };
      Detector5.prototype.sampleLine = function(p1, p2, size) {
        var result = 0;
        var d = this.distanceResultPoint(p1, p2);
        var moduleSize = d / size;
        var px = p1.getX();
        var py = p1.getY();
        var dx = moduleSize * (p2.getX() - p1.getX()) / d;
        var dy = moduleSize * (p2.getY() - p1.getY()) / d;
        for (var i = 0; i < size; i++) {
          if (this.image.get(MathUtils_default.round(px + i * dx), MathUtils_default.round(py + i * dy))) {
            result |= 1 << size - i - 1;
          }
        }
        return result;
      };
      Detector5.prototype.isWhiteOrBlackRectangle = function(p1, p2, p3, p4) {
        var corr = 3;
        p1 = new Point(p1.getX() - corr, p1.getY() + corr);
        p2 = new Point(p2.getX() - corr, p2.getY() - corr);
        p3 = new Point(p3.getX() + corr, p3.getY() - corr);
        p4 = new Point(p4.getX() + corr, p4.getY() + corr);
        var cInit = this.getColor(p4, p1);
        if (cInit === 0) {
          return false;
        }
        var c = this.getColor(p1, p2);
        if (c !== cInit) {
          return false;
        }
        c = this.getColor(p2, p3);
        if (c !== cInit) {
          return false;
        }
        c = this.getColor(p3, p4);
        return c === cInit;
      };
      Detector5.prototype.getColor = function(p1, p2) {
        var d = this.distancePoint(p1, p2);
        var dx = (p2.getX() - p1.getX()) / d;
        var dy = (p2.getY() - p1.getY()) / d;
        var error2 = 0;
        var px = p1.getX();
        var py = p1.getY();
        var colorModel = this.image.get(p1.getX(), p1.getY());
        var iMax = Math.ceil(d);
        for (var i = 0; i < iMax; i++) {
          px += dx;
          py += dy;
          if (this.image.get(MathUtils_default.round(px), MathUtils_default.round(py)) !== colorModel) {
            error2++;
          }
        }
        var errRatio = error2 / d;
        if (errRatio > 0.1 && errRatio < 0.9) {
          return 0;
        }
        return errRatio <= 0.1 === colorModel ? 1 : -1;
      };
      Detector5.prototype.getFirstDifferent = function(init, color, dx, dy) {
        var x = init.getX() + dx;
        var y = init.getY() + dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
          y += dy;
        }
        x -= dx;
        y -= dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
        }
        x -= dx;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          y += dy;
        }
        y -= dy;
        return new Point(x, y);
      };
      Detector5.prototype.expandSquare = function(cornerPoints, oldSide, newSide) {
        var ratio = newSide / (2 * oldSide);
        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
        var result0 = new ResultPoint_default(centerx + ratio * dx, centery + ratio * dy);
        var result2 = new ResultPoint_default(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
        var result1 = new ResultPoint_default(centerx + ratio * dx, centery + ratio * dy);
        var result3 = new ResultPoint_default(centerx - ratio * dx, centery - ratio * dy);
        var results = [result0, result1, result2, result3];
        return results;
      };
      Detector5.prototype.isValid = function(x, y) {
        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
      };
      Detector5.prototype.isValidPoint = function(point) {
        var x = MathUtils_default.round(point.getX());
        var y = MathUtils_default.round(point.getY());
        return this.isValid(x, y);
      };
      Detector5.prototype.distancePoint = function(a, b) {
        return MathUtils_default.distance(a.getX(), a.getY(), b.getX(), b.getY());
      };
      Detector5.prototype.distanceResultPoint = function(a, b) {
        return MathUtils_default.distance(a.getX(), a.getY(), b.getX(), b.getY());
      };
      Detector5.prototype.getDimension = function() {
        if (this.compact) {
          return 4 * this.nbLayers + 11;
        }
        if (this.nbLayers <= 4) {
          return 4 * this.nbLayers + 15;
        }
        return 4 * this.nbLayers + 2 * (Integer_default.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
      };
      return Detector5;
    }()
  );
  var Detector_default = Detector;

  // node_modules/@zxing/library/esm/core/aztec/AztecReader.js
  var AztecReader = (
    /** @class */
    function() {
      function AztecReader2() {
      }
      AztecReader2.prototype.decode = function(image, hints) {
        if (hints === void 0) {
          hints = null;
        }
        var exception = null;
        var detector = new Detector_default(image.getBlackMatrix());
        var points = null;
        var decoderResult = null;
        try {
          var detectorResult = detector.detectMirror(false);
          points = detectorResult.getPoints();
          this.reportFoundResultPoints(hints, points);
          decoderResult = new Decoder_default().decode(detectorResult);
        } catch (e) {
          exception = e;
        }
        if (decoderResult == null) {
          try {
            var detectorResult = detector.detectMirror(true);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder_default().decode(detectorResult);
          } catch (e) {
            if (exception != null) {
              throw exception;
            }
            throw e;
          }
        }
        var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat_default.AZTEC, System_default.currentTimeMillis());
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      };
      AztecReader2.prototype.reportFoundResultPoints = function(hints, points) {
        if (hints != null) {
          var rpcb_1 = hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
          if (rpcb_1 != null) {
            points.forEach(function(point, idx, arr) {
              rpcb_1.foundPossibleResultPoint(point);
            });
          }
        }
      };
      AztecReader2.prototype.reset = function() {
      };
      return AztecReader2;
    }()
  );
  var AztecReader_default = AztecReader;

  // node_modules/@zxing/library/esm/browser/BrowserAztecCodeReader.js
  var __extends21 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserAztecCodeReader = (
    /** @class */
    function(_super) {
      __extends21(BrowserAztecCodeReader3, _super);
      function BrowserAztecCodeReader3(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        return _super.call(this, new AztecReader_default(), timeBetweenScansMillis) || this;
      }
      return BrowserAztecCodeReader3;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/core/oned/OneDReader.js
  var OneDReader = (
    /** @class */
    function() {
      function OneDReader2() {
      }
      OneDReader2.prototype.decode = function(image, hints) {
        try {
          return this.doDecode(image, hints);
        } catch (nfe) {
          var tryHarder = hints && hints.get(DecodeHintType_default.TRY_HARDER) === true;
          if (tryHarder && image.isRotateSupported()) {
            var rotatedImage = image.rotateCounterClockwise();
            var result = this.doDecode(rotatedImage, hints);
            var metadata = result.getResultMetadata();
            var orientation_1 = 270;
            if (metadata !== null && metadata.get(ResultMetadataType_default.ORIENTATION) === true) {
              orientation_1 = orientation_1 + metadata.get(ResultMetadataType_default.ORIENTATION) % 360;
            }
            result.putMetadata(ResultMetadataType_default.ORIENTATION, orientation_1);
            var points = result.getResultPoints();
            if (points !== null) {
              var height = rotatedImage.getHeight();
              for (var i = 0; i < points.length; i++) {
                points[i] = new ResultPoint_default(height - points[i].getY() - 1, points[i].getX());
              }
            }
            return result;
          } else {
            throw new NotFoundException_default();
          }
        }
      };
      OneDReader2.prototype.reset = function() {
      };
      OneDReader2.prototype.doDecode = function(image, hints) {
        var width = image.getWidth();
        var height = image.getHeight();
        var row = new BitArray_default(width);
        var tryHarder = hints && hints.get(DecodeHintType_default.TRY_HARDER) === true;
        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
        var maxLines;
        if (tryHarder) {
          maxLines = height;
        } else {
          maxLines = 15;
        }
        var middle = Math.trunc(height / 2);
        for (var x = 0; x < maxLines; x++) {
          var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
          var isAbove = (x & 1) === 0;
          var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
          if (rowNumber < 0 || rowNumber >= height) {
            break;
          }
          try {
            row = image.getBlackRow(rowNumber, row);
          } catch (ignored) {
            continue;
          }
          var _loop_1 = function(attempt2) {
            if (attempt2 === 1) {
              row.reverse();
              if (hints && hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK) === true) {
                var newHints_1 = /* @__PURE__ */ new Map();
                hints.forEach(function(hint, key) {
                  return newHints_1.set(key, hint);
                });
                newHints_1.delete(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
                hints = newHints_1;
              }
            }
            try {
              var result = this_1.decodeRow(rowNumber, row, hints);
              if (attempt2 === 1) {
                result.putMetadata(ResultMetadataType_default.ORIENTATION, 180);
                var points = result.getResultPoints();
                if (points !== null) {
                  points[0] = new ResultPoint_default(width - points[0].getX() - 1, points[0].getY());
                  points[1] = new ResultPoint_default(width - points[1].getX() - 1, points[1].getY());
                }
              }
              return { value: result };
            } catch (re) {
            }
          };
          var this_1 = this;
          for (var attempt = 0; attempt < 2; attempt++) {
            var state_1 = _loop_1(attempt);
            if (typeof state_1 === "object")
              return state_1.value;
          }
        }
        throw new NotFoundException_default();
      };
      OneDReader2.recordPattern = function(row, start3, counters) {
        var numCounters = counters.length;
        for (var index = 0; index < numCounters; index++)
          counters[index] = 0;
        var end2 = row.getSize();
        if (start3 >= end2) {
          throw new NotFoundException_default();
        }
        var isWhite = !row.get(start3);
        var counterPosition = 0;
        var i = start3;
        while (i < end2) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (++counterPosition === numCounters) {
              break;
            } else {
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          i++;
        }
        if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end2)) {
          throw new NotFoundException_default();
        }
      };
      OneDReader2.recordPatternInReverse = function(row, start3, counters) {
        var numTransitionsLeft = counters.length;
        var last = row.get(start3);
        while (start3 > 0 && numTransitionsLeft >= 0) {
          if (row.get(--start3) !== last) {
            numTransitionsLeft--;
            last = !last;
          }
        }
        if (numTransitionsLeft >= 0) {
          throw new NotFoundException_default();
        }
        OneDReader2.recordPattern(row, start3 + 1, counters);
      };
      OneDReader2.patternMatchVariance = function(counters, pattern, maxIndividualVariance) {
        var numCounters = counters.length;
        var total = 0;
        var patternLength = 0;
        for (var i = 0; i < numCounters; i++) {
          total += counters[i];
          patternLength += pattern[i];
        }
        if (total < patternLength) {
          return Number.POSITIVE_INFINITY;
        }
        var unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        var totalVariance = 0;
        for (var x = 0; x < numCounters; x++) {
          var counter = counters[x];
          var scaledPattern = pattern[x] * unitBarWidth;
          var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return Number.POSITIVE_INFINITY;
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      };
      return OneDReader2;
    }()
  );
  var OneDReader_default = OneDReader;

  // node_modules/@zxing/library/esm/core/oned/Code128Reader.js
  var __extends22 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var Code128Reader = (
    /** @class */
    function(_super) {
      __extends22(Code128Reader2, _super);
      function Code128Reader2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Code128Reader2.findStartPattern = function(row) {
        var width = row.getSize();
        var rowOffset = row.getNextSet(0);
        var counterPosition = 0;
        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        var patternStart = rowOffset;
        var isWhite = false;
        var patternLength = 6;
        for (var i = rowOffset; i < width; i++) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              var bestVariance = Code128Reader2.MAX_AVG_VARIANCE;
              var bestMatch = -1;
              for (var startCode = Code128Reader2.CODE_START_A; startCode <= Code128Reader2.CODE_START_C; startCode++) {
                var variance = OneDReader_default.patternMatchVariance(counters, Code128Reader2.CODE_PATTERNS[startCode], Code128Reader2.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                  bestVariance = variance;
                  bestMatch = startCode;
                }
              }
              if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
                return Int32Array.from([patternStart, i, bestMatch]);
              }
              patternStart += counters[0] + counters[1];
              counters = counters.slice(2, counters.length);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      Code128Reader2.decodeCode = function(row, counters, rowOffset) {
        OneDReader_default.recordPattern(row, rowOffset, counters);
        var bestVariance = Code128Reader2.MAX_AVG_VARIANCE;
        var bestMatch = -1;
        for (var d = 0; d < Code128Reader2.CODE_PATTERNS.length; d++) {
          var pattern = Code128Reader2.CODE_PATTERNS[d];
          var variance = this.patternMatchVariance(counters, pattern, Code128Reader2.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = d;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException_default();
        }
      };
      Code128Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var convertFNC1 = hints && hints.get(DecodeHintType_default.ASSUME_GS1) === true;
        var startPatternInfo = Code128Reader2.findStartPattern(row);
        var startCode = startPatternInfo[2];
        var currentRawCodesIndex = 0;
        var rawCodes = new Uint8Array(20);
        rawCodes[currentRawCodesIndex++] = startCode;
        var codeSet;
        switch (startCode) {
          case Code128Reader2.CODE_START_A:
            codeSet = Code128Reader2.CODE_CODE_A;
            break;
          case Code128Reader2.CODE_START_B:
            codeSet = Code128Reader2.CODE_CODE_B;
            break;
          case Code128Reader2.CODE_START_C:
            codeSet = Code128Reader2.CODE_CODE_C;
            break;
          default:
            throw new FormatException_default();
        }
        var done = false;
        var isNextShifted = false;
        var result = "";
        var lastStart = startPatternInfo[0];
        var nextStart = startPatternInfo[1];
        var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        var lastCode = 0;
        var code = 0;
        var checksumTotal = startCode;
        var multiplier = 0;
        var lastCharacterWasPrintable = true;
        var upperMode = false;
        var shiftUpperMode = false;
        while (!done) {
          var unshift = isNextShifted;
          isNextShifted = false;
          lastCode = code;
          code = Code128Reader2.decodeCode(row, counters, nextStart);
          rawCodes[currentRawCodesIndex++] = code;
          if (code !== Code128Reader2.CODE_STOP) {
            lastCharacterWasPrintable = true;
          }
          if (code !== Code128Reader2.CODE_STOP) {
            multiplier++;
            checksumTotal += multiplier * code;
          }
          lastStart = nextStart;
          nextStart += counters.reduce(function(previous, current) {
            return previous + current;
          }, 0);
          switch (code) {
            case Code128Reader2.CODE_START_A:
            case Code128Reader2.CODE_START_B:
            case Code128Reader2.CODE_START_C:
              throw new FormatException_default();
          }
          switch (codeSet) {
            case Code128Reader2.CODE_CODE_A:
              if (code < 64) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(code - 64);
                } else {
                  result += String.fromCharCode(code + 64);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader2.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader2.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader2.CODE_FNC_2:
                  case Code128Reader2.CODE_FNC_3:
                    break;
                  case Code128Reader2.CODE_FNC_4_A:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader2.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader2.CODE_CODE_B;
                    break;
                  case Code128Reader2.CODE_CODE_B:
                    codeSet = Code128Reader2.CODE_CODE_B;
                    break;
                  case Code128Reader2.CODE_CODE_C:
                    codeSet = Code128Reader2.CODE_CODE_C;
                    break;
                  case Code128Reader2.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader2.CODE_CODE_B:
              if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader2.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader2.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader2.CODE_FNC_2:
                  case Code128Reader2.CODE_FNC_3:
                    break;
                  case Code128Reader2.CODE_FNC_4_B:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader2.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader2.CODE_CODE_A;
                    break;
                  case Code128Reader2.CODE_CODE_A:
                    codeSet = Code128Reader2.CODE_CODE_A;
                    break;
                  case Code128Reader2.CODE_CODE_C:
                    codeSet = Code128Reader2.CODE_CODE_C;
                    break;
                  case Code128Reader2.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader2.CODE_CODE_C:
              if (code < 100) {
                if (code < 10) {
                  result += "0";
                }
                result += code;
              } else {
                if (code !== Code128Reader2.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader2.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader2.CODE_CODE_A:
                    codeSet = Code128Reader2.CODE_CODE_A;
                    break;
                  case Code128Reader2.CODE_CODE_B:
                    codeSet = Code128Reader2.CODE_CODE_B;
                    break;
                  case Code128Reader2.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
          }
          if (unshift) {
            codeSet = codeSet === Code128Reader2.CODE_CODE_A ? Code128Reader2.CODE_CODE_B : Code128Reader2.CODE_CODE_A;
          }
        }
        var lastPatternSize = nextStart - lastStart;
        nextStart = row.getNextUnset(nextStart);
        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
          throw new NotFoundException_default();
        }
        checksumTotal -= multiplier * lastCode;
        if (checksumTotal % 103 !== lastCode) {
          throw new ChecksumException_default();
        }
        var resultLength = result.length;
        if (resultLength === 0) {
          throw new NotFoundException_default();
        }
        if (resultLength > 0 && lastCharacterWasPrintable) {
          if (codeSet === Code128Reader2.CODE_CODE_C) {
            result = result.substring(0, resultLength - 2);
          } else {
            result = result.substring(0, resultLength - 1);
          }
        }
        var left2 = (startPatternInfo[1] + startPatternInfo[0]) / 2;
        var right2 = lastStart + lastPatternSize / 2;
        var rawCodesSize = rawCodes.length;
        var rawBytes = new Uint8Array(rawCodesSize);
        for (var i = 0; i < rawCodesSize; i++) {
          rawBytes[i] = rawCodes[i];
        }
        var points = [new ResultPoint_default(left2, rowNumber), new ResultPoint_default(right2, rowNumber)];
        return new Result_default(result, rawBytes, 0, points, BarcodeFormat_default.CODE_128, (/* @__PURE__ */ new Date()).getTime());
      };
      Code128Reader2.CODE_PATTERNS = [
        Int32Array.from([2, 1, 2, 2, 2, 2]),
        Int32Array.from([2, 2, 2, 1, 2, 2]),
        Int32Array.from([2, 2, 2, 2, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 2, 3]),
        Int32Array.from([1, 2, 1, 3, 2, 2]),
        Int32Array.from([1, 3, 1, 2, 2, 2]),
        Int32Array.from([1, 2, 2, 2, 1, 3]),
        Int32Array.from([1, 2, 2, 3, 1, 2]),
        Int32Array.from([1, 3, 2, 2, 1, 2]),
        Int32Array.from([2, 2, 1, 2, 1, 3]),
        Int32Array.from([2, 2, 1, 3, 1, 2]),
        Int32Array.from([2, 3, 1, 2, 1, 2]),
        Int32Array.from([1, 1, 2, 2, 3, 2]),
        Int32Array.from([1, 2, 2, 1, 3, 2]),
        Int32Array.from([1, 2, 2, 2, 3, 1]),
        Int32Array.from([1, 1, 3, 2, 2, 2]),
        Int32Array.from([1, 2, 3, 1, 2, 2]),
        Int32Array.from([1, 2, 3, 2, 2, 1]),
        Int32Array.from([2, 2, 3, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 3, 2]),
        Int32Array.from([2, 2, 1, 2, 3, 1]),
        Int32Array.from([2, 1, 3, 2, 1, 2]),
        Int32Array.from([2, 2, 3, 1, 1, 2]),
        Int32Array.from([3, 1, 2, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 2, 2, 2]),
        Int32Array.from([3, 2, 1, 1, 2, 2]),
        Int32Array.from([3, 2, 1, 2, 2, 1]),
        Int32Array.from([3, 1, 2, 2, 1, 2]),
        Int32Array.from([3, 2, 2, 1, 1, 2]),
        Int32Array.from([3, 2, 2, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 2, 3]),
        Int32Array.from([2, 1, 2, 3, 2, 1]),
        Int32Array.from([2, 3, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 3, 2, 3]),
        Int32Array.from([1, 3, 1, 1, 2, 3]),
        Int32Array.from([1, 3, 1, 3, 2, 1]),
        Int32Array.from([1, 1, 2, 3, 1, 3]),
        Int32Array.from([1, 3, 2, 1, 1, 3]),
        Int32Array.from([1, 3, 2, 3, 1, 1]),
        Int32Array.from([2, 1, 1, 3, 1, 3]),
        Int32Array.from([2, 3, 1, 1, 1, 3]),
        Int32Array.from([2, 3, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 3, 3]),
        Int32Array.from([1, 1, 2, 3, 3, 1]),
        Int32Array.from([1, 3, 2, 1, 3, 1]),
        Int32Array.from([1, 1, 3, 1, 2, 3]),
        Int32Array.from([1, 1, 3, 3, 2, 1]),
        Int32Array.from([1, 3, 3, 1, 2, 1]),
        Int32Array.from([3, 1, 3, 1, 2, 1]),
        Int32Array.from([2, 1, 1, 3, 3, 1]),
        Int32Array.from([2, 3, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 3, 1, 1, 3]),
        Int32Array.from([2, 1, 3, 3, 1, 1]),
        Int32Array.from([2, 1, 3, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 2, 3]),
        Int32Array.from([3, 1, 1, 3, 2, 1]),
        Int32Array.from([3, 3, 1, 1, 2, 1]),
        Int32Array.from([3, 1, 2, 1, 1, 3]),
        Int32Array.from([3, 1, 2, 3, 1, 1]),
        Int32Array.from([3, 3, 2, 1, 1, 1]),
        Int32Array.from([3, 1, 4, 1, 1, 1]),
        Int32Array.from([2, 2, 1, 4, 1, 1]),
        Int32Array.from([4, 3, 1, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2, 4]),
        Int32Array.from([1, 1, 1, 4, 2, 2]),
        Int32Array.from([1, 2, 1, 1, 2, 4]),
        Int32Array.from([1, 2, 1, 4, 2, 1]),
        Int32Array.from([1, 4, 1, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 2, 2, 1]),
        Int32Array.from([1, 1, 2, 2, 1, 4]),
        Int32Array.from([1, 1, 2, 4, 1, 2]),
        Int32Array.from([1, 2, 2, 1, 1, 4]),
        Int32Array.from([1, 2, 2, 4, 1, 1]),
        Int32Array.from([1, 4, 2, 1, 1, 2]),
        Int32Array.from([1, 4, 2, 2, 1, 1]),
        Int32Array.from([2, 4, 1, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 1, 4]),
        Int32Array.from([4, 1, 3, 1, 1, 1]),
        Int32Array.from([2, 4, 1, 1, 1, 2]),
        Int32Array.from([1, 3, 4, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 4, 2]),
        Int32Array.from([1, 2, 1, 1, 4, 2]),
        Int32Array.from([1, 2, 1, 2, 4, 1]),
        Int32Array.from([1, 1, 4, 2, 1, 2]),
        Int32Array.from([1, 2, 4, 1, 1, 2]),
        Int32Array.from([1, 2, 4, 2, 1, 1]),
        Int32Array.from([4, 1, 1, 2, 1, 2]),
        Int32Array.from([4, 2, 1, 1, 1, 2]),
        Int32Array.from([4, 2, 1, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 4, 1]),
        Int32Array.from([2, 1, 4, 1, 2, 1]),
        Int32Array.from([4, 1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 1, 4, 3]),
        Int32Array.from([1, 1, 1, 3, 4, 1]),
        Int32Array.from([1, 3, 1, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 1, 3]),
        Int32Array.from([1, 1, 4, 3, 1, 1]),
        Int32Array.from([4, 1, 1, 1, 1, 3]),
        Int32Array.from([4, 1, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 4, 1]),
        Int32Array.from([4, 1, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 1, 4, 1, 2]),
        Int32Array.from([2, 1, 1, 2, 1, 4]),
        Int32Array.from([2, 1, 1, 2, 3, 2]),
        Int32Array.from([2, 3, 3, 1, 1, 1, 2])
      ];
      Code128Reader2.MAX_AVG_VARIANCE = 0.25;
      Code128Reader2.MAX_INDIVIDUAL_VARIANCE = 0.7;
      Code128Reader2.CODE_SHIFT = 98;
      Code128Reader2.CODE_CODE_C = 99;
      Code128Reader2.CODE_CODE_B = 100;
      Code128Reader2.CODE_CODE_A = 101;
      Code128Reader2.CODE_FNC_1 = 102;
      Code128Reader2.CODE_FNC_2 = 97;
      Code128Reader2.CODE_FNC_3 = 96;
      Code128Reader2.CODE_FNC_4_A = 101;
      Code128Reader2.CODE_FNC_4_B = 100;
      Code128Reader2.CODE_START_A = 103;
      Code128Reader2.CODE_START_B = 104;
      Code128Reader2.CODE_START_C = 105;
      Code128Reader2.CODE_STOP = 106;
      return Code128Reader2;
    }(OneDReader_default)
  );
  var Code128Reader_default = Code128Reader;

  // node_modules/@zxing/library/esm/core/oned/Code39Reader.js
  var __extends23 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values4 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Code39Reader = (
    /** @class */
    function(_super) {
      __extends23(Code39Reader2, _super);
      function Code39Reader2(usingCheckDigit, extendedMode) {
        if (usingCheckDigit === void 0) {
          usingCheckDigit = false;
        }
        if (extendedMode === void 0) {
          extendedMode = false;
        }
        var _this = _super.call(this) || this;
        _this.usingCheckDigit = usingCheckDigit;
        _this.extendedMode = extendedMode;
        _this.decodeRowResult = "";
        _this.counters = new Int32Array(9);
        return _this;
      }
      Code39Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var e_1, _a2, e_2, _b;
        var theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = "";
        var start3 = Code39Reader2.findAsteriskPattern(row, theCounters);
        var nextStart = row.getNextSet(start3[1]);
        var end2 = row.getSize();
        var decodedChar;
        var lastStart;
        do {
          Code39Reader2.recordPattern(row, nextStart, theCounters);
          var pattern = Code39Reader2.toNarrowWidePattern(theCounters);
          if (pattern < 0) {
            throw new NotFoundException_default();
          }
          decodedChar = Code39Reader2.patternToChar(pattern);
          this.decodeRowResult += decodedChar;
          lastStart = nextStart;
          try {
            for (var theCounters_1 = (e_1 = void 0, __values4(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {
              var counter = theCounters_1_1.value;
              nextStart += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (theCounters_1_1 && !theCounters_1_1.done && (_a2 = theCounters_1.return)) _a2.call(theCounters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== "*");
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
        var lastPatternSize = 0;
        try {
          for (var theCounters_2 = __values4(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {
            var counter = theCounters_2_1.value;
            lastPatternSize += counter;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
        if (nextStart !== end2 && whiteSpaceAfterEnd * 2 < lastPatternSize) {
          throw new NotFoundException_default();
        }
        if (this.usingCheckDigit) {
          var max2 = this.decodeRowResult.length - 1;
          var total = 0;
          for (var i = 0; i < max2; i++) {
            total += Code39Reader2.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
          }
          if (this.decodeRowResult.charAt(max2) !== Code39Reader2.ALPHABET_STRING.charAt(total % 43)) {
            throw new ChecksumException_default();
          }
          this.decodeRowResult = this.decodeRowResult.substring(0, max2);
        }
        if (this.decodeRowResult.length === 0) {
          throw new NotFoundException_default();
        }
        var resultString;
        if (this.extendedMode) {
          resultString = Code39Reader2.decodeExtended(this.decodeRowResult);
        } else {
          resultString = this.decodeRowResult;
        }
        var left2 = (start3[1] + start3[0]) / 2;
        var right2 = lastStart + lastPatternSize / 2;
        return new Result_default(resultString, null, 0, [new ResultPoint_default(left2, rowNumber), new ResultPoint_default(right2, rowNumber)], BarcodeFormat_default.CODE_39, (/* @__PURE__ */ new Date()).getTime());
      };
      Code39Reader2.findAsteriskPattern = function(row, counters) {
        var width = row.getSize();
        var rowOffset = row.getNextSet(0);
        var counterPosition = 0;
        var patternStart = rowOffset;
        var isWhite = false;
        var patternLength = counters.length;
        for (var i = rowOffset; i < width; i++) {
          if (row.get(i) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (this.toNarrowWidePattern(counters) === Code39Reader2.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
                return [patternStart, i];
              }
              patternStart += counters[0] + counters[1];
              counters.copyWithin(0, 2, 2 + counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      Code39Reader2.toNarrowWidePattern = function(counters) {
        var e_3, _a2;
        var numCounters = counters.length;
        var maxNarrowCounter = 0;
        var wideCounters;
        do {
          var minCounter = 2147483647;
          try {
            for (var counters_1 = (e_3 = void 0, __values4(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              if (counter < minCounter && counter > maxNarrowCounter) {
                minCounter = counter;
              }
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          maxNarrowCounter = minCounter;
          wideCounters = 0;
          var totalWideCountersWidth = 0;
          var pattern = 0;
          for (var i = 0; i < numCounters; i++) {
            var counter = counters[i];
            if (counter > maxNarrowCounter) {
              pattern |= 1 << numCounters - 1 - i;
              wideCounters++;
              totalWideCountersWidth += counter;
            }
          }
          if (wideCounters === 3) {
            for (var i = 0; i < numCounters && wideCounters > 0; i++) {
              var counter = counters[i];
              if (counter > maxNarrowCounter) {
                wideCounters--;
                if (counter * 2 >= totalWideCountersWidth) {
                  return -1;
                }
              }
            }
            return pattern;
          }
        } while (wideCounters > 3);
        return -1;
      };
      Code39Reader2.patternToChar = function(pattern) {
        for (var i = 0; i < Code39Reader2.CHARACTER_ENCODINGS.length; i++) {
          if (Code39Reader2.CHARACTER_ENCODINGS[i] === pattern) {
            return Code39Reader2.ALPHABET_STRING.charAt(i);
          }
        }
        if (pattern === Code39Reader2.ASTERISK_ENCODING) {
          return "*";
        }
        throw new NotFoundException_default();
      };
      Code39Reader2.decodeExtended = function(encoded) {
        var length = encoded.length;
        var decoded = "";
        for (var i = 0; i < length; i++) {
          var c = encoded.charAt(i);
          if (c === "+" || c === "$" || c === "%" || c === "/") {
            var next = encoded.charAt(i + 1);
            var decodedChar = "\0";
            switch (c) {
              case "+":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                } else {
                  throw new FormatException_default();
                }
                break;
              case "$":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                } else {
                  throw new FormatException_default();
                }
                break;
              case "%":
                if (next >= "A" && next <= "E") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                } else if (next >= "F" && next <= "J") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                } else if (next >= "K" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                } else if (next >= "P" && next <= "T") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                } else if (next === "U") {
                  decodedChar = "\0";
                } else if (next === "V") {
                  decodedChar = "@";
                } else if (next === "W") {
                  decodedChar = "`";
                } else if (next === "X" || next === "Y" || next === "Z") {
                  decodedChar = "\x7F";
                } else {
                  throw new FormatException_default();
                }
                break;
              case "/":
                if (next >= "A" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                } else if (next === "Z") {
                  decodedChar = ":";
                } else {
                  throw new FormatException_default();
                }
                break;
            }
            decoded += decodedChar;
            i++;
          } else {
            decoded += c;
          }
        }
        return decoded;
      };
      Code39Reader2.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
      Code39Reader2.CHARACTER_ENCODINGS = [
        52,
        289,
        97,
        352,
        49,
        304,
        112,
        37,
        292,
        100,
        265,
        73,
        328,
        25,
        280,
        88,
        13,
        268,
        76,
        28,
        259,
        67,
        322,
        19,
        274,
        82,
        7,
        262,
        70,
        22,
        385,
        193,
        448,
        145,
        400,
        208,
        133,
        388,
        196,
        168,
        162,
        138,
        42
        // /-%
      ];
      Code39Reader2.ASTERISK_ENCODING = 148;
      return Code39Reader2;
    }(OneDReader_default)
  );
  var Code39Reader_default = Code39Reader;

  // node_modules/@zxing/library/esm/core/oned/Code93Reader.js
  var __extends24 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values5 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Code93Reader = (
    /** @class */
    function(_super) {
      __extends24(Code93Reader2, _super);
      function Code93Reader2() {
        var _this = _super.call(this) || this;
        _this.decodeRowResult = "";
        _this.counters = new Int32Array(6);
        return _this;
      }
      Code93Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var e_1, _a2, e_2, _b;
        var start3 = this.findAsteriskPattern(row);
        var nextStart = row.getNextSet(start3[1]);
        var end2 = row.getSize();
        var theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = "";
        var decodedChar;
        var lastStart;
        do {
          Code93Reader2.recordPattern(row, nextStart, theCounters);
          var pattern = this.toPattern(theCounters);
          if (pattern < 0) {
            throw new NotFoundException_default();
          }
          decodedChar = this.patternToChar(pattern);
          this.decodeRowResult += decodedChar;
          lastStart = nextStart;
          try {
            for (var theCounters_1 = (e_1 = void 0, __values5(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {
              var counter = theCounters_1_1.value;
              nextStart += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (theCounters_1_1 && !theCounters_1_1.done && (_a2 = theCounters_1.return)) _a2.call(theCounters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== "*");
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
        var lastPatternSize = 0;
        try {
          for (var theCounters_2 = __values5(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {
            var counter = theCounters_2_1.value;
            lastPatternSize += counter;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        if (nextStart === end2 || !row.get(nextStart)) {
          throw new NotFoundException_default();
        }
        if (this.decodeRowResult.length < 2) {
          throw new NotFoundException_default();
        }
        this.checkChecksums(this.decodeRowResult);
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 2);
        var resultString = this.decodeExtended(this.decodeRowResult);
        var left2 = (start3[1] + start3[0]) / 2;
        var right2 = lastStart + lastPatternSize / 2;
        return new Result_default(resultString, null, 0, [new ResultPoint_default(left2, rowNumber), new ResultPoint_default(right2, rowNumber)], BarcodeFormat_default.CODE_93, (/* @__PURE__ */ new Date()).getTime());
      };
      Code93Reader2.prototype.findAsteriskPattern = function(row) {
        var width = row.getSize();
        var rowOffset = row.getNextSet(0);
        this.counters.fill(0);
        var theCounters = this.counters;
        var patternStart = rowOffset;
        var isWhite = false;
        var patternLength = theCounters.length;
        var counterPosition = 0;
        for (var i = rowOffset; i < width; i++) {
          if (row.get(i) !== isWhite) {
            theCounters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (this.toPattern(theCounters) === Code93Reader2.ASTERISK_ENCODING) {
                return new Int32Array([patternStart, i]);
              }
              patternStart += theCounters[0] + theCounters[1];
              theCounters.copyWithin(0, 2, 2 + counterPosition - 1);
              theCounters[counterPosition - 1] = 0;
              theCounters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            theCounters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      Code93Reader2.prototype.toPattern = function(counters) {
        var e_3, _a2;
        var sum = 0;
        try {
          for (var counters_1 = __values5(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
            var counter = counters_1_1.value;
            sum += counter;
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        var pattern = 0;
        var max2 = counters.length;
        for (var i = 0; i < max2; i++) {
          var scaled = Math.round(counters[i] * 9 / sum);
          if (scaled < 1 || scaled > 4) {
            return -1;
          }
          if ((i & 1) === 0) {
            for (var j = 0; j < scaled; j++) {
              pattern = pattern << 1 | 1;
            }
          } else {
            pattern <<= scaled;
          }
        }
        return pattern;
      };
      Code93Reader2.prototype.patternToChar = function(pattern) {
        for (var i = 0; i < Code93Reader2.CHARACTER_ENCODINGS.length; i++) {
          if (Code93Reader2.CHARACTER_ENCODINGS[i] === pattern) {
            return Code93Reader2.ALPHABET_STRING.charAt(i);
          }
        }
        throw new NotFoundException_default();
      };
      Code93Reader2.prototype.decodeExtended = function(encoded) {
        var length = encoded.length;
        var decoded = "";
        for (var i = 0; i < length; i++) {
          var c = encoded.charAt(i);
          if (c >= "a" && c <= "d") {
            if (i >= length - 1) {
              throw new FormatException_default();
            }
            var next = encoded.charAt(i + 1);
            var decodedChar = "\0";
            switch (c) {
              case "d":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                } else {
                  throw new FormatException_default();
                }
                break;
              case "a":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                } else {
                  throw new FormatException_default();
                }
                break;
              case "b":
                if (next >= "A" && next <= "E") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                } else if (next >= "F" && next <= "J") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                } else if (next >= "K" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                } else if (next >= "P" && next <= "T") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                } else if (next === "U") {
                  decodedChar = "\0";
                } else if (next === "V") {
                  decodedChar = "@";
                } else if (next === "W") {
                  decodedChar = "`";
                } else if (next >= "X" && next <= "Z") {
                  decodedChar = String.fromCharCode(127);
                } else {
                  throw new FormatException_default();
                }
                break;
              case "c":
                if (next >= "A" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                } else if (next === "Z") {
                  decodedChar = ":";
                } else {
                  throw new FormatException_default();
                }
                break;
            }
            decoded += decodedChar;
            i++;
          } else {
            decoded += c;
          }
        }
        return decoded;
      };
      Code93Reader2.prototype.checkChecksums = function(result) {
        var length = result.length;
        this.checkOneChecksum(result, length - 2, 20);
        this.checkOneChecksum(result, length - 1, 15);
      };
      Code93Reader2.prototype.checkOneChecksum = function(result, checkPosition, weightMax) {
        var weight = 1;
        var total = 0;
        for (var i = checkPosition - 1; i >= 0; i--) {
          total += weight * Code93Reader2.ALPHABET_STRING.indexOf(result.charAt(i));
          if (++weight > weightMax) {
            weight = 1;
          }
        }
        if (result.charAt(checkPosition) !== Code93Reader2.ALPHABET_STRING[total % 47]) {
          throw new ChecksumException_default();
        }
      };
      Code93Reader2.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";
      Code93Reader2.CHARACTER_ENCODINGS = [
        276,
        328,
        324,
        322,
        296,
        292,
        290,
        336,
        274,
        266,
        424,
        420,
        418,
        404,
        402,
        394,
        360,
        356,
        354,
        308,
        282,
        344,
        332,
        326,
        300,
        278,
        436,
        434,
        428,
        422,
        406,
        410,
        364,
        358,
        310,
        314,
        302,
        468,
        466,
        458,
        366,
        374,
        430,
        294,
        474,
        470,
        306,
        350
      ];
      Code93Reader2.ASTERISK_ENCODING = Code93Reader2.CHARACTER_ENCODINGS[47];
      return Code93Reader2;
    }(OneDReader_default)
  );
  var Code93Reader_default = Code93Reader;

  // node_modules/@zxing/library/esm/core/oned/ITFReader.js
  var __extends25 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values6 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ITFReader = (
    /** @class */
    function(_super) {
      __extends25(ITFReader2, _super);
      function ITFReader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.narrowLineWidth = -1;
        return _this;
      }
      ITFReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var e_1, _a2;
        var startRange = this.decodeStart(row);
        var endRange = this.decodeEnd(row);
        var result = new StringBuilder_default();
        ITFReader2.decodeMiddle(row, startRange[1], endRange[0], result);
        var resultString = result.toString();
        var allowedLengths = null;
        if (hints != null) {
          allowedLengths = hints.get(DecodeHintType_default.ALLOWED_LENGTHS);
        }
        if (allowedLengths == null) {
          allowedLengths = ITFReader2.DEFAULT_ALLOWED_LENGTHS;
        }
        var length = resultString.length;
        var lengthOK = false;
        var maxAllowedLength = 0;
        try {
          for (var allowedLengths_1 = __values6(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {
            var value = allowedLengths_1_1.value;
            if (length === value) {
              lengthOK = true;
              break;
            }
            if (value > maxAllowedLength) {
              maxAllowedLength = value;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a2 = allowedLengths_1.return)) _a2.call(allowedLengths_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (!lengthOK && length > maxAllowedLength) {
          lengthOK = true;
        }
        if (!lengthOK) {
          throw new FormatException_default();
        }
        var points = [new ResultPoint_default(startRange[1], rowNumber), new ResultPoint_default(endRange[0], rowNumber)];
        var resultReturn = new Result_default(
          resultString,
          null,
          // no natural byte representation for these barcodes
          0,
          points,
          BarcodeFormat_default.ITF,
          (/* @__PURE__ */ new Date()).getTime()
        );
        return resultReturn;
      };
      ITFReader2.decodeMiddle = function(row, payloadStart, payloadEnd, resultString) {
        var counterDigitPair = new Int32Array(10);
        var counterBlack = new Int32Array(5);
        var counterWhite = new Int32Array(5);
        counterDigitPair.fill(0);
        counterBlack.fill(0);
        counterWhite.fill(0);
        while (payloadStart < payloadEnd) {
          OneDReader_default.recordPattern(row, payloadStart, counterDigitPair);
          for (var k = 0; k < 5; k++) {
            var twoK = 2 * k;
            counterBlack[k] = counterDigitPair[twoK];
            counterWhite[k] = counterDigitPair[twoK + 1];
          }
          var bestMatch = ITFReader2.decodeDigit(counterBlack);
          resultString.append(bestMatch.toString());
          bestMatch = this.decodeDigit(counterWhite);
          resultString.append(bestMatch.toString());
          counterDigitPair.forEach(function(counterDigit) {
            payloadStart += counterDigit;
          });
        }
      };
      ITFReader2.prototype.decodeStart = function(row) {
        var endStart = ITFReader2.skipWhiteSpace(row);
        var startPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.START_PATTERN);
        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
        this.validateQuietZone(row, startPattern[0]);
        return startPattern;
      };
      ITFReader2.prototype.validateQuietZone = function(row, startPattern) {
        var quietCount = this.narrowLineWidth * 10;
        quietCount = quietCount < startPattern ? quietCount : startPattern;
        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
          if (row.get(i)) {
            break;
          }
          quietCount--;
        }
        if (quietCount !== 0) {
          throw new NotFoundException_default();
        }
      };
      ITFReader2.skipWhiteSpace = function(row) {
        var width = row.getSize();
        var endStart = row.getNextSet(0);
        if (endStart === width) {
          throw new NotFoundException_default();
        }
        return endStart;
      };
      ITFReader2.prototype.decodeEnd = function(row) {
        row.reverse();
        try {
          var endStart = ITFReader2.skipWhiteSpace(row);
          var endPattern = void 0;
          try {
            endPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.END_PATTERN_REVERSED[0]);
          } catch (error2) {
            if (error2 instanceof NotFoundException_default) {
              endPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.END_PATTERN_REVERSED[1]);
            }
          }
          this.validateQuietZone(row, endPattern[0]);
          var temp = endPattern[0];
          endPattern[0] = row.getSize() - endPattern[1];
          endPattern[1] = row.getSize() - temp;
          return endPattern;
        } finally {
          row.reverse();
        }
      };
      ITFReader2.findGuardPattern = function(row, rowOffset, pattern) {
        var patternLength = pattern.length;
        var counters = new Int32Array(patternLength);
        var width = row.getSize();
        var isWhite = false;
        var counterPosition = 0;
        var patternStart = rowOffset;
        counters.fill(0);
        for (var x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader_default.patternMatchVariance(counters, pattern, ITFReader2.MAX_INDIVIDUAL_VARIANCE) < ITFReader2.MAX_AVG_VARIANCE) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              System_default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      ITFReader2.decodeDigit = function(counters) {
        var bestVariance = ITFReader2.MAX_AVG_VARIANCE;
        var bestMatch = -1;
        var max2 = ITFReader2.PATTERNS.length;
        for (var i = 0; i < max2; i++) {
          var pattern = ITFReader2.PATTERNS[i];
          var variance = OneDReader_default.patternMatchVariance(counters, pattern, ITFReader2.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i;
          } else if (variance === bestVariance) {
            bestMatch = -1;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch % 10;
        } else {
          throw new NotFoundException_default();
        }
      };
      ITFReader2.PATTERNS = [
        Int32Array.from([1, 1, 2, 2, 1]),
        Int32Array.from([2, 1, 1, 1, 2]),
        Int32Array.from([1, 2, 1, 1, 2]),
        Int32Array.from([2, 2, 1, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 2]),
        Int32Array.from([2, 1, 2, 1, 1]),
        Int32Array.from([1, 2, 2, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2]),
        Int32Array.from([2, 1, 1, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 3, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 3]),
        Int32Array.from([1, 3, 1, 1, 3]),
        Int32Array.from([3, 3, 1, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 3]),
        Int32Array.from([3, 1, 3, 1, 1]),
        Int32Array.from([1, 3, 3, 1, 1]),
        Int32Array.from([1, 1, 1, 3, 3]),
        Int32Array.from([3, 1, 1, 3, 1]),
        Int32Array.from([1, 3, 1, 3, 1])
        // 9
      ];
      ITFReader2.MAX_AVG_VARIANCE = 0.38;
      ITFReader2.MAX_INDIVIDUAL_VARIANCE = 0.5;
      ITFReader2.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
      ITFReader2.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
      ITFReader2.END_PATTERN_REVERSED = [
        Int32Array.from([1, 1, 2]),
        Int32Array.from([1, 1, 3])
        // 3x
      ];
      return ITFReader2;
    }(OneDReader_default)
  );
  var ITFReader_default = ITFReader;

  // node_modules/@zxing/library/esm/core/oned/AbstractUPCEANReader.js
  var __extends26 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AbstractUPCEANReader = (
    /** @class */
    function(_super) {
      __extends26(AbstractUPCEANReader2, _super);
      function AbstractUPCEANReader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.decodeRowStringBuffer = "";
        return _this;
      }
      AbstractUPCEANReader2.findStartGuardPattern = function(row) {
        var foundStart = false;
        var startRange;
        var nextStart = 0;
        var counters = Int32Array.from([0, 0, 0]);
        while (!foundStart) {
          counters = Int32Array.from([0, 0, 0]);
          startRange = AbstractUPCEANReader2.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
          var start3 = startRange[0];
          nextStart = startRange[1];
          var quietStart = start3 - (nextStart - start3);
          if (quietStart >= 0) {
            foundStart = row.isRange(quietStart, start3, false);
          }
        }
        return startRange;
      };
      AbstractUPCEANReader2.checkChecksum = function(s) {
        return AbstractUPCEANReader2.checkStandardUPCEANChecksum(s);
      };
      AbstractUPCEANReader2.checkStandardUPCEANChecksum = function(s) {
        var length = s.length;
        if (length === 0)
          return false;
        var check = parseInt(s.charAt(length - 1), 10);
        return AbstractUPCEANReader2.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
      };
      AbstractUPCEANReader2.getStandardUPCEANChecksum = function(s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 1; i >= 0; i -= 2) {
          var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException_default();
          }
          sum += digit;
        }
        sum *= 3;
        for (var i = length - 2; i >= 0; i -= 2) {
          var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException_default();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      };
      AbstractUPCEANReader2.decodeEnd = function(row, endStart) {
        return AbstractUPCEANReader2.findGuardPattern(row, endStart, false, AbstractUPCEANReader2.START_END_PATTERN, new Int32Array(AbstractUPCEANReader2.START_END_PATTERN.length).fill(0));
      };
      AbstractUPCEANReader2.findGuardPatternWithoutCounters = function(row, rowOffset, whiteFirst, pattern) {
        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
      };
      AbstractUPCEANReader2.findGuardPattern = function(row, rowOffset, whiteFirst, pattern, counters) {
        var width = row.getSize();
        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
        var counterPosition = 0;
        var patternStart = rowOffset;
        var patternLength = pattern.length;
        var isWhite = whiteFirst;
        for (var x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader_default.patternMatchVariance(counters, pattern, AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader2.MAX_AVG_VARIANCE) {
                return Int32Array.from([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              var slice2 = counters.slice(2, counters.length);
              for (var i = 0; i < counterPosition - 1; i++) {
                counters[i] = slice2[i];
              }
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      AbstractUPCEANReader2.decodeDigit = function(row, counters, rowOffset, patterns) {
        this.recordPattern(row, rowOffset, counters);
        var bestVariance = this.MAX_AVG_VARIANCE;
        var bestMatch = -1;
        var max2 = patterns.length;
        for (var i = 0; i < max2; i++) {
          var pattern = patterns[i];
          var variance = OneDReader_default.patternMatchVariance(counters, pattern, AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException_default();
        }
      };
      AbstractUPCEANReader2.MAX_AVG_VARIANCE = 0.48;
      AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE = 0.7;
      AbstractUPCEANReader2.START_END_PATTERN = Int32Array.from([1, 1, 1]);
      AbstractUPCEANReader2.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
      AbstractUPCEANReader2.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
      AbstractUPCEANReader2.L_PATTERNS = [
        Int32Array.from([3, 2, 1, 1]),
        Int32Array.from([2, 2, 2, 1]),
        Int32Array.from([2, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 1]),
        Int32Array.from([1, 1, 3, 2]),
        Int32Array.from([1, 2, 3, 1]),
        Int32Array.from([1, 1, 1, 4]),
        Int32Array.from([1, 3, 1, 2]),
        Int32Array.from([1, 2, 1, 3]),
        Int32Array.from([3, 1, 1, 2])
      ];
      return AbstractUPCEANReader2;
    }(OneDReader_default)
  );
  var AbstractUPCEANReader_default = AbstractUPCEANReader;

  // node_modules/@zxing/library/esm/core/oned/UPCEANExtension5Support.js
  var __values7 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var UPCEANExtension5Support = (
    /** @class */
    function() {
      function UPCEANExtension5Support2() {
        this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      UPCEANExtension5Support2.prototype.decodeRow = function(rowNumber, row, extensionStartRange) {
        var result = this.decodeRowStringBuffer;
        var end2 = this.decodeMiddle(row, extensionStartRange, result);
        var resultString = result.toString();
        var extensionData = UPCEANExtension5Support2.parseExtensionString(resultString);
        var resultPoints = [
          new ResultPoint_default((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint_default(end2, rowNumber)
        ];
        var extensionResult = new Result_default(resultString, null, 0, resultPoints, BarcodeFormat_default.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      };
      UPCEANExtension5Support2.prototype.decodeMiddle = function(row, startRange, resultString) {
        var e_1, _a2;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end2 = row.getSize();
        var rowOffset = startRange[1];
        var lgPatternFound = 0;
        for (var x = 0; x < 5 && rowOffset < end2; x++) {
          var bestMatch = AbstractUPCEANReader_default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_default.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          try {
            for (var counters_1 = (e_1 = void 0, __values7(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              rowOffset += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 4 - x;
          }
          if (x !== 4) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 5) {
          throw new NotFoundException_default();
        }
        var checkDigit = this.determineCheckDigit(lgPatternFound);
        if (UPCEANExtension5Support2.extensionChecksum(resultString.toString()) !== checkDigit) {
          throw new NotFoundException_default();
        }
        return rowOffset;
      };
      UPCEANExtension5Support2.extensionChecksum = function(s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 2; i >= 0; i -= 2) {
          sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        for (var i = length - 1; i >= 0; i -= 2) {
          sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        return sum % 10;
      };
      UPCEANExtension5Support2.prototype.determineCheckDigit = function(lgPatternFound) {
        for (var d = 0; d < 10; d++) {
          if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
            return d;
          }
        }
        throw new NotFoundException_default();
      };
      UPCEANExtension5Support2.parseExtensionString = function(raw) {
        if (raw.length !== 5) {
          return null;
        }
        var value = UPCEANExtension5Support2.parseExtension5String(raw);
        if (value == null) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType_default.SUGGESTED_PRICE, value]]);
      };
      UPCEANExtension5Support2.parseExtension5String = function(raw) {
        var currency;
        switch (raw.charAt(0)) {
          case "0":
            currency = "\xA3";
            break;
          case "5":
            currency = "$";
            break;
          case "9":
            switch (raw) {
              case "90000":
                return null;
              case "99991":
                return "0.00";
              case "99990":
                return "Used";
            }
            currency = "";
            break;
          default:
            currency = "";
            break;
        }
        var rawAmount = parseInt(raw.substring(1));
        var unitsString = (rawAmount / 100).toString();
        var hundredths = rawAmount % 100;
        var hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
        return currency + unitsString + "." + hundredthsString;
      };
      return UPCEANExtension5Support2;
    }()
  );
  var UPCEANExtension5Support_default = UPCEANExtension5Support;

  // node_modules/@zxing/library/esm/core/oned/UPCEANExtension2Support.js
  var __values8 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var UPCEANExtension2Support = (
    /** @class */
    function() {
      function UPCEANExtension2Support2() {
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      UPCEANExtension2Support2.prototype.decodeRow = function(rowNumber, row, extensionStartRange) {
        var result = this.decodeRowStringBuffer;
        var end2 = this.decodeMiddle(row, extensionStartRange, result);
        var resultString = result.toString();
        var extensionData = UPCEANExtension2Support2.parseExtensionString(resultString);
        var resultPoints = [
          new ResultPoint_default((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint_default(end2, rowNumber)
        ];
        var extensionResult = new Result_default(resultString, null, 0, resultPoints, BarcodeFormat_default.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      };
      UPCEANExtension2Support2.prototype.decodeMiddle = function(row, startRange, resultString) {
        var e_1, _a2;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end2 = row.getSize();
        var rowOffset = startRange[1];
        var checkParity = 0;
        for (var x = 0; x < 2 && rowOffset < end2; x++) {
          var bestMatch = AbstractUPCEANReader_default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_default.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          try {
            for (var counters_1 = (e_1 = void 0, __values8(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              rowOffset += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (bestMatch >= 10) {
            checkParity |= 1 << 1 - x;
          }
          if (x !== 1) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 2) {
          throw new NotFoundException_default();
        }
        if (parseInt(resultString.toString()) % 4 !== checkParity) {
          throw new NotFoundException_default();
        }
        return rowOffset;
      };
      UPCEANExtension2Support2.parseExtensionString = function(raw) {
        if (raw.length !== 2) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType_default.ISSUE_NUMBER, parseInt(raw)]]);
      };
      return UPCEANExtension2Support2;
    }()
  );
  var UPCEANExtension2Support_default = UPCEANExtension2Support;

  // node_modules/@zxing/library/esm/core/oned/UPCEANExtensionSupport.js
  var UPCEANExtensionSupport = (
    /** @class */
    function() {
      function UPCEANExtensionSupport2() {
      }
      UPCEANExtensionSupport2.decodeRow = function(rowNumber, row, rowOffset) {
        var extensionStartRange = AbstractUPCEANReader_default.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
        try {
          var fiveSupport = new UPCEANExtension5Support_default();
          return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
        } catch (err) {
          var twoSupport = new UPCEANExtension2Support_default();
          return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
      };
      UPCEANExtensionSupport2.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
      return UPCEANExtensionSupport2;
    }()
  );
  var UPCEANExtensionSupport_default = UPCEANExtensionSupport;

  // node_modules/@zxing/library/esm/core/oned/UPCEANReader.js
  var __extends27 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var UPCEANReader = (
    /** @class */
    function(_super) {
      __extends27(UPCEANReader2, _super);
      function UPCEANReader2() {
        var _this = _super.call(this) || this;
        _this.decodeRowStringBuffer = "";
        UPCEANReader2.L_AND_G_PATTERNS = UPCEANReader2.L_PATTERNS.map(function(arr) {
          return Int32Array.from(arr);
        });
        for (var i = 10; i < 20; i++) {
          var widths = UPCEANReader2.L_PATTERNS[i - 10];
          var reversedWidths = new Int32Array(widths.length);
          for (var j = 0; j < widths.length; j++) {
            reversedWidths[j] = widths[widths.length - j - 1];
          }
          UPCEANReader2.L_AND_G_PATTERNS[i] = reversedWidths;
        }
        return _this;
      }
      UPCEANReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var startGuardRange = UPCEANReader2.findStartGuardPattern(row);
        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
        if (resultPointCallback != null) {
          var resultPoint_1 = new ResultPoint_default((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint_1);
        }
        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
        var endStart = budello.rowOffset;
        var result = budello.resultString;
        if (resultPointCallback != null) {
          var resultPoint_2 = new ResultPoint_default(endStart, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint_2);
        }
        var endRange = UPCEANReader2.decodeEnd(row, endStart);
        if (resultPointCallback != null) {
          var resultPoint_3 = new ResultPoint_default((endRange[0] + endRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint_3);
        }
        var end2 = endRange[1];
        var quietEnd = end2 + (end2 - endRange[0]);
        if (quietEnd >= row.getSize() || !row.isRange(end2, quietEnd, false)) {
          throw new NotFoundException_default();
        }
        var resultString = result.toString();
        if (resultString.length < 8) {
          throw new FormatException_default();
        }
        if (!UPCEANReader2.checkChecksum(resultString)) {
          throw new ChecksumException_default();
        }
        var left2 = (startGuardRange[1] + startGuardRange[0]) / 2;
        var right2 = (endRange[1] + endRange[0]) / 2;
        var format = this.getBarcodeFormat();
        var resultPoint = [new ResultPoint_default(left2, rowNumber), new ResultPoint_default(right2, rowNumber)];
        var decodeResult = new Result_default(resultString, null, 0, resultPoint, format, (/* @__PURE__ */ new Date()).getTime());
        var extensionLength = 0;
        try {
          var extensionResult = UPCEANExtensionSupport_default.decodeRow(rowNumber, row, endRange[1]);
          decodeResult.putMetadata(ResultMetadataType_default.UPC_EAN_EXTENSION, extensionResult.getText());
          decodeResult.putAllMetadata(extensionResult.getResultMetadata());
          decodeResult.addResultPoints(extensionResult.getResultPoints());
          extensionLength = extensionResult.getText().length;
        } catch (err) {
        }
        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_default.ALLOWED_EAN_EXTENSIONS);
        if (allowedExtensions != null) {
          var valid = false;
          for (var length_1 in allowedExtensions) {
            if (extensionLength.toString() === length_1) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            throw new NotFoundException_default();
          }
        }
        if (format === BarcodeFormat_default.EAN_13 || format === BarcodeFormat_default.UPC_A) {
        }
        return decodeResult;
      };
      UPCEANReader2.checkChecksum = function(s) {
        return UPCEANReader2.checkStandardUPCEANChecksum(s);
      };
      UPCEANReader2.checkStandardUPCEANChecksum = function(s) {
        var length = s.length;
        if (length === 0)
          return false;
        var check = parseInt(s.charAt(length - 1), 10);
        return UPCEANReader2.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
      };
      UPCEANReader2.getStandardUPCEANChecksum = function(s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 1; i >= 0; i -= 2) {
          var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException_default();
          }
          sum += digit;
        }
        sum *= 3;
        for (var i = length - 2; i >= 0; i -= 2) {
          var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException_default();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      };
      UPCEANReader2.decodeEnd = function(row, endStart) {
        return UPCEANReader2.findGuardPattern(row, endStart, false, UPCEANReader2.START_END_PATTERN, new Int32Array(UPCEANReader2.START_END_PATTERN.length).fill(0));
      };
      return UPCEANReader2;
    }(AbstractUPCEANReader_default)
  );
  var UPCEANReader_default = UPCEANReader;

  // node_modules/@zxing/library/esm/core/oned/EAN13Reader.js
  var __extends28 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values9 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var EAN13Reader = (
    /** @class */
    function(_super) {
      __extends28(EAN13Reader2, _super);
      function EAN13Reader2() {
        var _this = _super.call(this) || this;
        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        return _this;
      }
      EAN13Reader2.prototype.decodeMiddle = function(row, startRange, resultString) {
        var e_1, _a2, e_2, _b;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end2 = row.getSize();
        var rowOffset = startRange[1];
        var lgPatternFound = 0;
        for (var x = 0; x < 6 && rowOffset < end2; x++) {
          var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          try {
            for (var counters_1 = (e_1 = void 0, __values9(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              rowOffset += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        resultString = EAN13Reader2.determineFirstDigit(resultString, lgPatternFound);
        var middleRange = UPCEANReader_default.findGuardPattern(row, rowOffset, true, UPCEANReader_default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_default.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (var x = 0; x < 6 && rowOffset < end2; x++) {
          var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          try {
            for (var counters_2 = (e_2 = void 0, __values9(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
              var counter = counters_2_1.value;
              rowOffset += counter;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        return { rowOffset, resultString };
      };
      EAN13Reader2.prototype.getBarcodeFormat = function() {
        return BarcodeFormat_default.EAN_13;
      };
      EAN13Reader2.determineFirstDigit = function(resultString, lgPatternFound) {
        for (var d = 0; d < 10; d++) {
          if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
            resultString = String.fromCharCode("0".charCodeAt(0) + d) + resultString;
            return resultString;
          }
        }
        throw new NotFoundException_default();
      };
      EAN13Reader2.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
      return EAN13Reader2;
    }(UPCEANReader_default)
  );
  var EAN13Reader_default = EAN13Reader;

  // node_modules/@zxing/library/esm/core/oned/EAN8Reader.js
  var __extends29 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values10 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var EAN8Reader = (
    /** @class */
    function(_super) {
      __extends29(EAN8Reader2, _super);
      function EAN8Reader2() {
        var _this = _super.call(this) || this;
        _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        return _this;
      }
      EAN8Reader2.prototype.decodeMiddle = function(row, startRange, resultString) {
        var e_1, _a2, e_2, _b;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end2 = row.getSize();
        var rowOffset = startRange[1];
        for (var x = 0; x < 4 && rowOffset < end2; x++) {
          var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          try {
            for (var counters_1 = (e_1 = void 0, __values10(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              rowOffset += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
        var middleRange = UPCEANReader_default.findGuardPattern(row, rowOffset, true, UPCEANReader_default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_default.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (var x = 0; x < 4 && rowOffset < end2; x++) {
          var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          try {
            for (var counters_2 = (e_2 = void 0, __values10(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
              var counter = counters_2_1.value;
              rowOffset += counter;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        return { rowOffset, resultString };
      };
      EAN8Reader2.prototype.getBarcodeFormat = function() {
        return BarcodeFormat_default.EAN_8;
      };
      return EAN8Reader2;
    }(UPCEANReader_default)
  );
  var EAN8Reader_default = EAN8Reader;

  // node_modules/@zxing/library/esm/core/oned/UPCAReader.js
  var __extends30 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var UPCAReader = (
    /** @class */
    function(_super) {
      __extends30(UPCAReader2, _super);
      function UPCAReader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ean13Reader = new EAN13Reader_default();
        return _this;
      }
      UPCAReader2.prototype.getBarcodeFormat = function() {
        return BarcodeFormat_default.UPC_A;
      };
      UPCAReader2.prototype.decode = function(image, hints) {
        return this.maybeReturnResult(this.ean13Reader.decode(image));
      };
      UPCAReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
      };
      UPCAReader2.prototype.decodeMiddle = function(row, startRange, resultString) {
        return this.ean13Reader.decodeMiddle(row, startRange, resultString);
      };
      UPCAReader2.prototype.maybeReturnResult = function(result) {
        var text = result.getText();
        if (text.charAt(0) === "0") {
          var upcaResult = new Result_default(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat_default.UPC_A);
          if (result.getResultMetadata() != null) {
            upcaResult.putAllMetadata(result.getResultMetadata());
          }
          return upcaResult;
        } else {
          throw new NotFoundException_default();
        }
      };
      UPCAReader2.prototype.reset = function() {
        this.ean13Reader.reset();
      };
      return UPCAReader2;
    }(UPCEANReader_default)
  );
  var UPCAReader_default = UPCAReader;

  // node_modules/@zxing/library/esm/core/oned/UPCEReader.js
  var __extends31 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values11 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var UPCEReader = (
    /** @class */
    function(_super) {
      __extends31(UPCEReader2, _super);
      function UPCEReader2() {
        var _this = _super.call(this) || this;
        _this.decodeMiddleCounters = new Int32Array(4);
        return _this;
      }
      UPCEReader2.prototype.decodeMiddle = function(row, startRange, result) {
        var e_1, _a2;
        var counters = this.decodeMiddleCounters.map(function(x2) {
          return x2;
        });
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end2 = row.getSize();
        var rowOffset = startRange[1];
        var lgPatternFound = 0;
        for (var x = 0; x < 6 && rowOffset < end2; x++) {
          var bestMatch = UPCEReader2.decodeDigit(row, counters, rowOffset, UPCEReader2.L_AND_G_PATTERNS);
          result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          try {
            for (var counters_1 = (e_1 = void 0, __values11(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              rowOffset += counter;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        UPCEReader2.determineNumSysAndCheckDigit(new StringBuilder_default(result), lgPatternFound);
        return rowOffset;
      };
      UPCEReader2.prototype.decodeEnd = function(row, endStart) {
        return UPCEReader2.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader2.MIDDLE_END_PATTERN);
      };
      UPCEReader2.prototype.checkChecksum = function(s) {
        return UPCEANReader_default.checkChecksum(UPCEReader2.convertUPCEtoUPCA(s));
      };
      UPCEReader2.determineNumSysAndCheckDigit = function(resultString, lgPatternFound) {
        for (var numSys = 0; numSys <= 1; numSys++) {
          for (var d = 0; d < 10; d++) {
            if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
              resultString.insert(
                0,
                /*(char)*/
                "0" + numSys
              );
              resultString.append(
                /*(char)*/
                "0" + d
              );
              return;
            }
          }
        }
        throw NotFoundException_default.getNotFoundInstance();
      };
      UPCEReader2.prototype.getBarcodeFormat = function() {
        return BarcodeFormat_default.UPC_E;
      };
      UPCEReader2.convertUPCEtoUPCA = function(upce) {
        var upceChars = upce.slice(1, 7).split("").map(function(x) {
          return x.charCodeAt(0);
        });
        var result = new StringBuilder_default(
          /*12*/
        );
        result.append(upce.charAt(0));
        var lastChar = upceChars[5];
        switch (lastChar) {
          case 0:
          case 1:
          case 2:
            result.appendChars(upceChars, 0, 2);
            result.append(lastChar);
            result.append("0000");
            result.appendChars(upceChars, 2, 3);
            break;
          case 3:
            result.appendChars(upceChars, 0, 3);
            result.append("00000");
            result.appendChars(upceChars, 3, 2);
            break;
          case 4:
            result.appendChars(upceChars, 0, 4);
            result.append("00000");
            result.append(upceChars[4]);
            break;
          default:
            result.appendChars(upceChars, 0, 5);
            result.append("0000");
            result.append(lastChar);
            break;
        }
        if (upce.length >= 8) {
          result.append(upce.charAt(7));
        }
        return result.toString();
      };
      UPCEReader2.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
      UPCEReader2.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
        Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
        Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 1])
      ];
      return UPCEReader2;
    }(UPCEANReader_default)
  );
  var UPCEReader_default = UPCEReader;

  // node_modules/@zxing/library/esm/core/oned/MultiFormatUPCEANReader.js
  var __extends32 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values12 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var MultiFormatUPCEANReader = (
    /** @class */
    function(_super) {
      __extends32(MultiFormatUPCEANReader2, _super);
      function MultiFormatUPCEANReader2(hints) {
        var _this = _super.call(this) || this;
        var possibleFormats = hints == null ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
        var readers2 = [];
        if (possibleFormats != null) {
          if (possibleFormats.indexOf(BarcodeFormat_default.EAN_13) > -1) {
            readers2.push(new EAN13Reader_default());
          }
          if (possibleFormats.indexOf(BarcodeFormat_default.UPC_A) > -1) {
            readers2.push(new UPCAReader_default());
          }
          if (possibleFormats.indexOf(BarcodeFormat_default.EAN_8) > -1) {
            readers2.push(new EAN8Reader_default());
          }
          if (possibleFormats.indexOf(BarcodeFormat_default.UPC_E) > -1) {
            readers2.push(new UPCEReader_default());
          }
        }
        if (readers2.length === 0) {
          readers2.push(new EAN13Reader_default());
          readers2.push(new UPCAReader_default());
          readers2.push(new EAN8Reader_default());
          readers2.push(new UPCEReader_default());
        }
        _this.readers = readers2;
        return _this;
      }
      MultiFormatUPCEANReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var e_1, _a2;
        try {
          for (var _b = __values12(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var reader = _c.value;
            try {
              var result = reader.decodeRow(rowNumber, row, hints);
              var ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat_default.EAN_13 && result.getText().charAt(0) === "0";
              var possibleFormats = hints == null ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
              var canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat_default.UPC_A);
              if (ean13MayBeUPCA && canReturnUPCA) {
                var rawBytes = result.getRawBytes();
                var resultUPCA = new Result_default(result.getText().substring(1), rawBytes, rawBytes ? rawBytes.length : null, result.getResultPoints(), BarcodeFormat_default.UPC_A);
                resultUPCA.putAllMetadata(result.getResultMetadata());
                return resultUPCA;
              }
              return result;
            } catch (err) {
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        throw new NotFoundException_default();
      };
      MultiFormatUPCEANReader2.prototype.reset = function() {
        var e_2, _a2;
        try {
          for (var _b = __values12(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var reader = _c.value;
            reader.reset();
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      };
      return MultiFormatUPCEANReader2;
    }(OneDReader_default)
  );
  var MultiFormatUPCEANReader_default = MultiFormatUPCEANReader;

  // node_modules/@zxing/library/esm/core/oned/CodaBarReader.js
  var __extends33 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var CodaBarReader = (
    /** @class */
    function(_super) {
      __extends33(CodaBarReader2, _super);
      function CodaBarReader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.CODA_BAR_CHAR_SET = {
          nnnnnww: "0",
          nnnnwwn: "1",
          nnnwnnw: "2",
          wwnnnnn: "3",
          nnwnnwn: "4",
          wnnnnwn: "5",
          nwnnnnw: "6",
          nwnnwnn: "7",
          nwwnnnn: "8",
          wnnwnnn: "9",
          nnnwwnn: "-",
          nnwwnnn: "$",
          wnnnwnw: ":",
          wnwnnnw: "/",
          wnwnwnn: ".",
          nnwwwww: "+",
          nnwwnwn: "A",
          nwnwnnw: "B",
          nnnwnww: "C",
          nnnwwwn: "D"
        };
        return _this;
      }
      CodaBarReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var validRowData = this.getValidRowData(row);
        if (!validRowData)
          throw new NotFoundException_default();
        var retStr = this.codaBarDecodeRow(validRowData.row);
        if (!retStr)
          throw new NotFoundException_default();
        return new Result_default(retStr, null, 0, [new ResultPoint_default(validRowData.left, rowNumber), new ResultPoint_default(validRowData.right, rowNumber)], BarcodeFormat_default.CODABAR, (/* @__PURE__ */ new Date()).getTime());
      };
      CodaBarReader2.prototype.getValidRowData = function(row) {
        var booleanArr = row.toArray();
        var startIndex = booleanArr.indexOf(true);
        if (startIndex === -1)
          return null;
        var lastIndex = booleanArr.lastIndexOf(true);
        if (lastIndex <= startIndex)
          return null;
        booleanArr = booleanArr.slice(startIndex, lastIndex + 1);
        var result = [];
        var lastBit = booleanArr[0];
        var bitLength = 1;
        for (var i = 1; i < booleanArr.length; i++) {
          if (booleanArr[i] === lastBit) {
            bitLength++;
          } else {
            lastBit = booleanArr[i];
            result.push(bitLength);
            bitLength = 1;
          }
        }
        result.push(bitLength);
        if (result.length < 23 && (result.length + 1) % 8 !== 0)
          return null;
        return { row: result, left: startIndex, right: lastIndex };
      };
      CodaBarReader2.prototype.codaBarDecodeRow = function(row) {
        var code = [];
        var barThreshold = Math.ceil(row.reduce(function(pre, item) {
          return (pre + item) / 2;
        }, 0));
        while (row.length > 0) {
          var seg = row.splice(0, 8).splice(0, 7);
          var key = seg.map(function(len) {
            return len < barThreshold ? "n" : "w";
          }).join("");
          if (this.CODA_BAR_CHAR_SET[key] === void 0)
            return null;
          code.push(this.CODA_BAR_CHAR_SET[key]);
        }
        var strCode = code.join("");
        if (this.validCodaBarString(strCode))
          return strCode;
        return null;
      };
      CodaBarReader2.prototype.validCodaBarString = function(src) {
        var reg = /^[A-D].{1,}[A-D]$/;
        return reg.test(src);
      };
      return CodaBarReader2;
    }(OneDReader_default)
  );
  var CodaBarReader_default = CodaBarReader;

  // node_modules/@zxing/library/esm/core/oned/rss/AbstractRSSReader.js
  var __extends34 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values13 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var AbstractRSSReader = (
    /** @class */
    function(_super) {
      __extends34(AbstractRSSReader2, _super);
      function AbstractRSSReader2() {
        var _this = _super.call(this) || this;
        _this.decodeFinderCounters = new Int32Array(4);
        _this.dataCharacterCounters = new Int32Array(8);
        _this.oddRoundingErrors = new Array(4);
        _this.evenRoundingErrors = new Array(4);
        _this.oddCounts = new Array(_this.dataCharacterCounters.length / 2);
        _this.evenCounts = new Array(_this.dataCharacterCounters.length / 2);
        return _this;
      }
      AbstractRSSReader2.prototype.getDecodeFinderCounters = function() {
        return this.decodeFinderCounters;
      };
      AbstractRSSReader2.prototype.getDataCharacterCounters = function() {
        return this.dataCharacterCounters;
      };
      AbstractRSSReader2.prototype.getOddRoundingErrors = function() {
        return this.oddRoundingErrors;
      };
      AbstractRSSReader2.prototype.getEvenRoundingErrors = function() {
        return this.evenRoundingErrors;
      };
      AbstractRSSReader2.prototype.getOddCounts = function() {
        return this.oddCounts;
      };
      AbstractRSSReader2.prototype.getEvenCounts = function() {
        return this.evenCounts;
      };
      AbstractRSSReader2.prototype.parseFinderValue = function(counters, finderPatterns) {
        for (var value = 0; value < finderPatterns.length; value++) {
          if (OneDReader_default.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader2.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader2.MAX_AVG_VARIANCE) {
            return value;
          }
        }
        throw new NotFoundException_default();
      };
      AbstractRSSReader2.count = function(array) {
        return MathUtils_default.sum(new Int32Array(array));
      };
      AbstractRSSReader2.increment = function(array, errors) {
        var index = 0;
        var biggestError = errors[0];
        for (var i = 1; i < array.length; i++) {
          if (errors[i] > biggestError) {
            biggestError = errors[i];
            index = i;
          }
        }
        array[index]++;
      };
      AbstractRSSReader2.decrement = function(array, errors) {
        var index = 0;
        var biggestError = errors[0];
        for (var i = 1; i < array.length; i++) {
          if (errors[i] < biggestError) {
            biggestError = errors[i];
            index = i;
          }
        }
        array[index]--;
      };
      AbstractRSSReader2.isFinderPattern = function(counters) {
        var e_1, _a2;
        var firstTwoSum = counters[0] + counters[1];
        var sum = firstTwoSum + counters[2] + counters[3];
        var ratio = firstTwoSum / sum;
        if (ratio >= AbstractRSSReader2.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader2.MAX_FINDER_PATTERN_RATIO) {
          var minCounter = Number.MAX_SAFE_INTEGER;
          var maxCounter = Number.MIN_SAFE_INTEGER;
          try {
            for (var counters_1 = __values13(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
              var counter = counters_1_1.value;
              if (counter > maxCounter) {
                maxCounter = counter;
              }
              if (counter < minCounter) {
                minCounter = counter;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (counters_1_1 && !counters_1_1.done && (_a2 = counters_1.return)) _a2.call(counters_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return maxCounter < 10 * minCounter;
        }
        return false;
      };
      AbstractRSSReader2.MAX_AVG_VARIANCE = 0.2;
      AbstractRSSReader2.MAX_INDIVIDUAL_VARIANCE = 0.45;
      AbstractRSSReader2.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
      AbstractRSSReader2.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
      return AbstractRSSReader2;
    }(OneDReader_default)
  );
  var AbstractRSSReader_default = AbstractRSSReader;

  // node_modules/@zxing/library/esm/core/oned/rss/DataCharacter.js
  var DataCharacter = (
    /** @class */
    function() {
      function DataCharacter2(value, checksumPortion) {
        this.value = value;
        this.checksumPortion = checksumPortion;
      }
      DataCharacter2.prototype.getValue = function() {
        return this.value;
      };
      DataCharacter2.prototype.getChecksumPortion = function() {
        return this.checksumPortion;
      };
      DataCharacter2.prototype.toString = function() {
        return this.value + "(" + this.checksumPortion + ")";
      };
      DataCharacter2.prototype.equals = function(o) {
        if (!(o instanceof DataCharacter2)) {
          return false;
        }
        var that = o;
        return this.value === that.value && this.checksumPortion === that.checksumPortion;
      };
      DataCharacter2.prototype.hashCode = function() {
        return this.value ^ this.checksumPortion;
      };
      return DataCharacter2;
    }()
  );
  var DataCharacter_default = DataCharacter;

  // node_modules/@zxing/library/esm/core/oned/rss/FinderPattern.js
  var FinderPattern = (
    /** @class */
    function() {
      function FinderPattern3(value, startEnd, start3, end2, rowNumber) {
        this.value = value;
        this.startEnd = startEnd;
        this.value = value;
        this.startEnd = startEnd;
        this.resultPoints = new Array();
        this.resultPoints.push(new ResultPoint_default(start3, rowNumber));
        this.resultPoints.push(new ResultPoint_default(end2, rowNumber));
      }
      FinderPattern3.prototype.getValue = function() {
        return this.value;
      };
      FinderPattern3.prototype.getStartEnd = function() {
        return this.startEnd;
      };
      FinderPattern3.prototype.getResultPoints = function() {
        return this.resultPoints;
      };
      FinderPattern3.prototype.equals = function(o) {
        if (!(o instanceof FinderPattern3)) {
          return false;
        }
        var that = o;
        return this.value === that.value;
      };
      FinderPattern3.prototype.hashCode = function() {
        return this.value;
      };
      return FinderPattern3;
    }()
  );
  var FinderPattern_default = FinderPattern;

  // node_modules/@zxing/library/esm/core/oned/rss/RSSUtils.js
  var __values14 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var RSSUtils = (
    /** @class */
    function() {
      function RSSUtils2() {
      }
      RSSUtils2.getRSSvalue = function(widths, maxWidth, noNarrow) {
        var e_1, _a2;
        var n = 0;
        try {
          for (var widths_1 = __values14(widths), widths_1_1 = widths_1.next(); !widths_1_1.done; widths_1_1 = widths_1.next()) {
            var width = widths_1_1.value;
            n += width;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (widths_1_1 && !widths_1_1.done && (_a2 = widths_1.return)) _a2.call(widths_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var val = 0;
        var narrowMask = 0;
        var elements = widths.length;
        for (var bar = 0; bar < elements - 1; bar++) {
          var elmWidth = void 0;
          for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
            var subVal = RSSUtils2.combins(n - elmWidth - 1, elements - bar - 2);
            if (noNarrow && narrowMask === 0 && n - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
              subVal -= RSSUtils2.combins(n - elmWidth - (elements - bar), elements - bar - 2);
            }
            if (elements - bar - 1 > 1) {
              var lessVal = 0;
              for (var mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                lessVal += RSSUtils2.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
              }
              subVal -= lessVal * (elements - 1 - bar);
            } else if (n - elmWidth > maxWidth) {
              subVal--;
            }
            val += subVal;
          }
          n -= elmWidth;
        }
        return val;
      };
      RSSUtils2.combins = function(n, r) {
        var maxDenom;
        var minDenom;
        if (n - r > r) {
          minDenom = r;
          maxDenom = n - r;
        } else {
          minDenom = n - r;
          maxDenom = r;
        }
        var val = 1;
        var j = 1;
        for (var i = n; i > maxDenom; i--) {
          val *= i;
          if (j <= minDenom) {
            val /= j;
            j++;
          }
        }
        while (j <= minDenom) {
          val /= j;
          j++;
        }
        return val;
      };
      return RSSUtils2;
    }()
  );
  var RSSUtils_default = RSSUtils;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/BitArrayBuilder.js
  var BitArrayBuilder = (
    /** @class */
    function() {
      function BitArrayBuilder2() {
      }
      BitArrayBuilder2.buildBitArray = function(pairs) {
        var charNumber = pairs.length * 2 - 1;
        if (pairs[pairs.length - 1].getRightChar() == null) {
          charNumber -= 1;
        }
        var size = 12 * charNumber;
        var binary = new BitArray_default(size);
        var accPos = 0;
        var firstPair = pairs[0];
        var firstValue = firstPair.getRightChar().getValue();
        for (var i = 11; i >= 0; --i) {
          if ((firstValue & 1 << i) !== 0) {
            binary.set(accPos);
          }
          accPos++;
        }
        for (var i = 1; i < pairs.length; ++i) {
          var currentPair = pairs[i];
          var leftValue = currentPair.getLeftChar().getValue();
          for (var j = 11; j >= 0; --j) {
            if ((leftValue & 1 << j) !== 0) {
              binary.set(accPos);
            }
            accPos++;
          }
          if (currentPair.getRightChar() !== null) {
            var rightValue = currentPair.getRightChar().getValue();
            for (var j = 11; j >= 0; --j) {
              if ((rightValue & 1 << j) !== 0) {
                binary.set(accPos);
              }
              accPos++;
            }
          }
        }
        return binary;
      };
      return BitArrayBuilder2;
    }()
  );
  var BitArrayBuilder_default = BitArrayBuilder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/BlockParsedResult.js
  var BlockParsedResult = (
    /** @class */
    function() {
      function BlockParsedResult2(finished, decodedInformation) {
        if (decodedInformation) {
          this.decodedInformation = null;
        } else {
          this.finished = finished;
          this.decodedInformation = decodedInformation;
        }
      }
      BlockParsedResult2.prototype.getDecodedInformation = function() {
        return this.decodedInformation;
      };
      BlockParsedResult2.prototype.isFinished = function() {
        return this.finished;
      };
      return BlockParsedResult2;
    }()
  );
  var BlockParsedResult_default = BlockParsedResult;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedObject.js
  var DecodedObject = (
    /** @class */
    function() {
      function DecodedObject2(newPosition) {
        this.newPosition = newPosition;
      }
      DecodedObject2.prototype.getNewPosition = function() {
        return this.newPosition;
      };
      return DecodedObject2;
    }()
  );
  var DecodedObject_default = DecodedObject;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedChar.js
  var __extends35 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var DecodedChar = (
    /** @class */
    function(_super) {
      __extends35(DecodedChar2, _super);
      function DecodedChar2(newPosition, value) {
        var _this = _super.call(this, newPosition) || this;
        _this.value = value;
        return _this;
      }
      DecodedChar2.prototype.getValue = function() {
        return this.value;
      };
      DecodedChar2.prototype.isFNC1 = function() {
        return this.value === DecodedChar2.FNC1;
      };
      DecodedChar2.FNC1 = "$";
      return DecodedChar2;
    }(DecodedObject_default)
  );
  var DecodedChar_default = DecodedChar;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedInformation.js
  var __extends36 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var DecodedInformation = (
    /** @class */
    function(_super) {
      __extends36(DecodedInformation2, _super);
      function DecodedInformation2(newPosition, newString, remainingValue) {
        var _this = _super.call(this, newPosition) || this;
        if (remainingValue) {
          _this.remaining = true;
          _this.remainingValue = _this.remainingValue;
        } else {
          _this.remaining = false;
          _this.remainingValue = 0;
        }
        _this.newString = newString;
        return _this;
      }
      DecodedInformation2.prototype.getNewString = function() {
        return this.newString;
      };
      DecodedInformation2.prototype.isRemaining = function() {
        return this.remaining;
      };
      DecodedInformation2.prototype.getRemainingValue = function() {
        return this.remainingValue;
      };
      return DecodedInformation2;
    }(DecodedObject_default)
  );
  var DecodedInformation_default = DecodedInformation;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedNumeric.js
  var __extends37 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var DecodedNumeric = (
    /** @class */
    function(_super) {
      __extends37(DecodedNumeric2, _super);
      function DecodedNumeric2(newPosition, firstDigit, secondDigit) {
        var _this = _super.call(this, newPosition) || this;
        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
          throw new FormatException_default();
        }
        _this.firstDigit = firstDigit;
        _this.secondDigit = secondDigit;
        return _this;
      }
      DecodedNumeric2.prototype.getFirstDigit = function() {
        return this.firstDigit;
      };
      DecodedNumeric2.prototype.getSecondDigit = function() {
        return this.secondDigit;
      };
      DecodedNumeric2.prototype.getValue = function() {
        return this.firstDigit * 10 + this.secondDigit;
      };
      DecodedNumeric2.prototype.isFirstDigitFNC1 = function() {
        return this.firstDigit === DecodedNumeric2.FNC1;
      };
      DecodedNumeric2.prototype.isSecondDigitFNC1 = function() {
        return this.secondDigit === DecodedNumeric2.FNC1;
      };
      DecodedNumeric2.prototype.isAnyFNC1 = function() {
        return this.firstDigit === DecodedNumeric2.FNC1 || this.secondDigit === DecodedNumeric2.FNC1;
      };
      DecodedNumeric2.FNC1 = 10;
      return DecodedNumeric2;
    }(DecodedObject_default)
  );
  var DecodedNumeric_default = DecodedNumeric;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/FieldParser.js
  var __values15 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var FieldParser = (
    /** @class */
    function() {
      function FieldParser2() {
      }
      FieldParser2.parseFieldsInGeneralPurpose = function(rawInformation) {
        var e_1, _a2, e_2, _b, e_3, _c, e_4, _d;
        if (!rawInformation) {
          return null;
        }
        if (rawInformation.length < 2) {
          throw new NotFoundException_default();
        }
        var firstTwoDigits = rawInformation.substring(0, 2);
        try {
          for (var _e = __values15(FieldParser2.TWO_DIGIT_DATA_LENGTH), _f = _e.next(); !_f.done; _f = _e.next()) {
            var dataLength = _f.value;
            if (dataLength[0] === firstTwoDigits) {
              if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
                return FieldParser2.processVariableAI(2, dataLength[2], rawInformation);
              }
              return FieldParser2.processFixedAI(2, dataLength[1], rawInformation);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_f && !_f.done && (_a2 = _e.return)) _a2.call(_e);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (rawInformation.length < 3) {
          throw new NotFoundException_default();
        }
        var firstThreeDigits = rawInformation.substring(0, 3);
        try {
          for (var _g = __values15(FieldParser2.THREE_DIGIT_DATA_LENGTH), _h = _g.next(); !_h.done; _h = _g.next()) {
            var dataLength = _h.value;
            if (dataLength[0] === firstThreeDigits) {
              if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
                return FieldParser2.processVariableAI(3, dataLength[2], rawInformation);
              }
              return FieldParser2.processFixedAI(3, dataLength[1], rawInformation);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        try {
          for (var _j = __values15(FieldParser2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), _k = _j.next(); !_k.done; _k = _j.next()) {
            var dataLength = _k.value;
            if (dataLength[0] === firstThreeDigits) {
              if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
                return FieldParser2.processVariableAI(4, dataLength[2], rawInformation);
              }
              return FieldParser2.processFixedAI(4, dataLength[1], rawInformation);
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        if (rawInformation.length < 4) {
          throw new NotFoundException_default();
        }
        var firstFourDigits = rawInformation.substring(0, 4);
        try {
          for (var _l = __values15(FieldParser2.FOUR_DIGIT_DATA_LENGTH), _m = _l.next(); !_m.done; _m = _l.next()) {
            var dataLength = _m.value;
            if (dataLength[0] === firstFourDigits) {
              if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
                return FieldParser2.processVariableAI(4, dataLength[2], rawInformation);
              }
              return FieldParser2.processFixedAI(4, dataLength[1], rawInformation);
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
        throw new NotFoundException_default();
      };
      FieldParser2.processFixedAI = function(aiSize, fieldSize, rawInformation) {
        if (rawInformation.length < aiSize) {
          throw new NotFoundException_default();
        }
        var ai = rawInformation.substring(0, aiSize);
        if (rawInformation.length < aiSize + fieldSize) {
          throw new NotFoundException_default();
        }
        var field = rawInformation.substring(aiSize, aiSize + fieldSize);
        var remaining = rawInformation.substring(aiSize + fieldSize);
        var result = "(" + ai + ")" + field;
        var parsedAI = FieldParser2.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      };
      FieldParser2.processVariableAI = function(aiSize, variableFieldSize, rawInformation) {
        var ai = rawInformation.substring(0, aiSize);
        var maxSize;
        if (rawInformation.length < aiSize + variableFieldSize) {
          maxSize = rawInformation.length;
        } else {
          maxSize = aiSize + variableFieldSize;
        }
        var field = rawInformation.substring(aiSize, maxSize);
        var remaining = rawInformation.substring(maxSize);
        var result = "(" + ai + ")" + field;
        var parsedAI = FieldParser2.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      };
      FieldParser2.VARIABLE_LENGTH = [];
      FieldParser2.TWO_DIGIT_DATA_LENGTH = [
        ["00", 18],
        ["01", 14],
        ["02", 14],
        ["10", FieldParser2.VARIABLE_LENGTH, 20],
        ["11", 6],
        ["12", 6],
        ["13", 6],
        ["15", 6],
        ["17", 6],
        ["20", 2],
        ["21", FieldParser2.VARIABLE_LENGTH, 20],
        ["22", FieldParser2.VARIABLE_LENGTH, 29],
        ["30", FieldParser2.VARIABLE_LENGTH, 8],
        ["37", FieldParser2.VARIABLE_LENGTH, 8],
        // internal company codes
        ["90", FieldParser2.VARIABLE_LENGTH, 30],
        ["91", FieldParser2.VARIABLE_LENGTH, 30],
        ["92", FieldParser2.VARIABLE_LENGTH, 30],
        ["93", FieldParser2.VARIABLE_LENGTH, 30],
        ["94", FieldParser2.VARIABLE_LENGTH, 30],
        ["95", FieldParser2.VARIABLE_LENGTH, 30],
        ["96", FieldParser2.VARIABLE_LENGTH, 30],
        ["97", FieldParser2.VARIABLE_LENGTH, 3],
        ["98", FieldParser2.VARIABLE_LENGTH, 30],
        ["99", FieldParser2.VARIABLE_LENGTH, 30]
      ];
      FieldParser2.THREE_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["240", FieldParser2.VARIABLE_LENGTH, 30],
        ["241", FieldParser2.VARIABLE_LENGTH, 30],
        ["242", FieldParser2.VARIABLE_LENGTH, 6],
        ["250", FieldParser2.VARIABLE_LENGTH, 30],
        ["251", FieldParser2.VARIABLE_LENGTH, 30],
        ["253", FieldParser2.VARIABLE_LENGTH, 17],
        ["254", FieldParser2.VARIABLE_LENGTH, 20],
        ["400", FieldParser2.VARIABLE_LENGTH, 30],
        ["401", FieldParser2.VARIABLE_LENGTH, 30],
        ["402", 17],
        ["403", FieldParser2.VARIABLE_LENGTH, 30],
        ["410", 13],
        ["411", 13],
        ["412", 13],
        ["413", 13],
        ["414", 13],
        ["420", FieldParser2.VARIABLE_LENGTH, 20],
        ["421", FieldParser2.VARIABLE_LENGTH, 15],
        ["422", 3],
        ["423", FieldParser2.VARIABLE_LENGTH, 15],
        ["424", 3],
        ["425", 3],
        ["426", 3]
      ];
      FieldParser2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["310", 6],
        ["311", 6],
        ["312", 6],
        ["313", 6],
        ["314", 6],
        ["315", 6],
        ["316", 6],
        ["320", 6],
        ["321", 6],
        ["322", 6],
        ["323", 6],
        ["324", 6],
        ["325", 6],
        ["326", 6],
        ["327", 6],
        ["328", 6],
        ["329", 6],
        ["330", 6],
        ["331", 6],
        ["332", 6],
        ["333", 6],
        ["334", 6],
        ["335", 6],
        ["336", 6],
        ["340", 6],
        ["341", 6],
        ["342", 6],
        ["343", 6],
        ["344", 6],
        ["345", 6],
        ["346", 6],
        ["347", 6],
        ["348", 6],
        ["349", 6],
        ["350", 6],
        ["351", 6],
        ["352", 6],
        ["353", 6],
        ["354", 6],
        ["355", 6],
        ["356", 6],
        ["357", 6],
        ["360", 6],
        ["361", 6],
        ["362", 6],
        ["363", 6],
        ["364", 6],
        ["365", 6],
        ["366", 6],
        ["367", 6],
        ["368", 6],
        ["369", 6],
        ["390", FieldParser2.VARIABLE_LENGTH, 15],
        ["391", FieldParser2.VARIABLE_LENGTH, 18],
        ["392", FieldParser2.VARIABLE_LENGTH, 15],
        ["393", FieldParser2.VARIABLE_LENGTH, 18],
        ["703", FieldParser2.VARIABLE_LENGTH, 30]
      ];
      FieldParser2.FOUR_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["7001", 13],
        ["7002", FieldParser2.VARIABLE_LENGTH, 30],
        ["7003", 10],
        ["8001", 14],
        ["8002", FieldParser2.VARIABLE_LENGTH, 20],
        ["8003", FieldParser2.VARIABLE_LENGTH, 30],
        ["8004", FieldParser2.VARIABLE_LENGTH, 30],
        ["8005", 6],
        ["8006", 18],
        ["8007", FieldParser2.VARIABLE_LENGTH, 30],
        ["8008", FieldParser2.VARIABLE_LENGTH, 12],
        ["8018", 18],
        ["8020", FieldParser2.VARIABLE_LENGTH, 25],
        ["8100", 6],
        ["8101", 10],
        ["8102", 2],
        ["8110", FieldParser2.VARIABLE_LENGTH, 70],
        ["8200", FieldParser2.VARIABLE_LENGTH, 70]
      ];
      return FieldParser2;
    }()
  );
  var FieldParser_default = FieldParser;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js
  var GeneralAppIdDecoder = (
    /** @class */
    function() {
      function GeneralAppIdDecoder2(information) {
        this.buffer = new StringBuilder_default();
        this.information = information;
      }
      GeneralAppIdDecoder2.prototype.decodeAllCodes = function(buff, initialPosition) {
        var currentPosition = initialPosition;
        var remaining = null;
        do {
          var info = this.decodeGeneralPurposeField(currentPosition, remaining);
          var parsedFields = FieldParser_default.parseFieldsInGeneralPurpose(info.getNewString());
          if (parsedFields != null) {
            buff.append(parsedFields);
          }
          if (info.isRemaining()) {
            remaining = "" + info.getRemainingValue();
          } else {
            remaining = null;
          }
          if (currentPosition === info.getNewPosition()) {
            break;
          }
          currentPosition = info.getNewPosition();
        } while (true);
        return buff.toString();
      };
      GeneralAppIdDecoder2.prototype.isStillNumeric = function(pos) {
        if (pos + 7 > this.information.getSize()) {
          return pos + 4 <= this.information.getSize();
        }
        for (var i = pos; i < pos + 3; ++i) {
          if (this.information.get(i)) {
            return true;
          }
        }
        return this.information.get(pos + 3);
      };
      GeneralAppIdDecoder2.prototype.decodeNumeric = function(pos) {
        if (pos + 7 > this.information.getSize()) {
          var numeric_1 = this.extractNumericValueFromBitArray(pos, 4);
          if (numeric_1 === 0) {
            return new DecodedNumeric_default(this.information.getSize(), DecodedNumeric_default.FNC1, DecodedNumeric_default.FNC1);
          }
          return new DecodedNumeric_default(this.information.getSize(), numeric_1 - 1, DecodedNumeric_default.FNC1);
        }
        var numeric = this.extractNumericValueFromBitArray(pos, 7);
        var digit1 = (numeric - 8) / 11;
        var digit2 = (numeric - 8) % 11;
        return new DecodedNumeric_default(pos + 7, digit1, digit2);
      };
      GeneralAppIdDecoder2.prototype.extractNumericValueFromBitArray = function(pos, bits) {
        return GeneralAppIdDecoder2.extractNumericValueFromBitArray(this.information, pos, bits);
      };
      GeneralAppIdDecoder2.extractNumericValueFromBitArray = function(information, pos, bits) {
        var value = 0;
        for (var i = 0; i < bits; ++i) {
          if (information.get(pos + i)) {
            value |= 1 << bits - i - 1;
          }
        }
        return value;
      };
      GeneralAppIdDecoder2.prototype.decodeGeneralPurposeField = function(pos, remaining) {
        this.buffer.setLengthToZero();
        if (remaining != null) {
          this.buffer.append(remaining);
        }
        this.current.setPosition(pos);
        var lastDecoded = this.parseBlocks();
        if (lastDecoded != null && lastDecoded.isRemaining()) {
          return new DecodedInformation_default(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
        }
        return new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
      };
      GeneralAppIdDecoder2.prototype.parseBlocks = function() {
        var isFinished;
        var result;
        do {
          var initialPosition = this.current.getPosition();
          if (this.current.isAlpha()) {
            result = this.parseAlphaBlock();
            isFinished = result.isFinished();
          } else if (this.current.isIsoIec646()) {
            result = this.parseIsoIec646Block();
            isFinished = result.isFinished();
          } else {
            result = this.parseNumericBlock();
            isFinished = result.isFinished();
          }
          var positionChanged = initialPosition !== this.current.getPosition();
          if (!positionChanged && !isFinished) {
            break;
          }
        } while (!isFinished);
        return result.getDecodedInformation();
      };
      GeneralAppIdDecoder2.prototype.parseNumericBlock = function() {
        while (this.isStillNumeric(this.current.getPosition())) {
          var numeric = this.decodeNumeric(this.current.getPosition());
          this.current.setPosition(numeric.getNewPosition());
          if (numeric.isFirstDigitFNC1()) {
            var information = void 0;
            if (numeric.isSecondDigitFNC1()) {
              information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
            } else {
              information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
            }
            return new BlockParsedResult_default(true, information);
          }
          this.buffer.append(numeric.getFirstDigit());
          if (numeric.isSecondDigitFNC1()) {
            var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult_default(true, information);
          }
          this.buffer.append(numeric.getSecondDigit());
        }
        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
          this.current.setAlpha();
          this.current.incrementPosition(4);
        }
        return new BlockParsedResult_default(false);
      };
      GeneralAppIdDecoder2.prototype.parseIsoIec646Block = function() {
        while (this.isStillIsoIec646(this.current.getPosition())) {
          var iso = this.decodeIsoIec646(this.current.getPosition());
          this.current.setPosition(iso.getNewPosition());
          if (iso.isFNC1()) {
            var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult_default(true, information);
          }
          this.buffer.append(iso.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setAlpha();
        }
        return new BlockParsedResult_default(false);
      };
      GeneralAppIdDecoder2.prototype.parseAlphaBlock = function() {
        while (this.isStillAlpha(this.current.getPosition())) {
          var alpha = this.decodeAlphanumeric(this.current.getPosition());
          this.current.setPosition(alpha.getNewPosition());
          if (alpha.isFNC1()) {
            var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult_default(true, information);
          }
          this.buffer.append(alpha.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setIsoIec646();
        }
        return new BlockParsedResult_default(false);
      };
      GeneralAppIdDecoder2.prototype.isStillIsoIec646 = function(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 7 > this.information.getSize()) {
          return false;
        }
        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 116) {
          return true;
        }
        if (pos + 8 > this.information.getSize()) {
          return false;
        }
        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        return eightBitValue >= 232 && eightBitValue < 253;
      };
      GeneralAppIdDecoder2.prototype.decodeIsoIec646 = function(pos) {
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar_default(pos + 5, DecodedChar_default.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar_default(pos + 5, "0" + (fiveBitValue - 5));
        }
        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 90) {
          return new DecodedChar_default(pos + 7, "" + (sevenBitValue + 1));
        }
        if (sevenBitValue >= 90 && sevenBitValue < 116) {
          return new DecodedChar_default(pos + 7, "" + (sevenBitValue + 7));
        }
        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        var c;
        switch (eightBitValue) {
          case 232:
            c = "!";
            break;
          case 233:
            c = '"';
            break;
          case 234:
            c = "%";
            break;
          case 235:
            c = "&";
            break;
          case 236:
            c = "'";
            break;
          case 237:
            c = "(";
            break;
          case 238:
            c = ")";
            break;
          case 239:
            c = "*";
            break;
          case 240:
            c = "+";
            break;
          case 241:
            c = ",";
            break;
          case 242:
            c = "-";
            break;
          case 243:
            c = ".";
            break;
          case 244:
            c = "/";
            break;
          case 245:
            c = ":";
            break;
          case 246:
            c = ";";
            break;
          case 247:
            c = "<";
            break;
          case 248:
            c = "=";
            break;
          case 249:
            c = ">";
            break;
          case 250:
            c = "?";
            break;
          case 251:
            c = "_";
            break;
          case 252:
            c = " ";
            break;
          default:
            throw new FormatException_default();
        }
        return new DecodedChar_default(pos + 8, c);
      };
      GeneralAppIdDecoder2.prototype.isStillAlpha = function(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 6 > this.information.getSize()) {
          return false;
        }
        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        return sixBitValue >= 16 && sixBitValue < 63;
      };
      GeneralAppIdDecoder2.prototype.decodeAlphanumeric = function(pos) {
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar_default(pos + 5, DecodedChar_default.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar_default(pos + 5, "0" + (fiveBitValue - 5));
        }
        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        if (sixBitValue >= 32 && sixBitValue < 58) {
          return new DecodedChar_default(pos + 6, "" + (sixBitValue + 33));
        }
        var c;
        switch (sixBitValue) {
          case 58:
            c = "*";
            break;
          case 59:
            c = ",";
            break;
          case 60:
            c = "-";
            break;
          case 61:
            c = ".";
            break;
          case 62:
            c = "/";
            break;
          default:
            throw new IllegalStateException_default("Decoding invalid alphanumeric value: " + sixBitValue);
        }
        return new DecodedChar_default(pos + 6, c);
      };
      GeneralAppIdDecoder2.prototype.isAlphaTo646ToAlphaLatch = function(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (var i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
          if (i === 2) {
            if (!this.information.get(pos + 2)) {
              return false;
            }
          } else if (this.information.get(pos + i)) {
            return false;
          }
        }
        return true;
      };
      GeneralAppIdDecoder2.prototype.isAlphaOr646ToNumericLatch = function(pos) {
        if (pos + 3 > this.information.getSize()) {
          return false;
        }
        for (var i = pos; i < pos + 3; ++i) {
          if (this.information.get(i)) {
            return false;
          }
        }
        return true;
      };
      GeneralAppIdDecoder2.prototype.isNumericToAlphaNumericLatch = function(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (var i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
          if (this.information.get(pos + i)) {
            return false;
          }
        }
        return true;
      };
      return GeneralAppIdDecoder2;
    }()
  );
  var GeneralAppIdDecoder_default = GeneralAppIdDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js
  var AbstractExpandedDecoder = (
    /** @class */
    function() {
      function AbstractExpandedDecoder2(information) {
        this.information = information;
        this.generalDecoder = new GeneralAppIdDecoder_default(information);
      }
      AbstractExpandedDecoder2.prototype.getInformation = function() {
        return this.information;
      };
      AbstractExpandedDecoder2.prototype.getGeneralDecoder = function() {
        return this.generalDecoder;
      };
      return AbstractExpandedDecoder2;
    }()
  );
  var AbstractExpandedDecoder_default = AbstractExpandedDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01decoder.js
  var __extends38 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01decoder = (
    /** @class */
    function(_super) {
      __extends38(AI01decoder2, _super);
      function AI01decoder2(information) {
        return _super.call(this, information) || this;
      }
      AI01decoder2.prototype.encodeCompressedGtin = function(buf, currentPos) {
        buf.append("(01)");
        var initialPosition = buf.length();
        buf.append("9");
        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
      };
      AI01decoder2.prototype.encodeCompressedGtinWithoutAI = function(buf, currentPos, initialBufferPosition) {
        for (var i = 0; i < 4; ++i) {
          var currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
          if (currentBlock / 100 === 0) {
            buf.append("0");
          }
          if (currentBlock / 10 === 0) {
            buf.append("0");
          }
          buf.append(currentBlock);
        }
        AI01decoder2.appendCheckDigit(buf, initialBufferPosition);
      };
      AI01decoder2.appendCheckDigit = function(buf, currentPos) {
        var checkDigit = 0;
        for (var i = 0; i < 13; i++) {
          var digit = buf.charAt(i + currentPos).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buf.append(checkDigit);
      };
      AI01decoder2.GTIN_SIZE = 40;
      return AI01decoder2;
    }(AbstractExpandedDecoder_default)
  );
  var AI01decoder_default = AI01decoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js
  var __extends39 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01AndOtherAIs = (
    /** @class */
    function(_super) {
      __extends39(AI01AndOtherAIs2, _super);
      function AI01AndOtherAIs2(information) {
        return _super.call(this, information) || this;
      }
      AI01AndOtherAIs2.prototype.parseInformation = function() {
        var buff = new StringBuilder_default();
        buff.append("(01)");
        var initialGtinPosition = buff.length();
        var firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs2.HEADER_SIZE, 4);
        buff.append(firstGtinDigit);
        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs2.HEADER_SIZE + 4, initialGtinPosition);
        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs2.HEADER_SIZE + 44);
      };
      AI01AndOtherAIs2.HEADER_SIZE = 1 + 1 + 2;
      return AI01AndOtherAIs2;
    }(AI01decoder_default)
  );
  var AI01AndOtherAIs_default = AI01AndOtherAIs;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AnyAIDecoder.js
  var __extends40 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AnyAIDecoder = (
    /** @class */
    function(_super) {
      __extends40(AnyAIDecoder2, _super);
      function AnyAIDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AnyAIDecoder2.prototype.parseInformation = function() {
        var buf = new StringBuilder_default();
        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder2.HEADER_SIZE);
      };
      AnyAIDecoder2.HEADER_SIZE = 2 + 1 + 2;
      return AnyAIDecoder2;
    }(AbstractExpandedDecoder_default)
  );
  var AnyAIDecoder_default = AnyAIDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01weightDecoder.js
  var __extends41 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01weightDecoder = (
    /** @class */
    function(_super) {
      __extends41(AI01weightDecoder2, _super);
      function AI01weightDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AI01weightDecoder2.prototype.encodeCompressedWeight = function(buf, currentPos, weightSize) {
        var originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
        this.addWeightCode(buf, originalWeightNumeric);
        var weightNumeric = this.checkWeight(originalWeightNumeric);
        var currentDivisor = 1e5;
        for (var i = 0; i < 5; ++i) {
          if (weightNumeric / currentDivisor === 0) {
            buf.append("0");
          }
          currentDivisor /= 10;
        }
        buf.append(weightNumeric);
      };
      return AI01weightDecoder2;
    }(AI01decoder_default)
  );
  var AI01weightDecoder_default = AI01weightDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013x0xDecoder.js
  var __extends42 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI013x0xDecoder = (
    /** @class */
    function(_super) {
      __extends42(AI013x0xDecoder2, _super);
      function AI013x0xDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AI013x0xDecoder2.prototype.parseInformation = function() {
        if (this.getInformation().getSize() !== AI013x0xDecoder2.HEADER_SIZE + AI01weightDecoder_default.GTIN_SIZE + AI013x0xDecoder2.WEIGHT_SIZE) {
          throw new NotFoundException_default();
        }
        var buf = new StringBuilder_default();
        this.encodeCompressedGtin(buf, AI013x0xDecoder2.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0xDecoder2.HEADER_SIZE + AI01weightDecoder_default.GTIN_SIZE, AI013x0xDecoder2.WEIGHT_SIZE);
        return buf.toString();
      };
      AI013x0xDecoder2.HEADER_SIZE = 4 + 1;
      AI013x0xDecoder2.WEIGHT_SIZE = 15;
      return AI013x0xDecoder2;
    }(AI01weightDecoder_default)
  );
  var AI013x0xDecoder_default = AI013x0xDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013103decoder.js
  var __extends43 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI013103decoder = (
    /** @class */
    function(_super) {
      __extends43(AI013103decoder2, _super);
      function AI013103decoder2(information) {
        return _super.call(this, information) || this;
      }
      AI013103decoder2.prototype.addWeightCode = function(buf, weight) {
        buf.append("(3103)");
      };
      AI013103decoder2.prototype.checkWeight = function(weight) {
        return weight;
      };
      return AI013103decoder2;
    }(AI013x0xDecoder_default)
  );
  var AI013103decoder_default = AI013103decoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01320xDecoder.js
  var __extends44 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01320xDecoder = (
    /** @class */
    function(_super) {
      __extends44(AI01320xDecoder2, _super);
      function AI01320xDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AI01320xDecoder2.prototype.addWeightCode = function(buf, weight) {
        if (weight < 1e4) {
          buf.append("(3202)");
        } else {
          buf.append("(3203)");
        }
      };
      AI01320xDecoder2.prototype.checkWeight = function(weight) {
        if (weight < 1e4) {
          return weight;
        }
        return weight - 1e4;
      };
      return AI01320xDecoder2;
    }(AI013x0xDecoder_default)
  );
  var AI01320xDecoder_default = AI01320xDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01392xDecoder.js
  var __extends45 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01392xDecoder = (
    /** @class */
    function(_super) {
      __extends45(AI01392xDecoder2, _super);
      function AI01392xDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AI01392xDecoder2.prototype.parseInformation = function() {
        if (this.getInformation().getSize() < AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE) {
          throw new NotFoundException_default();
        }
        var buf = new StringBuilder_default();
        this.encodeCompressedGtin(buf, AI01392xDecoder2.HEADER_SIZE);
        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE, AI01392xDecoder2.LAST_DIGIT_SIZE);
        buf.append("(392");
        buf.append(lastAIdigit);
        buf.append(")");
        var decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01392xDecoder2.LAST_DIGIT_SIZE, null);
        buf.append(decodedInformation.getNewString());
        return buf.toString();
      };
      AI01392xDecoder2.HEADER_SIZE = 5 + 1 + 2;
      AI01392xDecoder2.LAST_DIGIT_SIZE = 2;
      return AI01392xDecoder2;
    }(AI01decoder_default)
  );
  var AI01392xDecoder_default = AI01392xDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01393xDecoder.js
  var __extends46 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI01393xDecoder = (
    /** @class */
    function(_super) {
      __extends46(AI01393xDecoder2, _super);
      function AI01393xDecoder2(information) {
        return _super.call(this, information) || this;
      }
      AI01393xDecoder2.prototype.parseInformation = function() {
        if (this.getInformation().getSize() < AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE) {
          throw new NotFoundException_default();
        }
        var buf = new StringBuilder_default();
        this.encodeCompressedGtin(buf, AI01393xDecoder2.HEADER_SIZE);
        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE, AI01393xDecoder2.LAST_DIGIT_SIZE);
        buf.append("(393");
        buf.append(lastAIdigit);
        buf.append(")");
        var firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01393xDecoder2.LAST_DIGIT_SIZE, AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE);
        if (firstThreeDigits / 100 === 0) {
          buf.append("0");
        }
        if (firstThreeDigits / 10 === 0) {
          buf.append("0");
        }
        buf.append(firstThreeDigits);
        var generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01393xDecoder2.LAST_DIGIT_SIZE + AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE, null);
        buf.append(generalInformation.getNewString());
        return buf.toString();
      };
      AI01393xDecoder2.HEADER_SIZE = 5 + 1 + 2;
      AI01393xDecoder2.LAST_DIGIT_SIZE = 2;
      AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE = 10;
      return AI01393xDecoder2;
    }(AI01decoder_default)
  );
  var AI01393xDecoder_default = AI01393xDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js
  var __extends47 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AI013x0x1xDecoder = (
    /** @class */
    function(_super) {
      __extends47(AI013x0x1xDecoder2, _super);
      function AI013x0x1xDecoder2(information, firstAIdigits, dateCode) {
        var _this = _super.call(this, information) || this;
        _this.dateCode = dateCode;
        _this.firstAIdigits = firstAIdigits;
        return _this;
      }
      AI013x0x1xDecoder2.prototype.parseInformation = function() {
        if (this.getInformation().getSize() !== AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE + AI013x0x1xDecoder2.WEIGHT_SIZE + AI013x0x1xDecoder2.DATE_SIZE) {
          throw new NotFoundException_default();
        }
        var buf = new StringBuilder_default();
        this.encodeCompressedGtin(buf, AI013x0x1xDecoder2.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE, AI013x0x1xDecoder2.WEIGHT_SIZE);
        this.encodeCompressedDate(buf, AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE + AI013x0x1xDecoder2.WEIGHT_SIZE);
        return buf.toString();
      };
      AI013x0x1xDecoder2.prototype.encodeCompressedDate = function(buf, currentPos) {
        var numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder2.DATE_SIZE);
        if (numericDate === 38400) {
          return;
        }
        buf.append("(");
        buf.append(this.dateCode);
        buf.append(")");
        var day = numericDate % 32;
        numericDate /= 32;
        var month = numericDate % 12 + 1;
        numericDate /= 12;
        var year = numericDate;
        if (year / 10 === 0) {
          buf.append("0");
        }
        buf.append(year);
        if (month / 10 === 0) {
          buf.append("0");
        }
        buf.append(month);
        if (day / 10 === 0) {
          buf.append("0");
        }
        buf.append(day);
      };
      AI013x0x1xDecoder2.prototype.addWeightCode = function(buf, weight) {
        buf.append("(");
        buf.append(this.firstAIdigits);
        buf.append(weight / 1e5);
        buf.append(")");
      };
      AI013x0x1xDecoder2.prototype.checkWeight = function(weight) {
        return weight % 1e5;
      };
      AI013x0x1xDecoder2.HEADER_SIZE = 7 + 1;
      AI013x0x1xDecoder2.WEIGHT_SIZE = 20;
      AI013x0x1xDecoder2.DATE_SIZE = 16;
      return AI013x0x1xDecoder2;
    }(AI01weightDecoder_default)
  );
  var AI013x0x1xDecoder_default = AI013x0x1xDecoder;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js
  function createDecoder(information) {
    try {
      if (information.get(1)) {
        return new AI01AndOtherAIs_default(information);
      }
      if (!information.get(2)) {
        return new AnyAIDecoder_default(information);
      }
      var fourBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 4);
      switch (fourBitEncodationMethod) {
        case 4:
          return new AI013103decoder_default(information);
        case 5:
          return new AI01320xDecoder_default(information);
      }
      var fiveBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 5);
      switch (fiveBitEncodationMethod) {
        case 12:
          return new AI01392xDecoder_default(information);
        case 13:
          return new AI01393xDecoder_default(information);
      }
      var sevenBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 7);
      switch (sevenBitEncodationMethod) {
        case 56:
          return new AI013x0x1xDecoder_default(information, "310", "11");
        case 57:
          return new AI013x0x1xDecoder_default(information, "320", "11");
        case 58:
          return new AI013x0x1xDecoder_default(information, "310", "13");
        case 59:
          return new AI013x0x1xDecoder_default(information, "320", "13");
        case 60:
          return new AI013x0x1xDecoder_default(information, "310", "15");
        case 61:
          return new AI013x0x1xDecoder_default(information, "320", "15");
        case 62:
          return new AI013x0x1xDecoder_default(information, "310", "17");
        case 63:
          return new AI013x0x1xDecoder_default(information, "320", "17");
      }
    } catch (e) {
      console.log(e);
      throw new IllegalStateException_default("unknown decoder: " + information);
    }
  }

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/ExpandedPair.js
  var ExpandedPair = (
    /** @class */
    function() {
      function ExpandedPair2(leftChar, rightChar, finderPatter, mayBeLast) {
        this.leftchar = leftChar;
        this.rightchar = rightChar;
        this.finderpattern = finderPatter;
        this.maybeLast = mayBeLast;
      }
      ExpandedPair2.prototype.mayBeLast = function() {
        return this.maybeLast;
      };
      ExpandedPair2.prototype.getLeftChar = function() {
        return this.leftchar;
      };
      ExpandedPair2.prototype.getRightChar = function() {
        return this.rightchar;
      };
      ExpandedPair2.prototype.getFinderPattern = function() {
        return this.finderpattern;
      };
      ExpandedPair2.prototype.mustBeLast = function() {
        return this.rightchar == null;
      };
      ExpandedPair2.prototype.toString = function() {
        return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
      };
      ExpandedPair2.equals = function(o1, o2) {
        if (!(o1 instanceof ExpandedPair2)) {
          return false;
        }
        return ExpandedPair2.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair2.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair2.equalsOrNull(o1.finderpattern, o2.finderpattern);
      };
      ExpandedPair2.equalsOrNull = function(o1, o2) {
        return o1 === null ? o2 === null : ExpandedPair2.equals(o1, o2);
      };
      ExpandedPair2.prototype.hashCode = function() {
        var value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
        return value;
      };
      return ExpandedPair2;
    }()
  );
  var ExpandedPair_default = ExpandedPair;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/ExpandedRow.js
  var ExpandedRow = (
    /** @class */
    function() {
      function ExpandedRow2(pairs, rowNumber, wasReversed) {
        this.pairs = pairs;
        this.rowNumber = rowNumber;
        this.wasReversed = wasReversed;
      }
      ExpandedRow2.prototype.getPairs = function() {
        return this.pairs;
      };
      ExpandedRow2.prototype.getRowNumber = function() {
        return this.rowNumber;
      };
      ExpandedRow2.prototype.isReversed = function() {
        return this.wasReversed;
      };
      ExpandedRow2.prototype.isEquivalent = function(otherPairs) {
        return this.checkEqualitity(this, otherPairs);
      };
      ExpandedRow2.prototype.toString = function() {
        return "{ " + this.pairs + " }";
      };
      ExpandedRow2.prototype.equals = function(o1, o2) {
        if (!(o1 instanceof ExpandedRow2)) {
          return false;
        }
        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
      };
      ExpandedRow2.prototype.checkEqualitity = function(pair1, pair2) {
        if (!pair1 || !pair2)
          return;
        var result;
        pair1.forEach(function(e1, i) {
          pair2.forEach(function(e2) {
            if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
              result = true;
            }
          });
        });
        return result;
      };
      return ExpandedRow2;
    }()
  );
  var ExpandedRow_default = ExpandedRow;

  // node_modules/@zxing/library/esm/core/oned/rss/expanded/RSSExpandedReader.js
  var __extends48 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values16 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var RSSExpandedReader = (
    /** @class */
    function(_super) {
      __extends48(RSSExpandedReader2, _super);
      function RSSExpandedReader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.pairs = new Array(RSSExpandedReader2.MAX_PAIRS);
        _this.rows = new Array();
        _this.startEnd = [2];
        return _this;
      }
      RSSExpandedReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        this.pairs.length = 0;
        this.startFromEven = false;
        try {
          return RSSExpandedReader2.constructResult(this.decodeRow2pairs(rowNumber, row));
        } catch (e) {
        }
        this.pairs.length = 0;
        this.startFromEven = true;
        return RSSExpandedReader2.constructResult(this.decodeRow2pairs(rowNumber, row));
      };
      RSSExpandedReader2.prototype.reset = function() {
        this.pairs.length = 0;
        this.rows.length = 0;
      };
      RSSExpandedReader2.prototype.decodeRow2pairs = function(rowNumber, row) {
        var done = false;
        while (!done) {
          try {
            this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
          } catch (error2) {
            if (error2 instanceof NotFoundException_default) {
              if (!this.pairs.length) {
                throw new NotFoundException_default();
              }
              done = true;
            }
          }
        }
        if (this.checkChecksum()) {
          return this.pairs;
        }
        var tryStackedDecode;
        if (this.rows.length) {
          tryStackedDecode = true;
        } else {
          tryStackedDecode = false;
        }
        this.storeRow(rowNumber, false);
        if (tryStackedDecode) {
          var ps = this.checkRowsBoolean(false);
          if (ps != null) {
            return ps;
          }
          ps = this.checkRowsBoolean(true);
          if (ps != null) {
            return ps;
          }
        }
        throw new NotFoundException_default();
      };
      RSSExpandedReader2.prototype.checkRowsBoolean = function(reverse) {
        if (this.rows.length > 25) {
          this.rows.length = 0;
          return null;
        }
        this.pairs.length = 0;
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        var ps = null;
        try {
          ps = this.checkRows(new Array(), 0);
        } catch (e) {
          console.log(e);
        }
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        return ps;
      };
      RSSExpandedReader2.prototype.checkRows = function(collectedRows, currentRow) {
        var e_1, _a2;
        for (var i = currentRow; i < this.rows.length; i++) {
          var row = this.rows[i];
          this.pairs.length = 0;
          try {
            for (var collectedRows_1 = (e_1 = void 0, __values16(collectedRows)), collectedRows_1_1 = collectedRows_1.next(); !collectedRows_1_1.done; collectedRows_1_1 = collectedRows_1.next()) {
              var collectedRow = collectedRows_1_1.value;
              this.pairs.push(collectedRow.getPairs());
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (collectedRows_1_1 && !collectedRows_1_1.done && (_a2 = collectedRows_1.return)) _a2.call(collectedRows_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          this.pairs.push(row.getPairs());
          if (!RSSExpandedReader2.isValidSequence(this.pairs)) {
            continue;
          }
          if (this.checkChecksum()) {
            return this.pairs;
          }
          var rs = new Array(collectedRows);
          rs.push(row);
          try {
            return this.checkRows(rs, i + 1);
          } catch (e) {
            console.log(e);
          }
        }
        throw new NotFoundException_default();
      };
      RSSExpandedReader2.isValidSequence = function(pairs) {
        var e_2, _a2;
        try {
          for (var _b = __values16(RSSExpandedReader2.FINDER_PATTERN_SEQUENCES), _c = _b.next(); !_c.done; _c = _b.next()) {
            var sequence = _c.value;
            if (pairs.length > sequence.length) {
              continue;
            }
            var stop_1 = true;
            for (var j = 0; j < pairs.length; j++) {
              if (pairs[j].getFinderPattern().getValue() !== sequence[j]) {
                stop_1 = false;
                break;
              }
            }
            if (stop_1) {
              return true;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return false;
      };
      RSSExpandedReader2.prototype.storeRow = function(rowNumber, wasReversed) {
        var insertPos = 0;
        var prevIsSame = false;
        var nextIsSame = false;
        while (insertPos < this.rows.length) {
          var erow = this.rows[insertPos];
          if (erow.getRowNumber() > rowNumber) {
            nextIsSame = erow.isEquivalent(this.pairs);
            break;
          }
          prevIsSame = erow.isEquivalent(this.pairs);
          insertPos++;
        }
        if (nextIsSame || prevIsSame) {
          return;
        }
        if (RSSExpandedReader2.isPartialRow(this.pairs, this.rows)) {
          return;
        }
        this.rows.push(insertPos, new ExpandedRow_default(this.pairs, rowNumber, wasReversed));
        this.removePartialRows(this.pairs, this.rows);
      };
      RSSExpandedReader2.prototype.removePartialRows = function(pairs, rows) {
        var e_3, _a2, e_4, _b, e_5, _c;
        try {
          for (var rows_1 = __values16(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
            var row = rows_1_1.value;
            if (row.getPairs().length === pairs.length) {
              continue;
            }
            var allFound = true;
            try {
              for (var _d = (e_4 = void 0, __values16(row.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {
                var p = _e.value;
                var found2 = false;
                try {
                  for (var pairs_1 = (e_5 = void 0, __values16(pairs)), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                    var pp = pairs_1_1.value;
                    if (ExpandedPair_default.equals(p, pp)) {
                      found2 = true;
                      break;
                    }
                  }
                } catch (e_5_1) {
                  e_5 = { error: e_5_1 };
                } finally {
                  try {
                    if (pairs_1_1 && !pairs_1_1.done && (_c = pairs_1.return)) _c.call(pairs_1);
                  } finally {
                    if (e_5) throw e_5.error;
                  }
                }
                if (!found2) {
                  allFound = false;
                }
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (rows_1_1 && !rows_1_1.done && (_a2 = rows_1.return)) _a2.call(rows_1);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
      RSSExpandedReader2.isPartialRow = function(pairs, rows) {
        var e_6, _a2, e_7, _b, e_8, _c;
        try {
          for (var rows_2 = __values16(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {
            var r = rows_2_1.value;
            var allFound = true;
            try {
              for (var pairs_2 = (e_7 = void 0, __values16(pairs)), pairs_2_1 = pairs_2.next(); !pairs_2_1.done; pairs_2_1 = pairs_2.next()) {
                var p = pairs_2_1.value;
                var found2 = false;
                try {
                  for (var _d = (e_8 = void 0, __values16(r.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var pp = _e.value;
                    if (p.equals(pp)) {
                      found2 = true;
                      break;
                    }
                  }
                } catch (e_8_1) {
                  e_8 = { error: e_8_1 };
                } finally {
                  try {
                    if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                  } finally {
                    if (e_8) throw e_8.error;
                  }
                }
                if (!found2) {
                  allFound = false;
                  break;
                }
              }
            } catch (e_7_1) {
              e_7 = { error: e_7_1 };
            } finally {
              try {
                if (pairs_2_1 && !pairs_2_1.done && (_b = pairs_2.return)) _b.call(pairs_2);
              } finally {
                if (e_7) throw e_7.error;
              }
            }
            if (allFound) {
              return true;
            }
          }
        } catch (e_6_1) {
          e_6 = { error: e_6_1 };
        } finally {
          try {
            if (rows_2_1 && !rows_2_1.done && (_a2 = rows_2.return)) _a2.call(rows_2);
          } finally {
            if (e_6) throw e_6.error;
          }
        }
        return false;
      };
      RSSExpandedReader2.prototype.getRows = function() {
        return this.rows;
      };
      RSSExpandedReader2.constructResult = function(pairs) {
        var binary = BitArrayBuilder_default.buildBitArray(pairs);
        var decoder = createDecoder(binary);
        var resultingString = decoder.parseInformation();
        var firstPoints = pairs[0].getFinderPattern().getResultPoints();
        var lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
        var points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
        return new Result_default(resultingString, null, null, points, BarcodeFormat_default.RSS_EXPANDED, null);
      };
      RSSExpandedReader2.prototype.checkChecksum = function() {
        var firstPair = this.pairs.get(0);
        var checkCharacter = firstPair.getLeftChar();
        var firstCharacter = firstPair.getRightChar();
        if (firstCharacter === null) {
          return false;
        }
        var checksum = firstCharacter.getChecksumPortion();
        var s = 2;
        for (var i = 1; i < this.pairs.size(); ++i) {
          var currentPair = this.pairs.get(i);
          checksum += currentPair.getLeftChar().getChecksumPortion();
          s++;
          var currentRightChar = currentPair.getRightChar();
          if (currentRightChar != null) {
            checksum += currentRightChar.getChecksumPortion();
            s++;
          }
        }
        checksum %= 211;
        var checkCharacterValue = 211 * (s - 4) + checksum;
        return checkCharacterValue === checkCharacter.getValue();
      };
      RSSExpandedReader2.getNextSecondBar = function(row, initialPos) {
        var currentPos;
        if (row.get(initialPos)) {
          currentPos = row.getNextUnset(initialPos);
          currentPos = row.getNextSet(currentPos);
        } else {
          currentPos = row.getNextSet(initialPos);
          currentPos = row.getNextUnset(currentPos);
        }
        return currentPos;
      };
      RSSExpandedReader2.prototype.retrieveNextPair = function(row, previousPairs, rowNumber) {
        var isOddPattern = previousPairs.length % 2 === 0;
        if (this.startFromEven) {
          isOddPattern = !isOddPattern;
        }
        var pattern;
        var keepFinding = true;
        var forcedOffset = -1;
        do {
          this.findNextPair(row, previousPairs, forcedOffset);
          pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
          if (pattern === null) {
            forcedOffset = RSSExpandedReader2.getNextSecondBar(row, this.startEnd[0]);
          } else {
            keepFinding = false;
          }
        } while (keepFinding);
        var leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
        if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
          throw new NotFoundException_default();
        }
        var rightChar;
        try {
          rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
        } catch (e) {
          rightChar = null;
          console.log(e);
        }
        return new ExpandedPair_default(leftChar, rightChar, pattern, true);
      };
      RSSExpandedReader2.prototype.isEmptyPair = function(pairs) {
        if (pairs.length === 0) {
          return true;
        }
        return false;
      };
      RSSExpandedReader2.prototype.findNextPair = function(row, previousPairs, forcedOffset) {
        var counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var width = row.getSize();
        var rowOffset;
        if (forcedOffset >= 0) {
          rowOffset = forcedOffset;
        } else if (this.isEmptyPair(previousPairs)) {
          rowOffset = 0;
        } else {
          var lastPair = previousPairs[previousPairs.length - 1];
          rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
        }
        var searchingEvenPair = previousPairs.length % 2 !== 0;
        if (this.startFromEven) {
          searchingEvenPair = !searchingEvenPair;
        }
        var isWhite = false;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (!isWhite) {
            break;
          }
          rowOffset++;
        }
        var counterPosition = 0;
        var patternStart = rowOffset;
        for (var x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === 3) {
              if (searchingEvenPair) {
                RSSExpandedReader2.reverseCounters(counters);
              }
              if (RSSExpandedReader2.isFinderPattern(counters)) {
                this.startEnd[0] = patternStart;
                this.startEnd[1] = x;
                return;
              }
              if (searchingEvenPair) {
                RSSExpandedReader2.reverseCounters(counters);
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      RSSExpandedReader2.reverseCounters = function(counters) {
        var length = counters.length;
        for (var i = 0; i < length / 2; ++i) {
          var tmp = counters[i];
          counters[i] = counters[length - i - 1];
          counters[length - i - 1] = tmp;
        }
      };
      RSSExpandedReader2.prototype.parseFoundFinderPattern = function(row, rowNumber, oddPattern) {
        var firstCounter;
        var start3;
        var end2;
        if (oddPattern) {
          var firstElementStart = this.startEnd[0] - 1;
          while (firstElementStart >= 0 && !row.get(firstElementStart)) {
            firstElementStart--;
          }
          firstElementStart++;
          firstCounter = this.startEnd[0] - firstElementStart;
          start3 = firstElementStart;
          end2 = this.startEnd[1];
        } else {
          start3 = this.startEnd[0];
          end2 = row.getNextUnset(this.startEnd[1] + 1);
          firstCounter = end2 - this.startEnd[1];
        }
        var counters = this.getDecodeFinderCounters();
        System_default.arraycopy(counters, 0, counters, 1, counters.length - 1);
        counters[0] = firstCounter;
        var value;
        try {
          value = this.parseFinderValue(counters, RSSExpandedReader2.FINDER_PATTERNS);
        } catch (e) {
          return null;
        }
        return new FinderPattern_default(value, [start3, end2], start3, end2, rowNumber);
      };
      RSSExpandedReader2.prototype.decodeDataCharacter = function(row, pattern, isOddPattern, leftChar) {
        var counters = this.getDataCharacterCounters();
        for (var x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (leftChar) {
          RSSExpandedReader2.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          RSSExpandedReader2.recordPattern(row, pattern.getStartEnd()[1], counters);
          for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
            var temp = counters[i];
            counters[i] = counters[j];
            counters[j] = temp;
          }
        }
        var numModules = 17;
        var elementWidth = MathUtils_default.sum(new Int32Array(counters)) / numModules;
        var expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
          throw new NotFoundException_default();
        }
        var oddCounts = this.getOddCounts();
        var evenCounts = this.getEvenCounts();
        var oddRoundingErrors = this.getOddRoundingErrors();
        var evenRoundingErrors = this.getEvenRoundingErrors();
        for (var i = 0; i < counters.length; i++) {
          var value_1 = 1 * counters[i] / elementWidth;
          var count = value_1 + 0.5;
          if (count < 1) {
            if (value_1 < 0.3) {
              throw new NotFoundException_default();
            }
            count = 1;
          } else if (count > 8) {
            if (value_1 > 8.7) {
              throw new NotFoundException_default();
            }
            count = 8;
          }
          var offset2 = i / 2;
          if ((i & 1) === 0) {
            oddCounts[offset2] = count;
            oddRoundingErrors[offset2] = value_1 - count;
          } else {
            evenCounts[offset2] = count;
            evenRoundingErrors[offset2] = value_1 - count;
          }
        }
        this.adjustOddEvenCounts(numModules);
        var weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
        var oddSum = 0;
        var oddChecksumPortion = 0;
        for (var i = oddCounts.length - 1; i >= 0; i--) {
          if (RSSExpandedReader2.isNotA1left(pattern, isOddPattern, leftChar)) {
            var weight = RSSExpandedReader2.WEIGHTS[weightRowNumber][2 * i];
            oddChecksumPortion += oddCounts[i] * weight;
          }
          oddSum += oddCounts[i];
        }
        var evenChecksumPortion = 0;
        for (var i = evenCounts.length - 1; i >= 0; i--) {
          if (RSSExpandedReader2.isNotA1left(pattern, isOddPattern, leftChar)) {
            var weight = RSSExpandedReader2.WEIGHTS[weightRowNumber][2 * i + 1];
            evenChecksumPortion += evenCounts[i] * weight;
          }
        }
        var checksumPortion = oddChecksumPortion + evenChecksumPortion;
        if ((oddSum & 1) !== 0 || oddSum > 13 || oddSum < 4) {
          throw new NotFoundException_default();
        }
        var group = (13 - oddSum) / 2;
        var oddWidest = RSSExpandedReader2.SYMBOL_WIDEST[group];
        var evenWidest = 9 - oddWidest;
        var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, true);
        var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, false);
        var tEven = RSSExpandedReader2.EVEN_TOTAL_SUBSET[group];
        var gSum = RSSExpandedReader2.GSUM[group];
        var value = vOdd * tEven + vEven + gSum;
        return new DataCharacter_default(value, checksumPortion);
      };
      RSSExpandedReader2.isNotA1left = function(pattern, isOddPattern, leftChar) {
        return !(pattern.getValue() === 0 && isOddPattern && leftChar);
      };
      RSSExpandedReader2.prototype.adjustOddEvenCounts = function(numModules) {
        var oddSum = MathUtils_default.sum(new Int32Array(this.getOddCounts()));
        var evenSum = MathUtils_default.sum(new Int32Array(this.getEvenCounts()));
        var incrementOdd = false;
        var decrementOdd = false;
        if (oddSum > 13) {
          decrementOdd = true;
        } else if (oddSum < 4) {
          incrementOdd = true;
        }
        var incrementEven = false;
        var decrementEven = false;
        if (evenSum > 13) {
          decrementEven = true;
        } else if (evenSum < 4) {
          incrementEven = true;
        }
        var mismatch = oddSum + evenSum - numModules;
        var oddParityBad = (oddSum & 1) === 1;
        var evenParityBad = (evenSum & 1) === 0;
        if (mismatch === 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            decrementEven = true;
          }
        } else if (mismatch === -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            incrementEven = true;
          }
        } else if (mismatch === 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
          }
        } else {
          throw new NotFoundException_default();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException_default();
          }
          RSSExpandedReader2.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          RSSExpandedReader2.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException_default();
          }
          RSSExpandedReader2.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          RSSExpandedReader2.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      };
      RSSExpandedReader2.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
      RSSExpandedReader2.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
      RSSExpandedReader2.GSUM = [0, 348, 1388, 2948, 3988];
      RSSExpandedReader2.FINDER_PATTERNS = [
        Int32Array.from([1, 8, 4, 1]),
        Int32Array.from([3, 6, 4, 1]),
        Int32Array.from([3, 4, 6, 1]),
        Int32Array.from([3, 2, 8, 1]),
        Int32Array.from([2, 6, 5, 1]),
        Int32Array.from([2, 2, 9, 1])
      ];
      RSSExpandedReader2.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89]
      ];
      RSSExpandedReader2.FINDER_PAT_A = 0;
      RSSExpandedReader2.FINDER_PAT_B = 1;
      RSSExpandedReader2.FINDER_PAT_C = 2;
      RSSExpandedReader2.FINDER_PAT_D = 3;
      RSSExpandedReader2.FINDER_PAT_E = 4;
      RSSExpandedReader2.FINDER_PAT_F = 5;
      RSSExpandedReader2.FINDER_PATTERN_SEQUENCES = [
        [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_B
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_D
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_C
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_F
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_F,
          RSSExpandedReader2.FINDER_PAT_F
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_D
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_E
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_F,
          RSSExpandedReader2.FINDER_PAT_F
        ],
        [
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_A,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_B,
          RSSExpandedReader2.FINDER_PAT_C,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_D,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_E,
          RSSExpandedReader2.FINDER_PAT_F,
          RSSExpandedReader2.FINDER_PAT_F
        ]
      ];
      RSSExpandedReader2.MAX_PAIRS = 11;
      return RSSExpandedReader2;
    }(AbstractRSSReader_default)
  );
  var RSSExpandedReader_default = RSSExpandedReader;

  // node_modules/@zxing/library/esm/core/oned/rss/Pair.js
  var __extends49 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var Pair = (
    /** @class */
    function(_super) {
      __extends49(Pair2, _super);
      function Pair2(value, checksumPortion, finderPattern) {
        var _this = _super.call(this, value, checksumPortion) || this;
        _this.count = 0;
        _this.finderPattern = finderPattern;
        return _this;
      }
      Pair2.prototype.getFinderPattern = function() {
        return this.finderPattern;
      };
      Pair2.prototype.getCount = function() {
        return this.count;
      };
      Pair2.prototype.incrementCount = function() {
        this.count++;
      };
      return Pair2;
    }(DataCharacter_default)
  );
  var Pair_default = Pair;

  // node_modules/@zxing/library/esm/core/oned/rss/RSS14Reader.js
  var __extends50 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values17 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var RSS14Reader = (
    /** @class */
    function(_super) {
      __extends50(RSS14Reader2, _super);
      function RSS14Reader2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.possibleLeftPairs = [];
        _this.possibleRightPairs = [];
        return _this;
      }
      RSS14Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
        var e_1, _a2, e_2, _b;
        var leftPair = this.decodePair(row, false, rowNumber, hints);
        RSS14Reader2.addOrTally(this.possibleLeftPairs, leftPair);
        row.reverse();
        var rightPair = this.decodePair(row, true, rowNumber, hints);
        RSS14Reader2.addOrTally(this.possibleRightPairs, rightPair);
        row.reverse();
        try {
          for (var _c = __values17(this.possibleLeftPairs), _d = _c.next(); !_d.done; _d = _c.next()) {
            var left2 = _d.value;
            if (left2.getCount() > 1) {
              try {
                for (var _e = (e_2 = void 0, __values17(this.possibleRightPairs)), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var right2 = _f.value;
                  if (right2.getCount() > 1 && RSS14Reader2.checkChecksum(left2, right2)) {
                    return RSS14Reader2.constructResult(left2, right2);
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return)) _a2.call(_c);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        throw new NotFoundException_default();
      };
      RSS14Reader2.addOrTally = function(possiblePairs, pair) {
        var e_3, _a2;
        if (pair == null) {
          return;
        }
        var found2 = false;
        try {
          for (var possiblePairs_1 = __values17(possiblePairs), possiblePairs_1_1 = possiblePairs_1.next(); !possiblePairs_1_1.done; possiblePairs_1_1 = possiblePairs_1.next()) {
            var other = possiblePairs_1_1.value;
            if (other.getValue() === pair.getValue()) {
              other.incrementCount();
              found2 = true;
              break;
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (possiblePairs_1_1 && !possiblePairs_1_1.done && (_a2 = possiblePairs_1.return)) _a2.call(possiblePairs_1);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        if (!found2) {
          possiblePairs.push(pair);
        }
      };
      RSS14Reader2.prototype.reset = function() {
        this.possibleLeftPairs.length = 0;
        this.possibleRightPairs.length = 0;
      };
      RSS14Reader2.constructResult = function(leftPair, rightPair) {
        var symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
        var text = new String(symbolValue).toString();
        var buffer = new StringBuilder_default();
        for (var i = 13 - text.length; i > 0; i--) {
          buffer.append("0");
        }
        buffer.append(text);
        var checkDigit = 0;
        for (var i = 0; i < 13; i++) {
          var digit = buffer.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buffer.append(checkDigit.toString());
        var leftPoints = leftPair.getFinderPattern().getResultPoints();
        var rightPoints = rightPair.getFinderPattern().getResultPoints();
        return new Result_default(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat_default.RSS_14, (/* @__PURE__ */ new Date()).getTime());
      };
      RSS14Reader2.checkChecksum = function(leftPair, rightPair) {
        var checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
        var targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
        if (targetCheckValue > 72) {
          targetCheckValue--;
        }
        if (targetCheckValue > 8) {
          targetCheckValue--;
        }
        return checkValue === targetCheckValue;
      };
      RSS14Reader2.prototype.decodePair = function(row, right2, rowNumber, hints) {
        try {
          var startEnd = this.findFinderPattern(row, right2);
          var pattern = this.parseFoundFinderPattern(row, rowNumber, right2, startEnd);
          var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
          if (resultPointCallback != null) {
            var center = (startEnd[0] + startEnd[1]) / 2;
            if (right2) {
              center = row.getSize() - 1 - center;
            }
            resultPointCallback.foundPossibleResultPoint(new ResultPoint_default(center, rowNumber));
          }
          var outside = this.decodeDataCharacter(row, pattern, true);
          var inside = this.decodeDataCharacter(row, pattern, false);
          return new Pair_default(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
        } catch (err) {
          return null;
        }
      };
      RSS14Reader2.prototype.decodeDataCharacter = function(row, pattern, outsideChar) {
        var counters = this.getDataCharacterCounters();
        for (var x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (outsideChar) {
          OneDReader_default.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          OneDReader_default.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
          for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
            var temp = counters[i];
            counters[i] = counters[j];
            counters[j] = temp;
          }
        }
        var numModules = outsideChar ? 16 : 15;
        var elementWidth = MathUtils_default.sum(new Int32Array(counters)) / numModules;
        var oddCounts = this.getOddCounts();
        var evenCounts = this.getEvenCounts();
        var oddRoundingErrors = this.getOddRoundingErrors();
        var evenRoundingErrors = this.getEvenRoundingErrors();
        for (var i = 0; i < counters.length; i++) {
          var value = counters[i] / elementWidth;
          var count = Math.floor(value + 0.5);
          if (count < 1) {
            count = 1;
          } else if (count > 8) {
            count = 8;
          }
          var offset2 = Math.floor(i / 2);
          if ((i & 1) === 0) {
            oddCounts[offset2] = count;
            oddRoundingErrors[offset2] = value - count;
          } else {
            evenCounts[offset2] = count;
            evenRoundingErrors[offset2] = value - count;
          }
        }
        this.adjustOddEvenCounts(outsideChar, numModules);
        var oddSum = 0;
        var oddChecksumPortion = 0;
        for (var i = oddCounts.length - 1; i >= 0; i--) {
          oddChecksumPortion *= 9;
          oddChecksumPortion += oddCounts[i];
          oddSum += oddCounts[i];
        }
        var evenChecksumPortion = 0;
        var evenSum = 0;
        for (var i = evenCounts.length - 1; i >= 0; i--) {
          evenChecksumPortion *= 9;
          evenChecksumPortion += evenCounts[i];
          evenSum += evenCounts[i];
        }
        var checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
        if (outsideChar) {
          if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
            throw new NotFoundException_default();
          }
          var group = (12 - oddSum) / 2;
          var oddWidest = RSS14Reader2.OUTSIDE_ODD_WIDEST[group];
          var evenWidest = 9 - oddWidest;
          var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, false);
          var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, true);
          var tEven = RSS14Reader2.OUTSIDE_EVEN_TOTAL_SUBSET[group];
          var gSum = RSS14Reader2.OUTSIDE_GSUM[group];
          return new DataCharacter_default(vOdd * tEven + vEven + gSum, checksumPortion);
        } else {
          if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
            throw new NotFoundException_default();
          }
          var group = (10 - evenSum) / 2;
          var oddWidest = RSS14Reader2.INSIDE_ODD_WIDEST[group];
          var evenWidest = 9 - oddWidest;
          var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, true);
          var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, false);
          var tOdd = RSS14Reader2.INSIDE_ODD_TOTAL_SUBSET[group];
          var gSum = RSS14Reader2.INSIDE_GSUM[group];
          return new DataCharacter_default(vEven * tOdd + vOdd + gSum, checksumPortion);
        }
      };
      RSS14Reader2.prototype.findFinderPattern = function(row, rightFinderPattern) {
        var counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var width = row.getSize();
        var isWhite = false;
        var rowOffset = 0;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (rightFinderPattern === isWhite) {
            break;
          }
          rowOffset++;
        }
        var counterPosition = 0;
        var patternStart = rowOffset;
        for (var x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === 3) {
              if (AbstractRSSReader_default.isFinderPattern(counters)) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException_default();
      };
      RSS14Reader2.prototype.parseFoundFinderPattern = function(row, rowNumber, right2, startEnd) {
        var firstIsBlack = row.get(startEnd[0]);
        var firstElementStart = startEnd[0] - 1;
        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
          firstElementStart--;
        }
        firstElementStart++;
        var firstCounter = startEnd[0] - firstElementStart;
        var counters = this.getDecodeFinderCounters();
        var copy2 = new Int32Array(counters.length);
        System_default.arraycopy(counters, 0, copy2, 1, counters.length - 1);
        copy2[0] = firstCounter;
        var value = this.parseFinderValue(copy2, RSS14Reader2.FINDER_PATTERNS);
        var start3 = firstElementStart;
        var end2 = startEnd[1];
        if (right2) {
          start3 = row.getSize() - 1 - start3;
          end2 = row.getSize() - 1 - end2;
        }
        return new FinderPattern_default(value, [firstElementStart, startEnd[1]], start3, end2, rowNumber);
      };
      RSS14Reader2.prototype.adjustOddEvenCounts = function(outsideChar, numModules) {
        var oddSum = MathUtils_default.sum(new Int32Array(this.getOddCounts()));
        var evenSum = MathUtils_default.sum(new Int32Array(this.getEvenCounts()));
        var incrementOdd = false;
        var decrementOdd = false;
        var incrementEven = false;
        var decrementEven = false;
        if (outsideChar) {
          if (oddSum > 12) {
            decrementOdd = true;
          } else if (oddSum < 4) {
            incrementOdd = true;
          }
          if (evenSum > 12) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        } else {
          if (oddSum > 11) {
            decrementOdd = true;
          } else if (oddSum < 5) {
            incrementOdd = true;
          }
          if (evenSum > 10) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        }
        var mismatch = oddSum + evenSum - numModules;
        var oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
        var evenParityBad = (evenSum & 1) === 1;
        if (mismatch === 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            decrementEven = true;
          }
        } else if (mismatch === -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            incrementEven = true;
          }
        } else if (mismatch === 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException_default();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException_default();
            }
          }
        } else {
          throw new NotFoundException_default();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException_default();
          }
          AbstractRSSReader_default.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          AbstractRSSReader_default.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException_default();
          }
          AbstractRSSReader_default.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          AbstractRSSReader_default.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      };
      RSS14Reader2.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
      RSS14Reader2.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
      RSS14Reader2.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
      RSS14Reader2.INSIDE_GSUM = [0, 336, 1036, 1516];
      RSS14Reader2.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
      RSS14Reader2.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
      RSS14Reader2.FINDER_PATTERNS = [
        Int32Array.from([3, 8, 2, 1]),
        Int32Array.from([3, 5, 5, 1]),
        Int32Array.from([3, 3, 7, 1]),
        Int32Array.from([3, 1, 9, 1]),
        Int32Array.from([2, 7, 4, 1]),
        Int32Array.from([2, 5, 6, 1]),
        Int32Array.from([2, 3, 8, 1]),
        Int32Array.from([1, 5, 7, 1]),
        Int32Array.from([1, 3, 9, 1])
      ];
      return RSS14Reader2;
    }(AbstractRSSReader_default)
  );
  var RSS14Reader_default = RSS14Reader;

  // node_modules/@zxing/library/esm/core/oned/MultiFormatOneDReader.js
  var __extends51 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var MultiFormatOneDReader = (
    /** @class */
    function(_super) {
      __extends51(MultiFormatOneDReader2, _super);
      function MultiFormatOneDReader2(hints) {
        var _this = _super.call(this) || this;
        _this.readers = [];
        var possibleFormats = !hints ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
        var useCode39CheckDigit = hints && hints.get(DecodeHintType_default.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
        var useCode39ExtendedMode = hints && hints.get(DecodeHintType_default.ENABLE_CODE_39_EXTENDED_MODE) !== void 0;
        if (possibleFormats) {
          if (possibleFormats.includes(BarcodeFormat_default.EAN_13) || possibleFormats.includes(BarcodeFormat_default.UPC_A) || possibleFormats.includes(BarcodeFormat_default.EAN_8) || possibleFormats.includes(BarcodeFormat_default.UPC_E)) {
            _this.readers.push(new MultiFormatUPCEANReader_default(hints));
          }
          if (possibleFormats.includes(BarcodeFormat_default.CODE_39)) {
            _this.readers.push(new Code39Reader_default(useCode39CheckDigit, useCode39ExtendedMode));
          }
          if (possibleFormats.includes(BarcodeFormat_default.CODE_93)) {
            _this.readers.push(new Code93Reader_default());
          }
          if (possibleFormats.includes(BarcodeFormat_default.CODE_128)) {
            _this.readers.push(new Code128Reader_default());
          }
          if (possibleFormats.includes(BarcodeFormat_default.ITF)) {
            _this.readers.push(new ITFReader_default());
          }
          if (possibleFormats.includes(BarcodeFormat_default.CODABAR)) {
            _this.readers.push(new CodaBarReader_default());
          }
          if (possibleFormats.includes(BarcodeFormat_default.RSS_14)) {
            _this.readers.push(new RSS14Reader_default());
          }
          if (possibleFormats.includes(BarcodeFormat_default.RSS_EXPANDED)) {
            console.warn("RSS Expanded reader IS NOT ready for production yet! use at your own risk.");
            _this.readers.push(new RSSExpandedReader_default());
          }
        }
        if (_this.readers.length === 0) {
          _this.readers.push(new MultiFormatUPCEANReader_default(hints));
          _this.readers.push(new Code39Reader_default());
          _this.readers.push(new Code93Reader_default());
          _this.readers.push(new MultiFormatUPCEANReader_default(hints));
          _this.readers.push(new Code128Reader_default());
          _this.readers.push(new ITFReader_default());
          _this.readers.push(new RSS14Reader_default());
        }
        return _this;
      }
      MultiFormatOneDReader2.prototype.decodeRow = function(rowNumber, row, hints) {
        for (var i = 0; i < this.readers.length; i++) {
          try {
            return this.readers[i].decodeRow(rowNumber, row, hints);
          } catch (re) {
          }
        }
        throw new NotFoundException_default();
      };
      MultiFormatOneDReader2.prototype.reset = function() {
        this.readers.forEach(function(reader) {
          return reader.reset();
        });
      };
      return MultiFormatOneDReader2;
    }(OneDReader_default)
  );
  var MultiFormatOneDReader_default = MultiFormatOneDReader;

  // node_modules/@zxing/library/esm/browser/BrowserBarcodeReader.js
  var __extends52 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserBarcodeReader = (
    /** @class */
    function(_super) {
      __extends52(BrowserBarcodeReader2, _super);
      function BrowserBarcodeReader2(timeBetweenScansMillis, hints) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        return _super.call(this, new MultiFormatOneDReader_default(hints), timeBetweenScansMillis, hints) || this;
      }
      return BrowserBarcodeReader2;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/core/datamatrix/decoder/Version.js
  var __values18 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ECBlocks = (
    /** @class */
    function() {
      function ECBlocks3(ecCodewords, ecBlocks1, ecBlocks2) {
        this.ecCodewords = ecCodewords;
        this.ecBlocks = [ecBlocks1];
        ecBlocks2 && this.ecBlocks.push(ecBlocks2);
      }
      ECBlocks3.prototype.getECCodewords = function() {
        return this.ecCodewords;
      };
      ECBlocks3.prototype.getECBlocks = function() {
        return this.ecBlocks;
      };
      return ECBlocks3;
    }()
  );
  var ECB = (
    /** @class */
    function() {
      function ECB3(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      ECB3.prototype.getCount = function() {
        return this.count;
      };
      ECB3.prototype.getDataCodewords = function() {
        return this.dataCodewords;
      };
      return ECB3;
    }()
  );
  var Version = (
    /** @class */
    function() {
      function Version3(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
        var e_1, _a2;
        this.versionNumber = versionNumber;
        this.symbolSizeRows = symbolSizeRows;
        this.symbolSizeColumns = symbolSizeColumns;
        this.dataRegionSizeRows = dataRegionSizeRows;
        this.dataRegionSizeColumns = dataRegionSizeColumns;
        this.ecBlocks = ecBlocks;
        var total = 0;
        var ecCodewords = ecBlocks.getECCodewords();
        var ecbArray = ecBlocks.getECBlocks();
        try {
          for (var ecbArray_1 = __values18(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
            var ecBlock = ecbArray_1_1.value;
            total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ecbArray_1_1 && !ecbArray_1_1.done && (_a2 = ecbArray_1.return)) _a2.call(ecbArray_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.totalCodewords = total;
      }
      Version3.prototype.getVersionNumber = function() {
        return this.versionNumber;
      };
      Version3.prototype.getSymbolSizeRows = function() {
        return this.symbolSizeRows;
      };
      Version3.prototype.getSymbolSizeColumns = function() {
        return this.symbolSizeColumns;
      };
      Version3.prototype.getDataRegionSizeRows = function() {
        return this.dataRegionSizeRows;
      };
      Version3.prototype.getDataRegionSizeColumns = function() {
        return this.dataRegionSizeColumns;
      };
      Version3.prototype.getTotalCodewords = function() {
        return this.totalCodewords;
      };
      Version3.prototype.getECBlocks = function() {
        return this.ecBlocks;
      };
      Version3.getVersionForDimensions = function(numRows, numColumns) {
        var e_2, _a2;
        if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
          throw new FormatException_default();
        }
        try {
          for (var _b = __values18(Version3.VERSIONS), _c = _b.next(); !_c.done; _c = _b.next()) {
            var version = _c.value;
            if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
              return version;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        throw new FormatException_default();
      };
      Version3.prototype.toString = function() {
        return "" + this.versionNumber;
      };
      Version3.buildVersions = function() {
        return [
          new Version3(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
          new Version3(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
          new Version3(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
          new Version3(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
          new Version3(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
          new Version3(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
          new Version3(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
          new Version3(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
          new Version3(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
          new Version3(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
          new Version3(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
          new Version3(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
          new Version3(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
          new Version3(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
          new Version3(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
          new Version3(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
          new Version3(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
          new Version3(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
          new Version3(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
          new Version3(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
          new Version3(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
          new Version3(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
          new Version3(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
          new Version3(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
          new Version3(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
          new Version3(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
          new Version3(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
          new Version3(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
          new Version3(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
          new Version3(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
        ];
      };
      Version3.VERSIONS = Version3.buildVersions();
      return Version3;
    }()
  );
  var Version_default = Version;

  // node_modules/@zxing/library/esm/core/datamatrix/decoder/BitMatrixParser.js
  var BitMatrixParser = (
    /** @class */
    function() {
      function BitMatrixParser3(bitMatrix) {
        var dimension = bitMatrix.getHeight();
        if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
          throw new FormatException_default();
        }
        this.version = BitMatrixParser3.readVersion(bitMatrix);
        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
        this.readMappingMatrix = new BitMatrix_default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
      }
      BitMatrixParser3.prototype.getVersion = function() {
        return this.version;
      };
      BitMatrixParser3.readVersion = function(bitMatrix) {
        var numRows = bitMatrix.getHeight();
        var numColumns = bitMatrix.getWidth();
        return Version_default.getVersionForDimensions(numRows, numColumns);
      };
      BitMatrixParser3.prototype.readCodewords = function() {
        var result = new Int8Array(this.version.getTotalCodewords());
        var resultOffset = 0;
        var row = 4;
        var column = 0;
        var numRows = this.mappingBitMatrix.getHeight();
        var numColumns = this.mappingBitMatrix.getWidth();
        var corner1Read = false;
        var corner2Read = false;
        var corner3Read = false;
        var corner4Read = false;
        do {
          if (row === numRows && column === 0 && !corner1Read) {
            result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner1Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
            result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner2Read = true;
          } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
            result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner3Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
            result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner4Read = true;
          } else {
            do {
              if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row -= 2;
              column += 2;
            } while (row >= 0 && column < numColumns);
            row += 1;
            column += 3;
            do {
              if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row += 2;
              column -= 2;
            } while (row < numRows && column >= 0);
            row += 3;
            column += 1;
          }
        } while (row < numRows || column < numColumns);
        if (resultOffset !== this.version.getTotalCodewords()) {
          throw new FormatException_default();
        }
        return result;
      };
      BitMatrixParser3.prototype.readModule = function(row, column, numRows, numColumns) {
        if (row < 0) {
          row += numRows;
          column += 4 - (numRows + 4 & 7);
        }
        if (column < 0) {
          column += numColumns;
          row += 4 - (numColumns + 4 & 7);
        }
        this.readMappingMatrix.set(column, row);
        return this.mappingBitMatrix.get(column, row);
      };
      BitMatrixParser3.prototype.readUtah = function(row, column, numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      };
      BitMatrixParser3.prototype.readCorner1 = function(numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      };
      BitMatrixParser3.prototype.readCorner2 = function(numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      };
      BitMatrixParser3.prototype.readCorner3 = function(numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      };
      BitMatrixParser3.prototype.readCorner4 = function(numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      };
      BitMatrixParser3.prototype.extractDataRegion = function(bitMatrix) {
        var symbolSizeRows = this.version.getSymbolSizeRows();
        var symbolSizeColumns = this.version.getSymbolSizeColumns();
        if (bitMatrix.getHeight() !== symbolSizeRows) {
          throw new IllegalArgumentException_default("Dimension of bitMatrix must match the version size");
        }
        var dataRegionSizeRows = this.version.getDataRegionSizeRows();
        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
        var bitMatrixWithoutAlignment = new BitMatrix_default(sizeDataRegionColumn, sizeDataRegionRow);
        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
          var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
          for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
            var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
            for (var i = 0; i < dataRegionSizeRows; ++i) {
              var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
              var writeRowOffset = dataRegionRowOffset + i;
              for (var j = 0; j < dataRegionSizeColumns; ++j) {
                var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                  var writeColumnOffset = dataRegionColumnOffset + j;
                  bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                }
              }
            }
          }
        }
        return bitMatrixWithoutAlignment;
      };
      return BitMatrixParser3;
    }()
  );
  var BitMatrixParser_default = BitMatrixParser;

  // node_modules/@zxing/library/esm/core/datamatrix/decoder/DataBlock.js
  var __values19 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var DataBlock = (
    /** @class */
    function() {
      function DataBlock3(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      DataBlock3.getDataBlocks = function(rawCodewords, version) {
        var e_1, _a2, e_2, _b;
        var ecBlocks = version.getECBlocks();
        var totalBlocks = 0;
        var ecBlockArray = ecBlocks.getECBlocks();
        try {
          for (var ecBlockArray_1 = __values19(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
            var ecBlock = ecBlockArray_1_1.value;
            totalBlocks += ecBlock.getCount();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a2 = ecBlockArray_1.return)) _a2.call(ecBlockArray_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var result = new Array(totalBlocks);
        var numResultBlocks = 0;
        try {
          for (var ecBlockArray_2 = __values19(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
            var ecBlock = ecBlockArray_2_1.value;
            for (var i = 0; i < ecBlock.getCount(); i++) {
              var numDataCodewords = ecBlock.getDataCodewords();
              var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
              result[numResultBlocks++] = new DataBlock3(numDataCodewords, new Uint8Array(numBlockCodewords));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        var longerBlocksTotalCodewords = result[0].codewords.length;
        var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
        var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
        var rawCodewordsOffset = 0;
        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
          }
        }
        var specialVersion = version.getVersionNumber() === 24;
        var numLongerBlocks = specialVersion ? 8 : numResultBlocks;
        for (var j = 0; j < numLongerBlocks; j++) {
          result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
        }
        var max2 = result[0].codewords.length;
        for (var i = longerBlocksNumDataCodewords; i < max2; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
            var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
            result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        if (rawCodewordsOffset !== rawCodewords.length) {
          throw new IllegalArgumentException_default();
        }
        return result;
      };
      DataBlock3.prototype.getNumDataCodewords = function() {
        return this.numDataCodewords;
      };
      DataBlock3.prototype.getCodewords = function() {
        return this.codewords;
      };
      return DataBlock3;
    }()
  );
  var DataBlock_default = DataBlock;

  // node_modules/@zxing/library/esm/core/common/BitSource.js
  var BitSource = (
    /** @class */
    function() {
      function BitSource2(bytes) {
        this.bytes = bytes;
        this.byteOffset = 0;
        this.bitOffset = 0;
      }
      BitSource2.prototype.getBitOffset = function() {
        return this.bitOffset;
      };
      BitSource2.prototype.getByteOffset = function() {
        return this.byteOffset;
      };
      BitSource2.prototype.readBits = function(numBits) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
          throw new IllegalArgumentException_default("" + numBits);
        }
        var result = 0;
        var bitOffset = this.bitOffset;
        var byteOffset = this.byteOffset;
        var bytes = this.bytes;
        if (bitOffset > 0) {
          var bitsLeft = 8 - bitOffset;
          var toRead = numBits < bitsLeft ? numBits : bitsLeft;
          var bitsToNotRead = bitsLeft - toRead;
          var mask = 255 >> 8 - toRead << bitsToNotRead;
          result = (bytes[byteOffset] & mask) >> bitsToNotRead;
          numBits -= toRead;
          bitOffset += toRead;
          if (bitOffset === 8) {
            bitOffset = 0;
            byteOffset++;
          }
        }
        if (numBits > 0) {
          while (numBits >= 8) {
            result = result << 8 | bytes[byteOffset] & 255;
            byteOffset++;
            numBits -= 8;
          }
          if (numBits > 0) {
            var bitsToNotRead = 8 - numBits;
            var mask = 255 >> bitsToNotRead << bitsToNotRead;
            result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
            bitOffset += numBits;
          }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
      };
      BitSource2.prototype.available = function() {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
      };
      return BitSource2;
    }()
  );
  var BitSource_default = BitSource;

  // node_modules/@zxing/library/esm/core/datamatrix/decoder/DecodedBitStreamParser.js
  var Mode;
  (function(Mode5) {
    Mode5[Mode5["PAD_ENCODE"] = 0] = "PAD_ENCODE";
    Mode5[Mode5["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
    Mode5[Mode5["C40_ENCODE"] = 2] = "C40_ENCODE";
    Mode5[Mode5["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
    Mode5[Mode5["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
    Mode5[Mode5["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
    Mode5[Mode5["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
  })(Mode || (Mode = {}));
  var DecodedBitStreamParser = (
    /** @class */
    function() {
      function DecodedBitStreamParser4() {
      }
      DecodedBitStreamParser4.decode = function(bytes) {
        var bits = new BitSource_default(bytes);
        var result = new StringBuilder_default();
        var resultTrailer = new StringBuilder_default();
        var byteSegments = new Array();
        var mode = Mode.ASCII_ENCODE;
        do {
          if (mode === Mode.ASCII_ENCODE) {
            mode = this.decodeAsciiSegment(bits, result, resultTrailer);
          } else {
            switch (mode) {
              case Mode.C40_ENCODE:
                this.decodeC40Segment(bits, result);
                break;
              case Mode.TEXT_ENCODE:
                this.decodeTextSegment(bits, result);
                break;
              case Mode.ANSIX12_ENCODE:
                this.decodeAnsiX12Segment(bits, result);
                break;
              case Mode.EDIFACT_ENCODE:
                this.decodeEdifactSegment(bits, result);
                break;
              case Mode.BASE256_ENCODE:
                this.decodeBase256Segment(bits, result, byteSegments);
                break;
              default:
                throw new FormatException_default();
            }
            mode = Mode.ASCII_ENCODE;
          }
        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
        if (resultTrailer.length() > 0) {
          result.append(resultTrailer.toString());
        }
        return new DecoderResult_default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
      };
      DecodedBitStreamParser4.decodeAsciiSegment = function(bits, result, resultTrailer) {
        var upperShift = false;
        do {
          var oneByte = bits.readBits(8);
          if (oneByte === 0) {
            throw new FormatException_default();
          } else if (oneByte <= 128) {
            if (upperShift) {
              oneByte += 128;
            }
            result.append(String.fromCharCode(oneByte - 1));
            return Mode.ASCII_ENCODE;
          } else if (oneByte === 129) {
            return Mode.PAD_ENCODE;
          } else if (oneByte <= 229) {
            var value = oneByte - 130;
            if (value < 10) {
              result.append("0");
            }
            result.append("" + value);
          } else {
            switch (oneByte) {
              case 230:
                return Mode.C40_ENCODE;
              case 231:
                return Mode.BASE256_ENCODE;
              case 232:
                result.append(String.fromCharCode(29));
                break;
              case 233:
              // Structured Append
              case 234:
                break;
              case 235:
                upperShift = true;
                break;
              case 236:
                result.append("[)>05");
                resultTrailer.insert(0, "");
                break;
              case 237:
                result.append("[)>06");
                resultTrailer.insert(0, "");
                break;
              case 238:
                return Mode.ANSIX12_ENCODE;
              case 239:
                return Mode.TEXT_ENCODE;
              case 240:
                return Mode.EDIFACT_ENCODE;
              case 241:
                break;
              default:
                if (oneByte !== 254 || bits.available() !== 0) {
                  throw new FormatException_default();
                }
                break;
            }
          }
        } while (bits.available() > 0);
        return Mode.ASCII_ENCODE;
      };
      DecodedBitStreamParser4.decodeC40Segment = function(bits, result) {
        var upperShift = false;
        var cValues = [];
        var shift2 = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          var firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (var i = 0; i < 3; i++) {
            var cValue = cValues[i];
            switch (shift2) {
              case 0:
                if (cValue < 3) {
                  shift2 = cValue + 1;
                } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                  var c40char = this.C40_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  throw new FormatException_default();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift2 = 0;
                break;
              case 2:
                if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                  var c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException_default();
                  }
                }
                shift2 = 0;
                break;
              case 3:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 224));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue + 96));
                }
                shift2 = 0;
                break;
              default:
                throw new FormatException_default();
            }
          }
        } while (bits.available() > 0);
      };
      DecodedBitStreamParser4.decodeTextSegment = function(bits, result) {
        var upperShift = false;
        var cValues = [];
        var shift2 = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          var firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (var i = 0; i < 3; i++) {
            var cValue = cValues[i];
            switch (shift2) {
              case 0:
                if (cValue < 3) {
                  shift2 = cValue + 1;
                } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                  var textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  throw new FormatException_default();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift2 = 0;
                break;
              case 2:
                if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                  var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException_default();
                  }
                }
                shift2 = 0;
                break;
              case 3:
                if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                  var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                  shift2 = 0;
                } else {
                  throw new FormatException_default();
                }
                break;
              default:
                throw new FormatException_default();
            }
          }
        } while (bits.available() > 0);
      };
      DecodedBitStreamParser4.decodeAnsiX12Segment = function(bits, result) {
        var cValues = [];
        do {
          if (bits.available() === 8) {
            return;
          }
          var firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (var i = 0; i < 3; i++) {
            var cValue = cValues[i];
            switch (cValue) {
              case 0:
                result.append("\r");
                break;
              case 1:
                result.append("*");
                break;
              case 2:
                result.append(">");
                break;
              case 3:
                result.append(" ");
                break;
              default:
                if (cValue < 14) {
                  result.append(String.fromCharCode(cValue + 44));
                } else if (cValue < 40) {
                  result.append(String.fromCharCode(cValue + 51));
                } else {
                  throw new FormatException_default();
                }
                break;
            }
          }
        } while (bits.available() > 0);
      };
      DecodedBitStreamParser4.parseTwoBytes = function(firstByte, secondByte, result) {
        var fullBitValue = (firstByte << 8) + secondByte - 1;
        var temp = Math.floor(fullBitValue / 1600);
        result[0] = temp;
        fullBitValue -= temp * 1600;
        temp = Math.floor(fullBitValue / 40);
        result[1] = temp;
        result[2] = fullBitValue - temp * 40;
      };
      DecodedBitStreamParser4.decodeEdifactSegment = function(bits, result) {
        do {
          if (bits.available() <= 16) {
            return;
          }
          for (var i = 0; i < 4; i++) {
            var edifactValue = bits.readBits(6);
            if (edifactValue === 31) {
              var bitsLeft = 8 - bits.getBitOffset();
              if (bitsLeft !== 8) {
                bits.readBits(bitsLeft);
              }
              return;
            }
            if ((edifactValue & 32) === 0) {
              edifactValue |= 64;
            }
            result.append(String.fromCharCode(edifactValue));
          }
        } while (bits.available() > 0);
      };
      DecodedBitStreamParser4.decodeBase256Segment = function(bits, result, byteSegments) {
        var codewordPosition = 1 + bits.getByteOffset();
        var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        var count;
        if (d1 === 0) {
          count = bits.available() / 8 | 0;
        } else if (d1 < 250) {
          count = d1;
        } else {
          count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        if (count < 0) {
          throw new FormatException_default();
        }
        var bytes = new Uint8Array(count);
        for (var i = 0; i < count; i++) {
          if (bits.available() < 8) {
            throw new FormatException_default();
          }
          bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        byteSegments.push(bytes);
        try {
          result.append(StringEncoding_default.decode(bytes, StringUtils_default.ISO88591));
        } catch (uee) {
          throw new IllegalStateException_default("Platform does not support required encoding: " + uee.message);
        }
      };
      DecodedBitStreamParser4.unrandomize255State = function(randomizedBase256Codeword, base256CodewordPosition) {
        var pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
        var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
        return tempVariable >= 0 ? tempVariable : tempVariable + 256;
      };
      DecodedBitStreamParser4.C40_BASIC_SET_CHARS = [
        "*",
        "*",
        "*",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z"
      ];
      DecodedBitStreamParser4.C40_SHIFT2_SET_CHARS = [
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "@",
        "[",
        "\\",
        "]",
        "^",
        "_"
      ];
      DecodedBitStreamParser4.TEXT_BASIC_SET_CHARS = [
        "*",
        "*",
        "*",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z"
      ];
      DecodedBitStreamParser4.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser4.C40_SHIFT2_SET_CHARS;
      DecodedBitStreamParser4.TEXT_SHIFT3_SET_CHARS = [
        "`",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "{",
        "|",
        "}",
        "~",
        String.fromCharCode(127)
      ];
      return DecodedBitStreamParser4;
    }()
  );
  var DecodedBitStreamParser_default = DecodedBitStreamParser;

  // node_modules/@zxing/library/esm/core/datamatrix/decoder/Decoder.js
  var __values20 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Decoder2 = (
    /** @class */
    function() {
      function Decoder4() {
        this.rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.DATA_MATRIX_FIELD_256);
      }
      Decoder4.prototype.decode = function(bits) {
        var e_1, _a2;
        var parser = new BitMatrixParser_default(bits);
        var version = parser.getVersion();
        var codewords = parser.readCodewords();
        var dataBlocks = DataBlock_default.getDataBlocks(codewords, version);
        var totalBytes = 0;
        try {
          for (var dataBlocks_1 = __values20(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
            var db = dataBlocks_1_1.value;
            totalBytes += db.getNumDataCodewords();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a2 = dataBlocks_1.return)) _a2.call(dataBlocks_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var resultBytes = new Uint8Array(totalBytes);
        var dataBlocksCount = dataBlocks.length;
        for (var j = 0; j < dataBlocksCount; j++) {
          var dataBlock = dataBlocks[j];
          var codewordBytes = dataBlock.getCodewords();
          var numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (var i = 0; i < numDataCodewords; i++) {
            resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
          }
        }
        return DecodedBitStreamParser_default.decode(resultBytes);
      };
      Decoder4.prototype.correctErrors = function(codewordBytes, numDataCodewords) {
        var codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException_default();
        }
        for (var i = 0; i < numDataCodewords; i++) {
          codewordBytes[i] = codewordsInts[i];
        }
      };
      return Decoder4;
    }()
  );
  var Decoder_default2 = Decoder2;

  // node_modules/@zxing/library/esm/core/datamatrix/detector/Detector.js
  var Detector2 = (
    /** @class */
    function() {
      function Detector5(image) {
        this.image = image;
        this.rectangleDetector = new WhiteRectangleDetector_default(this.image);
      }
      Detector5.prototype.detect = function() {
        var cornerPoints = this.rectangleDetector.detect();
        var points = this.detectSolid1(cornerPoints);
        points = this.detectSolid2(points);
        points[3] = this.correctTopRight(points);
        if (!points[3]) {
          throw new NotFoundException_default();
        }
        points = this.shiftToModuleCenter(points);
        var topLeft = points[0];
        var bottomLeft = points[1];
        var bottomRight = points[2];
        var topRight = points[3];
        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
        if ((dimensionTop & 1) === 1) {
          dimensionTop += 1;
        }
        if ((dimensionRight & 1) === 1) {
          dimensionRight += 1;
        }
        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
          dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
        }
        var bits = Detector5.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
        return new DetectorResult_default(bits, [topLeft, bottomLeft, bottomRight, topRight]);
      };
      Detector5.shiftPoint = function(point, to, div2) {
        var x = (to.getX() - point.getX()) / (div2 + 1);
        var y = (to.getY() - point.getY()) / (div2 + 1);
        return new ResultPoint_default(point.getX() + x, point.getY() + y);
      };
      Detector5.moveAway = function(point, fromX, fromY) {
        var x = point.getX();
        var y = point.getY();
        if (x < fromX) {
          x -= 1;
        } else {
          x += 1;
        }
        if (y < fromY) {
          y -= 1;
        } else {
          y += 1;
        }
        return new ResultPoint_default(x, y);
      };
      Detector5.prototype.detectSolid1 = function(cornerPoints) {
        var pointA = cornerPoints[0];
        var pointB = cornerPoints[1];
        var pointC = cornerPoints[3];
        var pointD = cornerPoints[2];
        var trAB = this.transitionsBetween(pointA, pointB);
        var trBC = this.transitionsBetween(pointB, pointC);
        var trCD = this.transitionsBetween(pointC, pointD);
        var trDA = this.transitionsBetween(pointD, pointA);
        var min2 = trAB;
        var points = [pointD, pointA, pointB, pointC];
        if (min2 > trBC) {
          min2 = trBC;
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        }
        if (min2 > trCD) {
          min2 = trCD;
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        if (min2 > trDA) {
          points[0] = pointC;
          points[1] = pointD;
          points[2] = pointA;
          points[3] = pointB;
        }
        return points;
      };
      Detector5.prototype.detectSolid2 = function(points) {
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        var tr = this.transitionsBetween(pointA, pointD);
        var pointBs = Detector5.shiftPoint(pointB, pointC, (tr + 1) * 4);
        var pointCs = Detector5.shiftPoint(pointC, pointB, (tr + 1) * 4);
        var trBA = this.transitionsBetween(pointBs, pointA);
        var trCD = this.transitionsBetween(pointCs, pointD);
        if (trBA < trCD) {
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        } else {
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        return points;
      };
      Detector5.prototype.correctTopRight = function(points) {
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        var trTop = this.transitionsBetween(pointA, pointD);
        var trRight = this.transitionsBetween(pointB, pointD);
        var pointAs = Detector5.shiftPoint(pointA, pointB, (trRight + 1) * 4);
        var pointCs = Detector5.shiftPoint(pointC, pointB, (trTop + 1) * 4);
        trTop = this.transitionsBetween(pointAs, pointD);
        trRight = this.transitionsBetween(pointCs, pointD);
        var candidate1 = new ResultPoint_default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
        var candidate2 = new ResultPoint_default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
        if (!this.isValid(candidate1)) {
          if (this.isValid(candidate2)) {
            return candidate2;
          }
          return null;
        }
        if (!this.isValid(candidate2)) {
          return candidate1;
        }
        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
        if (sumc1 > sumc2) {
          return candidate1;
        } else {
          return candidate2;
        }
      };
      Detector5.prototype.shiftToModuleCenter = function(points) {
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        var dimH = this.transitionsBetween(pointA, pointD) + 1;
        var dimV = this.transitionsBetween(pointC, pointD) + 1;
        var pointAs = Detector5.shiftPoint(pointA, pointB, dimV * 4);
        var pointCs = Detector5.shiftPoint(pointC, pointB, dimH * 4);
        dimH = this.transitionsBetween(pointAs, pointD) + 1;
        dimV = this.transitionsBetween(pointCs, pointD) + 1;
        if ((dimH & 1) === 1) {
          dimH += 1;
        }
        if ((dimV & 1) === 1) {
          dimV += 1;
        }
        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
        pointA = Detector5.moveAway(pointA, centerX, centerY);
        pointB = Detector5.moveAway(pointB, centerX, centerY);
        pointC = Detector5.moveAway(pointC, centerX, centerY);
        pointD = Detector5.moveAway(pointD, centerX, centerY);
        var pointBs;
        var pointDs;
        pointAs = Detector5.shiftPoint(pointA, pointB, dimV * 4);
        pointAs = Detector5.shiftPoint(pointAs, pointD, dimH * 4);
        pointBs = Detector5.shiftPoint(pointB, pointA, dimV * 4);
        pointBs = Detector5.shiftPoint(pointBs, pointC, dimH * 4);
        pointCs = Detector5.shiftPoint(pointC, pointD, dimV * 4);
        pointCs = Detector5.shiftPoint(pointCs, pointB, dimH * 4);
        pointDs = Detector5.shiftPoint(pointD, pointC, dimV * 4);
        pointDs = Detector5.shiftPoint(pointDs, pointA, dimH * 4);
        return [pointAs, pointBs, pointCs, pointDs];
      };
      Detector5.prototype.isValid = function(p) {
        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
      };
      Detector5.sampleGrid = function(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
        var sampler = GridSamplerInstance_default.getInstance();
        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
      };
      Detector5.prototype.transitionsBetween = function(from2, to) {
        var fromX = Math.trunc(from2.getX());
        var fromY = Math.trunc(from2.getY());
        var toX = Math.trunc(to.getX());
        var toY = Math.trunc(to.getY());
        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          var temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        var dx = Math.abs(toX - fromX);
        var dy = Math.abs(toY - fromY);
        var error2 = -dx / 2;
        var ystep = fromY < toY ? 1 : -1;
        var xstep = fromX < toX ? 1 : -1;
        var transitions = 0;
        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
        for (var x = fromX, y = fromY; x !== toX; x += xstep) {
          var isBlack = this.image.get(steep ? y : x, steep ? x : y);
          if (isBlack !== inBlack) {
            transitions++;
            inBlack = isBlack;
          }
          error2 += dy;
          if (error2 > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error2 -= dx;
          }
        }
        return transitions;
      };
      return Detector5;
    }()
  );
  var Detector_default2 = Detector2;

  // node_modules/@zxing/library/esm/core/datamatrix/DataMatrixReader.js
  var DataMatrixReader = (
    /** @class */
    function() {
      function DataMatrixReader2() {
        this.decoder = new Decoder_default2();
      }
      DataMatrixReader2.prototype.decode = function(image, hints) {
        if (hints === void 0) {
          hints = null;
        }
        var decoderResult;
        var points;
        if (hints != null && hints.has(DecodeHintType_default.PURE_BARCODE)) {
          var bits = DataMatrixReader2.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decode(bits);
          points = DataMatrixReader2.NO_POINTS;
        } else {
          var detectorResult = new Detector_default2(image.getBlackMatrix()).detect();
          decoderResult = this.decoder.decode(detectorResult.getBits());
          points = detectorResult.getPoints();
        }
        var rawBytes = decoderResult.getRawBytes();
        var result = new Result_default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_default.DATA_MATRIX, System_default.currentTimeMillis());
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      };
      DataMatrixReader2.prototype.reset = function() {
      };
      DataMatrixReader2.extractPureBits = function(image) {
        var leftTopBlack = image.getTopLeftOnBit();
        var rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack == null || rightBottomBlack == null) {
          throw new NotFoundException_default();
        }
        var moduleSize = this.moduleSize(leftTopBlack, image);
        var top2 = leftTopBlack[1];
        var bottom2 = rightBottomBlack[1];
        var left2 = leftTopBlack[0];
        var right2 = rightBottomBlack[0];
        var matrixWidth = (right2 - left2 + 1) / moduleSize;
        var matrixHeight = (bottom2 - top2 + 1) / moduleSize;
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException_default();
        }
        var nudge = moduleSize / 2;
        top2 += nudge;
        left2 += nudge;
        var bits = new BitMatrix_default(matrixWidth, matrixHeight);
        for (var y = 0; y < matrixHeight; y++) {
          var iOffset = top2 + y * moduleSize;
          for (var x = 0; x < matrixWidth; x++) {
            if (image.get(left2 + x * moduleSize, iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      };
      DataMatrixReader2.moduleSize = function(leftTopBlack, image) {
        var width = image.getWidth();
        var x = leftTopBlack[0];
        var y = leftTopBlack[1];
        while (x < width && image.get(x, y)) {
          x++;
        }
        if (x === width) {
          throw new NotFoundException_default();
        }
        var moduleSize = x - leftTopBlack[0];
        if (moduleSize === 0) {
          throw new NotFoundException_default();
        }
        return moduleSize;
      };
      DataMatrixReader2.NO_POINTS = [];
      return DataMatrixReader2;
    }()
  );
  var DataMatrixReader_default = DataMatrixReader;

  // node_modules/@zxing/library/esm/browser/BrowserDatamatrixCodeReader.js
  var __extends53 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserDatamatrixCodeReader = (
    /** @class */
    function(_super) {
      __extends53(BrowserDatamatrixCodeReader3, _super);
      function BrowserDatamatrixCodeReader3(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        return _super.call(this, new DataMatrixReader_default(), timeBetweenScansMillis) || this;
      }
      return BrowserDatamatrixCodeReader3;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/core/qrcode/decoder/ErrorCorrectionLevel.js
  var ErrorCorrectionLevelValues;
  (function(ErrorCorrectionLevelValues2) {
    ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
    ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
    ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
    ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
  })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
  var ErrorCorrectionLevel = (
    /** @class */
    function() {
      function ErrorCorrectionLevel2(value, stringValue, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits;
        ErrorCorrectionLevel2.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel2.FOR_VALUE.set(value, this);
      }
      ErrorCorrectionLevel2.prototype.getValue = function() {
        return this.value;
      };
      ErrorCorrectionLevel2.prototype.getBits = function() {
        return this.bits;
      };
      ErrorCorrectionLevel2.fromString = function(s) {
        switch (s) {
          case "L":
            return ErrorCorrectionLevel2.L;
          case "M":
            return ErrorCorrectionLevel2.M;
          case "Q":
            return ErrorCorrectionLevel2.Q;
          case "H":
            return ErrorCorrectionLevel2.H;
          default:
            throw new ArgumentException_default(s + "not available");
        }
      };
      ErrorCorrectionLevel2.prototype.toString = function() {
        return this.stringValue;
      };
      ErrorCorrectionLevel2.prototype.equals = function(o) {
        if (!(o instanceof ErrorCorrectionLevel2)) {
          return false;
        }
        var other = o;
        return this.value === other.value;
      };
      ErrorCorrectionLevel2.forBits = function(bits) {
        if (bits < 0 || bits >= ErrorCorrectionLevel2.FOR_BITS.size) {
          throw new IllegalArgumentException_default();
        }
        return ErrorCorrectionLevel2.FOR_BITS.get(bits);
      };
      ErrorCorrectionLevel2.FOR_BITS = /* @__PURE__ */ new Map();
      ErrorCorrectionLevel2.FOR_VALUE = /* @__PURE__ */ new Map();
      ErrorCorrectionLevel2.L = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.L, "L", 1);
      ErrorCorrectionLevel2.M = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.M, "M", 0);
      ErrorCorrectionLevel2.Q = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.Q, "Q", 3);
      ErrorCorrectionLevel2.H = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.H, "H", 2);
      return ErrorCorrectionLevel2;
    }()
  );
  var ErrorCorrectionLevel_default = ErrorCorrectionLevel;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/FormatInformation.js
  var __values21 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var FormatInformation = (
    /** @class */
    function() {
      function FormatInformation2(formatInfo) {
        this.errorCorrectionLevel = ErrorCorrectionLevel_default.forBits(formatInfo >> 3 & 3);
        this.dataMask = /*(byte) */
        formatInfo & 7;
      }
      FormatInformation2.numBitsDiffering = function(a, b) {
        return Integer_default.bitCount(a ^ b);
      };
      FormatInformation2.decodeFormatInformation = function(maskedFormatInfo1, maskedFormatInfo2) {
        var formatInfo = FormatInformation2.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
          return formatInfo;
        }
        return FormatInformation2.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation2.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation2.FORMAT_INFO_MASK_QR);
      };
      FormatInformation2.doDecodeFormatInformation = function(maskedFormatInfo1, maskedFormatInfo2) {
        var e_1, _a2;
        var bestDifference = Number.MAX_SAFE_INTEGER;
        var bestFormatInfo = 0;
        try {
          for (var _b = __values21(FormatInformation2.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {
            var decodeInfo = _c.value;
            var targetInfo = decodeInfo[0];
            if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
              return new FormatInformation2(decodeInfo[1]);
            }
            var bitsDifference = FormatInformation2.numBitsDiffering(maskedFormatInfo1, targetInfo);
            if (bitsDifference < bestDifference) {
              bestFormatInfo = decodeInfo[1];
              bestDifference = bitsDifference;
            }
            if (maskedFormatInfo1 !== maskedFormatInfo2) {
              bitsDifference = FormatInformation2.numBitsDiffering(maskedFormatInfo2, targetInfo);
              if (bitsDifference < bestDifference) {
                bestFormatInfo = decodeInfo[1];
                bestDifference = bitsDifference;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (bestDifference <= 3) {
          return new FormatInformation2(bestFormatInfo);
        }
        return null;
      };
      FormatInformation2.prototype.getErrorCorrectionLevel = function() {
        return this.errorCorrectionLevel;
      };
      FormatInformation2.prototype.getDataMask = function() {
        return this.dataMask;
      };
      FormatInformation2.prototype.hashCode = function() {
        return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
      };
      FormatInformation2.prototype.equals = function(o) {
        if (!(o instanceof FormatInformation2)) {
          return false;
        }
        var other = o;
        return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
      };
      FormatInformation2.FORMAT_INFO_MASK_QR = 21522;
      FormatInformation2.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([21522, 0]),
        Int32Array.from([20773, 1]),
        Int32Array.from([24188, 2]),
        Int32Array.from([23371, 3]),
        Int32Array.from([17913, 4]),
        Int32Array.from([16590, 5]),
        Int32Array.from([20375, 6]),
        Int32Array.from([19104, 7]),
        Int32Array.from([30660, 8]),
        Int32Array.from([29427, 9]),
        Int32Array.from([32170, 10]),
        Int32Array.from([30877, 11]),
        Int32Array.from([26159, 12]),
        Int32Array.from([25368, 13]),
        Int32Array.from([27713, 14]),
        Int32Array.from([26998, 15]),
        Int32Array.from([5769, 16]),
        Int32Array.from([5054, 17]),
        Int32Array.from([7399, 18]),
        Int32Array.from([6608, 19]),
        Int32Array.from([1890, 20]),
        Int32Array.from([597, 21]),
        Int32Array.from([3340, 22]),
        Int32Array.from([2107, 23]),
        Int32Array.from([13663, 24]),
        Int32Array.from([12392, 25]),
        Int32Array.from([16177, 26]),
        Int32Array.from([14854, 27]),
        Int32Array.from([9396, 28]),
        Int32Array.from([8579, 29]),
        Int32Array.from([11994, 30]),
        Int32Array.from([11245, 31])
      ];
      return FormatInformation2;
    }()
  );
  var FormatInformation_default = FormatInformation;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/ECBlocks.js
  var __values22 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ECBlocks2 = (
    /** @class */
    function() {
      function ECBlocks3(ecCodewordsPerBlock) {
        var ecBlocks = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          ecBlocks[_i - 1] = arguments[_i];
        }
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        this.ecBlocks = ecBlocks;
      }
      ECBlocks3.prototype.getECCodewordsPerBlock = function() {
        return this.ecCodewordsPerBlock;
      };
      ECBlocks3.prototype.getNumBlocks = function() {
        var e_1, _a2;
        var total = 0;
        var ecBlocks = this.ecBlocks;
        try {
          for (var ecBlocks_1 = __values22(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {
            var ecBlock = ecBlocks_1_1.value;
            total += ecBlock.getCount();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a2 = ecBlocks_1.return)) _a2.call(ecBlocks_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return total;
      };
      ECBlocks3.prototype.getTotalECCodewords = function() {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
      };
      ECBlocks3.prototype.getECBlocks = function() {
        return this.ecBlocks;
      };
      return ECBlocks3;
    }()
  );
  var ECBlocks_default = ECBlocks2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/ECB.js
  var ECB2 = (
    /** @class */
    function() {
      function ECB3(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      ECB3.prototype.getCount = function() {
        return this.count;
      };
      ECB3.prototype.getDataCodewords = function() {
        return this.dataCodewords;
      };
      return ECB3;
    }()
  );
  var ECB_default = ECB2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/Version.js
  var __values23 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Version2 = (
    /** @class */
    function() {
      function Version3(versionNumber, alignmentPatternCenters) {
        var e_1, _a2;
        var ecBlocks = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          ecBlocks[_i - 2] = arguments[_i];
        }
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        var total = 0;
        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        var ecbArray = ecBlocks[0].getECBlocks();
        try {
          for (var ecbArray_1 = __values23(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
            var ecBlock = ecbArray_1_1.value;
            total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ecbArray_1_1 && !ecbArray_1_1.done && (_a2 = ecbArray_1.return)) _a2.call(ecbArray_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.totalCodewords = total;
      }
      Version3.prototype.getVersionNumber = function() {
        return this.versionNumber;
      };
      Version3.prototype.getAlignmentPatternCenters = function() {
        return this.alignmentPatternCenters;
      };
      Version3.prototype.getTotalCodewords = function() {
        return this.totalCodewords;
      };
      Version3.prototype.getDimensionForVersion = function() {
        return 17 + 4 * this.versionNumber;
      };
      Version3.prototype.getECBlocksForLevel = function(ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
      };
      Version3.getProvisionalVersionForDimension = function(dimension) {
        if (dimension % 4 !== 1) {
          throw new FormatException_default();
        }
        try {
          return this.getVersionForNumber((dimension - 17) / 4);
        } catch (ignored) {
          throw new FormatException_default();
        }
      };
      Version3.getVersionForNumber = function(versionNumber) {
        if (versionNumber < 1 || versionNumber > 40) {
          throw new IllegalArgumentException_default();
        }
        return Version3.VERSIONS[versionNumber - 1];
      };
      Version3.decodeVersionInformation = function(versionBits) {
        var bestDifference = Number.MAX_SAFE_INTEGER;
        var bestVersion = 0;
        for (var i = 0; i < Version3.VERSION_DECODE_INFO.length; i++) {
          var targetVersion = Version3.VERSION_DECODE_INFO[i];
          if (targetVersion === versionBits) {
            return Version3.getVersionForNumber(i + 7);
          }
          var bitsDifference = FormatInformation_default.numBitsDiffering(versionBits, targetVersion);
          if (bitsDifference < bestDifference) {
            bestVersion = i + 7;
            bestDifference = bitsDifference;
          }
        }
        if (bestDifference <= 3) {
          return Version3.getVersionForNumber(bestVersion);
        }
        return null;
      };
      Version3.prototype.buildFunctionPattern = function() {
        var dimension = this.getDimensionForVersion();
        var bitMatrix = new BitMatrix_default(dimension);
        bitMatrix.setRegion(0, 0, 9, 9);
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        var max2 = this.alignmentPatternCenters.length;
        for (var x = 0; x < max2; x++) {
          var i = this.alignmentPatternCenters[x] - 2;
          for (var y = 0; y < max2; y++) {
            if (x === 0 && (y === 0 || y === max2 - 1) || x === max2 - 1 && y === 0) {
              continue;
            }
            bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
          }
        }
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
          bitMatrix.setRegion(dimension - 11, 0, 3, 6);
          bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
      };
      Version3.prototype.toString = function() {
        return "" + this.versionNumber;
      };
      Version3.VERSION_DECODE_INFO = Int32Array.from([
        31892,
        34236,
        39577,
        42195,
        48118,
        51042,
        55367,
        58893,
        63784,
        68472,
        70749,
        76311,
        79154,
        84390,
        87683,
        92361,
        96236,
        102084,
        102881,
        110507,
        110734,
        117786,
        119615,
        126325,
        127568,
        133589,
        136944,
        141498,
        145311,
        150283,
        152622,
        158308,
        161089,
        167017
      ]);
      Version3.VERSIONS = [
        new Version3(1, new Int32Array(0), new ECBlocks_default(7, new ECB_default(1, 19)), new ECBlocks_default(10, new ECB_default(1, 16)), new ECBlocks_default(13, new ECB_default(1, 13)), new ECBlocks_default(17, new ECB_default(1, 9))),
        new Version3(2, Int32Array.from([6, 18]), new ECBlocks_default(10, new ECB_default(1, 34)), new ECBlocks_default(16, new ECB_default(1, 28)), new ECBlocks_default(22, new ECB_default(1, 22)), new ECBlocks_default(28, new ECB_default(1, 16))),
        new Version3(3, Int32Array.from([6, 22]), new ECBlocks_default(15, new ECB_default(1, 55)), new ECBlocks_default(26, new ECB_default(1, 44)), new ECBlocks_default(18, new ECB_default(2, 17)), new ECBlocks_default(22, new ECB_default(2, 13))),
        new Version3(4, Int32Array.from([6, 26]), new ECBlocks_default(20, new ECB_default(1, 80)), new ECBlocks_default(18, new ECB_default(2, 32)), new ECBlocks_default(26, new ECB_default(2, 24)), new ECBlocks_default(16, new ECB_default(4, 9))),
        new Version3(5, Int32Array.from([6, 30]), new ECBlocks_default(26, new ECB_default(1, 108)), new ECBlocks_default(24, new ECB_default(2, 43)), new ECBlocks_default(18, new ECB_default(2, 15), new ECB_default(2, 16)), new ECBlocks_default(22, new ECB_default(2, 11), new ECB_default(2, 12))),
        new Version3(6, Int32Array.from([6, 34]), new ECBlocks_default(18, new ECB_default(2, 68)), new ECBlocks_default(16, new ECB_default(4, 27)), new ECBlocks_default(24, new ECB_default(4, 19)), new ECBlocks_default(28, new ECB_default(4, 15))),
        new Version3(7, Int32Array.from([6, 22, 38]), new ECBlocks_default(20, new ECB_default(2, 78)), new ECBlocks_default(18, new ECB_default(4, 31)), new ECBlocks_default(18, new ECB_default(2, 14), new ECB_default(4, 15)), new ECBlocks_default(26, new ECB_default(4, 13), new ECB_default(1, 14))),
        new Version3(8, Int32Array.from([6, 24, 42]), new ECBlocks_default(24, new ECB_default(2, 97)), new ECBlocks_default(22, new ECB_default(2, 38), new ECB_default(2, 39)), new ECBlocks_default(22, new ECB_default(4, 18), new ECB_default(2, 19)), new ECBlocks_default(26, new ECB_default(4, 14), new ECB_default(2, 15))),
        new Version3(9, Int32Array.from([6, 26, 46]), new ECBlocks_default(30, new ECB_default(2, 116)), new ECBlocks_default(22, new ECB_default(3, 36), new ECB_default(2, 37)), new ECBlocks_default(20, new ECB_default(4, 16), new ECB_default(4, 17)), new ECBlocks_default(24, new ECB_default(4, 12), new ECB_default(4, 13))),
        new Version3(10, Int32Array.from([6, 28, 50]), new ECBlocks_default(18, new ECB_default(2, 68), new ECB_default(2, 69)), new ECBlocks_default(26, new ECB_default(4, 43), new ECB_default(1, 44)), new ECBlocks_default(24, new ECB_default(6, 19), new ECB_default(2, 20)), new ECBlocks_default(28, new ECB_default(6, 15), new ECB_default(2, 16))),
        new Version3(11, Int32Array.from([6, 30, 54]), new ECBlocks_default(20, new ECB_default(4, 81)), new ECBlocks_default(30, new ECB_default(1, 50), new ECB_default(4, 51)), new ECBlocks_default(28, new ECB_default(4, 22), new ECB_default(4, 23)), new ECBlocks_default(24, new ECB_default(3, 12), new ECB_default(8, 13))),
        new Version3(12, Int32Array.from([6, 32, 58]), new ECBlocks_default(24, new ECB_default(2, 92), new ECB_default(2, 93)), new ECBlocks_default(22, new ECB_default(6, 36), new ECB_default(2, 37)), new ECBlocks_default(26, new ECB_default(4, 20), new ECB_default(6, 21)), new ECBlocks_default(28, new ECB_default(7, 14), new ECB_default(4, 15))),
        new Version3(13, Int32Array.from([6, 34, 62]), new ECBlocks_default(26, new ECB_default(4, 107)), new ECBlocks_default(22, new ECB_default(8, 37), new ECB_default(1, 38)), new ECBlocks_default(24, new ECB_default(8, 20), new ECB_default(4, 21)), new ECBlocks_default(22, new ECB_default(12, 11), new ECB_default(4, 12))),
        new Version3(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_default(30, new ECB_default(3, 115), new ECB_default(1, 116)), new ECBlocks_default(24, new ECB_default(4, 40), new ECB_default(5, 41)), new ECBlocks_default(20, new ECB_default(11, 16), new ECB_default(5, 17)), new ECBlocks_default(24, new ECB_default(11, 12), new ECB_default(5, 13))),
        new Version3(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_default(22, new ECB_default(5, 87), new ECB_default(1, 88)), new ECBlocks_default(24, new ECB_default(5, 41), new ECB_default(5, 42)), new ECBlocks_default(30, new ECB_default(5, 24), new ECB_default(7, 25)), new ECBlocks_default(24, new ECB_default(11, 12), new ECB_default(7, 13))),
        new Version3(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_default(24, new ECB_default(5, 98), new ECB_default(1, 99)), new ECBlocks_default(28, new ECB_default(7, 45), new ECB_default(3, 46)), new ECBlocks_default(24, new ECB_default(15, 19), new ECB_default(2, 20)), new ECBlocks_default(30, new ECB_default(3, 15), new ECB_default(13, 16))),
        new Version3(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_default(28, new ECB_default(1, 107), new ECB_default(5, 108)), new ECBlocks_default(28, new ECB_default(10, 46), new ECB_default(1, 47)), new ECBlocks_default(28, new ECB_default(1, 22), new ECB_default(15, 23)), new ECBlocks_default(28, new ECB_default(2, 14), new ECB_default(17, 15))),
        new Version3(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_default(30, new ECB_default(5, 120), new ECB_default(1, 121)), new ECBlocks_default(26, new ECB_default(9, 43), new ECB_default(4, 44)), new ECBlocks_default(28, new ECB_default(17, 22), new ECB_default(1, 23)), new ECBlocks_default(28, new ECB_default(2, 14), new ECB_default(19, 15))),
        new Version3(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_default(28, new ECB_default(3, 113), new ECB_default(4, 114)), new ECBlocks_default(26, new ECB_default(3, 44), new ECB_default(11, 45)), new ECBlocks_default(26, new ECB_default(17, 21), new ECB_default(4, 22)), new ECBlocks_default(26, new ECB_default(9, 13), new ECB_default(16, 14))),
        new Version3(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_default(28, new ECB_default(3, 107), new ECB_default(5, 108)), new ECBlocks_default(26, new ECB_default(3, 41), new ECB_default(13, 42)), new ECBlocks_default(30, new ECB_default(15, 24), new ECB_default(5, 25)), new ECBlocks_default(28, new ECB_default(15, 15), new ECB_default(10, 16))),
        new Version3(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_default(28, new ECB_default(4, 116), new ECB_default(4, 117)), new ECBlocks_default(26, new ECB_default(17, 42)), new ECBlocks_default(28, new ECB_default(17, 22), new ECB_default(6, 23)), new ECBlocks_default(30, new ECB_default(19, 16), new ECB_default(6, 17))),
        new Version3(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_default(28, new ECB_default(2, 111), new ECB_default(7, 112)), new ECBlocks_default(28, new ECB_default(17, 46)), new ECBlocks_default(30, new ECB_default(7, 24), new ECB_default(16, 25)), new ECBlocks_default(24, new ECB_default(34, 13))),
        new Version3(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_default(30, new ECB_default(4, 121), new ECB_default(5, 122)), new ECBlocks_default(28, new ECB_default(4, 47), new ECB_default(14, 48)), new ECBlocks_default(30, new ECB_default(11, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(16, 15), new ECB_default(14, 16))),
        new Version3(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_default(30, new ECB_default(6, 117), new ECB_default(4, 118)), new ECBlocks_default(28, new ECB_default(6, 45), new ECB_default(14, 46)), new ECBlocks_default(30, new ECB_default(11, 24), new ECB_default(16, 25)), new ECBlocks_default(30, new ECB_default(30, 16), new ECB_default(2, 17))),
        new Version3(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_default(26, new ECB_default(8, 106), new ECB_default(4, 107)), new ECBlocks_default(28, new ECB_default(8, 47), new ECB_default(13, 48)), new ECBlocks_default(30, new ECB_default(7, 24), new ECB_default(22, 25)), new ECBlocks_default(30, new ECB_default(22, 15), new ECB_default(13, 16))),
        new Version3(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_default(28, new ECB_default(10, 114), new ECB_default(2, 115)), new ECBlocks_default(28, new ECB_default(19, 46), new ECB_default(4, 47)), new ECBlocks_default(28, new ECB_default(28, 22), new ECB_default(6, 23)), new ECBlocks_default(30, new ECB_default(33, 16), new ECB_default(4, 17))),
        new Version3(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_default(30, new ECB_default(8, 122), new ECB_default(4, 123)), new ECBlocks_default(28, new ECB_default(22, 45), new ECB_default(3, 46)), new ECBlocks_default(30, new ECB_default(8, 23), new ECB_default(26, 24)), new ECBlocks_default(30, new ECB_default(12, 15), new ECB_default(28, 16))),
        new Version3(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_default(30, new ECB_default(3, 117), new ECB_default(10, 118)), new ECBlocks_default(28, new ECB_default(3, 45), new ECB_default(23, 46)), new ECBlocks_default(30, new ECB_default(4, 24), new ECB_default(31, 25)), new ECBlocks_default(30, new ECB_default(11, 15), new ECB_default(31, 16))),
        new Version3(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_default(30, new ECB_default(7, 116), new ECB_default(7, 117)), new ECBlocks_default(28, new ECB_default(21, 45), new ECB_default(7, 46)), new ECBlocks_default(30, new ECB_default(1, 23), new ECB_default(37, 24)), new ECBlocks_default(30, new ECB_default(19, 15), new ECB_default(26, 16))),
        new Version3(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_default(30, new ECB_default(5, 115), new ECB_default(10, 116)), new ECBlocks_default(28, new ECB_default(19, 47), new ECB_default(10, 48)), new ECBlocks_default(30, new ECB_default(15, 24), new ECB_default(25, 25)), new ECBlocks_default(30, new ECB_default(23, 15), new ECB_default(25, 16))),
        new Version3(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_default(30, new ECB_default(13, 115), new ECB_default(3, 116)), new ECBlocks_default(28, new ECB_default(2, 46), new ECB_default(29, 47)), new ECBlocks_default(30, new ECB_default(42, 24), new ECB_default(1, 25)), new ECBlocks_default(30, new ECB_default(23, 15), new ECB_default(28, 16))),
        new Version3(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_default(30, new ECB_default(17, 115)), new ECBlocks_default(28, new ECB_default(10, 46), new ECB_default(23, 47)), new ECBlocks_default(30, new ECB_default(10, 24), new ECB_default(35, 25)), new ECBlocks_default(30, new ECB_default(19, 15), new ECB_default(35, 16))),
        new Version3(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_default(30, new ECB_default(17, 115), new ECB_default(1, 116)), new ECBlocks_default(28, new ECB_default(14, 46), new ECB_default(21, 47)), new ECBlocks_default(30, new ECB_default(29, 24), new ECB_default(19, 25)), new ECBlocks_default(30, new ECB_default(11, 15), new ECB_default(46, 16))),
        new Version3(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_default(30, new ECB_default(13, 115), new ECB_default(6, 116)), new ECBlocks_default(28, new ECB_default(14, 46), new ECB_default(23, 47)), new ECBlocks_default(30, new ECB_default(44, 24), new ECB_default(7, 25)), new ECBlocks_default(30, new ECB_default(59, 16), new ECB_default(1, 17))),
        new Version3(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_default(30, new ECB_default(12, 121), new ECB_default(7, 122)), new ECBlocks_default(28, new ECB_default(12, 47), new ECB_default(26, 48)), new ECBlocks_default(30, new ECB_default(39, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(22, 15), new ECB_default(41, 16))),
        new Version3(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_default(30, new ECB_default(6, 121), new ECB_default(14, 122)), new ECBlocks_default(28, new ECB_default(6, 47), new ECB_default(34, 48)), new ECBlocks_default(30, new ECB_default(46, 24), new ECB_default(10, 25)), new ECBlocks_default(30, new ECB_default(2, 15), new ECB_default(64, 16))),
        new Version3(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_default(30, new ECB_default(17, 122), new ECB_default(4, 123)), new ECBlocks_default(28, new ECB_default(29, 46), new ECB_default(14, 47)), new ECBlocks_default(30, new ECB_default(49, 24), new ECB_default(10, 25)), new ECBlocks_default(30, new ECB_default(24, 15), new ECB_default(46, 16))),
        new Version3(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_default(30, new ECB_default(4, 122), new ECB_default(18, 123)), new ECBlocks_default(28, new ECB_default(13, 46), new ECB_default(32, 47)), new ECBlocks_default(30, new ECB_default(48, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(42, 15), new ECB_default(32, 16))),
        new Version3(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_default(30, new ECB_default(20, 117), new ECB_default(4, 118)), new ECBlocks_default(28, new ECB_default(40, 47), new ECB_default(7, 48)), new ECBlocks_default(30, new ECB_default(43, 24), new ECB_default(22, 25)), new ECBlocks_default(30, new ECB_default(10, 15), new ECB_default(67, 16))),
        new Version3(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_default(30, new ECB_default(19, 118), new ECB_default(6, 119)), new ECBlocks_default(28, new ECB_default(18, 47), new ECB_default(31, 48)), new ECBlocks_default(30, new ECB_default(34, 24), new ECB_default(34, 25)), new ECBlocks_default(30, new ECB_default(20, 15), new ECB_default(61, 16)))
      ];
      return Version3;
    }()
  );
  var Version_default2 = Version2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/DataMask.js
  var DataMaskValues;
  (function(DataMaskValues2) {
    DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
    DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
    DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
    DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
    DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
    DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
    DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
    DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
  })(DataMaskValues || (DataMaskValues = {}));
  var DataMask = (
    /** @class */
    function() {
      function DataMask2(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
      }
      DataMask2.prototype.unmaskBitMatrix = function(bits, dimension) {
        for (var i = 0; i < dimension; i++) {
          for (var j = 0; j < dimension; j++) {
            if (this.isMasked(i, j)) {
              bits.flip(j, i);
            }
          }
        }
      };
      DataMask2.values = /* @__PURE__ */ new Map([
        /**
         * 000: mask bits for which (x + y) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_000, new DataMask2(DataMaskValues.DATA_MASK_000, function(i, j) {
          return (i + j & 1) === 0;
        })],
        /**
         * 001: mask bits for which x mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_001, new DataMask2(DataMaskValues.DATA_MASK_001, function(i, j) {
          return (i & 1) === 0;
        })],
        /**
         * 010: mask bits for which y mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_010, new DataMask2(DataMaskValues.DATA_MASK_010, function(i, j) {
          return j % 3 === 0;
        })],
        /**
         * 011: mask bits for which (x + y) mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_011, new DataMask2(DataMaskValues.DATA_MASK_011, function(i, j) {
          return (i + j) % 3 === 0;
        })],
        /**
         * 100: mask bits for which (x/2 + y/3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_100, new DataMask2(DataMaskValues.DATA_MASK_100, function(i, j) {
          return (Math.floor(i / 2) + Math.floor(j / 3) & 1) === 0;
        })],
        /**
         * 101: mask bits for which xy mod 2 + xy mod 3 == 0
         * equivalently, such that xy mod 6 == 0
         */
        [DataMaskValues.DATA_MASK_101, new DataMask2(DataMaskValues.DATA_MASK_101, function(i, j) {
          return i * j % 6 === 0;
        })],
        /**
         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that xy mod 6 < 3
         */
        [DataMaskValues.DATA_MASK_110, new DataMask2(DataMaskValues.DATA_MASK_110, function(i, j) {
          return i * j % 6 < 3;
        })],
        /**
         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that (x + y + xy mod 3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_111, new DataMask2(DataMaskValues.DATA_MASK_111, function(i, j) {
          return (i + j + i * j % 3 & 1) === 0;
        })]
      ]);
      return DataMask2;
    }()
  );
  var DataMask_default = DataMask;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/BitMatrixParser.js
  var BitMatrixParser2 = (
    /** @class */
    function() {
      function BitMatrixParser3(bitMatrix) {
        var dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 3) !== 1) {
          throw new FormatException_default();
        }
        this.bitMatrix = bitMatrix;
      }
      BitMatrixParser3.prototype.readFormatInformation = function() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
          return this.parsedFormatInfo;
        }
        var formatInfoBits1 = 0;
        for (var i = 0; i < 6; i++) {
          formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
        }
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        for (var j = 5; j >= 0; j--) {
          formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
        }
        var dimension = this.bitMatrix.getHeight();
        var formatInfoBits2 = 0;
        var jMin = dimension - 7;
        for (var j = dimension - 1; j >= jMin; j--) {
          formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
        }
        for (var i = dimension - 8; i < dimension; i++) {
          formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation_default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
          return this.parsedFormatInfo;
        }
        throw new FormatException_default();
      };
      BitMatrixParser3.prototype.readVersion = function() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
          return this.parsedVersion;
        }
        var dimension = this.bitMatrix.getHeight();
        var provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
          return Version_default2.getVersionForNumber(provisionalVersion);
        }
        var versionBits = 0;
        var ijMin = dimension - 11;
        for (var j = 5; j >= 0; j--) {
          for (var i = dimension - 9; i >= ijMin; i--) {
            versionBits = this.copyBit(i, j, versionBits);
          }
        }
        var theParsedVersion = Version_default2.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        versionBits = 0;
        for (var i = 5; i >= 0; i--) {
          for (var j = dimension - 9; j >= ijMin; j--) {
            versionBits = this.copyBit(i, j, versionBits);
          }
        }
        theParsedVersion = Version_default2.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        throw new FormatException_default();
      };
      BitMatrixParser3.prototype.copyBit = function(i, j, versionBits) {
        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
        return bit ? versionBits << 1 | 1 : versionBits << 1;
      };
      BitMatrixParser3.prototype.readCodewords = function() {
        var formatInfo = this.readFormatInformation();
        var version = this.readVersion();
        var dataMask = DataMask_default.values.get(formatInfo.getDataMask());
        var dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        var functionPattern = version.buildFunctionPattern();
        var readingUp = true;
        var result = new Uint8Array(version.getTotalCodewords());
        var resultOffset = 0;
        var currentByte = 0;
        var bitsRead = 0;
        for (var j = dimension - 1; j > 0; j -= 2) {
          if (j === 6) {
            j--;
          }
          for (var count = 0; count < dimension; count++) {
            var i = readingUp ? dimension - 1 - count : count;
            for (var col = 0; col < 2; col++) {
              if (!functionPattern.get(j - col, i)) {
                bitsRead++;
                currentByte <<= 1;
                if (this.bitMatrix.get(j - col, i)) {
                  currentByte |= 1;
                }
                if (bitsRead === 8) {
                  result[resultOffset++] = /*(byte) */
                  currentByte;
                  bitsRead = 0;
                  currentByte = 0;
                }
              }
            }
          }
          readingUp = !readingUp;
        }
        if (resultOffset !== version.getTotalCodewords()) {
          throw new FormatException_default();
        }
        return result;
      };
      BitMatrixParser3.prototype.remask = function() {
        if (this.parsedFormatInfo === null) {
          return;
        }
        var dataMask = DataMask_default.values.get(this.parsedFormatInfo.getDataMask());
        var dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
      };
      BitMatrixParser3.prototype.setMirror = function(isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
      };
      BitMatrixParser3.prototype.mirror = function() {
        var bitMatrix = this.bitMatrix;
        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {
          for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
            if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
              bitMatrix.flip(y, x);
              bitMatrix.flip(x, y);
            }
          }
        }
      };
      return BitMatrixParser3;
    }()
  );
  var BitMatrixParser_default2 = BitMatrixParser2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/DataBlock.js
  var __values24 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var DataBlock2 = (
    /** @class */
    function() {
      function DataBlock3(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      DataBlock3.getDataBlocks = function(rawCodewords, version, ecLevel) {
        var e_1, _a2, e_2, _b;
        if (rawCodewords.length !== version.getTotalCodewords()) {
          throw new IllegalArgumentException_default();
        }
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var totalBlocks = 0;
        var ecBlockArray = ecBlocks.getECBlocks();
        try {
          for (var ecBlockArray_1 = __values24(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
            var ecBlock = ecBlockArray_1_1.value;
            totalBlocks += ecBlock.getCount();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a2 = ecBlockArray_1.return)) _a2.call(ecBlockArray_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var result = new Array(totalBlocks);
        var numResultBlocks = 0;
        try {
          for (var ecBlockArray_2 = __values24(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
            var ecBlock = ecBlockArray_2_1.value;
            for (var i = 0; i < ecBlock.getCount(); i++) {
              var numDataCodewords = ecBlock.getDataCodewords();
              var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
              result[numResultBlocks++] = new DataBlock3(numDataCodewords, new Uint8Array(numBlockCodewords));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        var shorterBlocksTotalCodewords = result[0].codewords.length;
        var longerBlocksStartAt = result.length - 1;
        while (longerBlocksStartAt >= 0) {
          var numCodewords = result[longerBlocksStartAt].codewords.length;
          if (numCodewords === shorterBlocksTotalCodewords) {
            break;
          }
          longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        var rawCodewordsOffset = 0;
        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
          }
        }
        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
          result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        var max2 = result[0].codewords.length;
        for (var i = shorterBlocksNumDataCodewords; i < max2; i++) {
          for (var j = 0; j < numResultBlocks; j++) {
            var iOffset = j < longerBlocksStartAt ? i : i + 1;
            result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        return result;
      };
      DataBlock3.prototype.getNumDataCodewords = function() {
        return this.numDataCodewords;
      };
      DataBlock3.prototype.getCodewords = function() {
        return this.codewords;
      };
      return DataBlock3;
    }()
  );
  var DataBlock_default2 = DataBlock2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/Mode.js
  var ModeValues;
  (function(ModeValues2) {
    ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
    ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
    ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
    ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
    ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
    ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
    ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
    ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
    ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
    ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
  })(ModeValues || (ModeValues = {}));
  var Mode2 = (
    /** @class */
    function() {
      function Mode5(value, stringValue, characterCountBitsForVersions, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits;
        Mode5.FOR_BITS.set(bits, this);
        Mode5.FOR_VALUE.set(value, this);
      }
      Mode5.forBits = function(bits) {
        var mode = Mode5.FOR_BITS.get(bits);
        if (void 0 === mode) {
          throw new IllegalArgumentException_default();
        }
        return mode;
      };
      Mode5.prototype.getCharacterCountBits = function(version) {
        var versionNumber = version.getVersionNumber();
        var offset2;
        if (versionNumber <= 9) {
          offset2 = 0;
        } else if (versionNumber <= 26) {
          offset2 = 1;
        } else {
          offset2 = 2;
        }
        return this.characterCountBitsForVersions[offset2];
      };
      Mode5.prototype.getValue = function() {
        return this.value;
      };
      Mode5.prototype.getBits = function() {
        return this.bits;
      };
      Mode5.prototype.equals = function(o) {
        if (!(o instanceof Mode5)) {
          return false;
        }
        var other = o;
        return this.value === other.value;
      };
      Mode5.prototype.toString = function() {
        return this.stringValue;
      };
      Mode5.FOR_BITS = /* @__PURE__ */ new Map();
      Mode5.FOR_VALUE = /* @__PURE__ */ new Map();
      Mode5.TERMINATOR = new Mode5(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
      Mode5.NUMERIC = new Mode5(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
      Mode5.ALPHANUMERIC = new Mode5(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
      Mode5.STRUCTURED_APPEND = new Mode5(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
      Mode5.BYTE = new Mode5(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
      Mode5.ECI = new Mode5(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
      Mode5.KANJI = new Mode5(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
      Mode5.FNC1_FIRST_POSITION = new Mode5(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
      Mode5.FNC1_SECOND_POSITION = new Mode5(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
      Mode5.HANZI = new Mode5(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
      return Mode5;
    }()
  );
  var Mode_default = Mode2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/DecodedBitStreamParser.js
  var DecodedBitStreamParser2 = (
    /** @class */
    function() {
      function DecodedBitStreamParser4() {
      }
      DecodedBitStreamParser4.decode = function(bytes, version, ecLevel, hints) {
        var bits = new BitSource_default(bytes);
        var result = new StringBuilder_default();
        var byteSegments = new Array();
        var symbolSequence = -1;
        var parityData = -1;
        try {
          var currentCharacterSetECI = null;
          var fc1InEffect = false;
          var mode = void 0;
          do {
            if (bits.available() < 4) {
              mode = Mode_default.TERMINATOR;
            } else {
              var modeBits = bits.readBits(4);
              mode = Mode_default.forBits(modeBits);
            }
            switch (mode) {
              case Mode_default.TERMINATOR:
                break;
              case Mode_default.FNC1_FIRST_POSITION:
              case Mode_default.FNC1_SECOND_POSITION:
                fc1InEffect = true;
                break;
              case Mode_default.STRUCTURED_APPEND:
                if (bits.available() < 16) {
                  throw new FormatException_default();
                }
                symbolSequence = bits.readBits(8);
                parityData = bits.readBits(8);
                break;
              case Mode_default.ECI:
                var value = DecodedBitStreamParser4.parseECIValue(bits);
                currentCharacterSetECI = CharacterSetECI_default.getCharacterSetECIByValue(value);
                if (currentCharacterSetECI === null) {
                  throw new FormatException_default();
                }
                break;
              case Mode_default.HANZI:
                var subset = bits.readBits(4);
                var countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                if (subset === DecodedBitStreamParser4.GB2312_SUBSET) {
                  DecodedBitStreamParser4.decodeHanziSegment(bits, result, countHanzi);
                }
                break;
              default:
                var count = bits.readBits(mode.getCharacterCountBits(version));
                switch (mode) {
                  case Mode_default.NUMERIC:
                    DecodedBitStreamParser4.decodeNumericSegment(bits, result, count);
                    break;
                  case Mode_default.ALPHANUMERIC:
                    DecodedBitStreamParser4.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                    break;
                  case Mode_default.BYTE:
                    DecodedBitStreamParser4.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                    break;
                  case Mode_default.KANJI:
                    DecodedBitStreamParser4.decodeKanjiSegment(bits, result, count);
                    break;
                  default:
                    throw new FormatException_default();
                }
                break;
            }
          } while (mode !== Mode_default.TERMINATOR);
        } catch (iae) {
          throw new FormatException_default();
        }
        return new DecoderResult_default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
      };
      DecodedBitStreamParser4.decodeHanziSegment = function(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException_default();
        }
        var buffer = new Uint8Array(2 * count);
        var offset2 = 0;
        while (count > 0) {
          var twoBytes = bits.readBits(13);
          var assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
          if (assembledTwoBytes < 959) {
            assembledTwoBytes += 41377;
          } else {
            assembledTwoBytes += 42657;
          }
          buffer[offset2] = /*(byte) */
          assembledTwoBytes >> 8 & 255;
          buffer[offset2 + 1] = /*(byte) */
          assembledTwoBytes & 255;
          offset2 += 2;
          count--;
        }
        try {
          result.append(StringEncoding_default.decode(buffer, StringUtils_default.GB2312));
        } catch (ignored) {
          throw new FormatException_default(ignored);
        }
      };
      DecodedBitStreamParser4.decodeKanjiSegment = function(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException_default();
        }
        var buffer = new Uint8Array(2 * count);
        var offset2 = 0;
        while (count > 0) {
          var twoBytes = bits.readBits(13);
          var assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
          if (assembledTwoBytes < 7936) {
            assembledTwoBytes += 33088;
          } else {
            assembledTwoBytes += 49472;
          }
          buffer[offset2] = /*(byte) */
          assembledTwoBytes >> 8;
          buffer[offset2 + 1] = /*(byte) */
          assembledTwoBytes;
          offset2 += 2;
          count--;
        }
        try {
          result.append(StringEncoding_default.decode(buffer, StringUtils_default.SHIFT_JIS));
        } catch (ignored) {
          throw new FormatException_default(ignored);
        }
      };
      DecodedBitStreamParser4.decodeByteSegment = function(bits, result, count, currentCharacterSetECI, byteSegments, hints) {
        if (8 * count > bits.available()) {
          throw new FormatException_default();
        }
        var readBytes = new Uint8Array(count);
        for (var i = 0; i < count; i++) {
          readBytes[i] = /*(byte) */
          bits.readBits(8);
        }
        var encoding;
        if (currentCharacterSetECI === null) {
          encoding = StringUtils_default.guessEncoding(readBytes, hints);
        } else {
          encoding = currentCharacterSetECI.getName();
        }
        try {
          result.append(StringEncoding_default.decode(readBytes, encoding));
        } catch (ignored) {
          throw new FormatException_default(ignored);
        }
        byteSegments.push(readBytes);
      };
      DecodedBitStreamParser4.toAlphaNumericChar = function(value) {
        if (value >= DecodedBitStreamParser4.ALPHANUMERIC_CHARS.length) {
          throw new FormatException_default();
        }
        return DecodedBitStreamParser4.ALPHANUMERIC_CHARS[value];
      };
      DecodedBitStreamParser4.decodeAlphanumericSegment = function(bits, result, count, fc1InEffect) {
        var start3 = result.length();
        while (count > 1) {
          if (bits.available() < 11) {
            throw new FormatException_default();
          }
          var nextTwoCharsBits = bits.readBits(11);
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(nextTwoCharsBits % 45));
          count -= 2;
        }
        if (count === 1) {
          if (bits.available() < 6) {
            throw new FormatException_default();
          }
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(bits.readBits(6)));
        }
        if (fc1InEffect) {
          for (var i = start3; i < result.length(); i++) {
            if (result.charAt(i) === "%") {
              if (i < result.length() - 1 && result.charAt(i + 1) === "%") {
                result.deleteCharAt(i + 1);
              } else {
                result.setCharAt(i, String.fromCharCode(29));
              }
            }
          }
        }
      };
      DecodedBitStreamParser4.decodeNumericSegment = function(bits, result, count) {
        while (count >= 3) {
          if (bits.available() < 10) {
            throw new FormatException_default();
          }
          var threeDigitsBits = bits.readBits(10);
          if (threeDigitsBits >= 1e3) {
            throw new FormatException_default();
          }
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(threeDigitsBits % 10));
          count -= 3;
        }
        if (count === 2) {
          if (bits.available() < 7) {
            throw new FormatException_default();
          }
          var twoDigitsBits = bits.readBits(7);
          if (twoDigitsBits >= 100) {
            throw new FormatException_default();
          }
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(twoDigitsBits % 10));
        } else if (count === 1) {
          if (bits.available() < 4) {
            throw new FormatException_default();
          }
          var digitBits = bits.readBits(4);
          if (digitBits >= 10) {
            throw new FormatException_default();
          }
          result.append(DecodedBitStreamParser4.toAlphaNumericChar(digitBits));
        }
      };
      DecodedBitStreamParser4.parseECIValue = function(bits) {
        var firstByte = bits.readBits(8);
        if ((firstByte & 128) === 0) {
          return firstByte & 127;
        }
        if ((firstByte & 192) === 128) {
          var secondByte = bits.readBits(8);
          return (firstByte & 63) << 8 & 4294967295 | secondByte;
        }
        if ((firstByte & 224) === 192) {
          var secondThirdBytes = bits.readBits(16);
          return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
        }
        throw new FormatException_default();
      };
      DecodedBitStreamParser4.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      DecodedBitStreamParser4.GB2312_SUBSET = 1;
      return DecodedBitStreamParser4;
    }()
  );
  var DecodedBitStreamParser_default2 = DecodedBitStreamParser2;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/QRCodeDecoderMetaData.js
  var QRCodeDecoderMetaData = (
    /** @class */
    function() {
      function QRCodeDecoderMetaData2(mirrored) {
        this.mirrored = mirrored;
      }
      QRCodeDecoderMetaData2.prototype.isMirrored = function() {
        return this.mirrored;
      };
      QRCodeDecoderMetaData2.prototype.applyMirroredCorrection = function(points) {
        if (!this.mirrored || points === null || points.length < 3) {
          return;
        }
        var bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
      };
      return QRCodeDecoderMetaData2;
    }()
  );
  var QRCodeDecoderMetaData_default = QRCodeDecoderMetaData;

  // node_modules/@zxing/library/esm/core/qrcode/decoder/Decoder.js
  var __values25 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Decoder3 = (
    /** @class */
    function() {
      function Decoder4() {
        this.rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.QR_CODE_FIELD_256);
      }
      Decoder4.prototype.decodeBooleanArray = function(image, hints) {
        return this.decodeBitMatrix(BitMatrix_default.parseFromBooleanArray(image), hints);
      };
      Decoder4.prototype.decodeBitMatrix = function(bits, hints) {
        var parser = new BitMatrixParser_default2(bits);
        var ex = null;
        try {
          return this.decodeBitMatrixParser(parser, hints);
        } catch (e) {
          ex = e;
        }
        try {
          parser.remask();
          parser.setMirror(true);
          parser.readVersion();
          parser.readFormatInformation();
          parser.mirror();
          var result = this.decodeBitMatrixParser(parser, hints);
          result.setOther(new QRCodeDecoderMetaData_default(true));
          return result;
        } catch (e) {
          if (ex !== null) {
            throw ex;
          }
          throw e;
        }
      };
      Decoder4.prototype.decodeBitMatrixParser = function(parser, hints) {
        var e_1, _a2, e_2, _b;
        var version = parser.readVersion();
        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        var codewords = parser.readCodewords();
        var dataBlocks = DataBlock_default2.getDataBlocks(codewords, version, ecLevel);
        var totalBytes = 0;
        try {
          for (var dataBlocks_1 = __values25(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
            var dataBlock = dataBlocks_1_1.value;
            totalBytes += dataBlock.getNumDataCodewords();
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a2 = dataBlocks_1.return)) _a2.call(dataBlocks_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var resultBytes = new Uint8Array(totalBytes);
        var resultOffset = 0;
        try {
          for (var dataBlocks_2 = __values25(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {
            var dataBlock = dataBlocks_2_1.value;
            var codewordBytes = dataBlock.getCodewords();
            var numDataCodewords = dataBlock.getNumDataCodewords();
            this.correctErrors(codewordBytes, numDataCodewords);
            for (var i = 0; i < numDataCodewords; i++) {
              resultBytes[resultOffset++] = codewordBytes[i];
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return DecodedBitStreamParser_default2.decode(resultBytes, version, ecLevel, hints);
      };
      Decoder4.prototype.correctErrors = function(codewordBytes, numDataCodewords) {
        var codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException_default();
        }
        for (var i = 0; i < numDataCodewords; i++) {
          codewordBytes[i] = /*(byte) */
          codewordsInts[i];
        }
      };
      return Decoder4;
    }()
  );
  var Decoder_default3 = Decoder3;

  // node_modules/@zxing/library/esm/core/qrcode/detector/AlignmentPattern.js
  var __extends54 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var AlignmentPattern = (
    /** @class */
    function(_super) {
      __extends54(AlignmentPattern2, _super);
      function AlignmentPattern2(posX, posY, estimatedModuleSize) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize;
        return _this;
      }
      AlignmentPattern2.prototype.aboutEquals = function(moduleSize, i, j) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      };
      AlignmentPattern2.prototype.combineEstimate = function(i, j, newModuleSize) {
        var combinedX = (this.getX() + j) / 2;
        var combinedY = (this.getY() + i) / 2;
        var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
        return new AlignmentPattern2(combinedX, combinedY, combinedModuleSize);
      };
      return AlignmentPattern2;
    }(ResultPoint_default)
  );
  var AlignmentPattern_default = AlignmentPattern;

  // node_modules/@zxing/library/esm/core/qrcode/detector/AlignmentPatternFinder.js
  var __values26 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var AlignmentPatternFinder = (
    /** @class */
    function() {
      function AlignmentPatternFinder2(image, startX, startY, width, height, moduleSize, resultPointCallback) {
        this.image = image;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(3);
      }
      AlignmentPatternFinder2.prototype.find = function() {
        var startX = this.startX;
        var height = this.height;
        var width = this.width;
        var maxJ = startX + width;
        var middleI = this.startY + height / 2;
        var stateCount = new Int32Array(3);
        var image = this.image;
        for (var iGen = 0; iGen < height; iGen++) {
          var i = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          var j = startX;
          while (j < maxJ && !image.get(j, i)) {
            j++;
          }
          var currentState = 0;
          while (j < maxJ) {
            if (image.get(j, i)) {
              if (currentState === 1) {
                stateCount[1]++;
              } else {
                if (currentState === 2) {
                  if (this.foundPatternCross(stateCount)) {
                    var confirmed = this.handlePossibleCenter(stateCount, i, j);
                    if (confirmed !== null) {
                      return confirmed;
                    }
                  }
                  stateCount[0] = stateCount[2];
                  stateCount[1] = 1;
                  stateCount[2] = 0;
                  currentState = 1;
                } else {
                  stateCount[++currentState]++;
                }
              }
            } else {
              if (currentState === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            }
            j++;
          }
          if (this.foundPatternCross(stateCount)) {
            var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
            if (confirmed !== null) {
              return confirmed;
            }
          }
        }
        if (this.possibleCenters.length !== 0) {
          return this.possibleCenters[0];
        }
        throw new NotFoundException_default();
      };
      AlignmentPatternFinder2.centerFromEnd = function(stateCount, end2) {
        return end2 - stateCount[2] - stateCount[1] / 2;
      };
      AlignmentPatternFinder2.prototype.foundPatternCross = function(stateCount) {
        var moduleSize = this.moduleSize;
        var maxVariance = moduleSize / 2;
        for (var i = 0; i < 3; i++) {
          if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
            return false;
          }
        }
        return true;
      };
      AlignmentPatternFinder2.prototype.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
        var image = this.image;
        var maxI = image.getHeight();
        var stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        var i = startI;
        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i--;
        }
        if (i < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i++;
        }
        if (i === maxI || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
          stateCount[2]++;
          i++;
        }
        if (stateCount[2] > maxCount) {
          return NaN;
        }
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder2.centerFromEnd(stateCount, i) : NaN;
      };
      AlignmentPatternFinder2.prototype.handlePossibleCenter = function(stateCount, i, j) {
        var e_1, _a2;
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        var centerJ = AlignmentPatternFinder2.centerFromEnd(stateCount, j);
        var centerI = this.crossCheckVertical(
          i,
          /*(int) */
          centerJ,
          2 * stateCount[1],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
          try {
            for (var _b = __values26(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
              var center = _c.value;
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          var point = new AlignmentPattern_default(centerJ, centerI, estimatedModuleSize);
          this.possibleCenters.push(point);
          if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
            this.resultPointCallback.foundPossibleResultPoint(point);
          }
        }
        return null;
      };
      return AlignmentPatternFinder2;
    }()
  );
  var AlignmentPatternFinder_default = AlignmentPatternFinder;

  // node_modules/@zxing/library/esm/core/qrcode/detector/FinderPattern.js
  var __extends55 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var FinderPattern2 = (
    /** @class */
    function(_super) {
      __extends55(FinderPattern3, _super);
      function FinderPattern3(posX, posY, estimatedModuleSize, count) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize;
        _this.count = count;
        if (void 0 === count) {
          _this.count = 1;
        }
        return _this;
      }
      FinderPattern3.prototype.getEstimatedModuleSize = function() {
        return this.estimatedModuleSize;
      };
      FinderPattern3.prototype.getCount = function() {
        return this.count;
      };
      FinderPattern3.prototype.aboutEquals = function(moduleSize, i, j) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      };
      FinderPattern3.prototype.combineEstimate = function(i, j, newModuleSize) {
        var combinedCount = this.count + 1;
        var combinedX = (this.count * this.getX() + j) / combinedCount;
        var combinedY = (this.count * this.getY() + i) / combinedCount;
        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern3(combinedX, combinedY, combinedModuleSize, combinedCount);
      };
      return FinderPattern3;
    }(ResultPoint_default)
  );
  var FinderPattern_default2 = FinderPattern2;

  // node_modules/@zxing/library/esm/core/qrcode/detector/FinderPatternInfo.js
  var FinderPatternInfo = (
    /** @class */
    function() {
      function FinderPatternInfo2(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
      }
      FinderPatternInfo2.prototype.getBottomLeft = function() {
        return this.bottomLeft;
      };
      FinderPatternInfo2.prototype.getTopLeft = function() {
        return this.topLeft;
      };
      FinderPatternInfo2.prototype.getTopRight = function() {
        return this.topRight;
      };
      return FinderPatternInfo2;
    }()
  );
  var FinderPatternInfo_default = FinderPatternInfo;

  // node_modules/@zxing/library/esm/core/qrcode/detector/FinderPatternFinder.js
  var __values27 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var FinderPatternFinder = (
    /** @class */
    function() {
      function FinderPatternFinder2(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
      }
      FinderPatternFinder2.prototype.getImage = function() {
        return this.image;
      };
      FinderPatternFinder2.prototype.getPossibleCenters = function() {
        return this.possibleCenters;
      };
      FinderPatternFinder2.prototype.find = function(hints) {
        var tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType_default.TRY_HARDER);
        var pureBarcode = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType_default.PURE_BARCODE);
        var image = this.image;
        var maxI = image.getHeight();
        var maxJ = image.getWidth();
        var iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder2.MAX_MODULES));
        if (iSkip < FinderPatternFinder2.MIN_SKIP || tryHarder) {
          iSkip = FinderPatternFinder2.MIN_SKIP;
        }
        var done = false;
        var stateCount = new Int32Array(5);
        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          stateCount[3] = 0;
          stateCount[4] = 0;
          var currentState = 0;
          for (var j = 0; j < maxJ; j++) {
            if (image.get(j, i)) {
              if ((currentState & 1) === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            } else {
              if ((currentState & 1) === 0) {
                if (currentState === 4) {
                  if (FinderPatternFinder2.foundPatternCross(stateCount)) {
                    var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                    if (confirmed === true) {
                      iSkip = 2;
                      if (this.hasSkipped === true) {
                        done = this.haveMultiplyConfirmedCenters();
                      } else {
                        var rowSkip = this.findRowSkip();
                        if (rowSkip > stateCount[2]) {
                          i += rowSkip - stateCount[2] - iSkip;
                          j = maxJ - 1;
                        }
                      }
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3;
                      continue;
                    }
                    currentState = 0;
                    stateCount[0] = 0;
                    stateCount[1] = 0;
                    stateCount[2] = 0;
                    stateCount[3] = 0;
                    stateCount[4] = 0;
                  } else {
                    stateCount[0] = stateCount[2];
                    stateCount[1] = stateCount[3];
                    stateCount[2] = stateCount[4];
                    stateCount[3] = 1;
                    stateCount[4] = 0;
                    currentState = 3;
                  }
                } else {
                  stateCount[++currentState]++;
                }
              } else {
                stateCount[currentState]++;
              }
            }
          }
          if (FinderPatternFinder2.foundPatternCross(stateCount)) {
            var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
            if (confirmed === true) {
              iSkip = stateCount[0];
              if (this.hasSkipped) {
                done = this.haveMultiplyConfirmedCenters();
              }
            }
          }
        }
        var patternInfo = this.selectBestPatterns();
        ResultPoint_default.orderBestPatterns(patternInfo);
        return new FinderPatternInfo_default(patternInfo);
      };
      FinderPatternFinder2.centerFromEnd = function(stateCount, end2) {
        return end2 - stateCount[4] - stateCount[3] - stateCount[2] / 2;
      };
      FinderPatternFinder2.foundPatternCross = function(stateCount) {
        var totalModuleSize = 0;
        for (var i = 0; i < 5; i++) {
          var count = stateCount[i];
          if (count === 0) {
            return false;
          }
          totalModuleSize += count;
        }
        if (totalModuleSize < 7) {
          return false;
        }
        var moduleSize = totalModuleSize / 7;
        var maxVariance = moduleSize / 2;
        return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
      };
      FinderPatternFinder2.prototype.getCrossCheckStateCount = function() {
        var crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
      };
      FinderPatternFinder2.prototype.crossCheckDiagonal = function(startI, centerJ, maxCount, originalStateCountTotal) {
        var stateCount = this.getCrossCheckStateCount();
        var i = 0;
        var image = this.image;
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
          stateCount[2]++;
          i++;
        }
        if (startI < i || centerJ < i) {
          return false;
        }
        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i++;
        }
        if (startI < i || centerJ < i || stateCount[1] > maxCount) {
          return false;
        }
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i++;
        }
        if (stateCount[0] > maxCount) {
          return false;
        }
        var maxI = image.getHeight();
        var maxJ = image.getWidth();
        i = 1;
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
          stateCount[2]++;
          i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ) {
          return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
          return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i++;
        }
        if (stateCount[4] >= maxCount) {
          return false;
        }
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder2.foundPatternCross(stateCount);
      };
      FinderPatternFinder2.prototype.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
        var image = this.image;
        var maxI = image.getHeight();
        var stateCount = this.getCrossCheckStateCount();
        var i = startI;
        while (i >= 0 && image.get(centerJ, i)) {
          stateCount[2]++;
          i--;
        }
        if (i < 0) {
          return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i--;
        }
        if (i < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i)) {
          stateCount[2]++;
          i++;
        }
        if (i === maxI) {
          return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i++;
        }
        if (i === maxI || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder2.foundPatternCross(stateCount) ? FinderPatternFinder2.centerFromEnd(stateCount, i) : NaN;
      };
      FinderPatternFinder2.prototype.crossCheckHorizontal = function(startJ, centerI, maxCount, originalStateCountTotal) {
        var image = this.image;
        var maxJ = image.getWidth();
        var stateCount = this.getCrossCheckStateCount();
        var j = startJ;
        while (j >= 0 && image.get(j, centerI)) {
          stateCount[2]++;
          j--;
        }
        if (j < 0) {
          return NaN;
        }
        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          j--;
        }
        if (j < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          j--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        j = startJ + 1;
        while (j < maxJ && image.get(j, centerI)) {
          stateCount[2]++;
          j++;
        }
        if (j === maxJ) {
          return NaN;
        }
        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
          stateCount[3]++;
          j++;
        }
        if (j === maxJ || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
          stateCount[4]++;
          j++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder2.foundPatternCross(stateCount) ? FinderPatternFinder2.centerFromEnd(stateCount, j) : NaN;
      };
      FinderPatternFinder2.prototype.handlePossibleCenter = function(stateCount, i, j, pureBarcode) {
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        var centerJ = FinderPatternFinder2.centerFromEnd(stateCount, j);
        var centerI = this.crossCheckVertical(
          i,
          /*(int) */
          Math.floor(centerJ),
          stateCount[2],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          centerJ = this.crossCheckHorizontal(
            /*(int) */
            Math.floor(centerJ),
            /*(int) */
            Math.floor(centerI),
            stateCount[2],
            stateCountTotal
          );
          if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(
            /*(int) */
            Math.floor(centerI),
            /*(int) */
            Math.floor(centerJ),
            stateCount[2],
            stateCountTotal
          ))) {
            var estimatedModuleSize = stateCountTotal / 7;
            var found2 = false;
            var possibleCenters = this.possibleCenters;
            for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {
              var center = possibleCenters[index];
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                found2 = true;
                break;
              }
            }
            if (!found2) {
              var point = new FinderPattern_default2(centerJ, centerI, estimatedModuleSize);
              possibleCenters.push(point);
              if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                this.resultPointCallback.foundPossibleResultPoint(point);
              }
            }
            return true;
          }
        }
        return false;
      };
      FinderPatternFinder2.prototype.findRowSkip = function() {
        var e_1, _a2;
        var max2 = this.possibleCenters.length;
        if (max2 <= 1) {
          return 0;
        }
        var firstConfirmedCenter = null;
        try {
          for (var _b = __values27(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var center = _c.value;
            if (center.getCount() >= FinderPatternFinder2.CENTER_QUORUM) {
              if (firstConfirmedCenter == null) {
                firstConfirmedCenter = center;
              } else {
                this.hasSkipped = true;
                return (
                  /*(int) */
                  Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2)
                );
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return 0;
      };
      FinderPatternFinder2.prototype.haveMultiplyConfirmedCenters = function() {
        var e_2, _a2, e_3, _b;
        var confirmedCount = 0;
        var totalModuleSize = 0;
        var max2 = this.possibleCenters.length;
        try {
          for (var _c = __values27(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
            var pattern = _d.value;
            if (pattern.getCount() >= FinderPatternFinder2.CENTER_QUORUM) {
              confirmedCount++;
              totalModuleSize += pattern.getEstimatedModuleSize();
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return)) _a2.call(_c);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        if (confirmedCount < 3) {
          return false;
        }
        var average = totalModuleSize / max2;
        var totalDeviation = 0;
        try {
          for (var _e = __values27(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {
            var pattern = _f.value;
            totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        return totalDeviation <= 0.05 * totalModuleSize;
      };
      FinderPatternFinder2.prototype.selectBestPatterns = function() {
        var e_4, _a2, e_5, _b;
        var startSize = this.possibleCenters.length;
        if (startSize < 3) {
          throw new NotFoundException_default();
        }
        var possibleCenters = this.possibleCenters;
        var average;
        if (startSize > 3) {
          var totalModuleSize = 0;
          var square = 0;
          try {
            for (var _c = __values27(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
              var center = _d.value;
              var size = center.getEstimatedModuleSize();
              totalModuleSize += size;
              square += size * size;
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (_d && !_d.done && (_a2 = _c.return)) _a2.call(_c);
            } finally {
              if (e_4) throw e_4.error;
            }
          }
          average = totalModuleSize / startSize;
          var stdDev = Math.sqrt(square / startSize - average * average);
          possibleCenters.sort(
            /**
             * <p>Orders by furthest from average</p>
             */
            // FurthestFromAverageComparator implements Comparator<FinderPattern>
            function(center1, center2) {
              var dA = Math.abs(center2.getEstimatedModuleSize() - average);
              var dB = Math.abs(center1.getEstimatedModuleSize() - average);
              return dA < dB ? -1 : dA > dB ? 1 : 0;
            }
          );
          var limit = Math.max(0.2 * average, stdDev);
          for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
            var pattern = possibleCenters[i];
            if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
              possibleCenters.splice(i, 1);
              i--;
            }
          }
        }
        if (possibleCenters.length > 3) {
          var totalModuleSize = 0;
          try {
            for (var possibleCenters_1 = __values27(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {
              var possibleCenter = possibleCenters_1_1.value;
              totalModuleSize += possibleCenter.getEstimatedModuleSize();
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);
            } finally {
              if (e_5) throw e_5.error;
            }
          }
          average = totalModuleSize / possibleCenters.length;
          possibleCenters.sort(
            /**
             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
             */
            // CenterComparator implements Comparator<FinderPattern>
            function(center1, center2) {
              if (center2.getCount() === center1.getCount()) {
                var dA = Math.abs(center2.getEstimatedModuleSize() - average);
                var dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? 1 : dA > dB ? -1 : 0;
              } else {
                return center2.getCount() - center1.getCount();
              }
            }
          );
          possibleCenters.splice(3);
        }
        return [
          possibleCenters[0],
          possibleCenters[1],
          possibleCenters[2]
        ];
      };
      FinderPatternFinder2.CENTER_QUORUM = 2;
      FinderPatternFinder2.MIN_SKIP = 3;
      FinderPatternFinder2.MAX_MODULES = 57;
      return FinderPatternFinder2;
    }()
  );
  var FinderPatternFinder_default = FinderPatternFinder;

  // node_modules/@zxing/library/esm/core/qrcode/detector/Detector.js
  var Detector3 = (
    /** @class */
    function() {
      function Detector5(image) {
        this.image = image;
      }
      Detector5.prototype.getImage = function() {
        return this.image;
      };
      Detector5.prototype.getResultPointCallback = function() {
        return this.resultPointCallback;
      };
      Detector5.prototype.detect = function(hints) {
        this.resultPointCallback = hints === null || hints === void 0 ? null : (
          /*(ResultPointCallback) */
          hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK)
        );
        var finder = new FinderPatternFinder_default(this.image, this.resultPointCallback);
        var info = finder.find(hints);
        return this.processFinderPatternInfo(info);
      };
      Detector5.prototype.processFinderPatternInfo = function(info) {
        var topLeft = info.getTopLeft();
        var topRight = info.getTopRight();
        var bottomLeft = info.getBottomLeft();
        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1) {
          throw new NotFoundException_default("No pattern found in proccess finder.");
        }
        var dimension = Detector5.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        var provisionalVersion = Version_default2.getProvisionalVersionForDimension(dimension);
        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        var alignmentPattern = null;
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
          var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          var correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
          var estAlignmentX = (
            /*(int) */
            Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()))
          );
          var estAlignmentY = (
            /*(int) */
            Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()))
          );
          for (var i = 4; i <= 16; i <<= 1) {
            try {
              alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
              break;
            } catch (re) {
              if (!(re instanceof NotFoundException_default)) {
                throw re;
              }
            }
          }
        }
        var transform = Detector5.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        var bits = Detector5.sampleGrid(this.image, transform, dimension);
        var points;
        if (alignmentPattern === null) {
          points = [bottomLeft, topLeft, topRight];
        } else {
          points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult_default(bits, points);
      };
      Detector5.createTransform = function(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
        var dimMinusThree = dimension - 3.5;
        var bottomRightX;
        var bottomRightY;
        var sourceBottomRightX;
        var sourceBottomRightY;
        if (alignmentPattern !== null) {
          bottomRightX = alignmentPattern.getX();
          bottomRightY = alignmentPattern.getY();
          sourceBottomRightX = dimMinusThree - 3;
          sourceBottomRightY = sourceBottomRightX;
        } else {
          bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          sourceBottomRightX = dimMinusThree;
          sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform_default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
      };
      Detector5.sampleGrid = function(image, transform, dimension) {
        var sampler = GridSamplerInstance_default.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
      };
      Detector5.computeDimension = function(topLeft, topRight, bottomLeft, moduleSize) {
        var tltrCentersDimension = MathUtils_default.round(ResultPoint_default.distance(topLeft, topRight) / moduleSize);
        var tlblCentersDimension = MathUtils_default.round(ResultPoint_default.distance(topLeft, bottomLeft) / moduleSize);
        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 3) {
          // mod 4
          case 0:
            dimension++;
            break;
          // 1? do nothing
          case 2:
            dimension--;
            break;
          case 3:
            throw new NotFoundException_default("Dimensions could be not found.");
        }
        return dimension;
      };
      Detector5.prototype.calculateModuleSize = function(topLeft, topRight, bottomLeft) {
        return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
      };
      Detector5.prototype.calculateModuleSizeOneWay = function(pattern, otherPattern) {
        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY()),
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY())
        );
        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY()),
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY())
        );
        if (isNaN(moduleSizeEst1)) {
          return moduleSizeEst2 / 7;
        }
        if (isNaN(moduleSizeEst2)) {
          return moduleSizeEst1 / 7;
        }
        return (moduleSizeEst1 + moduleSizeEst2) / 14;
      };
      Detector5.prototype.sizeOfBlackWhiteBlackRunBothWays = function(fromX, fromY, toX, toY) {
        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        var scale = 1;
        var otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
          scale = fromX / /*(float) */
          (fromX - otherToX);
          otherToX = 0;
        } else if (otherToX >= this.image.getWidth()) {
          scale = (this.image.getWidth() - 1 - fromX) / /*(float) */
          (otherToX - fromX);
          otherToX = this.image.getWidth() - 1;
        }
        var otherToY = (
          /*(int) */
          Math.floor(fromY - (toY - fromY) * scale)
        );
        scale = 1;
        if (otherToY < 0) {
          scale = fromY / /*(float) */
          (fromY - otherToY);
          otherToY = 0;
        } else if (otherToY >= this.image.getHeight()) {
          scale = (this.image.getHeight() - 1 - fromY) / /*(float) */
          (otherToY - fromY);
          otherToY = this.image.getHeight() - 1;
        }
        otherToX = /*(int) */
        Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        return result - 1;
      };
      Detector5.prototype.sizeOfBlackWhiteBlackRun = function(fromX, fromY, toX, toY) {
        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          var temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        var dx = Math.abs(toX - fromX);
        var dy = Math.abs(toY - fromY);
        var error2 = -dx / 2;
        var xstep = fromX < toX ? 1 : -1;
        var ystep = fromY < toY ? 1 : -1;
        var state = 0;
        var xLimit = toX + xstep;
        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {
          var realX = steep ? y : x;
          var realY = steep ? x : y;
          if (state === 1 === this.image.get(realX, realY)) {
            if (state === 2) {
              return MathUtils_default.distance(x, y, fromX, fromY);
            }
            state++;
          }
          error2 += dy;
          if (error2 > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error2 -= dx;
          }
        }
        if (state === 2) {
          return MathUtils_default.distance(toX + xstep, toY, fromX, fromY);
        }
        return NaN;
      };
      Detector5.prototype.findAlignmentInRegion = function(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
        var allowance = (
          /*(int) */
          Math.floor(allowanceFactor * overallEstModuleSize)
        );
        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
          throw new NotFoundException_default("Alignment top exceeds estimated module size.");
        }
        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
          throw new NotFoundException_default("Alignment bottom exceeds estimated module size.");
        }
        var alignmentFinder = new AlignmentPatternFinder_default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
      };
      return Detector5;
    }()
  );
  var Detector_default3 = Detector3;

  // node_modules/@zxing/library/esm/core/qrcode/QRCodeReader.js
  var QRCodeReader = (
    /** @class */
    function() {
      function QRCodeReader2() {
        this.decoder = new Decoder_default3();
      }
      QRCodeReader2.prototype.getDecoder = function() {
        return this.decoder;
      };
      QRCodeReader2.prototype.decode = function(image, hints) {
        var decoderResult;
        var points;
        if (hints !== void 0 && hints !== null && void 0 !== hints.get(DecodeHintType_default.PURE_BARCODE)) {
          var bits = QRCodeReader2.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decodeBitMatrix(bits, hints);
          points = QRCodeReader2.NO_POINTS;
        } else {
          var detectorResult = new Detector_default3(image.getBlackMatrix()).detect(hints);
          decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
          points = detectorResult.getPoints();
        }
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_default) {
          decoderResult.getOther().applyMirroredCorrection(points);
        }
        var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat_default.QR_CODE, void 0);
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
          result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
          result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
          result.putMetadata(ResultMetadataType_default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
          result.putMetadata(ResultMetadataType_default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
      };
      QRCodeReader2.prototype.reset = function() {
      };
      QRCodeReader2.extractPureBits = function(image) {
        var leftTopBlack = image.getTopLeftOnBit();
        var rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
          throw new NotFoundException_default();
        }
        var moduleSize = this.moduleSize(leftTopBlack, image);
        var top2 = leftTopBlack[1];
        var bottom2 = rightBottomBlack[1];
        var left2 = leftTopBlack[0];
        var right2 = rightBottomBlack[0];
        if (left2 >= right2 || top2 >= bottom2) {
          throw new NotFoundException_default();
        }
        if (bottom2 - top2 !== right2 - left2) {
          right2 = left2 + (bottom2 - top2);
          if (right2 >= image.getWidth()) {
            throw new NotFoundException_default();
          }
        }
        var matrixWidth = Math.round((right2 - left2 + 1) / moduleSize);
        var matrixHeight = Math.round((bottom2 - top2 + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException_default();
        }
        if (matrixHeight !== matrixWidth) {
          throw new NotFoundException_default();
        }
        var nudge = (
          /*(int) */
          Math.floor(moduleSize / 2)
        );
        top2 += nudge;
        left2 += nudge;
        var nudgedTooFarRight = left2 + /*(int) */
        Math.floor((matrixWidth - 1) * moduleSize) - right2;
        if (nudgedTooFarRight > 0) {
          if (nudgedTooFarRight > nudge) {
            throw new NotFoundException_default();
          }
          left2 -= nudgedTooFarRight;
        }
        var nudgedTooFarDown = top2 + /*(int) */
        Math.floor((matrixHeight - 1) * moduleSize) - bottom2;
        if (nudgedTooFarDown > 0) {
          if (nudgedTooFarDown > nudge) {
            throw new NotFoundException_default();
          }
          top2 -= nudgedTooFarDown;
        }
        var bits = new BitMatrix_default(matrixWidth, matrixHeight);
        for (var y = 0; y < matrixHeight; y++) {
          var iOffset = top2 + /*(int) */
          Math.floor(y * moduleSize);
          for (var x = 0; x < matrixWidth; x++) {
            if (image.get(left2 + /*(int) */
            Math.floor(x * moduleSize), iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      };
      QRCodeReader2.moduleSize = function(leftTopBlack, image) {
        var height = image.getHeight();
        var width = image.getWidth();
        var x = leftTopBlack[0];
        var y = leftTopBlack[1];
        var inBlack = true;
        var transitions = 0;
        while (x < width && y < height) {
          if (inBlack !== image.get(x, y)) {
            if (++transitions === 5) {
              break;
            }
            inBlack = !inBlack;
          }
          x++;
          y++;
        }
        if (x === width || y === height) {
          throw new NotFoundException_default();
        }
        return (x - leftTopBlack[0]) / 7;
      };
      QRCodeReader2.NO_POINTS = new Array();
      return QRCodeReader2;
    }()
  );
  var QRCodeReader_default = QRCodeReader;

  // node_modules/@zxing/library/esm/core/pdf417/PDF417Common.js
  var __values28 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var PDF417Common = (
    /** @class */
    function() {
      function PDF417Common2() {
      }
      PDF417Common2.prototype.PDF417Common = function() {
      };
      PDF417Common2.getBitCountSum = function(moduleBitCount) {
        return MathUtils_default.sum(moduleBitCount);
      };
      PDF417Common2.toIntArray = function(list) {
        var e_1, _a2;
        if (list == null || !list.length) {
          return PDF417Common2.EMPTY_INT_ARRAY;
        }
        var result = new Int32Array(list.length);
        var i = 0;
        try {
          for (var list_1 = __values28(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
            var integer = list_1_1.value;
            result[i++] = integer;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (list_1_1 && !list_1_1.done && (_a2 = list_1.return)) _a2.call(list_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return result;
      };
      PDF417Common2.getCodeword = function(symbol) {
        var i = Arrays_default.binarySearch(PDF417Common2.SYMBOL_TABLE, symbol & 262143);
        if (i < 0) {
          return -1;
        }
        return (PDF417Common2.CODEWORD_TABLE[i] - 1) % PDF417Common2.NUMBER_OF_CODEWORDS;
      };
      PDF417Common2.NUMBER_OF_CODEWORDS = 929;
      PDF417Common2.MAX_CODEWORDS_IN_BARCODE = PDF417Common2.NUMBER_OF_CODEWORDS - 1;
      PDF417Common2.MIN_ROWS_IN_BARCODE = 3;
      PDF417Common2.MAX_ROWS_IN_BARCODE = 90;
      PDF417Common2.MODULES_IN_CODEWORD = 17;
      PDF417Common2.MODULES_IN_STOP_PATTERN = 18;
      PDF417Common2.BARS_IN_MODULE = 8;
      PDF417Common2.EMPTY_INT_ARRAY = new Int32Array([]);
      PDF417Common2.SYMBOL_TABLE = Int32Array.from([
        66142,
        66170,
        66206,
        66236,
        66290,
        66292,
        66350,
        66382,
        66396,
        66454,
        66470,
        66476,
        66594,
        66600,
        66614,
        66626,
        66628,
        66632,
        66640,
        66654,
        66662,
        66668,
        66682,
        66690,
        66718,
        66720,
        66748,
        66758,
        66776,
        66798,
        66802,
        66804,
        66820,
        66824,
        66832,
        66846,
        66848,
        66876,
        66880,
        66936,
        66950,
        66956,
        66968,
        66992,
        67006,
        67022,
        67036,
        67042,
        67044,
        67048,
        67062,
        67118,
        67150,
        67164,
        67214,
        67228,
        67256,
        67294,
        67322,
        67350,
        67366,
        67372,
        67398,
        67404,
        67416,
        67438,
        67474,
        67476,
        67490,
        67492,
        67496,
        67510,
        67618,
        67624,
        67650,
        67656,
        67664,
        67678,
        67686,
        67692,
        67706,
        67714,
        67716,
        67728,
        67742,
        67744,
        67772,
        67782,
        67788,
        67800,
        67822,
        67826,
        67828,
        67842,
        67848,
        67870,
        67872,
        67900,
        67904,
        67960,
        67974,
        67992,
        68016,
        68030,
        68046,
        68060,
        68066,
        68068,
        68072,
        68086,
        68104,
        68112,
        68126,
        68128,
        68156,
        68160,
        68216,
        68336,
        68358,
        68364,
        68376,
        68400,
        68414,
        68448,
        68476,
        68494,
        68508,
        68536,
        68546,
        68548,
        68552,
        68560,
        68574,
        68582,
        68588,
        68654,
        68686,
        68700,
        68706,
        68708,
        68712,
        68726,
        68750,
        68764,
        68792,
        68802,
        68804,
        68808,
        68816,
        68830,
        68838,
        68844,
        68858,
        68878,
        68892,
        68920,
        68976,
        68990,
        68994,
        68996,
        69e3,
        69008,
        69022,
        69024,
        69052,
        69062,
        69068,
        69080,
        69102,
        69106,
        69108,
        69142,
        69158,
        69164,
        69190,
        69208,
        69230,
        69254,
        69260,
        69272,
        69296,
        69310,
        69326,
        69340,
        69386,
        69394,
        69396,
        69410,
        69416,
        69430,
        69442,
        69444,
        69448,
        69456,
        69470,
        69478,
        69484,
        69554,
        69556,
        69666,
        69672,
        69698,
        69704,
        69712,
        69726,
        69754,
        69762,
        69764,
        69776,
        69790,
        69792,
        69820,
        69830,
        69836,
        69848,
        69870,
        69874,
        69876,
        69890,
        69918,
        69920,
        69948,
        69952,
        70008,
        70022,
        70040,
        70064,
        70078,
        70094,
        70108,
        70114,
        70116,
        70120,
        70134,
        70152,
        70174,
        70176,
        70264,
        70384,
        70412,
        70448,
        70462,
        70496,
        70524,
        70542,
        70556,
        70584,
        70594,
        70600,
        70608,
        70622,
        70630,
        70636,
        70664,
        70672,
        70686,
        70688,
        70716,
        70720,
        70776,
        70896,
        71136,
        71180,
        71192,
        71216,
        71230,
        71264,
        71292,
        71360,
        71416,
        71452,
        71480,
        71536,
        71550,
        71554,
        71556,
        71560,
        71568,
        71582,
        71584,
        71612,
        71622,
        71628,
        71640,
        71662,
        71726,
        71732,
        71758,
        71772,
        71778,
        71780,
        71784,
        71798,
        71822,
        71836,
        71864,
        71874,
        71880,
        71888,
        71902,
        71910,
        71916,
        71930,
        71950,
        71964,
        71992,
        72048,
        72062,
        72066,
        72068,
        72080,
        72094,
        72096,
        72124,
        72134,
        72140,
        72152,
        72174,
        72178,
        72180,
        72206,
        72220,
        72248,
        72304,
        72318,
        72416,
        72444,
        72456,
        72464,
        72478,
        72480,
        72508,
        72512,
        72568,
        72588,
        72600,
        72624,
        72638,
        72654,
        72668,
        72674,
        72676,
        72680,
        72694,
        72726,
        72742,
        72748,
        72774,
        72780,
        72792,
        72814,
        72838,
        72856,
        72880,
        72894,
        72910,
        72924,
        72930,
        72932,
        72936,
        72950,
        72966,
        72972,
        72984,
        73008,
        73022,
        73056,
        73084,
        73102,
        73116,
        73144,
        73156,
        73160,
        73168,
        73182,
        73190,
        73196,
        73210,
        73226,
        73234,
        73236,
        73250,
        73252,
        73256,
        73270,
        73282,
        73284,
        73296,
        73310,
        73318,
        73324,
        73346,
        73348,
        73352,
        73360,
        73374,
        73376,
        73404,
        73414,
        73420,
        73432,
        73454,
        73498,
        73518,
        73522,
        73524,
        73550,
        73564,
        73570,
        73572,
        73576,
        73590,
        73800,
        73822,
        73858,
        73860,
        73872,
        73886,
        73888,
        73916,
        73944,
        73970,
        73972,
        73992,
        74014,
        74016,
        74044,
        74048,
        74104,
        74118,
        74136,
        74160,
        74174,
        74210,
        74212,
        74216,
        74230,
        74244,
        74256,
        74270,
        74272,
        74360,
        74480,
        74502,
        74508,
        74544,
        74558,
        74592,
        74620,
        74638,
        74652,
        74680,
        74690,
        74696,
        74704,
        74726,
        74732,
        74782,
        74784,
        74812,
        74992,
        75232,
        75288,
        75326,
        75360,
        75388,
        75456,
        75512,
        75576,
        75632,
        75646,
        75650,
        75652,
        75664,
        75678,
        75680,
        75708,
        75718,
        75724,
        75736,
        75758,
        75808,
        75836,
        75840,
        75896,
        76016,
        76256,
        76736,
        76824,
        76848,
        76862,
        76896,
        76924,
        76992,
        77048,
        77296,
        77340,
        77368,
        77424,
        77438,
        77536,
        77564,
        77572,
        77576,
        77584,
        77600,
        77628,
        77632,
        77688,
        77702,
        77708,
        77720,
        77744,
        77758,
        77774,
        77788,
        77870,
        77902,
        77916,
        77922,
        77928,
        77966,
        77980,
        78008,
        78018,
        78024,
        78032,
        78046,
        78060,
        78074,
        78094,
        78136,
        78192,
        78206,
        78210,
        78212,
        78224,
        78238,
        78240,
        78268,
        78278,
        78284,
        78296,
        78322,
        78324,
        78350,
        78364,
        78448,
        78462,
        78560,
        78588,
        78600,
        78622,
        78624,
        78652,
        78656,
        78712,
        78726,
        78744,
        78768,
        78782,
        78798,
        78812,
        78818,
        78820,
        78824,
        78838,
        78862,
        78876,
        78904,
        78960,
        78974,
        79072,
        79100,
        79296,
        79352,
        79368,
        79376,
        79390,
        79392,
        79420,
        79424,
        79480,
        79600,
        79628,
        79640,
        79664,
        79678,
        79712,
        79740,
        79772,
        79800,
        79810,
        79812,
        79816,
        79824,
        79838,
        79846,
        79852,
        79894,
        79910,
        79916,
        79942,
        79948,
        79960,
        79982,
        79988,
        80006,
        80024,
        80048,
        80062,
        80078,
        80092,
        80098,
        80100,
        80104,
        80134,
        80140,
        80176,
        80190,
        80224,
        80252,
        80270,
        80284,
        80312,
        80328,
        80336,
        80350,
        80358,
        80364,
        80378,
        80390,
        80396,
        80408,
        80432,
        80446,
        80480,
        80508,
        80576,
        80632,
        80654,
        80668,
        80696,
        80752,
        80766,
        80776,
        80784,
        80798,
        80800,
        80828,
        80844,
        80856,
        80878,
        80882,
        80884,
        80914,
        80916,
        80930,
        80932,
        80936,
        80950,
        80962,
        80968,
        80976,
        80990,
        80998,
        81004,
        81026,
        81028,
        81040,
        81054,
        81056,
        81084,
        81094,
        81100,
        81112,
        81134,
        81154,
        81156,
        81160,
        81168,
        81182,
        81184,
        81212,
        81216,
        81272,
        81286,
        81292,
        81304,
        81328,
        81342,
        81358,
        81372,
        81380,
        81384,
        81398,
        81434,
        81454,
        81458,
        81460,
        81486,
        81500,
        81506,
        81508,
        81512,
        81526,
        81550,
        81564,
        81592,
        81602,
        81604,
        81608,
        81616,
        81630,
        81638,
        81644,
        81702,
        81708,
        81722,
        81734,
        81740,
        81752,
        81774,
        81778,
        81780,
        82050,
        82078,
        82080,
        82108,
        82180,
        82184,
        82192,
        82206,
        82208,
        82236,
        82240,
        82296,
        82316,
        82328,
        82352,
        82366,
        82402,
        82404,
        82408,
        82440,
        82448,
        82462,
        82464,
        82492,
        82496,
        82552,
        82672,
        82694,
        82700,
        82712,
        82736,
        82750,
        82784,
        82812,
        82830,
        82882,
        82884,
        82888,
        82896,
        82918,
        82924,
        82952,
        82960,
        82974,
        82976,
        83004,
        83008,
        83064,
        83184,
        83424,
        83468,
        83480,
        83504,
        83518,
        83552,
        83580,
        83648,
        83704,
        83740,
        83768,
        83824,
        83838,
        83842,
        83844,
        83848,
        83856,
        83872,
        83900,
        83910,
        83916,
        83928,
        83950,
        83984,
        84e3,
        84028,
        84032,
        84088,
        84208,
        84448,
        84928,
        85040,
        85054,
        85088,
        85116,
        85184,
        85240,
        85488,
        85560,
        85616,
        85630,
        85728,
        85756,
        85764,
        85768,
        85776,
        85790,
        85792,
        85820,
        85824,
        85880,
        85894,
        85900,
        85912,
        85936,
        85966,
        85980,
        86048,
        86080,
        86136,
        86256,
        86496,
        86976,
        88160,
        88188,
        88256,
        88312,
        88560,
        89056,
        89200,
        89214,
        89312,
        89340,
        89536,
        89592,
        89608,
        89616,
        89632,
        89664,
        89720,
        89840,
        89868,
        89880,
        89904,
        89952,
        89980,
        89998,
        90012,
        90040,
        90190,
        90204,
        90254,
        90268,
        90296,
        90306,
        90308,
        90312,
        90334,
        90382,
        90396,
        90424,
        90480,
        90494,
        90500,
        90504,
        90512,
        90526,
        90528,
        90556,
        90566,
        90572,
        90584,
        90610,
        90612,
        90638,
        90652,
        90680,
        90736,
        90750,
        90848,
        90876,
        90884,
        90888,
        90896,
        90910,
        90912,
        90940,
        90944,
        91e3,
        91014,
        91020,
        91032,
        91056,
        91070,
        91086,
        91100,
        91106,
        91108,
        91112,
        91126,
        91150,
        91164,
        91192,
        91248,
        91262,
        91360,
        91388,
        91584,
        91640,
        91664,
        91678,
        91680,
        91708,
        91712,
        91768,
        91888,
        91928,
        91952,
        91966,
        92e3,
        92028,
        92046,
        92060,
        92088,
        92098,
        92100,
        92104,
        92112,
        92126,
        92134,
        92140,
        92188,
        92216,
        92272,
        92384,
        92412,
        92608,
        92664,
        93168,
        93200,
        93214,
        93216,
        93244,
        93248,
        93304,
        93424,
        93664,
        93720,
        93744,
        93758,
        93792,
        93820,
        93888,
        93944,
        93980,
        94008,
        94064,
        94078,
        94084,
        94088,
        94096,
        94110,
        94112,
        94140,
        94150,
        94156,
        94168,
        94246,
        94252,
        94278,
        94284,
        94296,
        94318,
        94342,
        94348,
        94360,
        94384,
        94398,
        94414,
        94428,
        94440,
        94470,
        94476,
        94488,
        94512,
        94526,
        94560,
        94588,
        94606,
        94620,
        94648,
        94658,
        94660,
        94664,
        94672,
        94686,
        94694,
        94700,
        94714,
        94726,
        94732,
        94744,
        94768,
        94782,
        94816,
        94844,
        94912,
        94968,
        94990,
        95004,
        95032,
        95088,
        95102,
        95112,
        95120,
        95134,
        95136,
        95164,
        95180,
        95192,
        95214,
        95218,
        95220,
        95244,
        95256,
        95280,
        95294,
        95328,
        95356,
        95424,
        95480,
        95728,
        95758,
        95772,
        95800,
        95856,
        95870,
        95968,
        95996,
        96008,
        96016,
        96030,
        96032,
        96060,
        96064,
        96120,
        96152,
        96176,
        96190,
        96220,
        96226,
        96228,
        96232,
        96290,
        96292,
        96296,
        96310,
        96322,
        96324,
        96328,
        96336,
        96350,
        96358,
        96364,
        96386,
        96388,
        96392,
        96400,
        96414,
        96416,
        96444,
        96454,
        96460,
        96472,
        96494,
        96498,
        96500,
        96514,
        96516,
        96520,
        96528,
        96542,
        96544,
        96572,
        96576,
        96632,
        96646,
        96652,
        96664,
        96688,
        96702,
        96718,
        96732,
        96738,
        96740,
        96744,
        96758,
        96772,
        96776,
        96784,
        96798,
        96800,
        96828,
        96832,
        96888,
        97008,
        97030,
        97036,
        97048,
        97072,
        97086,
        97120,
        97148,
        97166,
        97180,
        97208,
        97220,
        97224,
        97232,
        97246,
        97254,
        97260,
        97326,
        97330,
        97332,
        97358,
        97372,
        97378,
        97380,
        97384,
        97398,
        97422,
        97436,
        97464,
        97474,
        97476,
        97480,
        97488,
        97502,
        97510,
        97516,
        97550,
        97564,
        97592,
        97648,
        97666,
        97668,
        97672,
        97680,
        97694,
        97696,
        97724,
        97734,
        97740,
        97752,
        97774,
        97830,
        97836,
        97850,
        97862,
        97868,
        97880,
        97902,
        97906,
        97908,
        97926,
        97932,
        97944,
        97968,
        97998,
        98012,
        98018,
        98020,
        98024,
        98038,
        98618,
        98674,
        98676,
        98838,
        98854,
        98874,
        98892,
        98904,
        98926,
        98930,
        98932,
        98968,
        99006,
        99042,
        99044,
        99048,
        99062,
        99166,
        99194,
        99246,
        99286,
        99350,
        99366,
        99372,
        99386,
        99398,
        99416,
        99438,
        99442,
        99444,
        99462,
        99504,
        99518,
        99534,
        99548,
        99554,
        99556,
        99560,
        99574,
        99590,
        99596,
        99608,
        99632,
        99646,
        99680,
        99708,
        99726,
        99740,
        99768,
        99778,
        99780,
        99784,
        99792,
        99806,
        99814,
        99820,
        99834,
        99858,
        99860,
        99874,
        99880,
        99894,
        99906,
        99920,
        99934,
        99962,
        99970,
        99972,
        99976,
        99984,
        99998,
        1e5,
        100028,
        100038,
        100044,
        100056,
        100078,
        100082,
        100084,
        100142,
        100174,
        100188,
        100246,
        100262,
        100268,
        100306,
        100308,
        100390,
        100396,
        100410,
        100422,
        100428,
        100440,
        100462,
        100466,
        100468,
        100486,
        100504,
        100528,
        100542,
        100558,
        100572,
        100578,
        100580,
        100584,
        100598,
        100620,
        100656,
        100670,
        100704,
        100732,
        100750,
        100792,
        100802,
        100808,
        100816,
        100830,
        100838,
        100844,
        100858,
        100888,
        100912,
        100926,
        100960,
        100988,
        101056,
        101112,
        101148,
        101176,
        101232,
        101246,
        101250,
        101252,
        101256,
        101264,
        101278,
        101280,
        101308,
        101318,
        101324,
        101336,
        101358,
        101362,
        101364,
        101410,
        101412,
        101416,
        101430,
        101442,
        101448,
        101456,
        101470,
        101478,
        101498,
        101506,
        101508,
        101520,
        101534,
        101536,
        101564,
        101580,
        101618,
        101620,
        101636,
        101640,
        101648,
        101662,
        101664,
        101692,
        101696,
        101752,
        101766,
        101784,
        101838,
        101858,
        101860,
        101864,
        101934,
        101938,
        101940,
        101966,
        101980,
        101986,
        101988,
        101992,
        102030,
        102044,
        102072,
        102082,
        102084,
        102088,
        102096,
        102138,
        102166,
        102182,
        102188,
        102214,
        102220,
        102232,
        102254,
        102282,
        102290,
        102292,
        102306,
        102308,
        102312,
        102326,
        102444,
        102458,
        102470,
        102476,
        102488,
        102514,
        102516,
        102534,
        102552,
        102576,
        102590,
        102606,
        102620,
        102626,
        102632,
        102646,
        102662,
        102668,
        102704,
        102718,
        102752,
        102780,
        102798,
        102812,
        102840,
        102850,
        102856,
        102864,
        102878,
        102886,
        102892,
        102906,
        102936,
        102974,
        103008,
        103036,
        103104,
        103160,
        103224,
        103280,
        103294,
        103298,
        103300,
        103312,
        103326,
        103328,
        103356,
        103366,
        103372,
        103384,
        103406,
        103410,
        103412,
        103472,
        103486,
        103520,
        103548,
        103616,
        103672,
        103920,
        103992,
        104048,
        104062,
        104160,
        104188,
        104194,
        104196,
        104200,
        104208,
        104224,
        104252,
        104256,
        104312,
        104326,
        104332,
        104344,
        104368,
        104382,
        104398,
        104412,
        104418,
        104420,
        104424,
        104482,
        104484,
        104514,
        104520,
        104528,
        104542,
        104550,
        104570,
        104578,
        104580,
        104592,
        104606,
        104608,
        104636,
        104652,
        104690,
        104692,
        104706,
        104712,
        104734,
        104736,
        104764,
        104768,
        104824,
        104838,
        104856,
        104910,
        104930,
        104932,
        104936,
        104968,
        104976,
        104990,
        104992,
        105020,
        105024,
        105080,
        105200,
        105240,
        105278,
        105312,
        105372,
        105410,
        105412,
        105416,
        105424,
        105446,
        105518,
        105524,
        105550,
        105564,
        105570,
        105572,
        105576,
        105614,
        105628,
        105656,
        105666,
        105672,
        105680,
        105702,
        105722,
        105742,
        105756,
        105784,
        105840,
        105854,
        105858,
        105860,
        105864,
        105872,
        105888,
        105932,
        105970,
        105972,
        106006,
        106022,
        106028,
        106054,
        106060,
        106072,
        106100,
        106118,
        106124,
        106136,
        106160,
        106174,
        106190,
        106210,
        106212,
        106216,
        106250,
        106258,
        106260,
        106274,
        106276,
        106280,
        106306,
        106308,
        106312,
        106320,
        106334,
        106348,
        106394,
        106414,
        106418,
        106420,
        106566,
        106572,
        106610,
        106612,
        106630,
        106636,
        106648,
        106672,
        106686,
        106722,
        106724,
        106728,
        106742,
        106758,
        106764,
        106776,
        106800,
        106814,
        106848,
        106876,
        106894,
        106908,
        106936,
        106946,
        106948,
        106952,
        106960,
        106974,
        106982,
        106988,
        107032,
        107056,
        107070,
        107104,
        107132,
        107200,
        107256,
        107292,
        107320,
        107376,
        107390,
        107394,
        107396,
        107400,
        107408,
        107422,
        107424,
        107452,
        107462,
        107468,
        107480,
        107502,
        107506,
        107508,
        107544,
        107568,
        107582,
        107616,
        107644,
        107712,
        107768,
        108016,
        108060,
        108088,
        108144,
        108158,
        108256,
        108284,
        108290,
        108292,
        108296,
        108304,
        108318,
        108320,
        108348,
        108352,
        108408,
        108422,
        108428,
        108440,
        108464,
        108478,
        108494,
        108508,
        108514,
        108516,
        108520,
        108592,
        108640,
        108668,
        108736,
        108792,
        109040,
        109536,
        109680,
        109694,
        109792,
        109820,
        110016,
        110072,
        110084,
        110088,
        110096,
        110112,
        110140,
        110144,
        110200,
        110320,
        110342,
        110348,
        110360,
        110384,
        110398,
        110432,
        110460,
        110478,
        110492,
        110520,
        110532,
        110536,
        110544,
        110558,
        110658,
        110686,
        110714,
        110722,
        110724,
        110728,
        110736,
        110750,
        110752,
        110780,
        110796,
        110834,
        110836,
        110850,
        110852,
        110856,
        110864,
        110878,
        110880,
        110908,
        110912,
        110968,
        110982,
        111e3,
        111054,
        111074,
        111076,
        111080,
        111108,
        111112,
        111120,
        111134,
        111136,
        111164,
        111168,
        111224,
        111344,
        111372,
        111422,
        111456,
        111516,
        111554,
        111556,
        111560,
        111568,
        111590,
        111632,
        111646,
        111648,
        111676,
        111680,
        111736,
        111856,
        112096,
        112152,
        112224,
        112252,
        112320,
        112440,
        112514,
        112516,
        112520,
        112528,
        112542,
        112544,
        112588,
        112686,
        112718,
        112732,
        112782,
        112796,
        112824,
        112834,
        112836,
        112840,
        112848,
        112870,
        112890,
        112910,
        112924,
        112952,
        113008,
        113022,
        113026,
        113028,
        113032,
        113040,
        113054,
        113056,
        113100,
        113138,
        113140,
        113166,
        113180,
        113208,
        113264,
        113278,
        113376,
        113404,
        113416,
        113424,
        113440,
        113468,
        113472,
        113560,
        113614,
        113634,
        113636,
        113640,
        113686,
        113702,
        113708,
        113734,
        113740,
        113752,
        113778,
        113780,
        113798,
        113804,
        113816,
        113840,
        113854,
        113870,
        113890,
        113892,
        113896,
        113926,
        113932,
        113944,
        113968,
        113982,
        114016,
        114044,
        114076,
        114114,
        114116,
        114120,
        114128,
        114150,
        114170,
        114194,
        114196,
        114210,
        114212,
        114216,
        114242,
        114244,
        114248,
        114256,
        114270,
        114278,
        114306,
        114308,
        114312,
        114320,
        114334,
        114336,
        114364,
        114380,
        114420,
        114458,
        114478,
        114482,
        114484,
        114510,
        114524,
        114530,
        114532,
        114536,
        114842,
        114866,
        114868,
        114970,
        114994,
        114996,
        115042,
        115044,
        115048,
        115062,
        115130,
        115226,
        115250,
        115252,
        115278,
        115292,
        115298,
        115300,
        115304,
        115318,
        115342,
        115394,
        115396,
        115400,
        115408,
        115422,
        115430,
        115436,
        115450,
        115478,
        115494,
        115514,
        115526,
        115532,
        115570,
        115572,
        115738,
        115758,
        115762,
        115764,
        115790,
        115804,
        115810,
        115812,
        115816,
        115830,
        115854,
        115868,
        115896,
        115906,
        115912,
        115920,
        115934,
        115942,
        115948,
        115962,
        115996,
        116024,
        116080,
        116094,
        116098,
        116100,
        116104,
        116112,
        116126,
        116128,
        116156,
        116166,
        116172,
        116184,
        116206,
        116210,
        116212,
        116246,
        116262,
        116268,
        116282,
        116294,
        116300,
        116312,
        116334,
        116338,
        116340,
        116358,
        116364,
        116376,
        116400,
        116414,
        116430,
        116444,
        116450,
        116452,
        116456,
        116498,
        116500,
        116514,
        116520,
        116534,
        116546,
        116548,
        116552,
        116560,
        116574,
        116582,
        116588,
        116602,
        116654,
        116694,
        116714,
        116762,
        116782,
        116786,
        116788,
        116814,
        116828,
        116834,
        116836,
        116840,
        116854,
        116878,
        116892,
        116920,
        116930,
        116936,
        116944,
        116958,
        116966,
        116972,
        116986,
        117006,
        117048,
        117104,
        117118,
        117122,
        117124,
        117136,
        117150,
        117152,
        117180,
        117190,
        117196,
        117208,
        117230,
        117234,
        117236,
        117304,
        117360,
        117374,
        117472,
        117500,
        117506,
        117508,
        117512,
        117520,
        117536,
        117564,
        117568,
        117624,
        117638,
        117644,
        117656,
        117680,
        117694,
        117710,
        117724,
        117730,
        117732,
        117736,
        117750,
        117782,
        117798,
        117804,
        117818,
        117830,
        117848,
        117874,
        117876,
        117894,
        117936,
        117950,
        117966,
        117986,
        117988,
        117992,
        118022,
        118028,
        118040,
        118064,
        118078,
        118112,
        118140,
        118172,
        118210,
        118212,
        118216,
        118224,
        118238,
        118246,
        118266,
        118306,
        118312,
        118338,
        118352,
        118366,
        118374,
        118394,
        118402,
        118404,
        118408,
        118416,
        118430,
        118432,
        118460,
        118476,
        118514,
        118516,
        118574,
        118578,
        118580,
        118606,
        118620,
        118626,
        118628,
        118632,
        118678,
        118694,
        118700,
        118730,
        118738,
        118740,
        118830,
        118834,
        118836,
        118862,
        118876,
        118882,
        118884,
        118888,
        118902,
        118926,
        118940,
        118968,
        118978,
        118980,
        118984,
        118992,
        119006,
        119014,
        119020,
        119034,
        119068,
        119096,
        119152,
        119166,
        119170,
        119172,
        119176,
        119184,
        119198,
        119200,
        119228,
        119238,
        119244,
        119256,
        119278,
        119282,
        119284,
        119324,
        119352,
        119408,
        119422,
        119520,
        119548,
        119554,
        119556,
        119560,
        119568,
        119582,
        119584,
        119612,
        119616,
        119672,
        119686,
        119692,
        119704,
        119728,
        119742,
        119758,
        119772,
        119778,
        119780,
        119784,
        119798,
        119920,
        119934,
        120032,
        120060,
        120256,
        120312,
        120324,
        120328,
        120336,
        120352,
        120384,
        120440,
        120560,
        120582,
        120588,
        120600,
        120624,
        120638,
        120672,
        120700,
        120718,
        120732,
        120760,
        120770,
        120772,
        120776,
        120784,
        120798,
        120806,
        120812,
        120870,
        120876,
        120890,
        120902,
        120908,
        120920,
        120946,
        120948,
        120966,
        120972,
        120984,
        121008,
        121022,
        121038,
        121058,
        121060,
        121064,
        121078,
        121100,
        121112,
        121136,
        121150,
        121184,
        121212,
        121244,
        121282,
        121284,
        121288,
        121296,
        121318,
        121338,
        121356,
        121368,
        121392,
        121406,
        121440,
        121468,
        121536,
        121592,
        121656,
        121730,
        121732,
        121736,
        121744,
        121758,
        121760,
        121804,
        121842,
        121844,
        121890,
        121922,
        121924,
        121928,
        121936,
        121950,
        121958,
        121978,
        121986,
        121988,
        121992,
        122e3,
        122014,
        122016,
        122044,
        122060,
        122098,
        122100,
        122116,
        122120,
        122128,
        122142,
        122144,
        122172,
        122176,
        122232,
        122246,
        122264,
        122318,
        122338,
        122340,
        122344,
        122414,
        122418,
        122420,
        122446,
        122460,
        122466,
        122468,
        122472,
        122510,
        122524,
        122552,
        122562,
        122564,
        122568,
        122576,
        122598,
        122618,
        122646,
        122662,
        122668,
        122694,
        122700,
        122712,
        122738,
        122740,
        122762,
        122770,
        122772,
        122786,
        122788,
        122792,
        123018,
        123026,
        123028,
        123042,
        123044,
        123048,
        123062,
        123098,
        123146,
        123154,
        123156,
        123170,
        123172,
        123176,
        123190,
        123202,
        123204,
        123208,
        123216,
        123238,
        123244,
        123258,
        123290,
        123314,
        123316,
        123402,
        123410,
        123412,
        123426,
        123428,
        123432,
        123446,
        123458,
        123464,
        123472,
        123486,
        123494,
        123500,
        123514,
        123522,
        123524,
        123528,
        123536,
        123552,
        123580,
        123590,
        123596,
        123608,
        123630,
        123634,
        123636,
        123674,
        123698,
        123700,
        123740,
        123746,
        123748,
        123752,
        123834,
        123914,
        123922,
        123924,
        123938,
        123944,
        123958,
        123970,
        123976,
        123984,
        123998,
        124006,
        124012,
        124026,
        124034,
        124036,
        124048,
        124062,
        124064,
        124092,
        124102,
        124108,
        124120,
        124142,
        124146,
        124148,
        124162,
        124164,
        124168,
        124176,
        124190,
        124192,
        124220,
        124224,
        124280,
        124294,
        124300,
        124312,
        124336,
        124350,
        124366,
        124380,
        124386,
        124388,
        124392,
        124406,
        124442,
        124462,
        124466,
        124468,
        124494,
        124508,
        124514,
        124520,
        124558,
        124572,
        124600,
        124610,
        124612,
        124616,
        124624,
        124646,
        124666,
        124694,
        124710,
        124716,
        124730,
        124742,
        124748,
        124760,
        124786,
        124788,
        124818,
        124820,
        124834,
        124836,
        124840,
        124854,
        124946,
        124948,
        124962,
        124964,
        124968,
        124982,
        124994,
        124996,
        125e3,
        125008,
        125022,
        125030,
        125036,
        125050,
        125058,
        125060,
        125064,
        125072,
        125086,
        125088,
        125116,
        125126,
        125132,
        125144,
        125166,
        125170,
        125172,
        125186,
        125188,
        125192,
        125200,
        125216,
        125244,
        125248,
        125304,
        125318,
        125324,
        125336,
        125360,
        125374,
        125390,
        125404,
        125410,
        125412,
        125416,
        125430,
        125444,
        125448,
        125456,
        125472,
        125504,
        125560,
        125680,
        125702,
        125708,
        125720,
        125744,
        125758,
        125792,
        125820,
        125838,
        125852,
        125880,
        125890,
        125892,
        125896,
        125904,
        125918,
        125926,
        125932,
        125978,
        125998,
        126002,
        126004,
        126030,
        126044,
        126050,
        126052,
        126056,
        126094,
        126108,
        126136,
        126146,
        126148,
        126152,
        126160,
        126182,
        126202,
        126222,
        126236,
        126264,
        126320,
        126334,
        126338,
        126340,
        126344,
        126352,
        126366,
        126368,
        126412,
        126450,
        126452,
        126486,
        126502,
        126508,
        126522,
        126534,
        126540,
        126552,
        126574,
        126578,
        126580,
        126598,
        126604,
        126616,
        126640,
        126654,
        126670,
        126684,
        126690,
        126692,
        126696,
        126738,
        126754,
        126756,
        126760,
        126774,
        126786,
        126788,
        126792,
        126800,
        126814,
        126822,
        126828,
        126842,
        126894,
        126898,
        126900,
        126934,
        127126,
        127142,
        127148,
        127162,
        127178,
        127186,
        127188,
        127254,
        127270,
        127276,
        127290,
        127302,
        127308,
        127320,
        127342,
        127346,
        127348,
        127370,
        127378,
        127380,
        127394,
        127396,
        127400,
        127450,
        127510,
        127526,
        127532,
        127546,
        127558,
        127576,
        127598,
        127602,
        127604,
        127622,
        127628,
        127640,
        127664,
        127678,
        127694,
        127708,
        127714,
        127716,
        127720,
        127734,
        127754,
        127762,
        127764,
        127778,
        127784,
        127810,
        127812,
        127816,
        127824,
        127838,
        127846,
        127866,
        127898,
        127918,
        127922,
        127924,
        128022,
        128038,
        128044,
        128058,
        128070,
        128076,
        128088,
        128110,
        128114,
        128116,
        128134,
        128140,
        128152,
        128176,
        128190,
        128206,
        128220,
        128226,
        128228,
        128232,
        128246,
        128262,
        128268,
        128280,
        128304,
        128318,
        128352,
        128380,
        128398,
        128412,
        128440,
        128450,
        128452,
        128456,
        128464,
        128478,
        128486,
        128492,
        128506,
        128522,
        128530,
        128532,
        128546,
        128548,
        128552,
        128566,
        128578,
        128580,
        128584,
        128592,
        128606,
        128614,
        128634,
        128642,
        128644,
        128648,
        128656,
        128670,
        128672,
        128700,
        128716,
        128754,
        128756,
        128794,
        128814,
        128818,
        128820,
        128846,
        128860,
        128866,
        128868,
        128872,
        128886,
        128918,
        128934,
        128940,
        128954,
        128978,
        128980,
        129178,
        129198,
        129202,
        129204,
        129238,
        129258,
        129306,
        129326,
        129330,
        129332,
        129358,
        129372,
        129378,
        129380,
        129384,
        129398,
        129430,
        129446,
        129452,
        129466,
        129482,
        129490,
        129492,
        129562,
        129582,
        129586,
        129588,
        129614,
        129628,
        129634,
        129636,
        129640,
        129654,
        129678,
        129692,
        129720,
        129730,
        129732,
        129736,
        129744,
        129758,
        129766,
        129772,
        129814,
        129830,
        129836,
        129850,
        129862,
        129868,
        129880,
        129902,
        129906,
        129908,
        129930,
        129938,
        129940,
        129954,
        129956,
        129960,
        129974,
        130010
      ]);
      PDF417Common2.CODEWORD_TABLE = Int32Array.from([
        2627,
        1819,
        2622,
        2621,
        1813,
        1812,
        2729,
        2724,
        2723,
        2779,
        2774,
        2773,
        902,
        896,
        908,
        868,
        865,
        861,
        859,
        2511,
        873,
        871,
        1780,
        835,
        2493,
        825,
        2491,
        842,
        837,
        844,
        1764,
        1762,
        811,
        810,
        809,
        2483,
        807,
        2482,
        806,
        2480,
        815,
        814,
        813,
        812,
        2484,
        817,
        816,
        1745,
        1744,
        1742,
        1746,
        2655,
        2637,
        2635,
        2626,
        2625,
        2623,
        2628,
        1820,
        2752,
        2739,
        2737,
        2728,
        2727,
        2725,
        2730,
        2785,
        2783,
        2778,
        2777,
        2775,
        2780,
        787,
        781,
        747,
        739,
        736,
        2413,
        754,
        752,
        1719,
        692,
        689,
        681,
        2371,
        678,
        2369,
        700,
        697,
        694,
        703,
        1688,
        1686,
        642,
        638,
        2343,
        631,
        2341,
        627,
        2338,
        651,
        646,
        643,
        2345,
        654,
        652,
        1652,
        1650,
        1647,
        1654,
        601,
        599,
        2322,
        596,
        2321,
        594,
        2319,
        2317,
        611,
        610,
        608,
        606,
        2324,
        603,
        2323,
        615,
        614,
        612,
        1617,
        1616,
        1614,
        1612,
        616,
        1619,
        1618,
        2575,
        2538,
        2536,
        905,
        901,
        898,
        909,
        2509,
        2507,
        2504,
        870,
        867,
        864,
        860,
        2512,
        875,
        872,
        1781,
        2490,
        2489,
        2487,
        2485,
        1748,
        836,
        834,
        832,
        830,
        2494,
        827,
        2492,
        843,
        841,
        839,
        845,
        1765,
        1763,
        2701,
        2676,
        2674,
        2653,
        2648,
        2656,
        2634,
        2633,
        2631,
        2629,
        1821,
        2638,
        2636,
        2770,
        2763,
        2761,
        2750,
        2745,
        2753,
        2736,
        2735,
        2733,
        2731,
        1848,
        2740,
        2738,
        2786,
        2784,
        591,
        588,
        576,
        569,
        566,
        2296,
        1590,
        537,
        534,
        526,
        2276,
        522,
        2274,
        545,
        542,
        539,
        548,
        1572,
        1570,
        481,
        2245,
        466,
        2242,
        462,
        2239,
        492,
        485,
        482,
        2249,
        496,
        494,
        1534,
        1531,
        1528,
        1538,
        413,
        2196,
        406,
        2191,
        2188,
        425,
        419,
        2202,
        415,
        2199,
        432,
        430,
        427,
        1472,
        1467,
        1464,
        433,
        1476,
        1474,
        368,
        367,
        2160,
        365,
        2159,
        362,
        2157,
        2155,
        2152,
        378,
        377,
        375,
        2166,
        372,
        2165,
        369,
        2162,
        383,
        381,
        379,
        2168,
        1419,
        1418,
        1416,
        1414,
        385,
        1411,
        384,
        1423,
        1422,
        1420,
        1424,
        2461,
        802,
        2441,
        2439,
        790,
        786,
        783,
        794,
        2409,
        2406,
        2403,
        750,
        742,
        738,
        2414,
        756,
        753,
        1720,
        2367,
        2365,
        2362,
        2359,
        1663,
        693,
        691,
        684,
        2373,
        680,
        2370,
        702,
        699,
        696,
        704,
        1690,
        1687,
        2337,
        2336,
        2334,
        2332,
        1624,
        2329,
        1622,
        640,
        637,
        2344,
        634,
        2342,
        630,
        2340,
        650,
        648,
        645,
        2346,
        655,
        653,
        1653,
        1651,
        1649,
        1655,
        2612,
        2597,
        2595,
        2571,
        2568,
        2565,
        2576,
        2534,
        2529,
        2526,
        1787,
        2540,
        2537,
        907,
        904,
        900,
        910,
        2503,
        2502,
        2500,
        2498,
        1768,
        2495,
        1767,
        2510,
        2508,
        2506,
        869,
        866,
        863,
        2513,
        876,
        874,
        1782,
        2720,
        2713,
        2711,
        2697,
        2694,
        2691,
        2702,
        2672,
        2670,
        2664,
        1828,
        2678,
        2675,
        2647,
        2646,
        2644,
        2642,
        1823,
        2639,
        1822,
        2654,
        2652,
        2650,
        2657,
        2771,
        1855,
        2765,
        2762,
        1850,
        1849,
        2751,
        2749,
        2747,
        2754,
        353,
        2148,
        344,
        342,
        336,
        2142,
        332,
        2140,
        345,
        1375,
        1373,
        306,
        2130,
        299,
        2128,
        295,
        2125,
        319,
        314,
        311,
        2132,
        1354,
        1352,
        1349,
        1356,
        262,
        257,
        2101,
        253,
        2096,
        2093,
        274,
        273,
        267,
        2107,
        263,
        2104,
        280,
        278,
        275,
        1316,
        1311,
        1308,
        1320,
        1318,
        2052,
        202,
        2050,
        2044,
        2040,
        219,
        2063,
        212,
        2060,
        208,
        2055,
        224,
        221,
        2066,
        1260,
        1258,
        1252,
        231,
        1248,
        229,
        1266,
        1264,
        1261,
        1268,
        155,
        1998,
        153,
        1996,
        1994,
        1991,
        1988,
        165,
        164,
        2007,
        162,
        2006,
        159,
        2003,
        2e3,
        172,
        171,
        169,
        2012,
        166,
        2010,
        1186,
        1184,
        1182,
        1179,
        175,
        1176,
        173,
        1192,
        1191,
        1189,
        1187,
        176,
        1194,
        1193,
        2313,
        2307,
        2305,
        592,
        589,
        2294,
        2292,
        2289,
        578,
        572,
        568,
        2297,
        580,
        1591,
        2272,
        2267,
        2264,
        1547,
        538,
        536,
        529,
        2278,
        525,
        2275,
        547,
        544,
        541,
        1574,
        1571,
        2237,
        2235,
        2229,
        1493,
        2225,
        1489,
        478,
        2247,
        470,
        2244,
        465,
        2241,
        493,
        488,
        484,
        2250,
        498,
        495,
        1536,
        1533,
        1530,
        1539,
        2187,
        2186,
        2184,
        2182,
        1432,
        2179,
        1430,
        2176,
        1427,
        414,
        412,
        2197,
        409,
        2195,
        405,
        2193,
        2190,
        426,
        424,
        421,
        2203,
        418,
        2201,
        431,
        429,
        1473,
        1471,
        1469,
        1466,
        434,
        1477,
        1475,
        2478,
        2472,
        2470,
        2459,
        2457,
        2454,
        2462,
        803,
        2437,
        2432,
        2429,
        1726,
        2443,
        2440,
        792,
        789,
        785,
        2401,
        2399,
        2393,
        1702,
        2389,
        1699,
        2411,
        2408,
        2405,
        745,
        741,
        2415,
        758,
        755,
        1721,
        2358,
        2357,
        2355,
        2353,
        1661,
        2350,
        1660,
        2347,
        1657,
        2368,
        2366,
        2364,
        2361,
        1666,
        690,
        687,
        2374,
        683,
        2372,
        701,
        698,
        705,
        1691,
        1689,
        2619,
        2617,
        2610,
        2608,
        2605,
        2613,
        2593,
        2588,
        2585,
        1803,
        2599,
        2596,
        2563,
        2561,
        2555,
        1797,
        2551,
        1795,
        2573,
        2570,
        2567,
        2577,
        2525,
        2524,
        2522,
        2520,
        1786,
        2517,
        1785,
        2514,
        1783,
        2535,
        2533,
        2531,
        2528,
        1788,
        2541,
        2539,
        906,
        903,
        911,
        2721,
        1844,
        2715,
        2712,
        1838,
        1836,
        2699,
        2696,
        2693,
        2703,
        1827,
        1826,
        1824,
        2673,
        2671,
        2669,
        2666,
        1829,
        2679,
        2677,
        1858,
        1857,
        2772,
        1854,
        1853,
        1851,
        1856,
        2766,
        2764,
        143,
        1987,
        139,
        1986,
        135,
        133,
        131,
        1984,
        128,
        1983,
        125,
        1981,
        138,
        137,
        136,
        1985,
        1133,
        1132,
        1130,
        112,
        110,
        1974,
        107,
        1973,
        104,
        1971,
        1969,
        122,
        121,
        119,
        117,
        1977,
        114,
        1976,
        124,
        1115,
        1114,
        1112,
        1110,
        1117,
        1116,
        84,
        83,
        1953,
        81,
        1952,
        78,
        1950,
        1948,
        1945,
        94,
        93,
        91,
        1959,
        88,
        1958,
        85,
        1955,
        99,
        97,
        95,
        1961,
        1086,
        1085,
        1083,
        1081,
        1078,
        100,
        1090,
        1089,
        1087,
        1091,
        49,
        47,
        1917,
        44,
        1915,
        1913,
        1910,
        1907,
        59,
        1926,
        56,
        1925,
        53,
        1922,
        1919,
        66,
        64,
        1931,
        61,
        1929,
        1042,
        1040,
        1038,
        71,
        1035,
        70,
        1032,
        68,
        1048,
        1047,
        1045,
        1043,
        1050,
        1049,
        12,
        10,
        1869,
        1867,
        1864,
        1861,
        21,
        1880,
        19,
        1877,
        1874,
        1871,
        28,
        1888,
        25,
        1886,
        22,
        1883,
        982,
        980,
        977,
        974,
        32,
        30,
        991,
        989,
        987,
        984,
        34,
        995,
        994,
        992,
        2151,
        2150,
        2147,
        2146,
        2144,
        356,
        355,
        354,
        2149,
        2139,
        2138,
        2136,
        2134,
        1359,
        343,
        341,
        338,
        2143,
        335,
        2141,
        348,
        347,
        346,
        1376,
        1374,
        2124,
        2123,
        2121,
        2119,
        1326,
        2116,
        1324,
        310,
        308,
        305,
        2131,
        302,
        2129,
        298,
        2127,
        320,
        318,
        316,
        313,
        2133,
        322,
        321,
        1355,
        1353,
        1351,
        1357,
        2092,
        2091,
        2089,
        2087,
        1276,
        2084,
        1274,
        2081,
        1271,
        259,
        2102,
        256,
        2100,
        252,
        2098,
        2095,
        272,
        269,
        2108,
        266,
        2106,
        281,
        279,
        277,
        1317,
        1315,
        1313,
        1310,
        282,
        1321,
        1319,
        2039,
        2037,
        2035,
        2032,
        1203,
        2029,
        1200,
        1197,
        207,
        2053,
        205,
        2051,
        201,
        2049,
        2046,
        2043,
        220,
        218,
        2064,
        215,
        2062,
        211,
        2059,
        228,
        226,
        223,
        2069,
        1259,
        1257,
        1254,
        232,
        1251,
        230,
        1267,
        1265,
        1263,
        2316,
        2315,
        2312,
        2311,
        2309,
        2314,
        2304,
        2303,
        2301,
        2299,
        1593,
        2308,
        2306,
        590,
        2288,
        2287,
        2285,
        2283,
        1578,
        2280,
        1577,
        2295,
        2293,
        2291,
        579,
        577,
        574,
        571,
        2298,
        582,
        581,
        1592,
        2263,
        2262,
        2260,
        2258,
        1545,
        2255,
        1544,
        2252,
        1541,
        2273,
        2271,
        2269,
        2266,
        1550,
        535,
        532,
        2279,
        528,
        2277,
        546,
        543,
        549,
        1575,
        1573,
        2224,
        2222,
        2220,
        1486,
        2217,
        1485,
        2214,
        1482,
        1479,
        2238,
        2236,
        2234,
        2231,
        1496,
        2228,
        1492,
        480,
        477,
        2248,
        473,
        2246,
        469,
        2243,
        490,
        487,
        2251,
        497,
        1537,
        1535,
        1532,
        2477,
        2476,
        2474,
        2479,
        2469,
        2468,
        2466,
        2464,
        1730,
        2473,
        2471,
        2453,
        2452,
        2450,
        2448,
        1729,
        2445,
        1728,
        2460,
        2458,
        2456,
        2463,
        805,
        804,
        2428,
        2427,
        2425,
        2423,
        1725,
        2420,
        1724,
        2417,
        1722,
        2438,
        2436,
        2434,
        2431,
        1727,
        2444,
        2442,
        793,
        791,
        788,
        795,
        2388,
        2386,
        2384,
        1697,
        2381,
        1696,
        2378,
        1694,
        1692,
        2402,
        2400,
        2398,
        2395,
        1703,
        2392,
        1701,
        2412,
        2410,
        2407,
        751,
        748,
        744,
        2416,
        759,
        757,
        1807,
        2620,
        2618,
        1806,
        1805,
        2611,
        2609,
        2607,
        2614,
        1802,
        1801,
        1799,
        2594,
        2592,
        2590,
        2587,
        1804,
        2600,
        2598,
        1794,
        1793,
        1791,
        1789,
        2564,
        2562,
        2560,
        2557,
        1798,
        2554,
        1796,
        2574,
        2572,
        2569,
        2578,
        1847,
        1846,
        2722,
        1843,
        1842,
        1840,
        1845,
        2716,
        2714,
        1835,
        1834,
        1832,
        1830,
        1839,
        1837,
        2700,
        2698,
        2695,
        2704,
        1817,
        1811,
        1810,
        897,
        862,
        1777,
        829,
        826,
        838,
        1760,
        1758,
        808,
        2481,
        1741,
        1740,
        1738,
        1743,
        2624,
        1818,
        2726,
        2776,
        782,
        740,
        737,
        1715,
        686,
        679,
        695,
        1682,
        1680,
        639,
        628,
        2339,
        647,
        644,
        1645,
        1643,
        1640,
        1648,
        602,
        600,
        597,
        595,
        2320,
        593,
        2318,
        609,
        607,
        604,
        1611,
        1610,
        1608,
        1606,
        613,
        1615,
        1613,
        2328,
        926,
        924,
        892,
        886,
        899,
        857,
        850,
        2505,
        1778,
        824,
        823,
        821,
        819,
        2488,
        818,
        2486,
        833,
        831,
        828,
        840,
        1761,
        1759,
        2649,
        2632,
        2630,
        2746,
        2734,
        2732,
        2782,
        2781,
        570,
        567,
        1587,
        531,
        527,
        523,
        540,
        1566,
        1564,
        476,
        467,
        463,
        2240,
        486,
        483,
        1524,
        1521,
        1518,
        1529,
        411,
        403,
        2192,
        399,
        2189,
        423,
        416,
        1462,
        1457,
        1454,
        428,
        1468,
        1465,
        2210,
        366,
        363,
        2158,
        360,
        2156,
        357,
        2153,
        376,
        373,
        370,
        2163,
        1410,
        1409,
        1407,
        1405,
        382,
        1402,
        380,
        1417,
        1415,
        1412,
        1421,
        2175,
        2174,
        777,
        774,
        771,
        784,
        732,
        725,
        722,
        2404,
        743,
        1716,
        676,
        674,
        668,
        2363,
        665,
        2360,
        685,
        1684,
        1681,
        626,
        624,
        622,
        2335,
        620,
        2333,
        617,
        2330,
        641,
        635,
        649,
        1646,
        1644,
        1642,
        2566,
        928,
        925,
        2530,
        2527,
        894,
        891,
        888,
        2501,
        2499,
        2496,
        858,
        856,
        854,
        851,
        1779,
        2692,
        2668,
        2665,
        2645,
        2643,
        2640,
        2651,
        2768,
        2759,
        2757,
        2744,
        2743,
        2741,
        2748,
        352,
        1382,
        340,
        337,
        333,
        1371,
        1369,
        307,
        300,
        296,
        2126,
        315,
        312,
        1347,
        1342,
        1350,
        261,
        258,
        250,
        2097,
        246,
        2094,
        271,
        268,
        264,
        1306,
        1301,
        1298,
        276,
        1312,
        1309,
        2115,
        203,
        2048,
        195,
        2045,
        191,
        2041,
        213,
        209,
        2056,
        1246,
        1244,
        1238,
        225,
        1234,
        222,
        1256,
        1253,
        1249,
        1262,
        2080,
        2079,
        154,
        1997,
        150,
        1995,
        147,
        1992,
        1989,
        163,
        160,
        2004,
        156,
        2001,
        1175,
        1174,
        1172,
        1170,
        1167,
        170,
        1164,
        167,
        1185,
        1183,
        1180,
        1177,
        174,
        1190,
        1188,
        2025,
        2024,
        2022,
        587,
        586,
        564,
        559,
        556,
        2290,
        573,
        1588,
        520,
        518,
        512,
        2268,
        508,
        2265,
        530,
        1568,
        1565,
        461,
        457,
        2233,
        450,
        2230,
        446,
        2226,
        479,
        471,
        489,
        1526,
        1523,
        1520,
        397,
        395,
        2185,
        392,
        2183,
        389,
        2180,
        2177,
        410,
        2194,
        402,
        422,
        1463,
        1461,
        1459,
        1456,
        1470,
        2455,
        799,
        2433,
        2430,
        779,
        776,
        773,
        2397,
        2394,
        2390,
        734,
        728,
        724,
        746,
        1717,
        2356,
        2354,
        2351,
        2348,
        1658,
        677,
        675,
        673,
        670,
        667,
        688,
        1685,
        1683,
        2606,
        2589,
        2586,
        2559,
        2556,
        2552,
        927,
        2523,
        2521,
        2518,
        2515,
        1784,
        2532,
        895,
        893,
        890,
        2718,
        2709,
        2707,
        2689,
        2687,
        2684,
        2663,
        2662,
        2660,
        2658,
        1825,
        2667,
        2769,
        1852,
        2760,
        2758,
        142,
        141,
        1139,
        1138,
        134,
        132,
        129,
        126,
        1982,
        1129,
        1128,
        1126,
        1131,
        113,
        111,
        108,
        105,
        1972,
        101,
        1970,
        120,
        118,
        115,
        1109,
        1108,
        1106,
        1104,
        123,
        1113,
        1111,
        82,
        79,
        1951,
        75,
        1949,
        72,
        1946,
        92,
        89,
        86,
        1956,
        1077,
        1076,
        1074,
        1072,
        98,
        1069,
        96,
        1084,
        1082,
        1079,
        1088,
        1968,
        1967,
        48,
        45,
        1916,
        42,
        1914,
        39,
        1911,
        1908,
        60,
        57,
        54,
        1923,
        50,
        1920,
        1031,
        1030,
        1028,
        1026,
        67,
        1023,
        65,
        1020,
        62,
        1041,
        1039,
        1036,
        1033,
        69,
        1046,
        1044,
        1944,
        1943,
        1941,
        11,
        9,
        1868,
        7,
        1865,
        1862,
        1859,
        20,
        1878,
        16,
        1875,
        13,
        1872,
        970,
        968,
        966,
        963,
        29,
        960,
        26,
        23,
        983,
        981,
        978,
        975,
        33,
        971,
        31,
        990,
        988,
        985,
        1906,
        1904,
        1902,
        993,
        351,
        2145,
        1383,
        331,
        330,
        328,
        326,
        2137,
        323,
        2135,
        339,
        1372,
        1370,
        294,
        293,
        291,
        289,
        2122,
        286,
        2120,
        283,
        2117,
        309,
        303,
        317,
        1348,
        1346,
        1344,
        245,
        244,
        242,
        2090,
        239,
        2088,
        236,
        2085,
        2082,
        260,
        2099,
        249,
        270,
        1307,
        1305,
        1303,
        1300,
        1314,
        189,
        2038,
        186,
        2036,
        183,
        2033,
        2030,
        2026,
        206,
        198,
        2047,
        194,
        216,
        1247,
        1245,
        1243,
        1240,
        227,
        1237,
        1255,
        2310,
        2302,
        2300,
        2286,
        2284,
        2281,
        565,
        563,
        561,
        558,
        575,
        1589,
        2261,
        2259,
        2256,
        2253,
        1542,
        521,
        519,
        517,
        514,
        2270,
        511,
        533,
        1569,
        1567,
        2223,
        2221,
        2218,
        2215,
        1483,
        2211,
        1480,
        459,
        456,
        453,
        2232,
        449,
        474,
        491,
        1527,
        1525,
        1522,
        2475,
        2467,
        2465,
        2451,
        2449,
        2446,
        801,
        800,
        2426,
        2424,
        2421,
        2418,
        1723,
        2435,
        780,
        778,
        775,
        2387,
        2385,
        2382,
        2379,
        1695,
        2375,
        1693,
        2396,
        735,
        733,
        730,
        727,
        749,
        1718,
        2616,
        2615,
        2604,
        2603,
        2601,
        2584,
        2583,
        2581,
        2579,
        1800,
        2591,
        2550,
        2549,
        2547,
        2545,
        1792,
        2542,
        1790,
        2558,
        929,
        2719,
        1841,
        2710,
        2708,
        1833,
        1831,
        2690,
        2688,
        2686,
        1815,
        1809,
        1808,
        1774,
        1756,
        1754,
        1737,
        1736,
        1734,
        1739,
        1816,
        1711,
        1676,
        1674,
        633,
        629,
        1638,
        1636,
        1633,
        1641,
        598,
        1605,
        1604,
        1602,
        1600,
        605,
        1609,
        1607,
        2327,
        887,
        853,
        1775,
        822,
        820,
        1757,
        1755,
        1584,
        524,
        1560,
        1558,
        468,
        464,
        1514,
        1511,
        1508,
        1519,
        408,
        404,
        400,
        1452,
        1447,
        1444,
        417,
        1458,
        1455,
        2208,
        364,
        361,
        358,
        2154,
        1401,
        1400,
        1398,
        1396,
        374,
        1393,
        371,
        1408,
        1406,
        1403,
        1413,
        2173,
        2172,
        772,
        726,
        723,
        1712,
        672,
        669,
        666,
        682,
        1678,
        1675,
        625,
        623,
        621,
        618,
        2331,
        636,
        632,
        1639,
        1637,
        1635,
        920,
        918,
        884,
        880,
        889,
        849,
        848,
        847,
        846,
        2497,
        855,
        852,
        1776,
        2641,
        2742,
        2787,
        1380,
        334,
        1367,
        1365,
        301,
        297,
        1340,
        1338,
        1335,
        1343,
        255,
        251,
        247,
        1296,
        1291,
        1288,
        265,
        1302,
        1299,
        2113,
        204,
        196,
        192,
        2042,
        1232,
        1230,
        1224,
        214,
        1220,
        210,
        1242,
        1239,
        1235,
        1250,
        2077,
        2075,
        151,
        148,
        1993,
        144,
        1990,
        1163,
        1162,
        1160,
        1158,
        1155,
        161,
        1152,
        157,
        1173,
        1171,
        1168,
        1165,
        168,
        1181,
        1178,
        2021,
        2020,
        2018,
        2023,
        585,
        560,
        557,
        1585,
        516,
        509,
        1562,
        1559,
        458,
        447,
        2227,
        472,
        1516,
        1513,
        1510,
        398,
        396,
        393,
        390,
        2181,
        386,
        2178,
        407,
        1453,
        1451,
        1449,
        1446,
        420,
        1460,
        2209,
        769,
        764,
        720,
        712,
        2391,
        729,
        1713,
        664,
        663,
        661,
        659,
        2352,
        656,
        2349,
        671,
        1679,
        1677,
        2553,
        922,
        919,
        2519,
        2516,
        885,
        883,
        881,
        2685,
        2661,
        2659,
        2767,
        2756,
        2755,
        140,
        1137,
        1136,
        130,
        127,
        1125,
        1124,
        1122,
        1127,
        109,
        106,
        102,
        1103,
        1102,
        1100,
        1098,
        116,
        1107,
        1105,
        1980,
        80,
        76,
        73,
        1947,
        1068,
        1067,
        1065,
        1063,
        90,
        1060,
        87,
        1075,
        1073,
        1070,
        1080,
        1966,
        1965,
        46,
        43,
        40,
        1912,
        36,
        1909,
        1019,
        1018,
        1016,
        1014,
        58,
        1011,
        55,
        1008,
        51,
        1029,
        1027,
        1024,
        1021,
        63,
        1037,
        1034,
        1940,
        1939,
        1937,
        1942,
        8,
        1866,
        4,
        1863,
        1,
        1860,
        956,
        954,
        952,
        949,
        946,
        17,
        14,
        969,
        967,
        964,
        961,
        27,
        957,
        24,
        979,
        976,
        972,
        1901,
        1900,
        1898,
        1896,
        986,
        1905,
        1903,
        350,
        349,
        1381,
        329,
        327,
        324,
        1368,
        1366,
        292,
        290,
        287,
        284,
        2118,
        304,
        1341,
        1339,
        1337,
        1345,
        243,
        240,
        237,
        2086,
        233,
        2083,
        254,
        1297,
        1295,
        1293,
        1290,
        1304,
        2114,
        190,
        187,
        184,
        2034,
        180,
        2031,
        177,
        2027,
        199,
        1233,
        1231,
        1229,
        1226,
        217,
        1223,
        1241,
        2078,
        2076,
        584,
        555,
        554,
        552,
        550,
        2282,
        562,
        1586,
        507,
        506,
        504,
        502,
        2257,
        499,
        2254,
        515,
        1563,
        1561,
        445,
        443,
        441,
        2219,
        438,
        2216,
        435,
        2212,
        460,
        454,
        475,
        1517,
        1515,
        1512,
        2447,
        798,
        797,
        2422,
        2419,
        770,
        768,
        766,
        2383,
        2380,
        2376,
        721,
        719,
        717,
        714,
        731,
        1714,
        2602,
        2582,
        2580,
        2548,
        2546,
        2543,
        923,
        921,
        2717,
        2706,
        2705,
        2683,
        2682,
        2680,
        1771,
        1752,
        1750,
        1733,
        1732,
        1731,
        1735,
        1814,
        1707,
        1670,
        1668,
        1631,
        1629,
        1626,
        1634,
        1599,
        1598,
        1596,
        1594,
        1603,
        1601,
        2326,
        1772,
        1753,
        1751,
        1581,
        1554,
        1552,
        1504,
        1501,
        1498,
        1509,
        1442,
        1437,
        1434,
        401,
        1448,
        1445,
        2206,
        1392,
        1391,
        1389,
        1387,
        1384,
        359,
        1399,
        1397,
        1394,
        1404,
        2171,
        2170,
        1708,
        1672,
        1669,
        619,
        1632,
        1630,
        1628,
        1773,
        1378,
        1363,
        1361,
        1333,
        1328,
        1336,
        1286,
        1281,
        1278,
        248,
        1292,
        1289,
        2111,
        1218,
        1216,
        1210,
        197,
        1206,
        193,
        1228,
        1225,
        1221,
        1236,
        2073,
        2071,
        1151,
        1150,
        1148,
        1146,
        152,
        1143,
        149,
        1140,
        145,
        1161,
        1159,
        1156,
        1153,
        158,
        1169,
        1166,
        2017,
        2016,
        2014,
        2019,
        1582,
        510,
        1556,
        1553,
        452,
        448,
        1506,
        1500,
        394,
        391,
        387,
        1443,
        1441,
        1439,
        1436,
        1450,
        2207,
        765,
        716,
        713,
        1709,
        662,
        660,
        657,
        1673,
        1671,
        916,
        914,
        879,
        878,
        877,
        882,
        1135,
        1134,
        1121,
        1120,
        1118,
        1123,
        1097,
        1096,
        1094,
        1092,
        103,
        1101,
        1099,
        1979,
        1059,
        1058,
        1056,
        1054,
        77,
        1051,
        74,
        1066,
        1064,
        1061,
        1071,
        1964,
        1963,
        1007,
        1006,
        1004,
        1002,
        999,
        41,
        996,
        37,
        1017,
        1015,
        1012,
        1009,
        52,
        1025,
        1022,
        1936,
        1935,
        1933,
        1938,
        942,
        940,
        938,
        935,
        932,
        5,
        2,
        955,
        953,
        950,
        947,
        18,
        943,
        15,
        965,
        962,
        958,
        1895,
        1894,
        1892,
        1890,
        973,
        1899,
        1897,
        1379,
        325,
        1364,
        1362,
        288,
        285,
        1334,
        1332,
        1330,
        241,
        238,
        234,
        1287,
        1285,
        1283,
        1280,
        1294,
        2112,
        188,
        185,
        181,
        178,
        2028,
        1219,
        1217,
        1215,
        1212,
        200,
        1209,
        1227,
        2074,
        2072,
        583,
        553,
        551,
        1583,
        505,
        503,
        500,
        513,
        1557,
        1555,
        444,
        442,
        439,
        436,
        2213,
        455,
        451,
        1507,
        1505,
        1502,
        796,
        763,
        762,
        760,
        767,
        711,
        710,
        708,
        706,
        2377,
        718,
        715,
        1710,
        2544,
        917,
        915,
        2681,
        1627,
        1597,
        1595,
        2325,
        1769,
        1749,
        1747,
        1499,
        1438,
        1435,
        2204,
        1390,
        1388,
        1385,
        1395,
        2169,
        2167,
        1704,
        1665,
        1662,
        1625,
        1623,
        1620,
        1770,
        1329,
        1282,
        1279,
        2109,
        1214,
        1207,
        1222,
        2068,
        2065,
        1149,
        1147,
        1144,
        1141,
        146,
        1157,
        1154,
        2013,
        2011,
        2008,
        2015,
        1579,
        1549,
        1546,
        1495,
        1487,
        1433,
        1431,
        1428,
        1425,
        388,
        1440,
        2205,
        1705,
        658,
        1667,
        1664,
        1119,
        1095,
        1093,
        1978,
        1057,
        1055,
        1052,
        1062,
        1962,
        1960,
        1005,
        1003,
        1e3,
        997,
        38,
        1013,
        1010,
        1932,
        1930,
        1927,
        1934,
        941,
        939,
        936,
        933,
        6,
        930,
        3,
        951,
        948,
        944,
        1889,
        1887,
        1884,
        1881,
        959,
        1893,
        1891,
        35,
        1377,
        1360,
        1358,
        1327,
        1325,
        1322,
        1331,
        1277,
        1275,
        1272,
        1269,
        235,
        1284,
        2110,
        1205,
        1204,
        1201,
        1198,
        182,
        1195,
        179,
        1213,
        2070,
        2067,
        1580,
        501,
        1551,
        1548,
        440,
        437,
        1497,
        1494,
        1490,
        1503,
        761,
        709,
        707,
        1706,
        913,
        912,
        2198,
        1386,
        2164,
        2161,
        1621,
        1766,
        2103,
        1208,
        2058,
        2054,
        1145,
        1142,
        2005,
        2002,
        1999,
        2009,
        1488,
        1429,
        1426,
        2200,
        1698,
        1659,
        1656,
        1975,
        1053,
        1957,
        1954,
        1001,
        998,
        1924,
        1921,
        1918,
        1928,
        937,
        934,
        931,
        1879,
        1876,
        1873,
        1870,
        945,
        1885,
        1882,
        1323,
        1273,
        1270,
        2105,
        1202,
        1199,
        1196,
        1211,
        2061,
        2057,
        1576,
        1543,
        1540,
        1484,
        1481,
        1478,
        1491,
        1700
      ]);
      return PDF417Common2;
    }()
  );
  var PDF417Common_default = PDF417Common;

  // node_modules/@zxing/library/esm/core/pdf417/detector/PDF417DetectorResult.js
  var PDF417DetectorResult = (
    /** @class */
    function() {
      function PDF417DetectorResult2(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      PDF417DetectorResult2.prototype.getBits = function() {
        return this.bits;
      };
      PDF417DetectorResult2.prototype.getPoints = function() {
        return this.points;
      };
      return PDF417DetectorResult2;
    }()
  );
  var PDF417DetectorResult_default = PDF417DetectorResult;

  // node_modules/@zxing/library/esm/core/pdf417/detector/Detector.js
  var __values29 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Detector4 = (
    /** @class */
    function() {
      function Detector5() {
      }
      Detector5.detectMultiple = function(image, hints, multiple) {
        var bitMatrix = image.getBlackMatrix();
        var barcodeCoordinates = Detector5.detect(multiple, bitMatrix);
        if (!barcodeCoordinates.length) {
          bitMatrix = bitMatrix.clone();
          bitMatrix.rotate180();
          barcodeCoordinates = Detector5.detect(multiple, bitMatrix);
        }
        return new PDF417DetectorResult_default(bitMatrix, barcodeCoordinates);
      };
      Detector5.detect = function(multiple, bitMatrix) {
        var e_1, _a2;
        var barcodeCoordinates = new Array();
        var row = 0;
        var column = 0;
        var foundBarcodeInRow = false;
        while (row < bitMatrix.getHeight()) {
          var vertices = Detector5.findVertices(bitMatrix, row, column);
          if (vertices[0] == null && vertices[3] == null) {
            if (!foundBarcodeInRow) {
              break;
            }
            foundBarcodeInRow = false;
            column = 0;
            try {
              for (var barcodeCoordinates_1 = (e_1 = void 0, __values29(barcodeCoordinates)), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {
                var barcodeCoordinate = barcodeCoordinates_1_1.value;
                if (barcodeCoordinate[1] != null) {
                  row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
                }
                if (barcodeCoordinate[3] != null) {
                  row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a2 = barcodeCoordinates_1.return)) _a2.call(barcodeCoordinates_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            row += Detector5.ROW_STEP;
            continue;
          }
          foundBarcodeInRow = true;
          barcodeCoordinates.push(vertices);
          if (!multiple) {
            break;
          }
          if (vertices[2] != null) {
            column = Math.trunc(vertices[2].getX());
            row = Math.trunc(vertices[2].getY());
          } else {
            column = Math.trunc(vertices[4].getX());
            row = Math.trunc(vertices[4].getY());
          }
        }
        return barcodeCoordinates;
      };
      Detector5.findVertices = function(matrix, startRow, startColumn) {
        var height = matrix.getHeight();
        var width = matrix.getWidth();
        var result = new Array(8);
        Detector5.copyToResult(result, Detector5.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector5.START_PATTERN), Detector5.INDEXES_START_PATTERN);
        if (result[4] != null) {
          startColumn = Math.trunc(result[4].getX());
          startRow = Math.trunc(result[4].getY());
        }
        Detector5.copyToResult(result, Detector5.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector5.STOP_PATTERN), Detector5.INDEXES_STOP_PATTERN);
        return result;
      };
      Detector5.copyToResult = function(result, tmpResult, destinationIndexes) {
        for (var i = 0; i < destinationIndexes.length; i++) {
          result[destinationIndexes[i]] = tmpResult[i];
        }
      };
      Detector5.findRowsWithPattern = function(matrix, height, width, startRow, startColumn, pattern) {
        var result = new Array(4);
        var found2 = false;
        var counters = new Int32Array(pattern.length);
        for (; startRow < height; startRow += Detector5.ROW_STEP) {
          var loc = Detector5.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
          if (loc != null) {
            while (startRow > 0) {
              var previousRowLoc = Detector5.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
              if (previousRowLoc != null) {
                loc = previousRowLoc;
              } else {
                startRow++;
                break;
              }
            }
            result[0] = new ResultPoint_default(loc[0], startRow);
            result[1] = new ResultPoint_default(loc[1], startRow);
            found2 = true;
            break;
          }
        }
        var stopRow = startRow + 1;
        if (found2) {
          var skippedRowCount = 0;
          var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
          for (; stopRow < height; stopRow++) {
            var loc = Detector5.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
            if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector5.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector5.MAX_PATTERN_DRIFT) {
              previousRowLoc = loc;
              skippedRowCount = 0;
            } else {
              if (skippedRowCount > Detector5.SKIPPED_ROW_COUNT_MAX) {
                break;
              } else {
                skippedRowCount++;
              }
            }
          }
          stopRow -= skippedRowCount + 1;
          result[2] = new ResultPoint_default(previousRowLoc[0], stopRow);
          result[3] = new ResultPoint_default(previousRowLoc[1], stopRow);
        }
        if (stopRow - startRow < Detector5.BARCODE_MIN_HEIGHT) {
          Arrays_default.fill(result, null);
        }
        return result;
      };
      Detector5.findGuardPattern = function(matrix, column, row, width, whiteFirst, pattern, counters) {
        Arrays_default.fillWithin(counters, 0, counters.length, 0);
        var patternStart = column;
        var pixelDrift = 0;
        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector5.MAX_PIXEL_DRIFT) {
          patternStart--;
        }
        var x = patternStart;
        var counterPosition = 0;
        var patternLength = pattern.length;
        for (var isWhite = whiteFirst; x < width; x++) {
          var pixel = matrix.get(x, row);
          if (pixel !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (Detector5.patternMatchVariance(counters, pattern, Detector5.MAX_INDIVIDUAL_VARIANCE) < Detector5.MAX_AVG_VARIANCE) {
                return new Int32Array([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              System_default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        if (counterPosition === patternLength - 1 && Detector5.patternMatchVariance(counters, pattern, Detector5.MAX_INDIVIDUAL_VARIANCE) < Detector5.MAX_AVG_VARIANCE) {
          return new Int32Array([patternStart, x - 1]);
        }
        return null;
      };
      Detector5.patternMatchVariance = function(counters, pattern, maxIndividualVariance) {
        var numCounters = counters.length;
        var total = 0;
        var patternLength = 0;
        for (var i = 0; i < numCounters; i++) {
          total += counters[i];
          patternLength += pattern[i];
        }
        if (total < patternLength) {
          return (
            /*Float.POSITIVE_INFINITY*/
            Infinity
          );
        }
        var unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        var totalVariance = 0;
        for (var x = 0; x < numCounters; x++) {
          var counter = counters[x];
          var scaledPattern = pattern[x] * unitBarWidth;
          var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return (
              /*Float.POSITIVE_INFINITY*/
              Infinity
            );
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      };
      Detector5.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
      Detector5.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
      Detector5.MAX_AVG_VARIANCE = 0.42;
      Detector5.MAX_INDIVIDUAL_VARIANCE = 0.8;
      Detector5.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
      Detector5.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
      Detector5.MAX_PIXEL_DRIFT = 3;
      Detector5.MAX_PATTERN_DRIFT = 5;
      Detector5.SKIPPED_ROW_COUNT_MAX = 25;
      Detector5.ROW_STEP = 5;
      Detector5.BARCODE_MIN_HEIGHT = 10;
      return Detector5;
    }()
  );
  var Detector_default4 = Detector4;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusPoly.js
  var __values30 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ModulusPoly = (
    /** @class */
    function() {
      function ModulusPoly2(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException_default();
        }
        this.field = field;
        var coefficientsLength = (
          /*int*/
          coefficients.length
        );
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          var firstNonZero = (
            /*int*/
            1
          );
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = new Int32Array([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System_default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      ModulusPoly2.prototype.getCoefficients = function() {
        return this.coefficients;
      };
      ModulusPoly2.prototype.getDegree = function() {
        return this.coefficients.length - 1;
      };
      ModulusPoly2.prototype.isZero = function() {
        return this.coefficients[0] === 0;
      };
      ModulusPoly2.prototype.getCoefficient = function(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      };
      ModulusPoly2.prototype.evaluateAt = function(a) {
        var e_1, _a2;
        if (a === 0) {
          return this.getCoefficient(0);
        }
        if (a === 1) {
          var sum = (
            /*int*/
            0
          );
          try {
            for (var _b = __values30(this.coefficients), _c = _b.next(); !_c.done; _c = _b.next()) {
              var coefficient = _c.value;
              sum = this.field.add(sum, coefficient);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return sum;
        }
        var result = (
          /*int*/
          this.coefficients[0]
        );
        var size = (
          /*int*/
          this.coefficients.length
        );
        for (var i = 1; i < size; i++) {
          result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
        }
        return result;
      };
      ModulusPoly2.prototype.add = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        var smallerCoefficients = this.coefficients;
        var largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          var temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        var sumDiff = new Int32Array(largerCoefficients.length);
        var lengthDiff = (
          /*int*/
          largerCoefficients.length - smallerCoefficients.length
        );
        System_default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (var i = lengthDiff; i < largerCoefficients.length; i++) {
          sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new ModulusPoly2(this.field, sumDiff);
      };
      ModulusPoly2.prototype.subtract = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
        }
        if (other.isZero()) {
          return this;
        }
        return this.add(other.negative());
      };
      ModulusPoly2.prototype.multiply = function(other) {
        if (other instanceof ModulusPoly2) {
          return this.multiplyOther(other);
        }
        return this.multiplyScalar(other);
      };
      ModulusPoly2.prototype.multiplyOther = function(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero() || other.isZero()) {
          return new ModulusPoly2(this.field, new Int32Array([0]));
        }
        var aCoefficients = this.coefficients;
        var aLength = (
          /*int*/
          aCoefficients.length
        );
        var bCoefficients = other.coefficients;
        var bLength = (
          /*int*/
          bCoefficients.length
        );
        var product = new Int32Array(aLength + bLength - 1);
        for (var i = 0; i < aLength; i++) {
          var aCoeff = (
            /*int*/
            aCoefficients[i]
          );
          for (var j = 0; j < bLength; j++) {
            product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new ModulusPoly2(this.field, product);
      };
      ModulusPoly2.prototype.negative = function() {
        var size = (
          /*int*/
          this.coefficients.length
        );
        var negativeCoefficients = new Int32Array(size);
        for (var i = 0; i < size; i++) {
          negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
        }
        return new ModulusPoly2(this.field, negativeCoefficients);
      };
      ModulusPoly2.prototype.multiplyScalar = function(scalar) {
        if (scalar === 0) {
          return new ModulusPoly2(this.field, new Int32Array([0]));
        }
        if (scalar === 1) {
          return this;
        }
        var size = (
          /*int*/
          this.coefficients.length
        );
        var product = new Int32Array(size);
        for (var i = 0; i < size; i++) {
          product[i] = this.field.multiply(this.coefficients[i], scalar);
        }
        return new ModulusPoly2(this.field, product);
      };
      ModulusPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException_default();
        }
        if (coefficient === 0) {
          return new ModulusPoly2(this.field, new Int32Array([0]));
        }
        var size = (
          /*int*/
          this.coefficients.length
        );
        var product = new Int32Array(size + degree);
        for (var i = 0; i < size; i++) {
          product[i] = this.field.multiply(this.coefficients[i], coefficient);
        }
        return new ModulusPoly2(this.field, product);
      };
      ModulusPoly2.prototype.toString = function() {
        var result = new StringBuilder_default(
          /*8 * this.getDegree()*/
        );
        for (var degree = this.getDegree(); degree >= 0; degree--) {
          var coefficient = (
            /*int*/
            this.getCoefficient(degree)
          );
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result.append(" - ");
              coefficient = -coefficient;
            } else {
              if (result.length() > 0) {
                result.append(" + ");
              }
            }
            if (degree === 0 || coefficient !== 1) {
              result.append(coefficient);
            }
            if (degree !== 0) {
              if (degree === 1) {
                result.append("x");
              } else {
                result.append("x^");
                result.append(degree);
              }
            }
          }
        }
        return result.toString();
      };
      return ModulusPoly2;
    }()
  );
  var ModulusPoly_default = ModulusPoly;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusBase.js
  var ModulusBase = (
    /** @class */
    function() {
      function ModulusBase2() {
      }
      ModulusBase2.prototype.add = function(a, b) {
        return (a + b) % this.modulus;
      };
      ModulusBase2.prototype.subtract = function(a, b) {
        return (this.modulus + a - b) % this.modulus;
      };
      ModulusBase2.prototype.exp = function(a) {
        return this.expTable[a];
      };
      ModulusBase2.prototype.log = function(a) {
        if (a === 0) {
          throw new IllegalArgumentException_default();
        }
        return this.logTable[a];
      };
      ModulusBase2.prototype.inverse = function(a) {
        if (a === 0) {
          throw new ArithmeticException_default();
        }
        return this.expTable[this.modulus - this.logTable[a] - 1];
      };
      ModulusBase2.prototype.multiply = function(a, b) {
        if (a === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
      };
      ModulusBase2.prototype.getSize = function() {
        return this.modulus;
      };
      ModulusBase2.prototype.equals = function(o) {
        return o === this;
      };
      return ModulusBase2;
    }()
  );
  var ModulusBase_default = ModulusBase;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusGF.js
  var __extends56 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ModulusGF = (
    /** @class */
    function(_super) {
      __extends56(ModulusGF2, _super);
      function ModulusGF2(modulus, generator) {
        var _this = _super.call(this) || this;
        _this.modulus = modulus;
        _this.expTable = new Int32Array(modulus);
        _this.logTable = new Int32Array(modulus);
        var x = (
          /*int*/
          1
        );
        for (var i = 0; i < modulus; i++) {
          _this.expTable[i] = x;
          x = x * generator % modulus;
        }
        for (var i = 0; i < modulus - 1; i++) {
          _this.logTable[_this.expTable[i]] = i;
        }
        _this.zero = new ModulusPoly_default(_this, new Int32Array([0]));
        _this.one = new ModulusPoly_default(_this, new Int32Array([1]));
        return _this;
      }
      ModulusGF2.prototype.getZero = function() {
        return this.zero;
      };
      ModulusGF2.prototype.getOne = function() {
        return this.one;
      };
      ModulusGF2.prototype.buildMonomial = function(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException_default();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        var coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new ModulusPoly_default(this, coefficients);
      };
      ModulusGF2.PDF417_GF = new ModulusGF2(PDF417Common_default.NUMBER_OF_CODEWORDS, 3);
      return ModulusGF2;
    }(ModulusBase_default)
  );
  var ModulusGF_default = ModulusGF;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ErrorCorrection.js
  var __values31 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ErrorCorrection = (
    /** @class */
    function() {
      function ErrorCorrection3() {
        this.field = ModulusGF_default.PDF417_GF;
      }
      ErrorCorrection3.prototype.decode = function(received, numECCodewords, erasures) {
        var e_1, _a2;
        var poly = new ModulusPoly_default(this.field, received);
        var S = new Int32Array(numECCodewords);
        var error2 = false;
        for (var i = numECCodewords; i > 0; i--) {
          var evaluation = poly.evaluateAt(this.field.exp(i));
          S[numECCodewords - i] = evaluation;
          if (evaluation !== 0) {
            error2 = true;
          }
        }
        if (!error2) {
          return 0;
        }
        var knownErrors = this.field.getOne();
        if (erasures != null) {
          try {
            for (var erasures_1 = __values31(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {
              var erasure = erasures_1_1.value;
              var b = this.field.exp(received.length - 1 - erasure);
              var term = new ModulusPoly_default(this.field, new Int32Array([this.field.subtract(0, b), 1]));
              knownErrors = knownErrors.multiply(term);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (erasures_1_1 && !erasures_1_1.done && (_a2 = erasures_1.return)) _a2.call(erasures_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
        var syndrome = new ModulusPoly_default(this.field, S);
        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
        var sigma = sigmaOmega[0];
        var omega = sigmaOmega[1];
        var errorLocations = this.findErrorLocations(sigma);
        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
        for (var i = 0; i < errorLocations.length; i++) {
          var position = received.length - 1 - this.field.log(errorLocations[i]);
          if (position < 0) {
            throw ChecksumException_default.getChecksumInstance();
          }
          received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
        }
        return errorLocations.length;
      };
      ErrorCorrection3.prototype.runEuclideanAlgorithm = function(a, b, R) {
        if (a.getDegree() < b.getDegree()) {
          var temp = a;
          a = b;
          b = temp;
        }
        var rLast = a;
        var r = b;
        var tLast = this.field.getZero();
        var t = this.field.getOne();
        while (r.getDegree() >= Math.round(R / 2)) {
          var rLastLast = rLast;
          var tLastLast = tLast;
          rLast = r;
          tLast = t;
          if (rLast.isZero()) {
            throw ChecksumException_default.getChecksumInstance();
          }
          r = rLastLast;
          var q = this.field.getZero();
          var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          var dltInverse = this.field.inverse(denominatorLeadingTerm);
          while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
            var degreeDiff = r.getDegree() - rLast.getDegree();
            var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
            q = q.add(this.field.buildMonomial(degreeDiff, scale));
            r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t = q.multiply(tLast).subtract(tLastLast).negative();
        }
        var sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw ChecksumException_default.getChecksumInstance();
        }
        var inverse = this.field.inverse(sigmaTildeAtZero);
        var sigma = t.multiply(inverse);
        var omega = r.multiply(inverse);
        return [sigma, omega];
      };
      ErrorCorrection3.prototype.findErrorLocations = function(errorLocator) {
        var numErrors = errorLocator.getDegree();
        var result = new Int32Array(numErrors);
        var e = 0;
        for (var i = 1; i < this.field.getSize() && e < numErrors; i++) {
          if (errorLocator.evaluateAt(i) === 0) {
            result[e] = this.field.inverse(i);
            e++;
          }
        }
        if (e !== numErrors) {
          throw ChecksumException_default.getChecksumInstance();
        }
        return result;
      };
      ErrorCorrection3.prototype.findErrorMagnitudes = function(errorEvaluator, errorLocator, errorLocations) {
        var errorLocatorDegree = errorLocator.getDegree();
        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
        for (var i = 1; i <= errorLocatorDegree; i++) {
          formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));
        }
        var formalDerivative = new ModulusPoly_default(this.field, formalDerivativeCoefficients);
        var s = errorLocations.length;
        var result = new Int32Array(s);
        for (var i = 0; i < s; i++) {
          var xiInverse = this.field.inverse(errorLocations[i]);
          var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
          var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
          result[i] = this.field.multiply(numerator, denominator);
        }
        return result;
      };
      return ErrorCorrection3;
    }()
  );
  var ErrorCorrection_default = ErrorCorrection;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/BoundingBox.js
  var BoundingBox = (
    /** @class */
    function() {
      function BoundingBox2(image, topLeft, bottomLeft, topRight, bottomRight) {
        if (image instanceof BoundingBox2) {
          this.constructor_2(image);
        } else {
          this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
        }
      }
      BoundingBox2.prototype.constructor_1 = function(image, topLeft, bottomLeft, topRight, bottomRight) {
        var leftUnspecified = topLeft == null || bottomLeft == null;
        var rightUnspecified = topRight == null || bottomRight == null;
        if (leftUnspecified && rightUnspecified) {
          throw new NotFoundException_default();
        }
        if (leftUnspecified) {
          topLeft = new ResultPoint_default(0, topRight.getY());
          bottomLeft = new ResultPoint_default(0, bottomRight.getY());
        } else if (rightUnspecified) {
          topRight = new ResultPoint_default(image.getWidth() - 1, topLeft.getY());
          bottomRight = new ResultPoint_default(image.getWidth() - 1, bottomLeft.getY());
        }
        this.image = image;
        this.topLeft = topLeft;
        this.bottomLeft = bottomLeft;
        this.topRight = topRight;
        this.bottomRight = bottomRight;
        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
      };
      BoundingBox2.prototype.constructor_2 = function(boundingBox) {
        this.image = boundingBox.image;
        this.topLeft = boundingBox.getTopLeft();
        this.bottomLeft = boundingBox.getBottomLeft();
        this.topRight = boundingBox.getTopRight();
        this.bottomRight = boundingBox.getBottomRight();
        this.minX = boundingBox.getMinX();
        this.maxX = boundingBox.getMaxX();
        this.minY = boundingBox.getMinY();
        this.maxY = boundingBox.getMaxY();
      };
      BoundingBox2.merge = function(leftBox, rightBox) {
        if (leftBox == null) {
          return rightBox;
        }
        if (rightBox == null) {
          return leftBox;
        }
        return new BoundingBox2(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
      };
      BoundingBox2.prototype.addMissingRows = function(missingStartRows, missingEndRows, isLeft) {
        var newTopLeft = this.topLeft;
        var newBottomLeft = this.bottomLeft;
        var newTopRight = this.topRight;
        var newBottomRight = this.bottomRight;
        if (missingStartRows > 0) {
          var top_1 = isLeft ? this.topLeft : this.topRight;
          var newMinY = Math.trunc(top_1.getY() - missingStartRows);
          if (newMinY < 0) {
            newMinY = 0;
          }
          var newTop = new ResultPoint_default(top_1.getX(), newMinY);
          if (isLeft) {
            newTopLeft = newTop;
          } else {
            newTopRight = newTop;
          }
        }
        if (missingEndRows > 0) {
          var bottom2 = isLeft ? this.bottomLeft : this.bottomRight;
          var newMaxY = Math.trunc(bottom2.getY() + missingEndRows);
          if (newMaxY >= this.image.getHeight()) {
            newMaxY = this.image.getHeight() - 1;
          }
          var newBottom = new ResultPoint_default(bottom2.getX(), newMaxY);
          if (isLeft) {
            newBottomLeft = newBottom;
          } else {
            newBottomRight = newBottom;
          }
        }
        return new BoundingBox2(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
      };
      BoundingBox2.prototype.getMinX = function() {
        return this.minX;
      };
      BoundingBox2.prototype.getMaxX = function() {
        return this.maxX;
      };
      BoundingBox2.prototype.getMinY = function() {
        return this.minY;
      };
      BoundingBox2.prototype.getMaxY = function() {
        return this.maxY;
      };
      BoundingBox2.prototype.getTopLeft = function() {
        return this.topLeft;
      };
      BoundingBox2.prototype.getTopRight = function() {
        return this.topRight;
      };
      BoundingBox2.prototype.getBottomLeft = function() {
        return this.bottomLeft;
      };
      BoundingBox2.prototype.getBottomRight = function() {
        return this.bottomRight;
      };
      return BoundingBox2;
    }()
  );
  var BoundingBox_default = BoundingBox;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/BarcodeMetadata.js
  var BarcodeMetadata = (
    /** @class */
    function() {
      function BarcodeMetadata2(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
        this.columnCount = columnCount;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.rowCountUpperPart = rowCountUpperPart;
        this.rowCountLowerPart = rowCountLowerPart;
        this.rowCount = rowCountUpperPart + rowCountLowerPart;
      }
      BarcodeMetadata2.prototype.getColumnCount = function() {
        return this.columnCount;
      };
      BarcodeMetadata2.prototype.getErrorCorrectionLevel = function() {
        return this.errorCorrectionLevel;
      };
      BarcodeMetadata2.prototype.getRowCount = function() {
        return this.rowCount;
      };
      BarcodeMetadata2.prototype.getRowCountUpperPart = function() {
        return this.rowCountUpperPart;
      };
      BarcodeMetadata2.prototype.getRowCountLowerPart = function() {
        return this.rowCountLowerPart;
      };
      return BarcodeMetadata2;
    }()
  );
  var BarcodeMetadata_default = BarcodeMetadata;

  // node_modules/@zxing/library/esm/core/util/Formatter.js
  var Formatter = (
    /** @class */
    function() {
      function Formatter2() {
        this.buffer = "";
      }
      Formatter2.form = function(str, arr) {
        var i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (arr[++i] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          var base2 = p3 ? parseInt(p3.substr(1)) : void 0;
          var val;
          switch (p4) {
            case "s":
              val = arr[i];
              break;
            case "c":
              val = arr[i][0];
              break;
            case "f":
              val = parseFloat(arr[i]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(arr[i]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(arr[i]).toExponential(exp);
              break;
            case "x":
              val = parseInt(arr[i]).toString(base2 ? base2 : 16);
              break;
            case "d":
              val = parseFloat(parseInt(arr[i], base2 ? base2 : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base2);
          var size = parseInt(p1);
          var ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return str.replace(regex, callback);
      };
      Formatter2.prototype.format = function(append2) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        this.buffer += Formatter2.form(append2, args);
      };
      Formatter2.prototype.toString = function() {
        return this.buffer;
      };
      return Formatter2;
    }()
  );
  var Formatter_default = Formatter;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResultColumn.js
  var __values32 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var DetectionResultColumn = (
    /** @class */
    function() {
      function DetectionResultColumn2(boundingBox) {
        this.boundingBox = new BoundingBox_default(boundingBox);
        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
      }
      DetectionResultColumn2.prototype.getCodewordNearby = function(imageRow) {
        var codeword = this.getCodeword(imageRow);
        if (codeword != null) {
          return codeword;
        }
        for (var i = 1; i < DetectionResultColumn2.MAX_NEARBY_DISTANCE; i++) {
          var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
          if (nearImageRow >= 0) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
          nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
          if (nearImageRow < this.codewords.length) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
        }
        return null;
      };
      DetectionResultColumn2.prototype.imageRowToCodewordIndex = function(imageRow) {
        return imageRow - this.boundingBox.getMinY();
      };
      DetectionResultColumn2.prototype.setCodeword = function(imageRow, codeword) {
        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
      };
      DetectionResultColumn2.prototype.getCodeword = function(imageRow) {
        return this.codewords[this.imageRowToCodewordIndex(imageRow)];
      };
      DetectionResultColumn2.prototype.getBoundingBox = function() {
        return this.boundingBox;
      };
      DetectionResultColumn2.prototype.getCodewords = function() {
        return this.codewords;
      };
      DetectionResultColumn2.prototype.toString = function() {
        var e_1, _a2;
        var formatter = new Formatter_default();
        var row = 0;
        try {
          for (var _b = __values32(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {
            var codeword = _c.value;
            if (codeword == null) {
              formatter.format("%3d:    |   %n", row++);
              continue;
            }
            formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return formatter.toString();
      };
      DetectionResultColumn2.MAX_NEARBY_DISTANCE = 5;
      return DetectionResultColumn2;
    }()
  );
  var DetectionResultColumn_default = DetectionResultColumn;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/BarcodeValue.js
  var __values33 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var BarcodeValue = (
    /** @class */
    function() {
      function BarcodeValue2() {
        this.values = /* @__PURE__ */ new Map();
      }
      BarcodeValue2.prototype.setValue = function(value) {
        value = Math.trunc(value);
        var confidence = this.values.get(value);
        if (confidence == null) {
          confidence = 0;
        }
        confidence++;
        this.values.set(value, confidence);
      };
      BarcodeValue2.prototype.getValue = function() {
        var e_1, _a2;
        var maxConfidence = -1;
        var result = new Array();
        var _loop_1 = function(key2, value2) {
          var entry = {
            getKey: function() {
              return key2;
            },
            getValue: function() {
              return value2;
            }
          };
          if (entry.getValue() > maxConfidence) {
            maxConfidence = entry.getValue();
            result = [];
            result.push(entry.getKey());
          } else if (entry.getValue() === maxConfidence) {
            result.push(entry.getKey());
          }
        };
        try {
          for (var _b = __values33(this.values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            _loop_1(key, value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return PDF417Common_default.toIntArray(result);
      };
      BarcodeValue2.prototype.getConfidence = function(value) {
        return this.values.get(value);
      };
      return BarcodeValue2;
    }()
  );
  var BarcodeValue_default = BarcodeValue;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js
  var __extends57 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values34 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var DetectionResultRowIndicatorColumn = (
    /** @class */
    function(_super) {
      __extends57(DetectionResultRowIndicatorColumn2, _super);
      function DetectionResultRowIndicatorColumn2(boundingBox, isLeft) {
        var _this = _super.call(this, boundingBox) || this;
        _this._isLeft = isLeft;
        return _this;
      }
      DetectionResultRowIndicatorColumn2.prototype.setRowNumbers = function() {
        var e_1, _a2;
        try {
          for (var _b = __values34(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var codeword = _c.value;
            if (codeword != null) {
              codeword.setRowNumberAsRowIndicatorColumn();
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      DetectionResultRowIndicatorColumn2.prototype.adjustCompleteIndicatorColumnRowNumbers = function(barcodeMetadata) {
        var codewords = this.getCodewords();
        this.setRowNumbers();
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        var boundingBox = this.getBoundingBox();
        var top2 = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        var bottom2 = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top2.getY()));
        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom2.getY()));
        var barcodeRow = -1;
        var maxRowHeight = 1;
        var currentRowHeight = 0;
        for (var codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          var codeword = codewords[codewordsRow];
          var rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) {
            currentRowHeight++;
          } else if (rowDifference === 1) {
            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
            currentRowHeight = 1;
            barcodeRow = codeword.getRowNumber();
          } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
            codewords[codewordsRow] = null;
          } else {
            var checkedRows = void 0;
            if (maxRowHeight > 2) {
              checkedRows = (maxRowHeight - 2) * rowDifference;
            } else {
              checkedRows = rowDifference;
            }
            var closePreviousCodewordFound = checkedRows >= codewordsRow;
            for (var i = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
              closePreviousCodewordFound = codewords[codewordsRow - i] != null;
            }
            if (closePreviousCodewordFound) {
              codewords[codewordsRow] = null;
            } else {
              barcodeRow = codeword.getRowNumber();
              currentRowHeight = 1;
            }
          }
        }
      };
      DetectionResultRowIndicatorColumn2.prototype.getRowHeights = function() {
        var e_2, _a2;
        var barcodeMetadata = this.getBarcodeMetadata();
        if (barcodeMetadata == null) {
          return null;
        }
        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
        var result = new Int32Array(barcodeMetadata.getRowCount());
        try {
          for (var _b = __values34(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var codeword = _c.value;
            if (codeword != null) {
              var rowNumber = codeword.getRowNumber();
              if (rowNumber >= result.length) {
                continue;
              }
              result[rowNumber]++;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return result;
      };
      DetectionResultRowIndicatorColumn2.prototype.adjustIncompleteIndicatorColumnRowNumbers = function(barcodeMetadata) {
        var boundingBox = this.getBoundingBox();
        var top2 = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        var bottom2 = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top2.getY()));
        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom2.getY()));
        var codewords = this.getCodewords();
        var barcodeRow = -1;
        var maxRowHeight = 1;
        var currentRowHeight = 0;
        for (var codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          var codeword = codewords[codewordsRow];
          codeword.setRowNumberAsRowIndicatorColumn();
          var rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) {
            currentRowHeight++;
          } else if (rowDifference === 1) {
            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
            currentRowHeight = 1;
            barcodeRow = codeword.getRowNumber();
          } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
            codewords[codewordsRow] = null;
          } else {
            barcodeRow = codeword.getRowNumber();
            currentRowHeight = 1;
          }
        }
      };
      DetectionResultRowIndicatorColumn2.prototype.getBarcodeMetadata = function() {
        var e_3, _a2;
        var codewords = this.getCodewords();
        var barcodeColumnCount = new BarcodeValue_default();
        var barcodeRowCountUpperPart = new BarcodeValue_default();
        var barcodeRowCountLowerPart = new BarcodeValue_default();
        var barcodeECLevel = new BarcodeValue_default();
        try {
          for (var codewords_1 = __values34(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {
            var codeword = codewords_1_1.value;
            if (codeword == null) {
              continue;
            }
            codeword.setRowNumberAsRowIndicatorColumn();
            var rowIndicatorValue = codeword.getValue() % 30;
            var codewordRowNumber = codeword.getRowNumber();
            if (!this._isLeft) {
              codewordRowNumber += 2;
            }
            switch (codewordRowNumber % 3) {
              case 0:
                barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
                break;
              case 1:
                barcodeECLevel.setValue(rowIndicatorValue / 3);
                barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
                break;
              case 2:
                barcodeColumnCount.setValue(rowIndicatorValue + 1);
                break;
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (codewords_1_1 && !codewords_1_1.done && (_a2 = codewords_1.return)) _a2.call(codewords_1);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_default.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_default.MAX_ROWS_IN_BARCODE) {
          return null;
        }
        var barcodeMetadata = new BarcodeMetadata_default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        return barcodeMetadata;
      };
      DetectionResultRowIndicatorColumn2.prototype.removeIncorrectCodewords = function(codewords, barcodeMetadata) {
        for (var codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
          var codeword = codewords[codewordRow];
          if (codewords[codewordRow] == null) {
            continue;
          }
          var rowIndicatorValue = codeword.getValue() % 30;
          var codewordRowNumber = codeword.getRowNumber();
          if (codewordRowNumber > barcodeMetadata.getRowCount()) {
            codewords[codewordRow] = null;
            continue;
          }
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 1:
              if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 2:
              if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                codewords[codewordRow] = null;
              }
              break;
          }
        }
      };
      DetectionResultRowIndicatorColumn2.prototype.isLeft = function() {
        return this._isLeft;
      };
      DetectionResultRowIndicatorColumn2.prototype.toString = function() {
        return "IsLeft: " + this._isLeft + "\n" + _super.prototype.toString.call(this);
      };
      return DetectionResultRowIndicatorColumn2;
    }(DetectionResultColumn_default)
  );
  var DetectionResultRowIndicatorColumn_default = DetectionResultRowIndicatorColumn;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResult.js
  var __values35 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var DetectionResult = (
    /** @class */
    function() {
      function DetectionResult2(barcodeMetadata, boundingBox) {
        this.ADJUST_ROW_NUMBER_SKIP = 2;
        this.barcodeMetadata = barcodeMetadata;
        this.barcodeColumnCount = barcodeMetadata.getColumnCount();
        this.boundingBox = boundingBox;
        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
      }
      DetectionResult2.prototype.getDetectionResultColumns = function() {
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
        var unadjustedCodewordCount = PDF417Common_default.MAX_CODEWORDS_IN_BARCODE;
        var previousUnadjustedCount;
        do {
          previousUnadjustedCount = unadjustedCodewordCount;
          unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
        return this.detectionResultColumns;
      };
      DetectionResult2.prototype.adjustIndicatorColumnRowNumbers = function(detectionResultColumn) {
        if (detectionResultColumn != null) {
          detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
        }
      };
      DetectionResult2.prototype.adjustRowNumbersAndGetCount = function() {
        var unadjustedCount = this.adjustRowNumbersByRow();
        if (unadjustedCount === 0) {
          return 0;
        }
        for (var barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
          var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
          for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            if (!codewords[codewordsRow].hasValidRowNumber()) {
              this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
            }
          }
        }
        return unadjustedCount;
      };
      DetectionResult2.prototype.adjustRowNumbersByRow = function() {
        this.adjustRowNumbersFromBothRI();
        var unadjustedCount = this.adjustRowNumbersFromLRI();
        return unadjustedCount + this.adjustRowNumbersFromRRI();
      };
      DetectionResult2.prototype.adjustRowNumbersFromBothRI = function() {
        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return;
        }
        var LRIcodewords = this.detectionResultColumns[0].getCodewords();
        var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (var codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
          if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
            for (var barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
              var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword == null) {
                continue;
              }
              codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
              if (!codeword.hasValidRowNumber()) {
                this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
              }
            }
          }
        }
      };
      DetectionResult2.prototype.adjustRowNumbersFromRRI = function() {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return 0;
        }
        var unadjustedCount = 0;
        var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          var invalidRowCounts = 0;
          for (var barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
            var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult2.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      };
      DetectionResult2.prototype.adjustRowNumbersFromLRI = function() {
        if (this.detectionResultColumns[0] == null) {
          return 0;
        }
        var unadjustedCount = 0;
        var codewords = this.detectionResultColumns[0].getCodewords();
        for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          var invalidRowCounts = 0;
          for (var barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
            var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult2.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      };
      DetectionResult2.adjustRowNumberIfValid = function(rowIndicatorRowNumber, invalidRowCounts, codeword) {
        if (codeword == null) {
          return invalidRowCounts;
        }
        if (!codeword.hasValidRowNumber()) {
          if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
            codeword.setRowNumber(rowIndicatorRowNumber);
            invalidRowCounts = 0;
          } else {
            ++invalidRowCounts;
          }
        }
        return invalidRowCounts;
      };
      DetectionResult2.prototype.adjustRowNumbers = function(barcodeColumn, codewordsRow, codewords) {
        var e_1, _a2;
        if (this.detectionResultColumns[barcodeColumn - 1] == null) {
          return;
        }
        var codeword = codewords[codewordsRow];
        var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
        var nextColumnCodewords = previousColumnCodewords;
        if (this.detectionResultColumns[barcodeColumn + 1] != null) {
          nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
        }
        var otherCodewords = new Array(14);
        otherCodewords[2] = previousColumnCodewords[codewordsRow];
        otherCodewords[3] = nextColumnCodewords[codewordsRow];
        if (codewordsRow > 0) {
          otherCodewords[0] = codewords[codewordsRow - 1];
          otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
          otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
        }
        if (codewordsRow > 1) {
          otherCodewords[8] = codewords[codewordsRow - 2];
          otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
          otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
        }
        if (codewordsRow < codewords.length - 1) {
          otherCodewords[1] = codewords[codewordsRow + 1];
          otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
          otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
        }
        if (codewordsRow < codewords.length - 2) {
          otherCodewords[9] = codewords[codewordsRow + 2];
          otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
          otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
        }
        try {
          for (var otherCodewords_1 = __values35(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {
            var otherCodeword = otherCodewords_1_1.value;
            if (DetectionResult2.adjustRowNumber(codeword, otherCodeword)) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a2 = otherCodewords_1.return)) _a2.call(otherCodewords_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      DetectionResult2.adjustRowNumber = function(codeword, otherCodeword) {
        if (otherCodeword == null) {
          return false;
        }
        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
          codeword.setRowNumber(otherCodeword.getRowNumber());
          return true;
        }
        return false;
      };
      DetectionResult2.prototype.getBarcodeColumnCount = function() {
        return this.barcodeColumnCount;
      };
      DetectionResult2.prototype.getBarcodeRowCount = function() {
        return this.barcodeMetadata.getRowCount();
      };
      DetectionResult2.prototype.getBarcodeECLevel = function() {
        return this.barcodeMetadata.getErrorCorrectionLevel();
      };
      DetectionResult2.prototype.setBoundingBox = function(boundingBox) {
        this.boundingBox = boundingBox;
      };
      DetectionResult2.prototype.getBoundingBox = function() {
        return this.boundingBox;
      };
      DetectionResult2.prototype.setDetectionResultColumn = function(barcodeColumn, detectionResultColumn) {
        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
      };
      DetectionResult2.prototype.getDetectionResultColumn = function(barcodeColumn) {
        return this.detectionResultColumns[barcodeColumn];
      };
      DetectionResult2.prototype.toString = function() {
        var rowIndicatorColumn = this.detectionResultColumns[0];
        if (rowIndicatorColumn == null) {
          rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
        }
        var formatter = new Formatter_default();
        for (var codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
          formatter.format("CW %3d:", codewordsRow);
          for (var barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
            if (this.detectionResultColumns[barcodeColumn] == null) {
              formatter.format("    |   ");
              continue;
            }
            var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword == null) {
              formatter.format("    |   ");
              continue;
            }
            formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
          }
          formatter.format("%n");
        }
        return formatter.toString();
      };
      return DetectionResult2;
    }()
  );
  var DetectionResult_default = DetectionResult;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/Codeword.js
  var Codeword = (
    /** @class */
    function() {
      function Codeword2(startX, endX, bucket, value) {
        this.rowNumber = Codeword2.BARCODE_ROW_UNKNOWN;
        this.startX = Math.trunc(startX);
        this.endX = Math.trunc(endX);
        this.bucket = Math.trunc(bucket);
        this.value = Math.trunc(value);
      }
      Codeword2.prototype.hasValidRowNumber = function() {
        return this.isValidRowNumber(this.rowNumber);
      };
      Codeword2.prototype.isValidRowNumber = function(rowNumber) {
        return rowNumber !== Codeword2.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
      };
      Codeword2.prototype.setRowNumberAsRowIndicatorColumn = function() {
        this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
      };
      Codeword2.prototype.getWidth = function() {
        return this.endX - this.startX;
      };
      Codeword2.prototype.getStartX = function() {
        return this.startX;
      };
      Codeword2.prototype.getEndX = function() {
        return this.endX;
      };
      Codeword2.prototype.getBucket = function() {
        return this.bucket;
      };
      Codeword2.prototype.getValue = function() {
        return this.value;
      };
      Codeword2.prototype.getRowNumber = function() {
        return this.rowNumber;
      };
      Codeword2.prototype.setRowNumber = function(rowNumber) {
        this.rowNumber = rowNumber;
      };
      Codeword2.prototype.toString = function() {
        return this.rowNumber + "|" + this.value;
      };
      Codeword2.BARCODE_ROW_UNKNOWN = -1;
      return Codeword2;
    }()
  );
  var Codeword_default = Codeword;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/PDF417CodewordDecoder.js
  var PDF417CodewordDecoder = (
    /** @class */
    function() {
      function PDF417CodewordDecoder2() {
      }
      PDF417CodewordDecoder2.initialize = function() {
        for (var i = 0; i < PDF417Common_default.SYMBOL_TABLE.length; i++) {
          var currentSymbol = PDF417Common_default.SYMBOL_TABLE[i];
          var currentBit = currentSymbol & 1;
          for (var j = 0; j < PDF417Common_default.BARS_IN_MODULE; j++) {
            var size = 0;
            while ((currentSymbol & 1) === currentBit) {
              size += 1;
              currentSymbol >>= 1;
            }
            currentBit = currentSymbol & 1;
            if (!PDF417CodewordDecoder2.RATIOS_TABLE[i]) {
              PDF417CodewordDecoder2.RATIOS_TABLE[i] = new Array(PDF417Common_default.BARS_IN_MODULE);
            }
            PDF417CodewordDecoder2.RATIOS_TABLE[i][PDF417Common_default.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common_default.MODULES_IN_CODEWORD);
          }
        }
        this.bSymbolTableReady = true;
      };
      PDF417CodewordDecoder2.getDecodedValue = function(moduleBitCount) {
        var decodedValue = PDF417CodewordDecoder2.getDecodedCodewordValue(PDF417CodewordDecoder2.sampleBitCounts(moduleBitCount));
        if (decodedValue !== -1) {
          return decodedValue;
        }
        return PDF417CodewordDecoder2.getClosestDecodedValue(moduleBitCount);
      };
      PDF417CodewordDecoder2.sampleBitCounts = function(moduleBitCount) {
        var bitCountSum = MathUtils_default.sum(moduleBitCount);
        var result = new Int32Array(PDF417Common_default.BARS_IN_MODULE);
        var bitCountIndex = 0;
        var sumPreviousBits = 0;
        for (var i = 0; i < PDF417Common_default.MODULES_IN_CODEWORD; i++) {
          var sampleIndex = bitCountSum / (2 * PDF417Common_default.MODULES_IN_CODEWORD) + i * bitCountSum / PDF417Common_default.MODULES_IN_CODEWORD;
          if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
            sumPreviousBits += moduleBitCount[bitCountIndex];
            bitCountIndex++;
          }
          result[bitCountIndex]++;
        }
        return result;
      };
      PDF417CodewordDecoder2.getDecodedCodewordValue = function(moduleBitCount) {
        var decodedValue = PDF417CodewordDecoder2.getBitValue(moduleBitCount);
        return PDF417Common_default.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
      };
      PDF417CodewordDecoder2.getBitValue = function(moduleBitCount) {
        var result = (
          /*long*/
          0
        );
        for (var i = 0; i < moduleBitCount.length; i++) {
          for (var bit = 0; bit < moduleBitCount[i]; bit++) {
            result = result << 1 | (i % 2 === 0 ? 1 : 0);
          }
        }
        return Math.trunc(result);
      };
      PDF417CodewordDecoder2.getClosestDecodedValue = function(moduleBitCount) {
        var bitCountSum = MathUtils_default.sum(moduleBitCount);
        var bitCountRatios = new Array(PDF417Common_default.BARS_IN_MODULE);
        if (bitCountSum > 1) {
          for (var i = 0; i < bitCountRatios.length; i++) {
            bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
          }
        }
        var bestMatchError = Float_default.MAX_VALUE;
        var bestMatch = -1;
        if (!this.bSymbolTableReady) {
          PDF417CodewordDecoder2.initialize();
        }
        for (var j = 0; j < PDF417CodewordDecoder2.RATIOS_TABLE.length; j++) {
          var error2 = 0;
          var ratioTableRow = PDF417CodewordDecoder2.RATIOS_TABLE[j];
          for (var k = 0; k < PDF417Common_default.BARS_IN_MODULE; k++) {
            var diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
            error2 += Math.fround(diff * diff);
            if (error2 >= bestMatchError) {
              break;
            }
          }
          if (error2 < bestMatchError) {
            bestMatchError = error2;
            bestMatch = PDF417Common_default.SYMBOL_TABLE[j];
          }
        }
        return bestMatch;
      };
      PDF417CodewordDecoder2.bSymbolTableReady = false;
      PDF417CodewordDecoder2.RATIOS_TABLE = new Array(PDF417Common_default.SYMBOL_TABLE.length).map(function(x) {
        return x = new Array(PDF417Common_default.BARS_IN_MODULE);
      });
      return PDF417CodewordDecoder2;
    }()
  );
  var PDF417CodewordDecoder_default = PDF417CodewordDecoder;

  // node_modules/@zxing/library/esm/core/pdf417/PDF417ResultMetadata.js
  var PDF417ResultMetadata = (
    /** @class */
    function() {
      function PDF417ResultMetadata2() {
        this.segmentCount = -1;
        this.fileSize = -1;
        this.timestamp = -1;
        this.checksum = -1;
      }
      PDF417ResultMetadata2.prototype.getSegmentIndex = function() {
        return this.segmentIndex;
      };
      PDF417ResultMetadata2.prototype.setSegmentIndex = function(segmentIndex) {
        this.segmentIndex = segmentIndex;
      };
      PDF417ResultMetadata2.prototype.getFileId = function() {
        return this.fileId;
      };
      PDF417ResultMetadata2.prototype.setFileId = function(fileId) {
        this.fileId = fileId;
      };
      PDF417ResultMetadata2.prototype.getOptionalData = function() {
        return this.optionalData;
      };
      PDF417ResultMetadata2.prototype.setOptionalData = function(optionalData) {
        this.optionalData = optionalData;
      };
      PDF417ResultMetadata2.prototype.isLastSegment = function() {
        return this.lastSegment;
      };
      PDF417ResultMetadata2.prototype.setLastSegment = function(lastSegment) {
        this.lastSegment = lastSegment;
      };
      PDF417ResultMetadata2.prototype.getSegmentCount = function() {
        return this.segmentCount;
      };
      PDF417ResultMetadata2.prototype.setSegmentCount = function(segmentCount) {
        this.segmentCount = segmentCount;
      };
      PDF417ResultMetadata2.prototype.getSender = function() {
        return this.sender || null;
      };
      PDF417ResultMetadata2.prototype.setSender = function(sender) {
        this.sender = sender;
      };
      PDF417ResultMetadata2.prototype.getAddressee = function() {
        return this.addressee || null;
      };
      PDF417ResultMetadata2.prototype.setAddressee = function(addressee) {
        this.addressee = addressee;
      };
      PDF417ResultMetadata2.prototype.getFileName = function() {
        return this.fileName;
      };
      PDF417ResultMetadata2.prototype.setFileName = function(fileName) {
        this.fileName = fileName;
      };
      PDF417ResultMetadata2.prototype.getFileSize = function() {
        return this.fileSize;
      };
      PDF417ResultMetadata2.prototype.setFileSize = function(fileSize) {
        this.fileSize = fileSize;
      };
      PDF417ResultMetadata2.prototype.getChecksum = function() {
        return this.checksum;
      };
      PDF417ResultMetadata2.prototype.setChecksum = function(checksum) {
        this.checksum = checksum;
      };
      PDF417ResultMetadata2.prototype.getTimestamp = function() {
        return this.timestamp;
      };
      PDF417ResultMetadata2.prototype.setTimestamp = function(timestamp) {
        this.timestamp = timestamp;
      };
      return PDF417ResultMetadata2;
    }()
  );
  var PDF417ResultMetadata_default = PDF417ResultMetadata;

  // node_modules/@zxing/library/esm/core/util/Long.js
  var Long = (
    /** @class */
    function() {
      function Long2() {
      }
      Long2.parseLong = function(num, radix) {
        if (radix === void 0) {
          radix = void 0;
        }
        return parseInt(num, radix);
      };
      return Long2;
    }()
  );
  var Long_default = Long;

  // node_modules/@zxing/library/esm/core/NullPointerException.js
  var __extends58 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var NullPointerException = (
    /** @class */
    function(_super) {
      __extends58(NullPointerException2, _super);
      function NullPointerException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NullPointerException2.kind = "NullPointerException";
      return NullPointerException2;
    }(Exception_default)
  );
  var NullPointerException_default = NullPointerException;

  // node_modules/@zxing/library/esm/core/util/OutputStream.js
  var OutputStream = (
    /** @class */
    function() {
      function OutputStream2() {
      }
      OutputStream2.prototype.writeBytes = function(b) {
        this.writeBytesOffset(b, 0, b.length);
      };
      OutputStream2.prototype.writeBytesOffset = function(b, off, len) {
        if (b == null) {
          throw new NullPointerException_default();
        } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
          throw new IndexOutOfBoundsException_default();
        } else if (len === 0) {
          return;
        }
        for (var i = 0; i < len; i++) {
          this.write(b[off + i]);
        }
      };
      OutputStream2.prototype.flush = function() {
      };
      OutputStream2.prototype.close = function() {
      };
      return OutputStream2;
    }()
  );
  var OutputStream_default = OutputStream;

  // node_modules/@zxing/library/esm/core/OutOfMemoryError.js
  var __extends59 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var OutOfMemoryError = (
    /** @class */
    function(_super) {
      __extends59(OutOfMemoryError2, _super);
      function OutOfMemoryError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return OutOfMemoryError2;
    }(Exception_default)
  );
  var OutOfMemoryError_default = OutOfMemoryError;

  // node_modules/@zxing/library/esm/core/util/ByteArrayOutputStream.js
  var __extends60 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ByteArrayOutputStream = (
    /** @class */
    function(_super) {
      __extends60(ByteArrayOutputStream2, _super);
      function ByteArrayOutputStream2(size) {
        if (size === void 0) {
          size = 32;
        }
        var _this = _super.call(this) || this;
        _this.count = 0;
        if (size < 0) {
          throw new IllegalArgumentException_default("Negative initial size: " + size);
        }
        _this.buf = new Uint8Array(size);
        return _this;
      }
      ByteArrayOutputStream2.prototype.ensureCapacity = function(minCapacity) {
        if (minCapacity - this.buf.length > 0)
          this.grow(minCapacity);
      };
      ByteArrayOutputStream2.prototype.grow = function(minCapacity) {
        var oldCapacity = this.buf.length;
        var newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0)
          newCapacity = minCapacity;
        if (newCapacity < 0) {
          if (minCapacity < 0)
            throw new OutOfMemoryError_default();
          newCapacity = Integer_default.MAX_VALUE;
        }
        this.buf = Arrays_default.copyOfUint8Array(this.buf, newCapacity);
      };
      ByteArrayOutputStream2.prototype.write = function(b) {
        this.ensureCapacity(this.count + 1);
        this.buf[this.count] = /*(byte)*/
        b;
        this.count += 1;
      };
      ByteArrayOutputStream2.prototype.writeBytesOffset = function(b, off, len) {
        if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {
          throw new IndexOutOfBoundsException_default();
        }
        this.ensureCapacity(this.count + len);
        System_default.arraycopy(b, off, this.buf, this.count, len);
        this.count += len;
      };
      ByteArrayOutputStream2.prototype.writeTo = function(out) {
        out.writeBytesOffset(this.buf, 0, this.count);
      };
      ByteArrayOutputStream2.prototype.reset = function() {
        this.count = 0;
      };
      ByteArrayOutputStream2.prototype.toByteArray = function() {
        return Arrays_default.copyOfUint8Array(this.buf, this.count);
      };
      ByteArrayOutputStream2.prototype.size = function() {
        return this.count;
      };
      ByteArrayOutputStream2.prototype.toString = function(param) {
        if (!param) {
          return this.toString_void();
        }
        if (typeof param === "string") {
          return this.toString_string(param);
        }
        return this.toString_number(param);
      };
      ByteArrayOutputStream2.prototype.toString_void = function() {
        return new String(
          this.buf
          /*, 0, this.count*/
        ).toString();
      };
      ByteArrayOutputStream2.prototype.toString_string = function(charsetName) {
        return new String(
          this.buf
          /*, 0, this.count, charsetName*/
        ).toString();
      };
      ByteArrayOutputStream2.prototype.toString_number = function(hibyte) {
        return new String(
          this.buf
          /*, hibyte, 0, this.count*/
        ).toString();
      };
      ByteArrayOutputStream2.prototype.close = function() {
      };
      return ByteArrayOutputStream2;
    }(OutputStream_default)
  );
  var ByteArrayOutputStream_default = ByteArrayOutputStream;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/DecodedBitStreamParser.js
  var Mode3;
  (function(Mode5) {
    Mode5[Mode5["ALPHA"] = 0] = "ALPHA";
    Mode5[Mode5["LOWER"] = 1] = "LOWER";
    Mode5[Mode5["MIXED"] = 2] = "MIXED";
    Mode5[Mode5["PUNCT"] = 3] = "PUNCT";
    Mode5[Mode5["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
    Mode5[Mode5["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
  })(Mode3 || (Mode3 = {}));
  function getBigIntConstructor() {
    if (typeof window !== "undefined") {
      return window["BigInt"] || null;
    }
    if (typeof global !== "undefined") {
      return global["BigInt"] || null;
    }
    if (typeof self !== "undefined") {
      return self["BigInt"] || null;
    }
    throw new Error("Can't search globals for BigInt!");
  }
  var BigInteger;
  function createBigInt(num) {
    if (typeof BigInteger === "undefined") {
      BigInteger = getBigIntConstructor();
    }
    if (BigInteger === null) {
      throw new Error("BigInt is not supported!");
    }
    return BigInteger(num);
  }
  function getEXP900() {
    var EXP900 = [];
    EXP900[0] = createBigInt(1);
    var nineHundred = createBigInt(900);
    EXP900[1] = nineHundred;
    for (var i = 2; i < 16; i++) {
      EXP900[i] = EXP900[i - 1] * nineHundred;
    }
    return EXP900;
  }
  var DecodedBitStreamParser3 = (
    /** @class */
    function() {
      function DecodedBitStreamParser4() {
      }
      DecodedBitStreamParser4.decode = function(codewords, ecLevel) {
        var result = new StringBuilder_default("");
        var encoding = CharacterSetECI_default.ISO8859_1;
        result.enableDecoding(encoding);
        var codeIndex = 1;
        var code = codewords[codeIndex++];
        var resultMetadata = new PDF417ResultMetadata_default();
        while (codeIndex < codewords[0]) {
          switch (code) {
            case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
              codeIndex = DecodedBitStreamParser4.byteCompaction(code, codewords, encoding, codeIndex, result);
              break;
            case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              result.append(
                /*(char)*/
                codewords[codeIndex++]
              );
              break;
            case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser4.ECI_CHARSET:
              var charsetECI = CharacterSetECI_default.getCharacterSetECIByValue(codewords[codeIndex++]);
              break;
            case DecodedBitStreamParser4.ECI_GENERAL_PURPOSE:
              codeIndex += 2;
              break;
            case DecodedBitStreamParser4.ECI_USER_DEFINED:
              codeIndex++;
              break;
            case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              codeIndex = DecodedBitStreamParser4.decodeMacroBlock(codewords, codeIndex, resultMetadata);
              break;
            case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
              throw new FormatException_default();
            default:
              codeIndex--;
              codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, result);
              break;
          }
          if (codeIndex < codewords.length) {
            code = codewords[codeIndex++];
          } else {
            throw FormatException_default.getFormatInstance();
          }
        }
        if (result.length() === 0) {
          throw FormatException_default.getFormatInstance();
        }
        var decoderResult = new DecoderResult_default(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
      };
      DecodedBitStreamParser4.decodeMacroBlock = function(codewords, codeIndex, resultMetadata) {
        if (codeIndex + DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
          throw FormatException_default.getFormatInstance();
        }
        var segmentIndexArray = new Int32Array(DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS);
        for (var i = 0; i < DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
          segmentIndexArray[i] = codewords[codeIndex];
        }
        resultMetadata.setSegmentIndex(Integer_default.parseInt(DecodedBitStreamParser4.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS)));
        var fileId = new StringBuilder_default();
        codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, fileId);
        resultMetadata.setFileId(fileId.toString());
        var optionalFieldsStart = -1;
        if (codewords[codeIndex] === DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
          optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
          switch (codewords[codeIndex]) {
            case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              codeIndex++;
              switch (codewords[codeIndex]) {
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  var fileName = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, fileName);
                  resultMetadata.setFileName(fileName.toString());
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  var sender = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, sender);
                  resultMetadata.setSender(sender.toString());
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  var addressee = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, addressee);
                  resultMetadata.setAddressee(addressee.toString());
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  var segmentCount = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, segmentCount);
                  resultMetadata.setSegmentCount(Integer_default.parseInt(segmentCount.toString()));
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  var timestamp = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, timestamp);
                  resultMetadata.setTimestamp(Long_default.parseLong(timestamp.toString()));
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  var checksum = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, checksum);
                  resultMetadata.setChecksum(Integer_default.parseInt(checksum.toString()));
                  break;
                case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  var fileSize = new StringBuilder_default();
                  codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, fileSize);
                  resultMetadata.setFileSize(Long_default.parseLong(fileSize.toString()));
                  break;
                default:
                  throw FormatException_default.getFormatInstance();
              }
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
              codeIndex++;
              resultMetadata.setLastSegment(true);
              break;
            default:
              throw FormatException_default.getFormatInstance();
          }
        }
        if (optionalFieldsStart !== -1) {
          var optionalFieldsLength = codeIndex - optionalFieldsStart;
          if (resultMetadata.isLastSegment()) {
            optionalFieldsLength--;
          }
          resultMetadata.setOptionalData(Arrays_default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
        }
        return codeIndex;
      };
      DecodedBitStreamParser4.textCompaction = function(codewords, codeIndex, result) {
        var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        var index = 0;
        var end2 = false;
        while (codeIndex < codewords[0] && !end2) {
          var code = codewords[codeIndex++];
          if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
            textCompactionData[index] = code / 30;
            textCompactionData[index + 1] = code % 30;
            index += 2;
          } else {
            switch (code) {
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                textCompactionData[index++] = DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH;
                break;
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end2 = true;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                textCompactionData[index] = DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                code = codewords[codeIndex++];
                byteCompactionData[index] = code;
                index++;
                break;
            }
          }
        }
        DecodedBitStreamParser4.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
        return codeIndex;
      };
      DecodedBitStreamParser4.decodeTextCompaction = function(textCompactionData, byteCompactionData, length, result) {
        var subMode = Mode3.ALPHA;
        var priorToShiftMode = Mode3.ALPHA;
        var i = 0;
        while (i < length) {
          var subModeCh = textCompactionData[i];
          var ch = (
            /*char*/
            ""
          );
          switch (subMode) {
            case Mode3.ALPHA:
              if (subModeCh < 26) {
                ch = /*(char)('A' + subModeCh) */
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser4.LL:
                    subMode = Mode3.LOWER;
                    break;
                  case DecodedBitStreamParser4.ML:
                    subMode = Mode3.MIXED;
                    break;
                  case DecodedBitStreamParser4.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode3.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
            case Mode3.LOWER:
              if (subModeCh < 26) {
                ch = /*(char)('a' + subModeCh)*/
                String.fromCharCode(97 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser4.AS:
                    priorToShiftMode = subMode;
                    subMode = Mode3.ALPHA_SHIFT;
                    break;
                  case DecodedBitStreamParser4.ML:
                    subMode = Mode3.MIXED;
                    break;
                  case DecodedBitStreamParser4.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode3.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
            case Mode3.MIXED:
              if (subModeCh < DecodedBitStreamParser4.PL) {
                ch = DecodedBitStreamParser4.MIXED_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser4.PL:
                    subMode = Mode3.PUNCT;
                    break;
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser4.LL:
                    subMode = Mode3.LOWER;
                    break;
                  case DecodedBitStreamParser4.AL:
                    subMode = Mode3.ALPHA;
                    break;
                  case DecodedBitStreamParser4.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode3.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
            case Mode3.PUNCT:
              if (subModeCh < DecodedBitStreamParser4.PAL) {
                ch = DecodedBitStreamParser4.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser4.PAL:
                    subMode = Mode3.ALPHA;
                    break;
                  case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
            case Mode3.ALPHA_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < 26) {
                ch = /*(char)('A' + subModeCh)*/
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
            case Mode3.PUNCT_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < DecodedBitStreamParser4.PAL) {
                ch = DecodedBitStreamParser4.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser4.PAL:
                    subMode = Mode3.ALPHA;
                    break;
                  case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i]
                    );
                    break;
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode3.ALPHA;
                    break;
                }
              }
              break;
          }
          if (ch !== "") {
            result.append(ch);
          }
          i++;
        }
      };
      DecodedBitStreamParser4.byteCompaction = function(mode, codewords, encoding, codeIndex, result) {
        var decodedBytes = new ByteArrayOutputStream_default();
        var count = 0;
        var value = (
          /*long*/
          0
        );
        var end2 = false;
        switch (mode) {
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
            var byteCompactedCodewords = new Int32Array(6);
            var nextCode = codewords[codeIndex++];
            while (codeIndex < codewords[0] && !end2) {
              byteCompactedCodewords[count++] = nextCode;
              value = 900 * value + nextCode;
              nextCode = codewords[codeIndex++];
              switch (nextCode) {
                case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end2 = true;
                  break;
                default:
                  if (count % 5 === 0 && count > 0) {
                    for (var j = 0; j < 6; ++j) {
                      decodedBytes.write(
                        /*(byte)*/
                        Number(createBigInt(value) >> createBigInt(8 * (5 - j)))
                      );
                    }
                    value = 0;
                    count = 0;
                  }
                  break;
              }
            }
            if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
              byteCompactedCodewords[count++] = nextCode;
            }
            for (var i = 0; i < count; i++) {
              decodedBytes.write(
                /*(byte)*/
                byteCompactedCodewords[i]
              );
            }
            break;
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
            while (codeIndex < codewords[0] && !end2) {
              var code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
                count++;
                value = 900 * value + code;
              } else {
                switch (code) {
                  case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end2 = true;
                    break;
                }
              }
              if (count % 5 === 0 && count > 0) {
                for (var j = 0; j < 6; ++j) {
                  decodedBytes.write(
                    /*(byte)*/
                    Number(createBigInt(value) >> createBigInt(8 * (5 - j)))
                  );
                }
                value = 0;
                count = 0;
              }
            }
            break;
        }
        result.append(StringEncoding_default.decode(decodedBytes.toByteArray(), encoding));
        return codeIndex;
      };
      DecodedBitStreamParser4.numericCompaction = function(codewords, codeIndex, result) {
        var count = 0;
        var end2 = false;
        var numericCodewords = new Int32Array(DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS);
        while (codeIndex < codewords[0] && !end2) {
          var code = codewords[codeIndex++];
          if (codeIndex === codewords[0]) {
            end2 = true;
          }
          if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
            numericCodewords[count] = code;
            count++;
          } else {
            switch (code) {
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end2 = true;
                break;
            }
          }
          if ((count % DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH || end2) && count > 0) {
            result.append(DecodedBitStreamParser4.decodeBase900toBase10(numericCodewords, count));
            count = 0;
          }
        }
        return codeIndex;
      };
      DecodedBitStreamParser4.decodeBase900toBase10 = function(codewords, count) {
        var result = createBigInt(0);
        for (var i = 0; i < count; i++) {
          result += DecodedBitStreamParser4.EXP900[count - i - 1] * createBigInt(codewords[i]);
        }
        var resultString = result.toString();
        if (resultString.charAt(0) !== "1") {
          throw new FormatException_default();
        }
        return resultString.substring(1);
      };
      DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH = 900;
      DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH = 901;
      DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH = 902;
      DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6 = 924;
      DecodedBitStreamParser4.ECI_USER_DEFINED = 925;
      DecodedBitStreamParser4.ECI_GENERAL_PURPOSE = 926;
      DecodedBitStreamParser4.ECI_CHARSET = 927;
      DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
      DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
      DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR = 922;
      DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
      DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS = 15;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
      DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
      DecodedBitStreamParser4.PL = 25;
      DecodedBitStreamParser4.LL = 27;
      DecodedBitStreamParser4.AS = 27;
      DecodedBitStreamParser4.ML = 28;
      DecodedBitStreamParser4.AL = 28;
      DecodedBitStreamParser4.PS = 29;
      DecodedBitStreamParser4.PAL = 29;
      DecodedBitStreamParser4.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
      DecodedBitStreamParser4.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
      DecodedBitStreamParser4.EXP900 = getBigIntConstructor() ? getEXP900() : [];
      DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
      return DecodedBitStreamParser4;
    }()
  );
  var DecodedBitStreamParser_default3 = DecodedBitStreamParser3;

  // node_modules/@zxing/library/esm/core/pdf417/decoder/PDF417ScanningDecoder.js
  var __values36 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var PDF417ScanningDecoder = (
    /** @class */
    function() {
      function PDF417ScanningDecoder2() {
      }
      PDF417ScanningDecoder2.decode = function(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
        var boundingBox = new BoundingBox_default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
        var leftRowIndicatorColumn = null;
        var rightRowIndicatorColumn = null;
        var detectionResult;
        for (var firstPass = true; ; firstPass = false) {
          if (imageTopLeft != null) {
            leftRowIndicatorColumn = PDF417ScanningDecoder2.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
          }
          if (imageTopRight != null) {
            rightRowIndicatorColumn = PDF417ScanningDecoder2.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
          }
          detectionResult = PDF417ScanningDecoder2.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (detectionResult == null) {
            throw NotFoundException_default.getNotFoundInstance();
          }
          var resultBox = detectionResult.getBoundingBox();
          if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
            boundingBox = resultBox;
          } else {
            break;
          }
        }
        detectionResult.setBoundingBox(boundingBox);
        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
        var leftToRight = leftRowIndicatorColumn != null;
        for (var barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
          var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
          if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */
          void 0) {
            continue;
          }
          var detectionResultColumn = void 0;
          if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
            detectionResultColumn = new DetectionResultRowIndicatorColumn_default(boundingBox, barcodeColumn === 0);
          } else {
            detectionResultColumn = new DetectionResultColumn_default(boundingBox);
          }
          detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
          var startColumn = -1;
          var previousStartColumn = startColumn;
          for (var imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
            startColumn = PDF417ScanningDecoder2.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
            if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
              if (previousStartColumn === -1) {
                continue;
              }
              startColumn = previousStartColumn;
            }
            var codeword = PDF417ScanningDecoder2.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              detectionResultColumn.setCodeword(imageRow, codeword);
              previousStartColumn = startColumn;
              minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
              maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
            }
          }
        }
        return PDF417ScanningDecoder2.createDecoderResult(detectionResult);
      };
      PDF417ScanningDecoder2.merge = function(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
          return null;
        }
        var barcodeMetadata = PDF417ScanningDecoder2.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
        if (barcodeMetadata == null) {
          return null;
        }
        var boundingBox = BoundingBox_default.merge(PDF417ScanningDecoder2.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder2.adjustBoundingBox(rightRowIndicatorColumn));
        return new DetectionResult_default(barcodeMetadata, boundingBox);
      };
      PDF417ScanningDecoder2.adjustBoundingBox = function(rowIndicatorColumn) {
        var e_1, _a2;
        if (rowIndicatorColumn == null) {
          return null;
        }
        var rowHeights = rowIndicatorColumn.getRowHeights();
        if (rowHeights == null) {
          return null;
        }
        var maxRowHeight = PDF417ScanningDecoder2.getMax(rowHeights);
        var missingStartRows = 0;
        try {
          for (var rowHeights_1 = __values36(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {
            var rowHeight = rowHeights_1_1.value;
            missingStartRows += maxRowHeight - rowHeight;
            if (rowHeight > 0) {
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (rowHeights_1_1 && !rowHeights_1_1.done && (_a2 = rowHeights_1.return)) _a2.call(rowHeights_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        var codewords = rowIndicatorColumn.getCodewords();
        for (var row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
          missingStartRows--;
        }
        var missingEndRows = 0;
        for (var row = rowHeights.length - 1; row >= 0; row--) {
          missingEndRows += maxRowHeight - rowHeights[row];
          if (rowHeights[row] > 0) {
            break;
          }
        }
        for (var row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
          missingEndRows--;
        }
        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
      };
      PDF417ScanningDecoder2.getMax = function(values) {
        var e_2, _a2;
        var maxValue = -1;
        try {
          for (var values_1 = __values36(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
            var value = values_1_1.value;
            maxValue = Math.max(maxValue, value);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (values_1_1 && !values_1_1.done && (_a2 = values_1.return)) _a2.call(values_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return maxValue;
      };
      PDF417ScanningDecoder2.getBarcodeMetadata = function(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        var leftBarcodeMetadata;
        if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
        }
        var rightBarcodeMetadata;
        if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return leftBarcodeMetadata;
        }
        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
          return null;
        }
        return leftBarcodeMetadata;
      };
      PDF417ScanningDecoder2.getRowIndicatorColumn = function(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_default(boundingBox, leftToRight);
        for (var i = 0; i < 2; i++) {
          var increment = i === 0 ? 1 : -1;
          var startColumn = Math.trunc(Math.trunc(startPoint.getX()));
          for (var imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
            var codeword = PDF417ScanningDecoder2.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              rowIndicatorColumn.setCodeword(imageRow, codeword);
              if (leftToRight) {
                startColumn = codeword.getStartX();
              } else {
                startColumn = codeword.getEndX();
              }
            }
          }
        }
        return rowIndicatorColumn;
      };
      PDF417ScanningDecoder2.adjustCodewordCount = function(detectionResult, barcodeMatrix) {
        var barcodeMatrix01 = barcodeMatrix[0][1];
        var numberOfCodewords = barcodeMatrix01.getValue();
        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder2.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
        if (numberOfCodewords.length === 0) {
          if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_default.MAX_CODEWORDS_IN_BARCODE) {
            throw NotFoundException_default.getNotFoundInstance();
          }
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
      };
      PDF417ScanningDecoder2.createDecoderResult = function(detectionResult) {
        var barcodeMatrix = PDF417ScanningDecoder2.createBarcodeMatrix(detectionResult);
        PDF417ScanningDecoder2.adjustCodewordCount(detectionResult, barcodeMatrix);
        var erasures = new Array();
        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
        var ambiguousIndexValuesList = (
          /*List<int[]>*/
          []
        );
        var ambiguousIndexesList = (
          /*Collection<Integer>*/
          new Array()
        );
        for (var row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
          for (var column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
            var values = barcodeMatrix[row][column + 1].getValue();
            var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
            if (values.length === 0) {
              erasures.push(codewordIndex);
            } else if (values.length === 1) {
              codewords[codewordIndex] = values[0];
            } else {
              ambiguousIndexesList.push(codewordIndex);
              ambiguousIndexValuesList.push(values);
            }
          }
        }
        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
        for (var i = 0; i < ambiguousIndexValues.length; i++) {
          ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
        }
        return PDF417ScanningDecoder2.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_default.toIntArray(erasures), PDF417Common_default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
      };
      PDF417ScanningDecoder2.createDecoderResultFromAmbiguousValues = function(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
        var tries = 100;
        while (tries-- > 0) {
          for (var i = 0; i < ambiguousIndexCount.length; i++) {
            codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
          }
          try {
            return PDF417ScanningDecoder2.decodeCodewords(codewords, ecLevel, erasureArray);
          } catch (err) {
            var ignored = err instanceof ChecksumException_default;
            if (!ignored) {
              throw err;
            }
          }
          if (ambiguousIndexCount.length === 0) {
            throw ChecksumException_default.getChecksumInstance();
          }
          for (var i = 0; i < ambiguousIndexCount.length; i++) {
            if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
              ambiguousIndexCount[i]++;
              break;
            } else {
              ambiguousIndexCount[i] = 0;
              if (i === ambiguousIndexCount.length - 1) {
                throw ChecksumException_default.getChecksumInstance();
              }
            }
          }
        }
        throw ChecksumException_default.getChecksumInstance();
      };
      PDF417ScanningDecoder2.createBarcodeMatrix = function(detectionResult) {
        var e_3, _a2, e_4, _b;
        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function() {
          return new Array(detectionResult.getBarcodeColumnCount() + 2);
        });
        for (var row = 0; row < barcodeMatrix.length; row++) {
          for (var column_1 = 0; column_1 < barcodeMatrix[row].length; column_1++) {
            barcodeMatrix[row][column_1] = new BarcodeValue_default();
          }
        }
        var column = 0;
        try {
          for (var _c = __values36(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var detectionResultColumn = _d.value;
            if (detectionResultColumn != null) {
              try {
                for (var _e = (e_4 = void 0, __values36(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var codeword = _f.value;
                  if (codeword != null) {
                    var rowNumber = codeword.getRowNumber();
                    if (rowNumber >= 0) {
                      if (rowNumber >= barcodeMatrix.length) {
                        continue;
                      }
                      barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                    }
                  }
                }
              } catch (e_4_1) {
                e_4 = { error: e_4_1 };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_4) throw e_4.error;
                }
              }
            }
            column++;
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return)) _a2.call(_c);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        return barcodeMatrix;
      };
      PDF417ScanningDecoder2.isValidBarcodeColumn = function(detectionResult, barcodeColumn) {
        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
      };
      PDF417ScanningDecoder2.getStartColumn = function(detectionResult, barcodeColumn, imageRow, leftToRight) {
        var e_5, _a2;
        var offset2 = leftToRight ? 1 : -1;
        var codeword = null;
        if (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset2).getCodeword(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
        if (codeword != null) {
          return leftToRight ? codeword.getStartX() : codeword.getEndX();
        }
        if (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset2).getCodewordNearby(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        var skippedColumns = 0;
        while (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          barcodeColumn -= offset2;
          try {
            for (var _b = (e_5 = void 0, __values36(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {
              var previousRowCodeword = _c.value;
              if (previousRowCodeword != null) {
                return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset2 * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
              }
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
            } finally {
              if (e_5) throw e_5.error;
            }
          }
          skippedColumns++;
        }
        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
      };
      PDF417ScanningDecoder2.detectCodeword = function(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
        startColumn = PDF417ScanningDecoder2.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        var moduleBitCount = PDF417ScanningDecoder2.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        if (moduleBitCount == null) {
          return null;
        }
        var endColumn;
        var codewordBitCount = MathUtils_default.sum(moduleBitCount);
        if (leftToRight) {
          endColumn = startColumn + codewordBitCount;
        } else {
          for (var i = 0; i < moduleBitCount.length / 2; i++) {
            var tmpCount = moduleBitCount[i];
            moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
            moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
          }
          endColumn = startColumn;
          startColumn = endColumn - codewordBitCount;
        }
        if (!PDF417ScanningDecoder2.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
          return null;
        }
        var decodedValue = PDF417CodewordDecoder_default.getDecodedValue(moduleBitCount);
        var codeword = PDF417Common_default.getCodeword(decodedValue);
        if (codeword === -1) {
          return null;
        }
        return new Codeword_default(startColumn, endColumn, PDF417ScanningDecoder2.getCodewordBucketNumber(decodedValue), codeword);
      };
      PDF417ScanningDecoder2.getModuleBitCount = function(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
        var imageColumn = startColumn;
        var moduleBitCount = new Int32Array(8);
        var moduleNumber = 0;
        var increment = leftToRight ? 1 : -1;
        var previousPixelValue = leftToRight;
        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
          if (image.get(imageColumn, imageRow) === previousPixelValue) {
            moduleBitCount[moduleNumber]++;
            imageColumn += increment;
          } else {
            moduleNumber++;
            previousPixelValue = !previousPixelValue;
          }
        }
        if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
          return moduleBitCount;
        }
        return null;
      };
      PDF417ScanningDecoder2.getNumberOfECCodeWords = function(barcodeECLevel) {
        return 2 << barcodeECLevel;
      };
      PDF417ScanningDecoder2.adjustCodewordStartColumn = function(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
        var correctedStartColumn = codewordStartColumn;
        var increment = leftToRight ? -1 : 1;
        for (var i = 0; i < 2; i++) {
          while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
            if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE) {
              return codewordStartColumn;
            }
            correctedStartColumn += increment;
          }
          increment = -increment;
          leftToRight = !leftToRight;
        }
        return correctedStartColumn;
      };
      PDF417ScanningDecoder2.checkCodewordSkew = function(codewordSize, minCodewordWidth, maxCodewordWidth) {
        return minCodewordWidth - PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE;
      };
      PDF417ScanningDecoder2.decodeCodewords = function(codewords, ecLevel, erasures) {
        if (codewords.length === 0) {
          throw FormatException_default.getFormatInstance();
        }
        var numECCodewords = 1 << ecLevel + 1;
        var correctedErrorsCount = PDF417ScanningDecoder2.correctErrors(codewords, erasures, numECCodewords);
        PDF417ScanningDecoder2.verifyCodewordCount(codewords, numECCodewords);
        var decoderResult = DecodedBitStreamParser_default3.decode(codewords, "" + ecLevel);
        decoderResult.setErrorsCorrected(correctedErrorsCount);
        decoderResult.setErasures(erasures.length);
        return decoderResult;
      };
      PDF417ScanningDecoder2.correctErrors = function(codewords, erasures, numECCodewords) {
        if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder2.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder2.MAX_EC_CODEWORDS) {
          throw ChecksumException_default.getChecksumInstance();
        }
        return PDF417ScanningDecoder2.errorCorrection.decode(codewords, numECCodewords, erasures);
      };
      PDF417ScanningDecoder2.verifyCodewordCount = function(codewords, numECCodewords) {
        if (codewords.length < 4) {
          throw FormatException_default.getFormatInstance();
        }
        var numberOfCodewords = codewords[0];
        if (numberOfCodewords > codewords.length) {
          throw FormatException_default.getFormatInstance();
        }
        if (numberOfCodewords === 0) {
          if (numECCodewords < codewords.length) {
            codewords[0] = codewords.length - numECCodewords;
          } else {
            throw FormatException_default.getFormatInstance();
          }
        }
      };
      PDF417ScanningDecoder2.getBitCountForCodeword = function(codeword) {
        var result = new Int32Array(8);
        var previousValue = 0;
        var i = result.length - 1;
        while (true) {
          if ((codeword & 1) !== previousValue) {
            previousValue = codeword & 1;
            i--;
            if (i < 0) {
              break;
            }
          }
          result[i]++;
          codeword >>= 1;
        }
        return result;
      };
      PDF417ScanningDecoder2.getCodewordBucketNumber = function(codeword) {
        if (codeword instanceof Int32Array) {
          return this.getCodewordBucketNumber_Int32Array(codeword);
        }
        return this.getCodewordBucketNumber_number(codeword);
      };
      PDF417ScanningDecoder2.getCodewordBucketNumber_number = function(codeword) {
        return PDF417ScanningDecoder2.getCodewordBucketNumber(PDF417ScanningDecoder2.getBitCountForCodeword(codeword));
      };
      PDF417ScanningDecoder2.getCodewordBucketNumber_Int32Array = function(moduleBitCount) {
        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
      };
      PDF417ScanningDecoder2.toString = function(barcodeMatrix) {
        var formatter = new Formatter_default();
        for (var row = 0; row < barcodeMatrix.length; row++) {
          formatter.format("Row %2d: ", row);
          for (var column = 0; column < barcodeMatrix[row].length; column++) {
            var barcodeValue = barcodeMatrix[row][column];
            if (barcodeValue.getValue().length === 0) {
              formatter.format("        ", null);
            } else {
              formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
            }
          }
          formatter.format("%n");
        }
        return formatter.toString();
      };
      PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE = 2;
      PDF417ScanningDecoder2.MAX_ERRORS = 3;
      PDF417ScanningDecoder2.MAX_EC_CODEWORDS = 512;
      PDF417ScanningDecoder2.errorCorrection = new ErrorCorrection_default();
      return PDF417ScanningDecoder2;
    }()
  );
  var PDF417ScanningDecoder_default = PDF417ScanningDecoder;

  // node_modules/@zxing/library/esm/core/pdf417/PDF417Reader.js
  var __values37 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var PDF417Reader = (
    /** @class */
    function() {
      function PDF417Reader2() {
      }
      PDF417Reader2.prototype.decode = function(image, hints) {
        if (hints === void 0) {
          hints = null;
        }
        var result = PDF417Reader2.decode(image, hints, false);
        if (result == null || result.length === 0 || result[0] == null) {
          throw NotFoundException_default.getNotFoundInstance();
        }
        return result[0];
      };
      PDF417Reader2.prototype.decodeMultiple = function(image, hints) {
        if (hints === void 0) {
          hints = null;
        }
        try {
          return PDF417Reader2.decode(image, hints, true);
        } catch (ignored) {
          if (ignored instanceof FormatException_default || ignored instanceof ChecksumException_default) {
            throw NotFoundException_default.getNotFoundInstance();
          }
          throw ignored;
        }
      };
      PDF417Reader2.decode = function(image, hints, multiple) {
        var e_1, _a2;
        var results = new Array();
        var detectorResult = Detector_default4.detectMultiple(image, hints, multiple);
        try {
          for (var _b = __values37(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var points = _c.value;
            var decoderResult = PDF417ScanningDecoder_default.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader2.getMinCodewordWidth(points), PDF417Reader2.getMaxCodewordWidth(points));
            var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat_default.PDF_417);
            result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
            var pdf417ResultMetadata = decoderResult.getOther();
            if (pdf417ResultMetadata != null) {
              result.putMetadata(ResultMetadataType_default.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
            }
            results.push(result);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return results.map(function(x) {
          return x;
        });
      };
      PDF417Reader2.getMaxWidth = function(p1, p2) {
        if (p1 == null || p2 == null) {
          return 0;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      };
      PDF417Reader2.getMinWidth = function(p1, p2) {
        if (p1 == null || p2 == null) {
          return Integer_default.MAX_VALUE;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      };
      PDF417Reader2.getMaxCodewordWidth = function(p) {
        return Math.floor(Math.max(Math.max(PDF417Reader2.getMaxWidth(p[0], p[4]), PDF417Reader2.getMaxWidth(p[6], p[2]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader2.getMaxWidth(p[1], p[5]), PDF417Reader2.getMaxWidth(p[7], p[3]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN)));
      };
      PDF417Reader2.getMinCodewordWidth = function(p) {
        return Math.floor(Math.min(Math.min(PDF417Reader2.getMinWidth(p[0], p[4]), PDF417Reader2.getMinWidth(p[6], p[2]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader2.getMinWidth(p[1], p[5]), PDF417Reader2.getMinWidth(p[7], p[3]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN)));
      };
      PDF417Reader2.prototype.reset = function() {
      };
      return PDF417Reader2;
    }()
  );
  var PDF417Reader_default = PDF417Reader;

  // node_modules/@zxing/library/esm/core/ReaderException.js
  var __extends61 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var ReaderException = (
    /** @class */
    function(_super) {
      __extends61(ReaderException2, _super);
      function ReaderException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ReaderException2.kind = "ReaderException";
      return ReaderException2;
    }(Exception_default)
  );
  var ReaderException_default = ReaderException;

  // node_modules/@zxing/library/esm/core/MultiFormatReader.js
  var __values38 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var MultiFormatReader = (
    /** @class */
    function() {
      function MultiFormatReader2() {
      }
      MultiFormatReader2.prototype.decode = function(image, hints) {
        this.setHints(hints);
        return this.decodeInternal(image);
      };
      MultiFormatReader2.prototype.decodeWithState = function(image) {
        if (this.readers === null || this.readers === void 0) {
          this.setHints(null);
        }
        return this.decodeInternal(image);
      };
      MultiFormatReader2.prototype.setHints = function(hints) {
        this.hints = hints;
        var tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType_default.TRY_HARDER);
        var formats = hints === null || hints === void 0 ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
        var readers2 = new Array();
        if (formats !== null && formats !== void 0) {
          var addOneDReader = formats.some(function(f) {
            return f === BarcodeFormat_default.UPC_A || f === BarcodeFormat_default.UPC_E || f === BarcodeFormat_default.EAN_13 || f === BarcodeFormat_default.EAN_8 || f === BarcodeFormat_default.CODABAR || f === BarcodeFormat_default.CODE_39 || f === BarcodeFormat_default.CODE_93 || f === BarcodeFormat_default.CODE_128 || f === BarcodeFormat_default.ITF || f === BarcodeFormat_default.RSS_14 || f === BarcodeFormat_default.RSS_EXPANDED;
          });
          if (addOneDReader && !tryHarder) {
            readers2.push(new MultiFormatOneDReader_default(hints));
          }
          if (formats.includes(BarcodeFormat_default.QR_CODE)) {
            readers2.push(new QRCodeReader_default());
          }
          if (formats.includes(BarcodeFormat_default.DATA_MATRIX)) {
            readers2.push(new DataMatrixReader_default());
          }
          if (formats.includes(BarcodeFormat_default.AZTEC)) {
            readers2.push(new AztecReader_default());
          }
          if (formats.includes(BarcodeFormat_default.PDF_417)) {
            readers2.push(new PDF417Reader_default());
          }
          if (addOneDReader && tryHarder) {
            readers2.push(new MultiFormatOneDReader_default(hints));
          }
        }
        if (readers2.length === 0) {
          if (!tryHarder) {
            readers2.push(new MultiFormatOneDReader_default(hints));
          }
          readers2.push(new QRCodeReader_default());
          readers2.push(new DataMatrixReader_default());
          readers2.push(new AztecReader_default());
          readers2.push(new PDF417Reader_default());
          if (tryHarder) {
            readers2.push(new MultiFormatOneDReader_default(hints));
          }
        }
        this.readers = readers2;
      };
      MultiFormatReader2.prototype.reset = function() {
        var e_1, _a2;
        if (this.readers !== null) {
          try {
            for (var _b = __values38(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var reader = _c.value;
              reader.reset();
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      };
      MultiFormatReader2.prototype.decodeInternal = function(image) {
        var e_2, _a2;
        if (this.readers === null) {
          throw new ReaderException_default("No readers where selected, nothing can be read.");
        }
        try {
          for (var _b = __values38(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var reader = _c.value;
            try {
              return reader.decode(image, this.hints);
            } catch (ex) {
              if (ex instanceof ReaderException_default) {
                continue;
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        throw new NotFoundException_default("No MultiFormat Readers were able to detect the code.");
      };
      return MultiFormatReader2;
    }()
  );
  var MultiFormatReader_default = MultiFormatReader;

  // node_modules/@zxing/library/esm/browser/BrowserMultiFormatReader.js
  var __extends62 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserMultiFormatReader = (
    /** @class */
    function(_super) {
      __extends62(BrowserMultiFormatReader3, _super);
      function BrowserMultiFormatReader3(hints, timeBetweenScansMillis) {
        if (hints === void 0) {
          hints = null;
        }
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        var _this = this;
        var reader = new MultiFormatReader_default();
        reader.setHints(hints);
        _this = _super.call(this, reader, timeBetweenScansMillis) || this;
        return _this;
      }
      BrowserMultiFormatReader3.prototype.decodeBitmap = function(binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
      };
      return BrowserMultiFormatReader3;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/browser/BrowserPDF417Reader.js
  var __extends63 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserPDF417Reader = (
    /** @class */
    function(_super) {
      __extends63(BrowserPDF417Reader3, _super);
      function BrowserPDF417Reader3(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        return _super.call(this, new PDF417Reader_default(), timeBetweenScansMillis) || this;
      }
      return BrowserPDF417Reader3;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/browser/BrowserQRCodeReader.js
  var __extends64 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserQRCodeReader = (
    /** @class */
    function(_super) {
      __extends64(BrowserQRCodeReader3, _super);
      function BrowserQRCodeReader3(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) {
          timeBetweenScansMillis = 500;
        }
        return _super.call(this, new QRCodeReader_default(), timeBetweenScansMillis) || this;
      }
      return BrowserQRCodeReader3;
    }(BrowserCodeReader)
  );

  // node_modules/@zxing/library/esm/core/EncodeHintType.js
  var EncodeHintType;
  (function(EncodeHintType2) {
    EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
    EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
    EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
    EncodeHintType2[EncodeHintType2["DATA_MATRIX_COMPACT"] = 3] = "DATA_MATRIX_COMPACT";
    EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 4] = "MIN_SIZE";
    EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 5] = "MAX_SIZE";
    EncodeHintType2[EncodeHintType2["MARGIN"] = 6] = "MARGIN";
    EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 7] = "PDF417_COMPACT";
    EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 8] = "PDF417_COMPACTION";
    EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 9] = "PDF417_DIMENSIONS";
    EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 10] = "AZTEC_LAYERS";
    EncodeHintType2[EncodeHintType2["QR_VERSION"] = 11] = "QR_VERSION";
    EncodeHintType2[EncodeHintType2["GS1_FORMAT"] = 12] = "GS1_FORMAT";
    EncodeHintType2[EncodeHintType2["FORCE_C40"] = 13] = "FORCE_C40";
  })(EncodeHintType || (EncodeHintType = {}));
  var EncodeHintType_default = EncodeHintType;

  // node_modules/@zxing/library/esm/core/common/reedsolomon/ReedSolomonEncoder.js
  var ReedSolomonEncoder = (
    /** @class */
    function() {
      function ReedSolomonEncoder2(field) {
        this.field = field;
        this.cachedGenerators = [];
        this.cachedGenerators.push(new GenericGFPoly_default(field, Int32Array.from([1])));
      }
      ReedSolomonEncoder2.prototype.buildGenerator = function(degree) {
        var cachedGenerators = this.cachedGenerators;
        if (degree >= cachedGenerators.length) {
          var lastGenerator = cachedGenerators[cachedGenerators.length - 1];
          var field = this.field;
          for (var d = cachedGenerators.length; d <= degree; d++) {
            var nextGenerator = lastGenerator.multiply(new GenericGFPoly_default(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
            cachedGenerators.push(nextGenerator);
            lastGenerator = nextGenerator;
          }
        }
        return cachedGenerators[degree];
      };
      ReedSolomonEncoder2.prototype.encode = function(toEncode, ecBytes) {
        if (ecBytes === 0) {
          throw new IllegalArgumentException_default("No error correction bytes");
        }
        var dataBytes = toEncode.length - ecBytes;
        if (dataBytes <= 0) {
          throw new IllegalArgumentException_default("No data bytes provided");
        }
        var generator = this.buildGenerator(ecBytes);
        var infoCoefficients = new Int32Array(dataBytes);
        System_default.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
        var info = new GenericGFPoly_default(this.field, infoCoefficients);
        info = info.multiplyByMonomial(ecBytes, 1);
        var remainder = info.divide(generator)[1];
        var coefficients = remainder.getCoefficients();
        var numZeroCoefficients = ecBytes - coefficients.length;
        for (var i = 0; i < numZeroCoefficients; i++) {
          toEncode[dataBytes + i] = 0;
        }
        System_default.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
      };
      return ReedSolomonEncoder2;
    }()
  );
  var ReedSolomonEncoder_default = ReedSolomonEncoder;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/MaskUtil.js
  var MaskUtil = (
    /** @class */
    function() {
      function MaskUtil2() {
      }
      MaskUtil2.applyMaskPenaltyRule1 = function(matrix) {
        return MaskUtil2.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil2.applyMaskPenaltyRule1Internal(matrix, false);
      };
      MaskUtil2.applyMaskPenaltyRule2 = function(matrix) {
        var penalty = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height - 1; y++) {
          var arrayY = array[y];
          for (var x = 0; x < width - 1; x++) {
            var value = arrayY[x];
            if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
              penalty++;
            }
          }
        }
        return MaskUtil2.N2 * penalty;
      };
      MaskUtil2.applyMaskPenaltyRule3 = function(matrix) {
        var numPenalties = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height; y++) {
          for (var x = 0; x < width; x++) {
            var arrayY = array[y];
            if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil2.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil2.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
              numPenalties++;
            }
            if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil2.isWhiteVertical(array, x, y - 4, y) || MaskUtil2.isWhiteVertical(array, x, y + 7, y + 11))) {
              numPenalties++;
            }
          }
        }
        return numPenalties * MaskUtil2.N3;
      };
      MaskUtil2.isWhiteHorizontal = function(rowArray, from2, to) {
        from2 = Math.max(from2, 0);
        to = Math.min(to, rowArray.length);
        for (var i = from2; i < to; i++) {
          if (rowArray[i] === 1) {
            return false;
          }
        }
        return true;
      };
      MaskUtil2.isWhiteVertical = function(array, col, from2, to) {
        from2 = Math.max(from2, 0);
        to = Math.min(to, array.length);
        for (var i = from2; i < to; i++) {
          if (array[i][col] === 1) {
            return false;
          }
        }
        return true;
      };
      MaskUtil2.applyMaskPenaltyRule4 = function(matrix) {
        var numDarkCells = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height; y++) {
          var arrayY = array[y];
          for (var x = 0; x < width; x++) {
            if (arrayY[x] === 1) {
              numDarkCells++;
            }
          }
        }
        var numTotalCells = matrix.getHeight() * matrix.getWidth();
        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
        return fivePercentVariances * MaskUtil2.N4;
      };
      MaskUtil2.getDataMaskBit = function(maskPattern, x, y) {
        var intermediate;
        var temp;
        switch (maskPattern) {
          case 0:
            intermediate = y + x & 1;
            break;
          case 1:
            intermediate = y & 1;
            break;
          case 2:
            intermediate = x % 3;
            break;
          case 3:
            intermediate = (y + x) % 3;
            break;
          case 4:
            intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 1;
            break;
          case 5:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3;
            break;
          case 6:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3 & 1;
            break;
          case 7:
            temp = y * x;
            intermediate = temp % 3 + (y + x & 1) & 1;
            break;
          default:
            throw new IllegalArgumentException_default("Invalid mask pattern: " + maskPattern);
        }
        return intermediate === 0;
      };
      MaskUtil2.applyMaskPenaltyRule1Internal = function(matrix, isHorizontal) {
        var penalty = 0;
        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
        var array = matrix.getArray();
        for (var i = 0; i < iLimit; i++) {
          var numSameBitCells = 0;
          var prevBit = -1;
          for (var j = 0; j < jLimit; j++) {
            var bit = isHorizontal ? array[i][j] : array[j][i];
            if (bit === prevBit) {
              numSameBitCells++;
            } else {
              if (numSameBitCells >= 5) {
                penalty += MaskUtil2.N1 + (numSameBitCells - 5);
              }
              numSameBitCells = 1;
              prevBit = bit;
            }
          }
          if (numSameBitCells >= 5) {
            penalty += MaskUtil2.N1 + (numSameBitCells - 5);
          }
        }
        return penalty;
      };
      MaskUtil2.N1 = 3;
      MaskUtil2.N2 = 3;
      MaskUtil2.N3 = 40;
      MaskUtil2.N4 = 10;
      return MaskUtil2;
    }()
  );
  var MaskUtil_default = MaskUtil;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/ByteMatrix.js
  var __values39 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var ByteMatrix = (
    /** @class */
    function() {
      function ByteMatrix2(width, height) {
        this.width = width;
        this.height = height;
        var bytes = new Array(height);
        for (var i = 0; i !== height; i++) {
          bytes[i] = new Uint8Array(width);
        }
        this.bytes = bytes;
      }
      ByteMatrix2.prototype.getHeight = function() {
        return this.height;
      };
      ByteMatrix2.prototype.getWidth = function() {
        return this.width;
      };
      ByteMatrix2.prototype.get = function(x, y) {
        return this.bytes[y][x];
      };
      ByteMatrix2.prototype.getArray = function() {
        return this.bytes;
      };
      ByteMatrix2.prototype.setNumber = function(x, y, value) {
        this.bytes[y][x] = value;
      };
      ByteMatrix2.prototype.setBoolean = function(x, y, value) {
        this.bytes[y][x] = /*(byte) */
        value ? 1 : 0;
      };
      ByteMatrix2.prototype.clear = function(value) {
        var e_1, _a2;
        try {
          for (var _b = __values39(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {
            var aByte = _c.value;
            Arrays_default.fill(aByte, value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      ByteMatrix2.prototype.equals = function(o) {
        if (!(o instanceof ByteMatrix2)) {
          return false;
        }
        var other = o;
        if (this.width !== other.width) {
          return false;
        }
        if (this.height !== other.height) {
          return false;
        }
        for (var y = 0, height = this.height; y < height; ++y) {
          var bytesY = this.bytes[y];
          var otherBytesY = other.bytes[y];
          for (var x = 0, width = this.width; x < width; ++x) {
            if (bytesY[x] !== otherBytesY[x]) {
              return false;
            }
          }
        }
        return true;
      };
      ByteMatrix2.prototype.toString = function() {
        var result = new StringBuilder_default();
        for (var y = 0, height = this.height; y < height; ++y) {
          var bytesY = this.bytes[y];
          for (var x = 0, width = this.width; x < width; ++x) {
            switch (bytesY[x]) {
              case 0:
                result.append(" 0");
                break;
              case 1:
                result.append(" 1");
                break;
              default:
                result.append("  ");
                break;
            }
          }
          result.append("\n");
        }
        return result.toString();
      };
      return ByteMatrix2;
    }()
  );
  var ByteMatrix_default = ByteMatrix;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/QRCode.js
  var QRCode = (
    /** @class */
    function() {
      function QRCode2() {
        this.maskPattern = -1;
      }
      QRCode2.prototype.getMode = function() {
        return this.mode;
      };
      QRCode2.prototype.getECLevel = function() {
        return this.ecLevel;
      };
      QRCode2.prototype.getVersion = function() {
        return this.version;
      };
      QRCode2.prototype.getMaskPattern = function() {
        return this.maskPattern;
      };
      QRCode2.prototype.getMatrix = function() {
        return this.matrix;
      };
      QRCode2.prototype.toString = function() {
        var result = new StringBuilder_default();
        result.append("<<\n");
        result.append(" mode: ");
        result.append(this.mode ? this.mode.toString() : "null");
        result.append("\n ecLevel: ");
        result.append(this.ecLevel ? this.ecLevel.toString() : "null");
        result.append("\n version: ");
        result.append(this.version ? this.version.toString() : "null");
        result.append("\n maskPattern: ");
        result.append(this.maskPattern.toString());
        if (this.matrix) {
          result.append("\n matrix:\n");
          result.append(this.matrix.toString());
        } else {
          result.append("\n matrix: null\n");
        }
        result.append(">>\n");
        return result.toString();
      };
      QRCode2.prototype.setMode = function(value) {
        this.mode = value;
      };
      QRCode2.prototype.setECLevel = function(value) {
        this.ecLevel = value;
      };
      QRCode2.prototype.setVersion = function(version) {
        this.version = version;
      };
      QRCode2.prototype.setMaskPattern = function(value) {
        this.maskPattern = value;
      };
      QRCode2.prototype.setMatrix = function(value) {
        this.matrix = value;
      };
      QRCode2.isValidMaskPattern = function(maskPattern) {
        return maskPattern >= 0 && maskPattern < QRCode2.NUM_MASK_PATTERNS;
      };
      QRCode2.NUM_MASK_PATTERNS = 8;
      return QRCode2;
    }()
  );
  var QRCode_default = QRCode;

  // node_modules/@zxing/library/esm/core/WriterException.js
  var __extends65 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var WriterException = (
    /** @class */
    function(_super) {
      __extends65(WriterException2, _super);
      function WriterException2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      WriterException2.kind = "WriterException";
      return WriterException2;
    }(Exception_default)
  );
  var WriterException_default = WriterException;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/MatrixUtil.js
  var MatrixUtil = (
    /** @class */
    function() {
      function MatrixUtil2() {
      }
      MatrixUtil2.clearMatrix = function(matrix) {
        matrix.clear(
          /*(byte) */
          /*-1*/
          255
        );
      };
      MatrixUtil2.buildMatrix = function(dataBits, ecLevel, version, maskPattern, matrix) {
        MatrixUtil2.clearMatrix(matrix);
        MatrixUtil2.embedBasicPatterns(version, matrix);
        MatrixUtil2.embedTypeInfo(ecLevel, maskPattern, matrix);
        MatrixUtil2.maybeEmbedVersionInfo(version, matrix);
        MatrixUtil2.embedDataBits(dataBits, maskPattern, matrix);
      };
      MatrixUtil2.embedBasicPatterns = function(version, matrix) {
        MatrixUtil2.embedPositionDetectionPatternsAndSeparators(matrix);
        MatrixUtil2.embedDarkDotAtLeftBottomCorner(matrix);
        MatrixUtil2.maybeEmbedPositionAdjustmentPatterns(version, matrix);
        MatrixUtil2.embedTimingPatterns(matrix);
      };
      MatrixUtil2.embedTypeInfo = function(ecLevel, maskPattern, matrix) {
        var typeInfoBits = new BitArray_default();
        MatrixUtil2.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
        for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
          var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
          var coordinates = MatrixUtil2.TYPE_INFO_COORDINATES[i];
          var x1 = coordinates[0];
          var y1 = coordinates[1];
          matrix.setBoolean(x1, y1, bit);
          if (i < 8) {
            var x2 = matrix.getWidth() - i - 1;
            var y2 = 8;
            matrix.setBoolean(x2, y2, bit);
          } else {
            var x2 = 8;
            var y2 = matrix.getHeight() - 7 + (i - 8);
            matrix.setBoolean(x2, y2, bit);
          }
        }
      };
      MatrixUtil2.maybeEmbedVersionInfo = function(version, matrix) {
        if (version.getVersionNumber() < 7) {
          return;
        }
        var versionInfoBits = new BitArray_default();
        MatrixUtil2.makeVersionInfoBits(version, versionInfoBits);
        var bitIndex = 6 * 3 - 1;
        for (var i = 0; i < 6; ++i) {
          for (var j = 0; j < 3; ++j) {
            var bit = versionInfoBits.get(bitIndex);
            bitIndex--;
            matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
            matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
          }
        }
      };
      MatrixUtil2.embedDataBits = function(dataBits, maskPattern, matrix) {
        var bitIndex = 0;
        var direction = -1;
        var x = matrix.getWidth() - 1;
        var y = matrix.getHeight() - 1;
        while (x > 0) {
          if (x === 6) {
            x -= 1;
          }
          while (y >= 0 && y < matrix.getHeight()) {
            for (var i = 0; i < 2; ++i) {
              var xx = x - i;
              if (!MatrixUtil2.isEmpty(matrix.get(xx, y))) {
                continue;
              }
              var bit = void 0;
              if (bitIndex < dataBits.getSize()) {
                bit = dataBits.get(bitIndex);
                ++bitIndex;
              } else {
                bit = false;
              }
              if (maskPattern !== 255 && MaskUtil_default.getDataMaskBit(maskPattern, xx, y)) {
                bit = !bit;
              }
              matrix.setBoolean(xx, y, bit);
            }
            y += direction;
          }
          direction = -direction;
          y += direction;
          x -= 2;
        }
        if (bitIndex !== dataBits.getSize()) {
          throw new WriterException_default("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
        }
      };
      MatrixUtil2.findMSBSet = function(value) {
        return 32 - Integer_default.numberOfLeadingZeros(value);
      };
      MatrixUtil2.calculateBCHCode = function(value, poly) {
        if (poly === 0) {
          throw new IllegalArgumentException_default("0 polynomial");
        }
        var msbSetInPoly = MatrixUtil2.findMSBSet(poly);
        value <<= msbSetInPoly - 1;
        while (MatrixUtil2.findMSBSet(value) >= msbSetInPoly) {
          value ^= poly << MatrixUtil2.findMSBSet(value) - msbSetInPoly;
        }
        return value;
      };
      MatrixUtil2.makeTypeInfoBits = function(ecLevel, maskPattern, bits) {
        if (!QRCode_default.isValidMaskPattern(maskPattern)) {
          throw new WriterException_default("Invalid mask pattern");
        }
        var typeInfo = ecLevel.getBits() << 3 | maskPattern;
        bits.appendBits(typeInfo, 5);
        var bchCode = MatrixUtil2.calculateBCHCode(typeInfo, MatrixUtil2.TYPE_INFO_POLY);
        bits.appendBits(bchCode, 10);
        var maskBits = new BitArray_default();
        maskBits.appendBits(MatrixUtil2.TYPE_INFO_MASK_PATTERN, 15);
        bits.xor(maskBits);
        if (bits.getSize() !== 15) {
          throw new WriterException_default("should not happen but we got: " + bits.getSize());
        }
      };
      MatrixUtil2.makeVersionInfoBits = function(version, bits) {
        bits.appendBits(version.getVersionNumber(), 6);
        var bchCode = MatrixUtil2.calculateBCHCode(version.getVersionNumber(), MatrixUtil2.VERSION_INFO_POLY);
        bits.appendBits(bchCode, 12);
        if (bits.getSize() !== 18) {
          throw new WriterException_default("should not happen but we got: " + bits.getSize());
        }
      };
      MatrixUtil2.isEmpty = function(value) {
        return value === 255;
      };
      MatrixUtil2.embedTimingPatterns = function(matrix) {
        for (var i = 8; i < matrix.getWidth() - 8; ++i) {
          var bit = (i + 1) % 2;
          if (MatrixUtil2.isEmpty(matrix.get(i, 6))) {
            matrix.setNumber(i, 6, bit);
          }
          if (MatrixUtil2.isEmpty(matrix.get(6, i))) {
            matrix.setNumber(6, i, bit);
          }
        }
      };
      MatrixUtil2.embedDarkDotAtLeftBottomCorner = function(matrix) {
        if (matrix.get(8, matrix.getHeight() - 8) === 0) {
          throw new WriterException_default();
        }
        matrix.setNumber(8, matrix.getHeight() - 8, 1);
      };
      MatrixUtil2.embedHorizontalSeparationPattern = function(xStart, yStart, matrix) {
        for (var x = 0; x < 8; ++x) {
          if (!MatrixUtil2.isEmpty(matrix.get(xStart + x, yStart))) {
            throw new WriterException_default();
          }
          matrix.setNumber(xStart + x, yStart, 0);
        }
      };
      MatrixUtil2.embedVerticalSeparationPattern = function(xStart, yStart, matrix) {
        for (var y = 0; y < 7; ++y) {
          if (!MatrixUtil2.isEmpty(matrix.get(xStart, yStart + y))) {
            throw new WriterException_default();
          }
          matrix.setNumber(xStart, yStart + y, 0);
        }
      };
      MatrixUtil2.embedPositionAdjustmentPattern = function(xStart, yStart, matrix) {
        for (var y = 0; y < 5; ++y) {
          var patternY = MatrixUtil2.POSITION_ADJUSTMENT_PATTERN[y];
          for (var x = 0; x < 5; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      };
      MatrixUtil2.embedPositionDetectionPattern = function(xStart, yStart, matrix) {
        for (var y = 0; y < 7; ++y) {
          var patternY = MatrixUtil2.POSITION_DETECTION_PATTERN[y];
          for (var x = 0; x < 7; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      };
      MatrixUtil2.embedPositionDetectionPatternsAndSeparators = function(matrix) {
        var pdpWidth = MatrixUtil2.POSITION_DETECTION_PATTERN[0].length;
        MatrixUtil2.embedPositionDetectionPattern(0, 0, matrix);
        MatrixUtil2.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
        MatrixUtil2.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
        var hspWidth = 8;
        MatrixUtil2.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
        MatrixUtil2.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
        MatrixUtil2.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
        var vspSize = 7;
        MatrixUtil2.embedVerticalSeparationPattern(vspSize, 0, matrix);
        MatrixUtil2.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
        MatrixUtil2.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
      };
      MatrixUtil2.maybeEmbedPositionAdjustmentPatterns = function(version, matrix) {
        if (version.getVersionNumber() < 2) {
          return;
        }
        var index = version.getVersionNumber() - 1;
        var coordinates = MatrixUtil2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
        for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {
          var y = coordinates[i];
          if (y >= 0) {
            for (var j = 0; j !== length_1; j++) {
              var x = coordinates[j];
              if (x >= 0 && MatrixUtil2.isEmpty(matrix.get(x, y))) {
                MatrixUtil2.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
              }
            }
          }
        }
      };
      MatrixUtil2.POSITION_DETECTION_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1, 1, 1])
      ]);
      MatrixUtil2.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1])
      ]);
      MatrixUtil2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170])
      ]);
      MatrixUtil2.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8])
      ]);
      MatrixUtil2.VERSION_INFO_POLY = 7973;
      MatrixUtil2.TYPE_INFO_POLY = 1335;
      MatrixUtil2.TYPE_INFO_MASK_PATTERN = 21522;
      return MatrixUtil2;
    }()
  );
  var MatrixUtil_default = MatrixUtil;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/BlockPair.js
  var BlockPair = (
    /** @class */
    function() {
      function BlockPair2(dataBytes, errorCorrectionBytes) {
        this.dataBytes = dataBytes;
        this.errorCorrectionBytes = errorCorrectionBytes;
      }
      BlockPair2.prototype.getDataBytes = function() {
        return this.dataBytes;
      };
      BlockPair2.prototype.getErrorCorrectionBytes = function() {
        return this.errorCorrectionBytes;
      };
      return BlockPair2;
    }()
  );
  var BlockPair_default = BlockPair;

  // node_modules/@zxing/library/esm/core/qrcode/encoder/Encoder.js
  var __values40 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Encoder = (
    /** @class */
    function() {
      function Encoder3() {
      }
      Encoder3.calculateMaskPenalty = function(matrix) {
        return MaskUtil_default.applyMaskPenaltyRule1(matrix) + MaskUtil_default.applyMaskPenaltyRule2(matrix) + MaskUtil_default.applyMaskPenaltyRule3(matrix) + MaskUtil_default.applyMaskPenaltyRule4(matrix);
      };
      Encoder3.encode = function(content, ecLevel, hints) {
        if (hints === void 0) {
          hints = null;
        }
        var encoding = Encoder3.DEFAULT_BYTE_MODE_ENCODING;
        var hasEncodingHint = hints !== null && void 0 !== hints.get(EncodeHintType_default.CHARACTER_SET);
        if (hasEncodingHint) {
          encoding = hints.get(EncodeHintType_default.CHARACTER_SET).toString();
        }
        var mode = this.chooseMode(content, encoding);
        var headerBits = new BitArray_default();
        if (mode === Mode_default.BYTE && (hasEncodingHint || Encoder3.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
          var eci = CharacterSetECI_default.getCharacterSetECIByName(encoding);
          if (eci !== void 0) {
            this.appendECI(eci, headerBits);
          }
        }
        this.appendModeInfo(mode, headerBits);
        var dataBits = new BitArray_default();
        this.appendBytes(content, mode, dataBits, encoding);
        var version;
        if (hints !== null && void 0 !== hints.get(EncodeHintType_default.QR_VERSION)) {
          var versionNumber = Number.parseInt(hints.get(EncodeHintType_default.QR_VERSION).toString(), 10);
          version = Version_default2.getVersionForNumber(versionNumber);
          var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
          if (!this.willFit(bitsNeeded, version, ecLevel)) {
            throw new WriterException_default("Data too big for requested version");
          }
        } else {
          version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
        }
        var headerAndDataBits = new BitArray_default();
        headerAndDataBits.appendBitArray(headerBits);
        var numLetters = mode === Mode_default.BYTE ? dataBits.getSizeInBytes() : content.length;
        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
        headerAndDataBits.appendBitArray(dataBits);
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
        this.terminateBits(numDataBytes, headerAndDataBits);
        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
        var qrCode = new QRCode_default();
        qrCode.setECLevel(ecLevel);
        qrCode.setMode(mode);
        qrCode.setVersion(version);
        var dimension = version.getDimensionForVersion();
        var matrix = new ByteMatrix_default(dimension, dimension);
        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
        qrCode.setMaskPattern(maskPattern);
        MatrixUtil_default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
        qrCode.setMatrix(matrix);
        return qrCode;
      };
      Encoder3.recommendVersion = function(ecLevel, mode, headerBits, dataBits) {
        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_default2.getVersionForNumber(1));
        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
        return this.chooseVersion(bitsNeeded, ecLevel);
      };
      Encoder3.calculateBitsNeeded = function(mode, headerBits, dataBits, version) {
        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
      };
      Encoder3.getAlphanumericCode = function(code) {
        if (code < Encoder3.ALPHANUMERIC_TABLE.length) {
          return Encoder3.ALPHANUMERIC_TABLE[code];
        }
        return -1;
      };
      Encoder3.chooseMode = function(content, encoding) {
        if (encoding === void 0) {
          encoding = null;
        }
        if (CharacterSetECI_default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
          return Mode_default.KANJI;
        }
        var hasNumeric = false;
        var hasAlphanumeric = false;
        for (var i = 0, length_1 = content.length; i < length_1; ++i) {
          var c = content.charAt(i);
          if (Encoder3.isDigit(c)) {
            hasNumeric = true;
          } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
            hasAlphanumeric = true;
          } else {
            return Mode_default.BYTE;
          }
        }
        if (hasAlphanumeric) {
          return Mode_default.ALPHANUMERIC;
        }
        if (hasNumeric) {
          return Mode_default.NUMERIC;
        }
        return Mode_default.BYTE;
      };
      Encoder3.isOnlyDoubleByteKanji = function(content) {
        var bytes;
        try {
          bytes = StringEncoding_default.encode(content, CharacterSetECI_default.SJIS);
        } catch (ignored) {
          return false;
        }
        var length = bytes.length;
        if (length % 2 !== 0) {
          return false;
        }
        for (var i = 0; i < length; i += 2) {
          var byte1 = bytes[i] & 255;
          if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
            return false;
          }
        }
        return true;
      };
      Encoder3.chooseMaskPattern = function(bits, ecLevel, version, matrix) {
        var minPenalty = Number.MAX_SAFE_INTEGER;
        var bestMaskPattern = -1;
        for (var maskPattern = 0; maskPattern < QRCode_default.NUM_MASK_PATTERNS; maskPattern++) {
          MatrixUtil_default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
          var penalty = this.calculateMaskPenalty(matrix);
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestMaskPattern = maskPattern;
          }
        }
        return bestMaskPattern;
      };
      Encoder3.chooseVersion = function(numInputBits, ecLevel) {
        for (var versionNum = 1; versionNum <= 40; versionNum++) {
          var version = Version_default2.getVersionForNumber(versionNum);
          if (Encoder3.willFit(numInputBits, version, ecLevel)) {
            return version;
          }
        }
        throw new WriterException_default("Data too big");
      };
      Encoder3.willFit = function(numInputBits, version, ecLevel) {
        var numBytes = version.getTotalCodewords();
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var numEcBytes = ecBlocks.getTotalECCodewords();
        var numDataBytes = numBytes - numEcBytes;
        var totalInputBytes = (numInputBits + 7) / 8;
        return numDataBytes >= totalInputBytes;
      };
      Encoder3.terminateBits = function(numDataBytes, bits) {
        var capacity = numDataBytes * 8;
        if (bits.getSize() > capacity) {
          throw new WriterException_default("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
        }
        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {
          bits.appendBit(false);
        }
        var numBitsInLastByte = bits.getSize() & 7;
        if (numBitsInLastByte > 0) {
          for (var i = numBitsInLastByte; i < 8; i++) {
            bits.appendBit(false);
          }
        }
        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();
        for (var i = 0; i < numPaddingBytes; ++i) {
          bits.appendBits((i & 1) === 0 ? 236 : 17, 8);
        }
        if (bits.getSize() !== capacity) {
          throw new WriterException_default("Bits size does not equal capacity");
        }
      };
      Encoder3.getNumDataBytesAndNumECBytesForBlockID = function(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
        if (blockID >= numRSBlocks) {
          throw new WriterException_default("Block ID too large");
        }
        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
          throw new WriterException_default("EC bytes mismatch");
        }
        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
          throw new WriterException_default("RS blocks mismatch");
        }
        if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
          throw new WriterException_default("Total bytes mismatch");
        }
        if (blockID < numRsBlocksInGroup1) {
          numDataBytesInBlock[0] = numDataBytesInGroup1;
          numECBytesInBlock[0] = numEcBytesInGroup1;
        } else {
          numDataBytesInBlock[0] = numDataBytesInGroup2;
          numECBytesInBlock[0] = numEcBytesInGroup2;
        }
      };
      Encoder3.interleaveWithECBytes = function(bits, numTotalBytes, numDataBytes, numRSBlocks) {
        var e_1, _a2, e_2, _b;
        if (bits.getSizeInBytes() !== numDataBytes) {
          throw new WriterException_default("Number of bits and data bytes does not match");
        }
        var dataBytesOffset = 0;
        var maxNumDataBytes = 0;
        var maxNumEcBytes = 0;
        var blocks = new Array();
        for (var i = 0; i < numRSBlocks; ++i) {
          var numDataBytesInBlock = new Int32Array(1);
          var numEcBytesInBlock = new Int32Array(1);
          Encoder3.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
          var size = numDataBytesInBlock[0];
          var dataBytes = new Uint8Array(size);
          bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
          var ecBytes = Encoder3.generateECBytes(dataBytes, numEcBytesInBlock[0]);
          blocks.push(new BlockPair_default(dataBytes, ecBytes));
          maxNumDataBytes = Math.max(maxNumDataBytes, size);
          maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
          dataBytesOffset += numDataBytesInBlock[0];
        }
        if (numDataBytes !== dataBytesOffset) {
          throw new WriterException_default("Data bytes does not match offset");
        }
        var result = new BitArray_default();
        for (var i = 0; i < maxNumDataBytes; ++i) {
          try {
            for (var blocks_1 = (e_1 = void 0, __values40(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
              var block = blocks_1_1.value;
              var dataBytes = block.getDataBytes();
              if (i < dataBytes.length) {
                result.appendBits(dataBytes[i], 8);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (blocks_1_1 && !blocks_1_1.done && (_a2 = blocks_1.return)) _a2.call(blocks_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
        for (var i = 0; i < maxNumEcBytes; ++i) {
          try {
            for (var blocks_2 = (e_2 = void 0, __values40(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {
              var block = blocks_2_1.value;
              var ecBytes = block.getErrorCorrectionBytes();
              if (i < ecBytes.length) {
                result.appendBits(ecBytes[i], 8);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
        if (numTotalBytes !== result.getSizeInBytes()) {
          throw new WriterException_default("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
        }
        return result;
      };
      Encoder3.generateECBytes = function(dataBytes, numEcBytesInBlock) {
        var numDataBytes = dataBytes.length;
        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
        for (var i = 0; i < numDataBytes; i++) {
          toEncode[i] = dataBytes[i] & 255;
        }
        new ReedSolomonEncoder_default(GenericGF_default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
        var ecBytes = new Uint8Array(numEcBytesInBlock);
        for (var i = 0; i < numEcBytesInBlock; i++) {
          ecBytes[i] = /*(byte) */
          toEncode[numDataBytes + i];
        }
        return ecBytes;
      };
      Encoder3.appendModeInfo = function(mode, bits) {
        bits.appendBits(mode.getBits(), 4);
      };
      Encoder3.appendLengthInfo = function(numLetters, version, mode, bits) {
        var numBits = mode.getCharacterCountBits(version);
        if (numLetters >= 1 << numBits) {
          throw new WriterException_default(numLetters + " is bigger than " + ((1 << numBits) - 1));
        }
        bits.appendBits(numLetters, numBits);
      };
      Encoder3.appendBytes = function(content, mode, bits, encoding) {
        switch (mode) {
          case Mode_default.NUMERIC:
            Encoder3.appendNumericBytes(content, bits);
            break;
          case Mode_default.ALPHANUMERIC:
            Encoder3.appendAlphanumericBytes(content, bits);
            break;
          case Mode_default.BYTE:
            Encoder3.append8BitBytes(content, bits, encoding);
            break;
          case Mode_default.KANJI:
            Encoder3.appendKanjiBytes(content, bits);
            break;
          default:
            throw new WriterException_default("Invalid mode: " + mode);
        }
      };
      Encoder3.getDigit = function(singleCharacter) {
        return singleCharacter.charCodeAt(0) - 48;
      };
      Encoder3.isDigit = function(singleCharacter) {
        var cn = Encoder3.getDigit(singleCharacter);
        return cn >= 0 && cn <= 9;
      };
      Encoder3.appendNumericBytes = function(content, bits) {
        var length = content.length;
        var i = 0;
        while (i < length) {
          var num1 = Encoder3.getDigit(content.charAt(i));
          if (i + 2 < length) {
            var num2 = Encoder3.getDigit(content.charAt(i + 1));
            var num3 = Encoder3.getDigit(content.charAt(i + 2));
            bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
            i += 3;
          } else if (i + 1 < length) {
            var num2 = Encoder3.getDigit(content.charAt(i + 1));
            bits.appendBits(num1 * 10 + num2, 7);
            i += 2;
          } else {
            bits.appendBits(num1, 4);
            i++;
          }
        }
      };
      Encoder3.appendAlphanumericBytes = function(content, bits) {
        var length = content.length;
        var i = 0;
        while (i < length) {
          var code1 = Encoder3.getAlphanumericCode(content.charCodeAt(i));
          if (code1 === -1) {
            throw new WriterException_default();
          }
          if (i + 1 < length) {
            var code2 = Encoder3.getAlphanumericCode(content.charCodeAt(i + 1));
            if (code2 === -1) {
              throw new WriterException_default();
            }
            bits.appendBits(code1 * 45 + code2, 11);
            i += 2;
          } else {
            bits.appendBits(code1, 6);
            i++;
          }
        }
      };
      Encoder3.append8BitBytes = function(content, bits, encoding) {
        var bytes;
        try {
          bytes = StringEncoding_default.encode(content, encoding);
        } catch (uee) {
          throw new WriterException_default(uee);
        }
        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {
          var b = bytes[i];
          bits.appendBits(b, 8);
        }
      };
      Encoder3.appendKanjiBytes = function(content, bits) {
        var bytes;
        try {
          bytes = StringEncoding_default.encode(content, CharacterSetECI_default.SJIS);
        } catch (uee) {
          throw new WriterException_default(uee);
        }
        var length = bytes.length;
        for (var i = 0; i < length; i += 2) {
          var byte1 = bytes[i] & 255;
          var byte2 = bytes[i + 1] & 255;
          var code = byte1 << 8 & 4294967295 | byte2;
          var subtracted = -1;
          if (code >= 33088 && code <= 40956) {
            subtracted = code - 33088;
          } else if (code >= 57408 && code <= 60351) {
            subtracted = code - 49472;
          }
          if (subtracted === -1) {
            throw new WriterException_default("Invalid byte sequence");
          }
          var encoded = (subtracted >> 8) * 192 + (subtracted & 255);
          bits.appendBits(encoded, 13);
        }
      };
      Encoder3.appendECI = function(eci, bits) {
        bits.appendBits(Mode_default.ECI.getBits(), 4);
        bits.appendBits(eci.getValue(), 8);
      };
      Encoder3.ALPHANUMERIC_TABLE = Int32Array.from([
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        36,
        -1,
        -1,
        -1,
        37,
        38,
        -1,
        -1,
        -1,
        -1,
        39,
        40,
        -1,
        41,
        42,
        43,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        44,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        -1,
        -1,
        -1,
        -1,
        -1
      ]);
      Encoder3.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_default.UTF8.getName();
      return Encoder3;
    }()
  );
  var Encoder_default = Encoder;

  // node_modules/@zxing/library/esm/browser/BrowserQRCodeSvgWriter.js
  var BrowserQRCodeSvgWriter = (
    /** @class */
    function() {
      function BrowserQRCodeSvgWriter3() {
      }
      BrowserQRCodeSvgWriter3.prototype.write = function(contents, width, height, hints) {
        if (hints === void 0) {
          hints = null;
        }
        if (contents.length === 0) {
          throw new IllegalArgumentException_default("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
        }
        var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
        var quietZone = BrowserQRCodeSvgWriter3.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType_default.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType_default.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10);
          }
        }
        var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
      };
      BrowserQRCodeSvgWriter3.prototype.writeToDom = function(containerElement, contents, width, height, hints) {
        if (hints === void 0) {
          hints = null;
        }
        if (typeof containerElement === "string") {
          containerElement = document.querySelector(containerElement);
        }
        var svgElement = this.write(contents, width, height, hints);
        if (containerElement)
          containerElement.appendChild(svgElement);
      };
      BrowserQRCodeSvgWriter3.prototype.renderResult = function(code, width, height, quietZone) {
        var input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException_default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + quietZone * 2;
        var qrHeight = inputHeight + quietZone * 2;
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        var svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      };
      BrowserQRCodeSvgWriter3.prototype.createSVGElement = function(w, h) {
        var svgElement = document.createElementNS(BrowserQRCodeSvgWriter3.SVG_NS, "svg");
        svgElement.setAttributeNS(null, "height", w.toString());
        svgElement.setAttributeNS(null, "width", h.toString());
        return svgElement;
      };
      BrowserQRCodeSvgWriter3.prototype.createSvgRectElement = function(x, y, w, h) {
        var rect = document.createElementNS(BrowserQRCodeSvgWriter3.SVG_NS, "rect");
        rect.setAttributeNS(null, "x", x.toString());
        rect.setAttributeNS(null, "y", y.toString());
        rect.setAttributeNS(null, "height", w.toString());
        rect.setAttributeNS(null, "width", h.toString());
        rect.setAttributeNS(null, "fill", "#000000");
        return rect;
      };
      BrowserQRCodeSvgWriter3.QUIET_ZONE_SIZE = 4;
      BrowserQRCodeSvgWriter3.SVG_NS = "http://www.w3.org/2000/svg";
      return BrowserQRCodeSvgWriter3;
    }()
  );

  // node_modules/@zxing/library/esm/core/qrcode/QRCodeWriter.js
  var QRCodeWriter = (
    /** @class */
    function() {
      function QRCodeWriter2() {
      }
      QRCodeWriter2.prototype.encode = function(contents, format, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException_default("Found empty contents");
        }
        if (format !== BarcodeFormat_default.QR_CODE) {
          throw new IllegalArgumentException_default("Can only encode QR_CODE, but got " + format);
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
        }
        var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
        var quietZone = QRCodeWriter2.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType_default.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType_default.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10);
          }
        }
        var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
        return QRCodeWriter2.renderResult(code, width, height, quietZone);
      };
      QRCodeWriter2.renderResult = function(code, width, height, quietZone) {
        var input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException_default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + quietZone * 2;
        var qrHeight = inputHeight + quietZone * 2;
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        var output = new BitMatrix_default(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      };
      QRCodeWriter2.QUIET_ZONE_SIZE = 4;
      return QRCodeWriter2;
    }()
  );
  var QRCodeWriter_default = QRCodeWriter;

  // node_modules/@zxing/library/esm/core/MultiFormatWriter.js
  var MultiFormatWriter = (
    /** @class */
    function() {
      function MultiFormatWriter2() {
      }
      MultiFormatWriter2.prototype.encode = function(contents, format, width, height, hints) {
        var writer;
        switch (format) {
          // case BarcodeFormat.EAN_8:
          //   writer = new EAN8Writer()
          //   break
          // case BarcodeFormat.UPC_E:
          //   writer = new UPCEWriter()
          //   break
          // case BarcodeFormat.EAN_13:
          //   writer = new EAN13Writer()
          //   break
          // case BarcodeFormat.UPC_A:
          //   writer = new UPCAWriter()
          //   break
          case BarcodeFormat_default.QR_CODE:
            writer = new QRCodeWriter_default();
            break;
          // case BarcodeFormat.CODE_39:
          //   writer = new Code39Writer()
          //   break
          // case BarcodeFormat.CODE_93:
          //   writer = new Code93Writer()
          //   break
          // case BarcodeFormat.CODE_128:
          //   writer = new Code128Writer()
          //   break
          // case BarcodeFormat.ITF:
          //   writer = new ITFWriter()
          //   break
          // case BarcodeFormat.PDF_417:
          //   writer = new PDF417Writer()
          //   break
          // case BarcodeFormat.CODABAR:
          //   writer = new CodaBarWriter()
          //   break
          // case BarcodeFormat.DATA_MATRIX:
          //   writer = new DataMatrixWriter()
          //   break
          // case BarcodeFormat.AZTEC:
          //   writer = new AztecWriter()
          //   break
          default:
            throw new IllegalArgumentException_default("No encoder available for format " + format);
        }
        return writer.encode(contents, format, width, height, hints);
      };
      return MultiFormatWriter2;
    }()
  );

  // node_modules/@zxing/library/esm/core/PlanarYUVLuminanceSource.js
  var __extends66 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var PlanarYUVLuminanceSource = (
    /** @class */
    function(_super) {
      __extends66(PlanarYUVLuminanceSource2, _super);
      function PlanarYUVLuminanceSource2(yuvData, dataWidth, dataHeight, left2, top2, width, height, reverseHorizontal) {
        var _this = _super.call(this, width, height) || this;
        _this.yuvData = yuvData;
        _this.dataWidth = dataWidth;
        _this.dataHeight = dataHeight;
        _this.left = left2;
        _this.top = top2;
        if (left2 + width > dataWidth || top2 + height > dataHeight) {
          throw new IllegalArgumentException_default("Crop rectangle does not fit within image data.");
        }
        if (reverseHorizontal) {
          _this.reverseHorizontal(width, height);
        }
        return _this;
      }
      PlanarYUVLuminanceSource2.prototype.getRow = function(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
        }
        var width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        var offset2 = (y + this.top) * this.dataWidth + this.left;
        System_default.arraycopy(this.yuvData, offset2, row, 0, width);
        return row;
      };
      PlanarYUVLuminanceSource2.prototype.getMatrix = function() {
        var width = this.getWidth();
        var height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.yuvData;
        }
        var area = width * height;
        var matrix = new Uint8ClampedArray(area);
        var inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System_default.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (var y = 0; y < height; y++) {
          var outputOffset = y * width;
          System_default.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      };
      PlanarYUVLuminanceSource2.prototype.isCropSupported = function() {
        return true;
      };
      PlanarYUVLuminanceSource2.prototype.crop = function(left2, top2, width, height) {
        return new PlanarYUVLuminanceSource2(this.yuvData, this.dataWidth, this.dataHeight, this.left + left2, this.top + top2, width, height, false);
      };
      PlanarYUVLuminanceSource2.prototype.renderThumbnail = function() {
        var width = this.getWidth() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
        var height = this.getHeight() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
        var pixels = new Int32Array(width * height);
        var yuv = this.yuvData;
        var inputOffset = this.top * this.dataWidth + this.left;
        for (var y = 0; y < height; y++) {
          var outputOffset = y * width;
          for (var x = 0; x < width; x++) {
            var grey = yuv[inputOffset + x * PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR] & 255;
            pixels[outputOffset + x] = 4278190080 | grey * 65793;
          }
          inputOffset += this.dataWidth * PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
        }
        return pixels;
      };
      PlanarYUVLuminanceSource2.prototype.getThumbnailWidth = function() {
        return this.getWidth() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
      };
      PlanarYUVLuminanceSource2.prototype.getThumbnailHeight = function() {
        return this.getHeight() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
      };
      PlanarYUVLuminanceSource2.prototype.reverseHorizontal = function(width, height) {
        var yuvData = this.yuvData;
        for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
          var middle = rowStart + width / 2;
          for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
            var temp = yuvData[x1];
            yuvData[x1] = yuvData[x2];
            yuvData[x2] = temp;
          }
        }
      };
      PlanarYUVLuminanceSource2.prototype.invert = function() {
        return new InvertedLuminanceSource_default(this);
      };
      PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR = 2;
      return PlanarYUVLuminanceSource2;
    }(LuminanceSource_default)
  );

  // node_modules/@zxing/library/esm/core/RGBLuminanceSource.js
  var __extends67 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var RGBLuminanceSource = (
    /** @class */
    function(_super) {
      __extends67(RGBLuminanceSource2, _super);
      function RGBLuminanceSource2(luminances, width, height, dataWidth, dataHeight, left2, top2) {
        var _this = _super.call(this, width, height) || this;
        _this.dataWidth = dataWidth;
        _this.dataHeight = dataHeight;
        _this.left = left2;
        _this.top = top2;
        if (luminances.BYTES_PER_ELEMENT === 4) {
          var size = width * height;
          var luminancesUint8Array = new Uint8ClampedArray(size);
          for (var offset2 = 0; offset2 < size; offset2++) {
            var pixel = luminances[offset2];
            var r = pixel >> 16 & 255;
            var g2 = pixel >> 7 & 510;
            var b = pixel & 255;
            luminancesUint8Array[offset2] = /*(byte) */
            (r + g2 + b) / 4 & 255;
          }
          _this.luminances = luminancesUint8Array;
        } else {
          _this.luminances = luminances;
        }
        if (void 0 === dataWidth) {
          _this.dataWidth = width;
        }
        if (void 0 === dataHeight) {
          _this.dataHeight = height;
        }
        if (void 0 === left2) {
          _this.left = 0;
        }
        if (void 0 === top2) {
          _this.top = 0;
        }
        if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {
          throw new IllegalArgumentException_default("Crop rectangle does not fit within image data.");
        }
        return _this;
      }
      RGBLuminanceSource2.prototype.getRow = function(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
        }
        var width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        var offset2 = (y + this.top) * this.dataWidth + this.left;
        System_default.arraycopy(this.luminances, offset2, row, 0, width);
        return row;
      };
      RGBLuminanceSource2.prototype.getMatrix = function() {
        var width = this.getWidth();
        var height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.luminances;
        }
        var area = width * height;
        var matrix = new Uint8ClampedArray(area);
        var inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System_default.arraycopy(this.luminances, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (var y = 0; y < height; y++) {
          var outputOffset = y * width;
          System_default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      };
      RGBLuminanceSource2.prototype.isCropSupported = function() {
        return true;
      };
      RGBLuminanceSource2.prototype.crop = function(left2, top2, width, height) {
        return new RGBLuminanceSource2(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left2, this.top + top2);
      };
      RGBLuminanceSource2.prototype.invert = function() {
        return new InvertedLuminanceSource_default(this);
      };
      return RGBLuminanceSource2;
    }(LuminanceSource_default)
  );

  // node_modules/@zxing/library/esm/core/util/Charset.js
  var __extends68 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var Charset = (
    /** @class */
    function(_super) {
      __extends68(Charset2, _super);
      function Charset2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Charset2.forName = function(name) {
        return this.getCharacterSetECIByName(name);
      };
      return Charset2;
    }(CharacterSetECI_default)
  );
  var Charset_default = Charset;

  // node_modules/@zxing/library/esm/core/util/StandardCharsets.js
  var StandardCharsets = (
    /** @class */
    function() {
      function StandardCharsets2() {
      }
      StandardCharsets2.ISO_8859_1 = CharacterSetECI_default.ISO8859_1;
      return StandardCharsets2;
    }()
  );
  var StandardCharsets_default = StandardCharsets;

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/DefaultPlacement.js
  var DefaultPlacement = (
    /** @class */
    function() {
      function DefaultPlacement2(codewords, numcols, numrows) {
        this.codewords = codewords;
        this.numcols = numcols;
        this.numrows = numrows;
        this.bits = new Uint8Array(numcols * numrows);
        Arrays_default.fill(this.bits, 2);
      }
      DefaultPlacement2.prototype.getNumrows = function() {
        return this.numrows;
      };
      DefaultPlacement2.prototype.getNumcols = function() {
        return this.numcols;
      };
      DefaultPlacement2.prototype.getBits = function() {
        return this.bits;
      };
      DefaultPlacement2.prototype.getBit = function(col, row) {
        return this.bits[row * this.numcols + col] === 1;
      };
      DefaultPlacement2.prototype.setBit = function(col, row, bit) {
        this.bits[row * this.numcols + col] = bit ? 1 : 0;
      };
      DefaultPlacement2.prototype.noBit = function(col, row) {
        return this.bits[row * this.numcols + col] === 2;
      };
      DefaultPlacement2.prototype.place = function() {
        var pos = 0;
        var row = 4;
        var col = 0;
        do {
          if (row === this.numrows && col === 0) {
            this.corner1(pos++);
          }
          if (row === this.numrows - 2 && col === 0 && this.numcols % 4 !== 0) {
            this.corner2(pos++);
          }
          if (row === this.numrows - 2 && col === 0 && this.numcols % 8 === 4) {
            this.corner3(pos++);
          }
          if (row === this.numrows + 4 && col === 2 && this.numcols % 8 === 0) {
            this.corner4(pos++);
          }
          do {
            if (row < this.numrows && col >= 0 && this.noBit(col, row)) {
              this.utah(row, col, pos++);
            }
            row -= 2;
            col += 2;
          } while (row >= 0 && col < this.numcols);
          row++;
          col += 3;
          do {
            if (row >= 0 && col < this.numcols && this.noBit(col, row)) {
              this.utah(row, col, pos++);
            }
            row += 2;
            col -= 2;
          } while (row < this.numrows && col >= 0);
          row += 3;
          col++;
        } while (row < this.numrows || col < this.numcols);
        if (this.noBit(this.numcols - 1, this.numrows - 1)) {
          this.setBit(this.numcols - 1, this.numrows - 1, true);
          this.setBit(this.numcols - 2, this.numrows - 2, true);
        }
      };
      DefaultPlacement2.prototype.module = function(row, col, pos, bit) {
        if (row < 0) {
          row += this.numrows;
          col += 4 - (this.numrows + 4) % 8;
        }
        if (col < 0) {
          col += this.numcols;
          row += 4 - (this.numcols + 4) % 8;
        }
        var v = this.codewords.charCodeAt(pos);
        v &= 1 << 8 - bit;
        this.setBit(col, row, v !== 0);
      };
      DefaultPlacement2.prototype.utah = function(row, col, pos) {
        this.module(row - 2, col - 2, pos, 1);
        this.module(row - 2, col - 1, pos, 2);
        this.module(row - 1, col - 2, pos, 3);
        this.module(row - 1, col - 1, pos, 4);
        this.module(row - 1, col, pos, 5);
        this.module(row, col - 2, pos, 6);
        this.module(row, col - 1, pos, 7);
        this.module(row, col, pos, 8);
      };
      DefaultPlacement2.prototype.corner1 = function(pos) {
        this.module(this.numrows - 1, 0, pos, 1);
        this.module(this.numrows - 1, 1, pos, 2);
        this.module(this.numrows - 1, 2, pos, 3);
        this.module(0, this.numcols - 2, pos, 4);
        this.module(0, this.numcols - 1, pos, 5);
        this.module(1, this.numcols - 1, pos, 6);
        this.module(2, this.numcols - 1, pos, 7);
        this.module(3, this.numcols - 1, pos, 8);
      };
      DefaultPlacement2.prototype.corner2 = function(pos) {
        this.module(this.numrows - 3, 0, pos, 1);
        this.module(this.numrows - 2, 0, pos, 2);
        this.module(this.numrows - 1, 0, pos, 3);
        this.module(0, this.numcols - 4, pos, 4);
        this.module(0, this.numcols - 3, pos, 5);
        this.module(0, this.numcols - 2, pos, 6);
        this.module(0, this.numcols - 1, pos, 7);
        this.module(1, this.numcols - 1, pos, 8);
      };
      DefaultPlacement2.prototype.corner3 = function(pos) {
        this.module(this.numrows - 3, 0, pos, 1);
        this.module(this.numrows - 2, 0, pos, 2);
        this.module(this.numrows - 1, 0, pos, 3);
        this.module(0, this.numcols - 2, pos, 4);
        this.module(0, this.numcols - 1, pos, 5);
        this.module(1, this.numcols - 1, pos, 6);
        this.module(2, this.numcols - 1, pos, 7);
        this.module(3, this.numcols - 1, pos, 8);
      };
      DefaultPlacement2.prototype.corner4 = function(pos) {
        this.module(this.numrows - 1, 0, pos, 1);
        this.module(this.numrows - 1, this.numcols - 1, pos, 2);
        this.module(0, this.numcols - 3, pos, 3);
        this.module(0, this.numcols - 2, pos, 4);
        this.module(0, this.numcols - 1, pos, 5);
        this.module(1, this.numcols - 3, pos, 6);
        this.module(1, this.numcols - 2, pos, 7);
        this.module(1, this.numcols - 1, pos, 8);
      };
      return DefaultPlacement2;
    }()
  );
  var DefaultPlacement_default = DefaultPlacement;

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/constants.js
  var _a;
  var FACTOR_SETS = [
    5,
    7,
    10,
    11,
    12,
    14,
    18,
    20,
    24,
    28,
    36,
    42,
    48,
    56,
    62,
    68
  ];
  var FACTORS = [
    [228, 48, 15, 111, 62],
    [23, 68, 144, 134, 240, 92, 254],
    [28, 24, 185, 166, 223, 248, 116, 255, 110, 61],
    [175, 138, 205, 12, 194, 168, 39, 245, 60, 97, 120],
    [41, 153, 158, 91, 61, 42, 142, 213, 97, 178, 100, 242],
    [156, 97, 192, 252, 95, 9, 157, 119, 138, 45, 18, 186, 83, 185],
    [
      83,
      195,
      100,
      39,
      188,
      75,
      66,
      61,
      241,
      213,
      109,
      129,
      94,
      254,
      225,
      48,
      90,
      188
    ],
    [
      15,
      195,
      244,
      9,
      233,
      71,
      168,
      2,
      188,
      160,
      153,
      145,
      253,
      79,
      108,
      82,
      27,
      174,
      186,
      172
    ],
    [
      52,
      190,
      88,
      205,
      109,
      39,
      176,
      21,
      155,
      197,
      251,
      223,
      155,
      21,
      5,
      172,
      254,
      124,
      12,
      181,
      184,
      96,
      50,
      193
    ],
    [
      211,
      231,
      43,
      97,
      71,
      96,
      103,
      174,
      37,
      151,
      170,
      53,
      75,
      34,
      249,
      121,
      17,
      138,
      110,
      213,
      141,
      136,
      120,
      151,
      233,
      168,
      93,
      255
    ],
    [
      245,
      127,
      242,
      218,
      130,
      250,
      162,
      181,
      102,
      120,
      84,
      179,
      220,
      251,
      80,
      182,
      229,
      18,
      2,
      4,
      68,
      33,
      101,
      137,
      95,
      119,
      115,
      44,
      175,
      184,
      59,
      25,
      225,
      98,
      81,
      112
    ],
    [
      77,
      193,
      137,
      31,
      19,
      38,
      22,
      153,
      247,
      105,
      122,
      2,
      245,
      133,
      242,
      8,
      175,
      95,
      100,
      9,
      167,
      105,
      214,
      111,
      57,
      121,
      21,
      1,
      253,
      57,
      54,
      101,
      248,
      202,
      69,
      50,
      150,
      177,
      226,
      5,
      9,
      5
    ],
    [
      245,
      132,
      172,
      223,
      96,
      32,
      117,
      22,
      238,
      133,
      238,
      231,
      205,
      188,
      237,
      87,
      191,
      106,
      16,
      147,
      118,
      23,
      37,
      90,
      170,
      205,
      131,
      88,
      120,
      100,
      66,
      138,
      186,
      240,
      82,
      44,
      176,
      87,
      187,
      147,
      160,
      175,
      69,
      213,
      92,
      253,
      225,
      19
    ],
    [
      175,
      9,
      223,
      238,
      12,
      17,
      220,
      208,
      100,
      29,
      175,
      170,
      230,
      192,
      215,
      235,
      150,
      159,
      36,
      223,
      38,
      200,
      132,
      54,
      228,
      146,
      218,
      234,
      117,
      203,
      29,
      232,
      144,
      238,
      22,
      150,
      201,
      117,
      62,
      207,
      164,
      13,
      137,
      245,
      127,
      67,
      247,
      28,
      155,
      43,
      203,
      107,
      233,
      53,
      143,
      46
    ],
    [
      242,
      93,
      169,
      50,
      144,
      210,
      39,
      118,
      202,
      188,
      201,
      189,
      143,
      108,
      196,
      37,
      185,
      112,
      134,
      230,
      245,
      63,
      197,
      190,
      250,
      106,
      185,
      221,
      175,
      64,
      114,
      71,
      161,
      44,
      147,
      6,
      27,
      218,
      51,
      63,
      87,
      10,
      40,
      130,
      188,
      17,
      163,
      31,
      176,
      170,
      4,
      107,
      232,
      7,
      94,
      166,
      224,
      124,
      86,
      47,
      11,
      204
    ],
    [
      220,
      228,
      173,
      89,
      251,
      149,
      159,
      56,
      89,
      33,
      147,
      244,
      154,
      36,
      73,
      127,
      213,
      136,
      248,
      180,
      234,
      197,
      158,
      177,
      68,
      122,
      93,
      213,
      15,
      160,
      227,
      236,
      66,
      139,
      153,
      185,
      202,
      167,
      179,
      25,
      220,
      232,
      96,
      210,
      231,
      136,
      223,
      239,
      181,
      241,
      59,
      52,
      172,
      25,
      49,
      232,
      211,
      189,
      64,
      54,
      108,
      153,
      132,
      63,
      96,
      103,
      82,
      186
    ]
  ];
  var MODULO_VALUE = 301;
  var static_LOG = function(LOG2, ALOG2) {
    var p = 1;
    for (var i = 0; i < 255; i++) {
      ALOG2[i] = p;
      LOG2[p] = i;
      p *= 2;
      if (p >= 256) {
        p ^= MODULO_VALUE;
      }
    }
    return {
      LOG: LOG2,
      ALOG: ALOG2
    };
  };
  var LOG = (_a = static_LOG([], []), _a.LOG);
  var ALOG = _a.ALOG;
  var SymbolShapeHint;
  (function(SymbolShapeHint2) {
    SymbolShapeHint2[SymbolShapeHint2["FORCE_NONE"] = 0] = "FORCE_NONE";
    SymbolShapeHint2[SymbolShapeHint2["FORCE_SQUARE"] = 1] = "FORCE_SQUARE";
    SymbolShapeHint2[SymbolShapeHint2["FORCE_RECTANGLE"] = 2] = "FORCE_RECTANGLE";
  })(SymbolShapeHint || (SymbolShapeHint = {}));
  var PAD = 129;
  var LATCH_TO_C40 = 230;
  var LATCH_TO_BASE256 = 231;
  var UPPER_SHIFT = 235;
  var MACRO_05 = 236;
  var MACRO_06 = 237;
  var LATCH_TO_ANSIX12 = 238;
  var LATCH_TO_TEXT = 239;
  var LATCH_TO_EDIFACT = 240;
  var C40_UNLATCH = 254;
  var X12_UNLATCH = 254;
  var MACRO_05_HEADER = "[)>05";
  var MACRO_06_HEADER = "[)>06";
  var MACRO_TRAILER = "";
  var ASCII_ENCODATION = 0;
  var C40_ENCODATION = 1;
  var TEXT_ENCODATION = 2;
  var X12_ENCODATION = 3;
  var EDIFACT_ENCODATION = 4;
  var BASE256_ENCODATION = 5;

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/ErrorCorrection.js
  var ErrorCorrection2 = (
    /** @class */
    function() {
      function ErrorCorrection3() {
      }
      ErrorCorrection3.encodeECC200 = function(codewords, symbolInfo) {
        if (codewords.length !== symbolInfo.getDataCapacity()) {
          throw new Error("The number of codewords does not match the selected symbol");
        }
        var sb = new StringBuilder_default();
        sb.append(codewords);
        var blockCount = symbolInfo.getInterleavedBlockCount();
        if (blockCount === 1) {
          var ecc = this.createECCBlock(codewords, symbolInfo.getErrorCodewords());
          sb.append(ecc);
        } else {
          var dataSizes = [];
          var errorSizes = [];
          for (var i = 0; i < blockCount; i++) {
            dataSizes[i] = symbolInfo.getDataLengthForInterleavedBlock(i + 1);
            errorSizes[i] = symbolInfo.getErrorLengthForInterleavedBlock(i + 1);
          }
          for (var block = 0; block < blockCount; block++) {
            var temp = new StringBuilder_default();
            for (var d = block; d < symbolInfo.getDataCapacity(); d += blockCount) {
              temp.append(codewords.charAt(d));
            }
            var ecc = this.createECCBlock(temp.toString(), errorSizes[block]);
            var pos = 0;
            for (var e = block; e < errorSizes[block] * blockCount; e += blockCount) {
              sb.setCharAt(symbolInfo.getDataCapacity() + e, ecc.charAt(pos++));
            }
          }
        }
        return sb.toString();
      };
      ErrorCorrection3.createECCBlock = function(codewords, numECWords) {
        var table = -1;
        for (var i = 0; i < FACTOR_SETS.length; i++) {
          if (FACTOR_SETS[i] === numECWords) {
            table = i;
            break;
          }
        }
        if (table < 0) {
          throw new Error("Illegal number of error correction codewords specified: " + numECWords);
        }
        var poly = FACTORS[table];
        var ecc = [];
        for (var i = 0; i < numECWords; i++) {
          ecc[i] = 0;
        }
        for (var i = 0; i < codewords.length; i++) {
          var m = ecc[numECWords - 1] ^ codewords.charAt(i).charCodeAt(0);
          for (var k = numECWords - 1; k > 0; k--) {
            if (m !== 0 && poly[k] !== 0) {
              ecc[k] = ecc[k - 1] ^ ALOG[(LOG[m] + LOG[poly[k]]) % 255];
            } else {
              ecc[k] = ecc[k - 1];
            }
          }
          if (m !== 0 && poly[0] !== 0) {
            ecc[0] = ALOG[(LOG[m] + LOG[poly[0]]) % 255];
          } else {
            ecc[0] = 0;
          }
        }
        var eccReversed = [];
        for (var i = 0; i < numECWords; i++) {
          eccReversed[i] = ecc[numECWords - i - 1];
        }
        return eccReversed.map(function(c) {
          return String.fromCharCode(c);
        }).join("");
      };
      return ErrorCorrection3;
    }()
  );
  var ErrorCorrection_default2 = ErrorCorrection2;

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/ASCIIEncoder.js
  var ASCIIEncoder = (
    /** @class */
    function() {
      function ASCIIEncoder2() {
      }
      ASCIIEncoder2.prototype.getEncodingMode = function() {
        return ASCII_ENCODATION;
      };
      ASCIIEncoder2.prototype.encode = function(context) {
        var n = HighLevelEncoder_default.determineConsecutiveDigitCount(context.getMessage(), context.pos);
        if (n >= 2) {
          context.writeCodeword(this.encodeASCIIDigits(context.getMessage().charCodeAt(context.pos), context.getMessage().charCodeAt(context.pos + 1)));
          context.pos += 2;
        } else {
          var c = context.getCurrentChar();
          var newMode = HighLevelEncoder_default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());
          if (newMode !== this.getEncodingMode()) {
            switch (newMode) {
              case BASE256_ENCODATION:
                context.writeCodeword(LATCH_TO_BASE256);
                context.signalEncoderChange(BASE256_ENCODATION);
                return;
              case C40_ENCODATION:
                context.writeCodeword(LATCH_TO_C40);
                context.signalEncoderChange(C40_ENCODATION);
                return;
              case X12_ENCODATION:
                context.writeCodeword(LATCH_TO_ANSIX12);
                context.signalEncoderChange(X12_ENCODATION);
                break;
              case TEXT_ENCODATION:
                context.writeCodeword(LATCH_TO_TEXT);
                context.signalEncoderChange(TEXT_ENCODATION);
                break;
              case EDIFACT_ENCODATION:
                context.writeCodeword(LATCH_TO_EDIFACT);
                context.signalEncoderChange(EDIFACT_ENCODATION);
                break;
              default:
                throw new Error("Illegal mode: " + newMode);
            }
          } else if (HighLevelEncoder_default.isExtendedASCII(c)) {
            context.writeCodeword(UPPER_SHIFT);
            context.writeCodeword(c - 128 + 1);
            context.pos++;
          } else {
            context.writeCodeword(c + 1);
            context.pos++;
          }
        }
      };
      ASCIIEncoder2.prototype.encodeASCIIDigits = function(digit1, digit2) {
        if (HighLevelEncoder_default.isDigit(digit1) && HighLevelEncoder_default.isDigit(digit2)) {
          var num = (digit1 - 48) * 10 + (digit2 - 48);
          return num + 130;
        }
        throw new Error("not digits: " + digit1 + digit2);
      };
      return ASCIIEncoder2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/Base256Encoder.js
  var Base256Encoder = (
    /** @class */
    function() {
      function Base256Encoder2() {
      }
      Base256Encoder2.prototype.getEncodingMode = function() {
        return BASE256_ENCODATION;
      };
      Base256Encoder2.prototype.encode = function(context) {
        var buffer = new StringBuilder_default();
        buffer.append(0);
        while (context.hasMoreCharacters()) {
          var c = context.getCurrentChar();
          buffer.append(c);
          context.pos++;
          var newMode = HighLevelEncoder_default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());
          if (newMode !== this.getEncodingMode()) {
            context.signalEncoderChange(ASCII_ENCODATION);
            break;
          }
        }
        var dataCount = buffer.length() - 1;
        var lengthFieldSize = 1;
        var currentSize = context.getCodewordCount() + dataCount + lengthFieldSize;
        context.updateSymbolInfo(currentSize);
        var mustPad = context.getSymbolInfo().getDataCapacity() - currentSize > 0;
        if (context.hasMoreCharacters() || mustPad) {
          if (dataCount <= 249) {
            buffer.setCharAt(0, StringUtils_default.getCharAt(dataCount));
          } else if (dataCount <= 1555) {
            buffer.setCharAt(0, StringUtils_default.getCharAt(Math.floor(dataCount / 250) + 249));
            buffer.insert(1, StringUtils_default.getCharAt(dataCount % 250));
          } else {
            throw new Error("Message length not in valid ranges: " + dataCount);
          }
        }
        for (var i = 0, c = buffer.length(); i < c; i++) {
          context.writeCodeword(this.randomize255State(buffer.charAt(i).charCodeAt(0), context.getCodewordCount() + 1));
        }
      };
      Base256Encoder2.prototype.randomize255State = function(ch, codewordPosition) {
        var pseudoRandom = 149 * codewordPosition % 255 + 1;
        var tempVariable = ch + pseudoRandom;
        if (tempVariable <= 255) {
          return tempVariable;
        } else {
          return tempVariable - 256;
        }
      };
      return Base256Encoder2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/C40Encoder.js
  var C40Encoder = (
    /** @class */
    function() {
      function C40Encoder2() {
      }
      C40Encoder2.prototype.getEncodingMode = function() {
        return C40_ENCODATION;
      };
      C40Encoder2.prototype.encodeMaximal = function(context) {
        var buffer = new StringBuilder_default();
        var lastCharSize = 0;
        var backtrackStartPosition = context.pos;
        var backtrackBufferLength = 0;
        while (context.hasMoreCharacters()) {
          var c = context.getCurrentChar();
          context.pos++;
          lastCharSize = this.encodeChar(c, buffer);
          if (buffer.length() % 3 === 0) {
            backtrackStartPosition = context.pos;
            backtrackBufferLength = buffer.length();
          }
        }
        if (backtrackBufferLength !== buffer.length()) {
          var unwritten = Math.floor(buffer.length() / 3 * 2);
          var curCodewordCount = Math.floor(context.getCodewordCount() + unwritten + 1);
          context.updateSymbolInfo(curCodewordCount);
          var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;
          var rest = Math.floor(buffer.length() % 3);
          if (rest === 2 && available !== 2 || rest === 1 && (lastCharSize > 3 || available !== 1)) {
            context.pos = backtrackStartPosition;
          }
        }
        if (buffer.length() > 0) {
          context.writeCodeword(LATCH_TO_C40);
        }
        this.handleEOD(context, buffer);
      };
      C40Encoder2.prototype.encode = function(context) {
        var buffer = new StringBuilder_default();
        while (context.hasMoreCharacters()) {
          var c = context.getCurrentChar();
          context.pos++;
          var lastCharSize = this.encodeChar(c, buffer);
          var unwritten = Math.floor(buffer.length() / 3) * 2;
          var curCodewordCount = context.getCodewordCount() + unwritten;
          context.updateSymbolInfo(curCodewordCount);
          var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;
          if (!context.hasMoreCharacters()) {
            var removed = new StringBuilder_default();
            if (buffer.length() % 3 === 2 && available !== 2) {
              lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);
            }
            while (buffer.length() % 3 === 1 && (lastCharSize > 3 || available !== 1)) {
              lastCharSize = this.backtrackOneCharacter(context, buffer, removed, lastCharSize);
            }
            break;
          }
          var count = buffer.length();
          if (count % 3 === 0) {
            var newMode = HighLevelEncoder_default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());
            if (newMode !== this.getEncodingMode()) {
              context.signalEncoderChange(ASCII_ENCODATION);
              break;
            }
          }
        }
        this.handleEOD(context, buffer);
      };
      C40Encoder2.prototype.backtrackOneCharacter = function(context, buffer, removed, lastCharSize) {
        var count = buffer.length();
        var test = buffer.toString().substring(0, count - lastCharSize);
        buffer.setLengthToZero();
        buffer.append(test);
        context.pos--;
        var c = context.getCurrentChar();
        lastCharSize = this.encodeChar(c, removed);
        context.resetSymbolInfo();
        return lastCharSize;
      };
      C40Encoder2.prototype.writeNextTriplet = function(context, buffer) {
        context.writeCodewords(this.encodeToCodewords(buffer.toString()));
        var test = buffer.toString().substring(3);
        buffer.setLengthToZero();
        buffer.append(test);
      };
      C40Encoder2.prototype.handleEOD = function(context, buffer) {
        var unwritten = Math.floor(buffer.length() / 3 * 2);
        var rest = buffer.length() % 3;
        var curCodewordCount = context.getCodewordCount() + unwritten;
        context.updateSymbolInfo(curCodewordCount);
        var available = context.getSymbolInfo().getDataCapacity() - curCodewordCount;
        if (rest === 2) {
          buffer.append("\0");
          while (buffer.length() >= 3) {
            this.writeNextTriplet(context, buffer);
          }
          if (context.hasMoreCharacters()) {
            context.writeCodeword(C40_UNLATCH);
          }
        } else if (available === 1 && rest === 1) {
          while (buffer.length() >= 3) {
            this.writeNextTriplet(context, buffer);
          }
          if (context.hasMoreCharacters()) {
            context.writeCodeword(C40_UNLATCH);
          }
          context.pos--;
        } else if (rest === 0) {
          while (buffer.length() >= 3) {
            this.writeNextTriplet(context, buffer);
          }
          if (available > 0 || context.hasMoreCharacters()) {
            context.writeCodeword(C40_UNLATCH);
          }
        } else {
          throw new Error("Unexpected case. Please report!");
        }
        context.signalEncoderChange(ASCII_ENCODATION);
      };
      C40Encoder2.prototype.encodeChar = function(c, sb) {
        if (c === " ".charCodeAt(0)) {
          sb.append(3);
          return 1;
        }
        if (c >= "0".charCodeAt(0) && c <= "9".charCodeAt(0)) {
          sb.append(c - 48 + 4);
          return 1;
        }
        if (c >= "A".charCodeAt(0) && c <= "Z".charCodeAt(0)) {
          sb.append(c - 65 + 14);
          return 1;
        }
        if (c < " ".charCodeAt(0)) {
          sb.append(0);
          sb.append(c);
          return 2;
        }
        if (c <= "/".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 33);
          return 2;
        }
        if (c <= "@".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 58 + 15);
          return 2;
        }
        if (c <= "_".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 91 + 22);
          return 2;
        }
        if (c <= 127) {
          sb.append(2);
          sb.append(c - 96);
          return 2;
        }
        sb.append("1");
        var len = 2;
        len += this.encodeChar(c - 128, sb);
        return len;
      };
      C40Encoder2.prototype.encodeToCodewords = function(sb) {
        var v = 1600 * sb.charCodeAt(0) + 40 * sb.charCodeAt(1) + sb.charCodeAt(2) + 1;
        var cw1 = v / 256;
        var cw2 = v % 256;
        var result = new StringBuilder_default();
        result.append(cw1);
        result.append(cw2);
        return result.toString();
      };
      return C40Encoder2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/EdifactEncoder.js
  var EdifactEncoder = (
    /** @class */
    function() {
      function EdifactEncoder2() {
      }
      EdifactEncoder2.prototype.getEncodingMode = function() {
        return EDIFACT_ENCODATION;
      };
      EdifactEncoder2.prototype.encode = function(context) {
        var buffer = new StringBuilder_default();
        while (context.hasMoreCharacters()) {
          var c = context.getCurrentChar();
          this.encodeChar(c, buffer);
          context.pos++;
          var count = buffer.length();
          if (count >= 4) {
            context.writeCodewords(this.encodeToCodewords(buffer.toString()));
            var test_1 = buffer.toString().substring(4);
            buffer.setLengthToZero();
            buffer.append(test_1);
            var newMode = HighLevelEncoder_default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());
            if (newMode !== this.getEncodingMode()) {
              context.signalEncoderChange(ASCII_ENCODATION);
              break;
            }
          }
        }
        buffer.append(StringUtils_default.getCharAt(31));
        this.handleEOD(context, buffer);
      };
      EdifactEncoder2.prototype.handleEOD = function(context, buffer) {
        try {
          var count = buffer.length();
          if (count === 0) {
            return;
          }
          if (count === 1) {
            context.updateSymbolInfo();
            var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();
            var remaining = context.getRemainingCharacters();
            if (remaining > available) {
              context.updateSymbolInfo(context.getCodewordCount() + 1);
              available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();
            }
            if (remaining <= available && available <= 2) {
              return;
            }
          }
          if (count > 4) {
            throw new Error("Count must not exceed 4");
          }
          var restChars = count - 1;
          var encoded = this.encodeToCodewords(buffer.toString());
          var endOfSymbolReached = !context.hasMoreCharacters();
          var restInAscii = endOfSymbolReached && restChars <= 2;
          if (restChars <= 2) {
            context.updateSymbolInfo(context.getCodewordCount() + restChars);
            var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();
            if (available >= 3) {
              restInAscii = false;
              context.updateSymbolInfo(context.getCodewordCount() + encoded.length);
            }
          }
          if (restInAscii) {
            context.resetSymbolInfo();
            context.pos -= restChars;
          } else {
            context.writeCodewords(encoded);
          }
        } finally {
          context.signalEncoderChange(ASCII_ENCODATION);
        }
      };
      EdifactEncoder2.prototype.encodeChar = function(c, sb) {
        if (c >= " ".charCodeAt(0) && c <= "?".charCodeAt(0)) {
          sb.append(c);
        } else if (c >= "@".charCodeAt(0) && c <= "^".charCodeAt(0)) {
          sb.append(StringUtils_default.getCharAt(c - 64));
        } else {
          HighLevelEncoder_default.illegalCharacter(StringUtils_default.getCharAt(c));
        }
      };
      EdifactEncoder2.prototype.encodeToCodewords = function(sb) {
        var len = sb.length;
        if (len === 0) {
          throw new Error("StringBuilder must not be empty");
        }
        var c1 = sb.charAt(0).charCodeAt(0);
        var c2 = len >= 2 ? sb.charAt(1).charCodeAt(0) : 0;
        var c3 = len >= 3 ? sb.charAt(2).charCodeAt(0) : 0;
        var c4 = len >= 4 ? sb.charAt(3).charCodeAt(0) : 0;
        var v = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4;
        var cw1 = v >> 16 & 255;
        var cw2 = v >> 8 & 255;
        var cw3 = v & 255;
        var res = new StringBuilder_default();
        res.append(cw1);
        if (len >= 2) {
          res.append(cw2);
        }
        if (len >= 3) {
          res.append(cw3);
        }
        return res.toString();
      };
      return EdifactEncoder2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/SymbolInfo.js
  var __extends69 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values41 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var SymbolInfo = (
    /** @class */
    function() {
      function SymbolInfo2(rectangular, dataCapacity, errorCodewords, matrixWidth, matrixHeight, dataRegions, rsBlockData, rsBlockError) {
        if (rsBlockData === void 0) {
          rsBlockData = 0;
        }
        if (rsBlockError === void 0) {
          rsBlockError = 0;
        }
        this.rectangular = rectangular;
        this.dataCapacity = dataCapacity;
        this.errorCodewords = errorCodewords;
        this.matrixWidth = matrixWidth;
        this.matrixHeight = matrixHeight;
        this.dataRegions = dataRegions;
        this.rsBlockData = rsBlockData;
        this.rsBlockError = rsBlockError;
      }
      SymbolInfo2.lookup = function(dataCodewords, shape, minSize, maxSize, fail) {
        var e_1, _a2;
        if (shape === void 0) {
          shape = 0;
        }
        if (minSize === void 0) {
          minSize = null;
        }
        if (maxSize === void 0) {
          maxSize = null;
        }
        if (fail === void 0) {
          fail = true;
        }
        try {
          for (var PROD_SYMBOLS_1 = __values41(PROD_SYMBOLS), PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next(); !PROD_SYMBOLS_1_1.done; PROD_SYMBOLS_1_1 = PROD_SYMBOLS_1.next()) {
            var symbol = PROD_SYMBOLS_1_1.value;
            if (shape === 1 && symbol.rectangular) {
              continue;
            }
            if (shape === 2 && !symbol.rectangular) {
              continue;
            }
            if (minSize != null && (symbol.getSymbolWidth() < minSize.getWidth() || symbol.getSymbolHeight() < minSize.getHeight())) {
              continue;
            }
            if (maxSize != null && (symbol.getSymbolWidth() > maxSize.getWidth() || symbol.getSymbolHeight() > maxSize.getHeight())) {
              continue;
            }
            if (dataCodewords <= symbol.dataCapacity) {
              return symbol;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (PROD_SYMBOLS_1_1 && !PROD_SYMBOLS_1_1.done && (_a2 = PROD_SYMBOLS_1.return)) _a2.call(PROD_SYMBOLS_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (fail) {
          throw new Error("Can't find a symbol arrangement that matches the message. Data codewords: " + dataCodewords);
        }
        return null;
      };
      SymbolInfo2.prototype.getHorizontalDataRegions = function() {
        switch (this.dataRegions) {
          case 1:
            return 1;
          case 2:
          case 4:
            return 2;
          case 16:
            return 4;
          case 36:
            return 6;
          default:
            throw new Error("Cannot handle this number of data regions");
        }
      };
      SymbolInfo2.prototype.getVerticalDataRegions = function() {
        switch (this.dataRegions) {
          case 1:
          case 2:
            return 1;
          case 4:
            return 2;
          case 16:
            return 4;
          case 36:
            return 6;
          default:
            throw new Error("Cannot handle this number of data regions");
        }
      };
      SymbolInfo2.prototype.getSymbolDataWidth = function() {
        return this.getHorizontalDataRegions() * this.matrixWidth;
      };
      SymbolInfo2.prototype.getSymbolDataHeight = function() {
        return this.getVerticalDataRegions() * this.matrixHeight;
      };
      SymbolInfo2.prototype.getSymbolWidth = function() {
        return this.getSymbolDataWidth() + this.getHorizontalDataRegions() * 2;
      };
      SymbolInfo2.prototype.getSymbolHeight = function() {
        return this.getSymbolDataHeight() + this.getVerticalDataRegions() * 2;
      };
      SymbolInfo2.prototype.getCodewordCount = function() {
        return this.dataCapacity + this.errorCodewords;
      };
      SymbolInfo2.prototype.getInterleavedBlockCount = function() {
        if (!this.rsBlockData)
          return 1;
        return this.dataCapacity / this.rsBlockData;
      };
      SymbolInfo2.prototype.getDataCapacity = function() {
        return this.dataCapacity;
      };
      SymbolInfo2.prototype.getErrorCodewords = function() {
        return this.errorCodewords;
      };
      SymbolInfo2.prototype.getDataLengthForInterleavedBlock = function(index) {
        return this.rsBlockData;
      };
      SymbolInfo2.prototype.getErrorLengthForInterleavedBlock = function(index) {
        return this.rsBlockError;
      };
      return SymbolInfo2;
    }()
  );
  var SymbolInfo_default = SymbolInfo;
  var DataMatrixSymbolInfo144 = (
    /** @class */
    function(_super) {
      __extends69(DataMatrixSymbolInfo1442, _super);
      function DataMatrixSymbolInfo1442() {
        return _super.call(this, false, 1558, 620, 22, 22, 36, -1, 62) || this;
      }
      DataMatrixSymbolInfo1442.prototype.getInterleavedBlockCount = function() {
        return 10;
      };
      DataMatrixSymbolInfo1442.prototype.getDataLengthForInterleavedBlock = function(index) {
        return index <= 8 ? 156 : 155;
      };
      return DataMatrixSymbolInfo1442;
    }(SymbolInfo)
  );
  var PROD_SYMBOLS = [
    new SymbolInfo(false, 3, 5, 8, 8, 1),
    new SymbolInfo(false, 5, 7, 10, 10, 1),
    /*rect*/
    new SymbolInfo(true, 5, 7, 16, 6, 1),
    new SymbolInfo(false, 8, 10, 12, 12, 1),
    /*rect*/
    new SymbolInfo(true, 10, 11, 14, 6, 2),
    new SymbolInfo(false, 12, 12, 14, 14, 1),
    /*rect*/
    new SymbolInfo(true, 16, 14, 24, 10, 1),
    new SymbolInfo(false, 18, 14, 16, 16, 1),
    new SymbolInfo(false, 22, 18, 18, 18, 1),
    /*rect*/
    new SymbolInfo(true, 22, 18, 16, 10, 2),
    new SymbolInfo(false, 30, 20, 20, 20, 1),
    /*rect*/
    new SymbolInfo(true, 32, 24, 16, 14, 2),
    new SymbolInfo(false, 36, 24, 22, 22, 1),
    new SymbolInfo(false, 44, 28, 24, 24, 1),
    /*rect*/
    new SymbolInfo(true, 49, 28, 22, 14, 2),
    new SymbolInfo(false, 62, 36, 14, 14, 4),
    new SymbolInfo(false, 86, 42, 16, 16, 4),
    new SymbolInfo(false, 114, 48, 18, 18, 4),
    new SymbolInfo(false, 144, 56, 20, 20, 4),
    new SymbolInfo(false, 174, 68, 22, 22, 4),
    new SymbolInfo(false, 204, 84, 24, 24, 4, 102, 42),
    new SymbolInfo(false, 280, 112, 14, 14, 16, 140, 56),
    new SymbolInfo(false, 368, 144, 16, 16, 16, 92, 36),
    new SymbolInfo(false, 456, 192, 18, 18, 16, 114, 48),
    new SymbolInfo(false, 576, 224, 20, 20, 16, 144, 56),
    new SymbolInfo(false, 696, 272, 22, 22, 16, 174, 68),
    new SymbolInfo(false, 816, 336, 24, 24, 16, 136, 56),
    new SymbolInfo(false, 1050, 408, 18, 18, 36, 175, 68),
    new SymbolInfo(false, 1304, 496, 20, 20, 36, 163, 62),
    new DataMatrixSymbolInfo144()
  ];

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/EncoderContext.js
  var EncoderContext = (
    /** @class */
    function() {
      function EncoderContext2(msg) {
        this.msg = msg;
        this.pos = 0;
        this.skipAtEnd = 0;
        var msgBinary = msg.split("").map(function(c2) {
          return c2.charCodeAt(0);
        });
        var sb = new StringBuilder_default();
        for (var i = 0, c = msgBinary.length; i < c; i++) {
          var ch = String.fromCharCode(msgBinary[i] & 255);
          if (ch === "?" && msg.charAt(i) !== "?") {
            throw new Error("Message contains characters outside ISO-8859-1 encoding.");
          }
          sb.append(ch);
        }
        this.msg = sb.toString();
        this.shape = 0;
        this.codewords = new StringBuilder_default();
        this.newEncoding = -1;
      }
      EncoderContext2.prototype.setSymbolShape = function(shape) {
        this.shape = shape;
      };
      EncoderContext2.prototype.setSizeConstraints = function(minSize, maxSize) {
        this.minSize = minSize;
        this.maxSize = maxSize;
      };
      EncoderContext2.prototype.getMessage = function() {
        return this.msg;
      };
      EncoderContext2.prototype.setSkipAtEnd = function(count) {
        this.skipAtEnd = count;
      };
      EncoderContext2.prototype.getCurrentChar = function() {
        return this.msg.charCodeAt(this.pos);
      };
      EncoderContext2.prototype.getCurrent = function() {
        return this.msg.charCodeAt(this.pos);
      };
      EncoderContext2.prototype.getCodewords = function() {
        return this.codewords;
      };
      EncoderContext2.prototype.writeCodewords = function(codewords) {
        this.codewords.append(codewords);
      };
      EncoderContext2.prototype.writeCodeword = function(codeword) {
        this.codewords.append(codeword);
      };
      EncoderContext2.prototype.getCodewordCount = function() {
        return this.codewords.length();
      };
      EncoderContext2.prototype.getNewEncoding = function() {
        return this.newEncoding;
      };
      EncoderContext2.prototype.signalEncoderChange = function(encoding) {
        this.newEncoding = encoding;
      };
      EncoderContext2.prototype.resetEncoderSignal = function() {
        this.newEncoding = -1;
      };
      EncoderContext2.prototype.hasMoreCharacters = function() {
        return this.pos < this.getTotalMessageCharCount();
      };
      EncoderContext2.prototype.getTotalMessageCharCount = function() {
        return this.msg.length - this.skipAtEnd;
      };
      EncoderContext2.prototype.getRemainingCharacters = function() {
        return this.getTotalMessageCharCount() - this.pos;
      };
      EncoderContext2.prototype.getSymbolInfo = function() {
        return this.symbolInfo;
      };
      EncoderContext2.prototype.updateSymbolInfo = function(len) {
        if (len === void 0) {
          len = this.getCodewordCount();
        }
        if (this.symbolInfo == null || len > this.symbolInfo.getDataCapacity()) {
          this.symbolInfo = SymbolInfo_default.lookup(len, this.shape, this.minSize, this.maxSize, true);
        }
      };
      EncoderContext2.prototype.resetSymbolInfo = function() {
        this.symbolInfo = null;
      };
      return EncoderContext2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/X12Encoder.js
  var __extends70 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var X12Encoder = (
    /** @class */
    function(_super) {
      __extends70(X12Encoder2, _super);
      function X12Encoder2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      X12Encoder2.prototype.getEncodingMode = function() {
        return X12_ENCODATION;
      };
      X12Encoder2.prototype.encode = function(context) {
        var buffer = new StringBuilder_default();
        while (context.hasMoreCharacters()) {
          var c = context.getCurrentChar();
          context.pos++;
          this.encodeChar(c, buffer);
          var count = buffer.length();
          if (count % 3 === 0) {
            this.writeNextTriplet(context, buffer);
            var newMode = HighLevelEncoder_default.lookAheadTest(context.getMessage(), context.pos, this.getEncodingMode());
            if (newMode !== this.getEncodingMode()) {
              context.signalEncoderChange(ASCII_ENCODATION);
              break;
            }
          }
        }
        this.handleEOD(context, buffer);
      };
      X12Encoder2.prototype.encodeChar = function(c, sb) {
        switch (c) {
          case 13:
            sb.append(0);
            break;
          case "*".charCodeAt(0):
            sb.append(1);
            break;
          case ">".charCodeAt(0):
            sb.append(2);
            break;
          case " ".charCodeAt(0):
            sb.append(3);
            break;
          default:
            if (c >= "0".charCodeAt(0) && c <= "9".charCodeAt(0)) {
              sb.append(c - 48 + 4);
            } else if (c >= "A".charCodeAt(0) && c <= "Z".charCodeAt(0)) {
              sb.append(c - 65 + 14);
            } else {
              HighLevelEncoder_default.illegalCharacter(StringUtils_default.getCharAt(c));
            }
            break;
        }
        return 1;
      };
      X12Encoder2.prototype.handleEOD = function(context, buffer) {
        context.updateSymbolInfo();
        var available = context.getSymbolInfo().getDataCapacity() - context.getCodewordCount();
        var count = buffer.length();
        context.pos -= count;
        if (context.getRemainingCharacters() > 1 || available > 1 || context.getRemainingCharacters() !== available) {
          context.writeCodeword(X12_UNLATCH);
        }
        if (context.getNewEncoding() < 0) {
          context.signalEncoderChange(ASCII_ENCODATION);
        }
      };
      return X12Encoder2;
    }(C40Encoder)
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/TextEncoder.js
  var __extends71 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var TextEncoder2 = (
    /** @class */
    function(_super) {
      __extends71(TextEncoder3, _super);
      function TextEncoder3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      TextEncoder3.prototype.getEncodingMode = function() {
        return TEXT_ENCODATION;
      };
      TextEncoder3.prototype.encodeChar = function(c, sb) {
        if (c === " ".charCodeAt(0)) {
          sb.append(3);
          return 1;
        }
        if (c >= "0".charCodeAt(0) && c <= "9".charCodeAt(0)) {
          sb.append(c - 48 + 4);
          return 1;
        }
        if (c >= "a".charCodeAt(0) && c <= "z".charCodeAt(0)) {
          sb.append(c - 97 + 14);
          return 1;
        }
        if (c < " ".charCodeAt(0)) {
          sb.append(0);
          sb.append(c);
          return 2;
        }
        if (c <= "/".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 33);
          return 2;
        }
        if (c <= "@".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 58 + 15);
          return 2;
        }
        if (c >= "[".charCodeAt(0) && c <= "_".charCodeAt(0)) {
          sb.append(1);
          sb.append(c - 91 + 22);
          return 2;
        }
        if (c === "`".charCodeAt(0)) {
          sb.append(2);
          sb.append(0);
          return 2;
        }
        if (c <= "Z".charCodeAt(0)) {
          sb.append(2);
          sb.append(c - 65 + 1);
          return 2;
        }
        if (c <= 127) {
          sb.append(2);
          sb.append(c - 123 + 27);
          return 2;
        }
        sb.append("1");
        var len = 2;
        len += this.encodeChar(c - 128, sb);
        return len;
      };
      return TextEncoder3;
    }(C40Encoder)
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/HighLevelEncoder.js
  var HighLevelEncoder = (
    /** @class */
    function() {
      function HighLevelEncoder3() {
      }
      HighLevelEncoder3.randomize253State = function(codewordPosition) {
        var pseudoRandom = 149 * codewordPosition % 253 + 1;
        var tempVariable = PAD + pseudoRandom;
        return tempVariable <= 254 ? tempVariable : tempVariable - 254;
      };
      HighLevelEncoder3.encodeHighLevel = function(msg, shape, minSize, maxSize, forceC40) {
        if (shape === void 0) {
          shape = 0;
        }
        if (minSize === void 0) {
          minSize = null;
        }
        if (maxSize === void 0) {
          maxSize = null;
        }
        if (forceC40 === void 0) {
          forceC40 = false;
        }
        var c40Encoder = new C40Encoder();
        var encoders = [
          new ASCIIEncoder(),
          c40Encoder,
          new TextEncoder2(),
          new X12Encoder(),
          new EdifactEncoder(),
          new Base256Encoder()
        ];
        var context = new EncoderContext(msg);
        context.setSymbolShape(shape);
        context.setSizeConstraints(minSize, maxSize);
        if (msg.startsWith(MACRO_05_HEADER) && msg.endsWith(MACRO_TRAILER)) {
          context.writeCodeword(MACRO_05);
          context.setSkipAtEnd(2);
          context.pos += MACRO_05_HEADER.length;
        } else if (msg.startsWith(MACRO_06_HEADER) && msg.endsWith(MACRO_TRAILER)) {
          context.writeCodeword(MACRO_06);
          context.setSkipAtEnd(2);
          context.pos += MACRO_06_HEADER.length;
        }
        var encodingMode = ASCII_ENCODATION;
        if (forceC40) {
          c40Encoder.encodeMaximal(context);
          encodingMode = context.getNewEncoding();
          context.resetEncoderSignal();
        }
        while (context.hasMoreCharacters()) {
          encoders[encodingMode].encode(context);
          if (context.getNewEncoding() >= 0) {
            encodingMode = context.getNewEncoding();
            context.resetEncoderSignal();
          }
        }
        var len = context.getCodewordCount();
        context.updateSymbolInfo();
        var capacity = context.getSymbolInfo().getDataCapacity();
        if (len < capacity && encodingMode !== ASCII_ENCODATION && encodingMode !== BASE256_ENCODATION && encodingMode !== EDIFACT_ENCODATION) {
          context.writeCodeword("\xFE");
        }
        var codewords = context.getCodewords();
        if (codewords.length() < capacity) {
          codewords.append(PAD);
        }
        while (codewords.length() < capacity) {
          codewords.append(this.randomize253State(codewords.length() + 1));
        }
        return context.getCodewords().toString();
      };
      HighLevelEncoder3.lookAheadTest = function(msg, startpos, currentMode) {
        var newMode = this.lookAheadTestIntern(msg, startpos, currentMode);
        if (currentMode === X12_ENCODATION && newMode === X12_ENCODATION) {
          var endpos = Math.min(startpos + 3, msg.length);
          for (var i = startpos; i < endpos; i++) {
            if (!this.isNativeX12(msg.charCodeAt(i))) {
              return ASCII_ENCODATION;
            }
          }
        } else if (currentMode === EDIFACT_ENCODATION && newMode === EDIFACT_ENCODATION) {
          var endpos = Math.min(startpos + 4, msg.length);
          for (var i = startpos; i < endpos; i++) {
            if (!this.isNativeEDIFACT(msg.charCodeAt(i))) {
              return ASCII_ENCODATION;
            }
          }
        }
        return newMode;
      };
      HighLevelEncoder3.lookAheadTestIntern = function(msg, startpos, currentMode) {
        if (startpos >= msg.length) {
          return currentMode;
        }
        var charCounts;
        if (currentMode === ASCII_ENCODATION) {
          charCounts = [0, 1, 1, 1, 1, 1.25];
        } else {
          charCounts = [1, 2, 2, 2, 2, 2.25];
          charCounts[currentMode] = 0;
        }
        var charsProcessed = 0;
        var mins = new Uint8Array(6);
        var intCharCounts = [];
        while (true) {
          if (startpos + charsProcessed === msg.length) {
            Arrays_default.fill(mins, 0);
            Arrays_default.fill(intCharCounts, 0);
            var min2 = this.findMinimums(charCounts, intCharCounts, Integer_default.MAX_VALUE, mins);
            var minCount = this.getMinimumCount(mins);
            if (intCharCounts[ASCII_ENCODATION] === min2) {
              return ASCII_ENCODATION;
            }
            if (minCount === 1) {
              if (mins[BASE256_ENCODATION] > 0) {
                return BASE256_ENCODATION;
              }
              if (mins[EDIFACT_ENCODATION] > 0) {
                return EDIFACT_ENCODATION;
              }
              if (mins[TEXT_ENCODATION] > 0) {
                return TEXT_ENCODATION;
              }
              if (mins[X12_ENCODATION] > 0) {
                return X12_ENCODATION;
              }
            }
            return C40_ENCODATION;
          }
          var c = msg.charCodeAt(startpos + charsProcessed);
          charsProcessed++;
          if (this.isDigit(c)) {
            charCounts[ASCII_ENCODATION] += 0.5;
          } else if (this.isExtendedASCII(c)) {
            charCounts[ASCII_ENCODATION] = Math.ceil(charCounts[ASCII_ENCODATION]);
            charCounts[ASCII_ENCODATION] += 2;
          } else {
            charCounts[ASCII_ENCODATION] = Math.ceil(charCounts[ASCII_ENCODATION]);
            charCounts[ASCII_ENCODATION]++;
          }
          if (this.isNativeC40(c)) {
            charCounts[C40_ENCODATION] += 2 / 3;
          } else if (this.isExtendedASCII(c)) {
            charCounts[C40_ENCODATION] += 8 / 3;
          } else {
            charCounts[C40_ENCODATION] += 4 / 3;
          }
          if (this.isNativeText(c)) {
            charCounts[TEXT_ENCODATION] += 2 / 3;
          } else if (this.isExtendedASCII(c)) {
            charCounts[TEXT_ENCODATION] += 8 / 3;
          } else {
            charCounts[TEXT_ENCODATION] += 4 / 3;
          }
          if (this.isNativeX12(c)) {
            charCounts[X12_ENCODATION] += 2 / 3;
          } else if (this.isExtendedASCII(c)) {
            charCounts[X12_ENCODATION] += 13 / 3;
          } else {
            charCounts[X12_ENCODATION] += 10 / 3;
          }
          if (this.isNativeEDIFACT(c)) {
            charCounts[EDIFACT_ENCODATION] += 3 / 4;
          } else if (this.isExtendedASCII(c)) {
            charCounts[EDIFACT_ENCODATION] += 17 / 4;
          } else {
            charCounts[EDIFACT_ENCODATION] += 13 / 4;
          }
          if (this.isSpecialB256(c)) {
            charCounts[BASE256_ENCODATION] += 4;
          } else {
            charCounts[BASE256_ENCODATION]++;
          }
          if (charsProcessed >= 4) {
            Arrays_default.fill(mins, 0);
            Arrays_default.fill(intCharCounts, 0);
            this.findMinimums(charCounts, intCharCounts, Integer_default.MAX_VALUE, mins);
            if (intCharCounts[ASCII_ENCODATION] < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[EDIFACT_ENCODATION])) {
              return ASCII_ENCODATION;
            }
            if (intCharCounts[BASE256_ENCODATION] < intCharCounts[ASCII_ENCODATION] || intCharCounts[BASE256_ENCODATION] + 1 < this.min(intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[EDIFACT_ENCODATION])) {
              return BASE256_ENCODATION;
            }
            if (intCharCounts[EDIFACT_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[ASCII_ENCODATION])) {
              return EDIFACT_ENCODATION;
            }
            if (intCharCounts[TEXT_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[X12_ENCODATION], intCharCounts[ASCII_ENCODATION])) {
              return TEXT_ENCODATION;
            }
            if (intCharCounts[X12_ENCODATION] + 1 < this.min(intCharCounts[BASE256_ENCODATION], intCharCounts[C40_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[TEXT_ENCODATION], intCharCounts[ASCII_ENCODATION])) {
              return X12_ENCODATION;
            }
            if (intCharCounts[C40_ENCODATION] + 1 < this.min(intCharCounts[ASCII_ENCODATION], intCharCounts[BASE256_ENCODATION], intCharCounts[EDIFACT_ENCODATION], intCharCounts[TEXT_ENCODATION])) {
              if (intCharCounts[C40_ENCODATION] < intCharCounts[X12_ENCODATION]) {
                return C40_ENCODATION;
              }
              if (intCharCounts[C40_ENCODATION] === intCharCounts[X12_ENCODATION]) {
                var p = startpos + charsProcessed + 1;
                while (p < msg.length) {
                  var tc = msg.charCodeAt(p);
                  if (this.isX12TermSep(tc)) {
                    return X12_ENCODATION;
                  }
                  if (!this.isNativeX12(tc)) {
                    break;
                  }
                  p++;
                }
                return C40_ENCODATION;
              }
            }
          }
        }
      };
      HighLevelEncoder3.min = function(f1, f2, f3, f4, f5) {
        var val = Math.min(f1, Math.min(f2, Math.min(f3, f4)));
        if (f5 === void 0) {
          return val;
        } else {
          return Math.min(val, f5);
        }
      };
      HighLevelEncoder3.findMinimums = function(charCounts, intCharCounts, min2, mins) {
        for (var i = 0; i < 6; i++) {
          var current = intCharCounts[i] = Math.ceil(charCounts[i]);
          if (min2 > current) {
            min2 = current;
            Arrays_default.fill(mins, 0);
          }
          if (min2 === current) {
            mins[i] = mins[i] + 1;
          }
        }
        return min2;
      };
      HighLevelEncoder3.getMinimumCount = function(mins) {
        var minCount = 0;
        for (var i = 0; i < 6; i++) {
          minCount += mins[i];
        }
        return minCount || 0;
      };
      HighLevelEncoder3.isDigit = function(ch) {
        return ch >= "0".charCodeAt(0) && ch <= "9".charCodeAt(0);
      };
      HighLevelEncoder3.isExtendedASCII = function(ch) {
        return ch >= 128 && ch <= 255;
      };
      HighLevelEncoder3.isNativeC40 = function(ch) {
        return ch === " ".charCodeAt(0) || ch >= "0".charCodeAt(0) && ch <= "9".charCodeAt(0) || ch >= "A".charCodeAt(0) && ch <= "Z".charCodeAt(0);
      };
      HighLevelEncoder3.isNativeText = function(ch) {
        return ch === " ".charCodeAt(0) || ch >= "0".charCodeAt(0) && ch <= "9".charCodeAt(0) || ch >= "a".charCodeAt(0) && ch <= "z".charCodeAt(0);
      };
      HighLevelEncoder3.isNativeX12 = function(ch) {
        return this.isX12TermSep(ch) || ch === " ".charCodeAt(0) || ch >= "0".charCodeAt(0) && ch <= "9".charCodeAt(0) || ch >= "A".charCodeAt(0) && ch <= "Z".charCodeAt(0);
      };
      HighLevelEncoder3.isX12TermSep = function(ch) {
        return ch === 13 || // CR
        ch === "*".charCodeAt(0) || ch === ">".charCodeAt(0);
      };
      HighLevelEncoder3.isNativeEDIFACT = function(ch) {
        return ch >= " ".charCodeAt(0) && ch <= "^".charCodeAt(0);
      };
      HighLevelEncoder3.isSpecialB256 = function(ch) {
        return false;
      };
      HighLevelEncoder3.determineConsecutiveDigitCount = function(msg, startpos) {
        if (startpos === void 0) {
          startpos = 0;
        }
        var len = msg.length;
        var idx = startpos;
        while (idx < len && this.isDigit(msg.charCodeAt(idx))) {
          idx++;
        }
        return idx - startpos;
      };
      HighLevelEncoder3.illegalCharacter = function(singleCharacter) {
        var hex = Integer_default.toHexString(singleCharacter.charCodeAt(0));
        hex = "0000".substring(0, 4 - hex.length) + hex;
        throw new Error("Illegal character: " + singleCharacter + " (0x" + hex + ")");
      };
      return HighLevelEncoder3;
    }()
  );
  var HighLevelEncoder_default = HighLevelEncoder;

  // node_modules/@zxing/library/esm/core/common/ECIEncoderSet.js
  var __values42 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var CharsetEncoder = (
    /** @class */
    function() {
      function CharsetEncoder2(charset) {
        this.charset = charset;
        this.name = charset.name;
      }
      CharsetEncoder2.prototype.canEncode = function(c) {
        try {
          return StringEncoding_default.encode(c, this.charset) != null;
        } catch (ex) {
          return false;
        }
      };
      return CharsetEncoder2;
    }()
  );
  var ECIEncoderSet = (
    /** @class */
    function() {
      function ECIEncoderSet2(stringToEncode, priorityCharset, fnc1) {
        var e_1, _a2, e_2, _b, e_3, _c;
        this.ENCODERS = [
          "IBM437",
          "ISO-8859-2",
          "ISO-8859-3",
          "ISO-8859-4",
          "ISO-8859-5",
          "ISO-8859-6",
          "ISO-8859-7",
          "ISO-8859-8",
          "ISO-8859-9",
          "ISO-8859-10",
          "ISO-8859-11",
          "ISO-8859-13",
          "ISO-8859-14",
          "ISO-8859-15",
          "ISO-8859-16",
          "windows-1250",
          "windows-1251",
          "windows-1252",
          "windows-1256",
          "Shift_JIS"
        ].map(function(name) {
          return new CharsetEncoder(Charset_default.forName(name));
        });
        this.encoders = [];
        var neededEncoders = [];
        neededEncoders.push(new CharsetEncoder(StandardCharsets_default.ISO_8859_1));
        var needUnicodeEncoder = priorityCharset != null && priorityCharset.name.startsWith("UTF");
        for (var i = 0; i < stringToEncode.length; i++) {
          var canEncode = false;
          try {
            for (var neededEncoders_1 = (e_1 = void 0, __values42(neededEncoders)), neededEncoders_1_1 = neededEncoders_1.next(); !neededEncoders_1_1.done; neededEncoders_1_1 = neededEncoders_1.next()) {
              var encoder = neededEncoders_1_1.value;
              var singleCharacter = stringToEncode.charAt(i);
              var c = singleCharacter.charCodeAt(0);
              if (c === fnc1 || encoder.canEncode(singleCharacter)) {
                canEncode = true;
                break;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (neededEncoders_1_1 && !neededEncoders_1_1.done && (_a2 = neededEncoders_1.return)) _a2.call(neededEncoders_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (!canEncode) {
            try {
              for (var _d = (e_2 = void 0, __values42(this.ENCODERS)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var encoder = _e.value;
                if (encoder.canEncode(stringToEncode.charAt(i))) {
                  neededEncoders.push(encoder);
                  canEncode = true;
                  break;
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
          if (!canEncode) {
            needUnicodeEncoder = true;
          }
        }
        if (neededEncoders.length === 1 && !needUnicodeEncoder) {
          this.encoders = [neededEncoders[0]];
        } else {
          this.encoders = [];
          var index = 0;
          try {
            for (var neededEncoders_2 = __values42(neededEncoders), neededEncoders_2_1 = neededEncoders_2.next(); !neededEncoders_2_1.done; neededEncoders_2_1 = neededEncoders_2.next()) {
              var encoder = neededEncoders_2_1.value;
              this.encoders[index++] = encoder;
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (neededEncoders_2_1 && !neededEncoders_2_1.done && (_c = neededEncoders_2.return)) _c.call(neededEncoders_2);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }
        var priorityEncoderIndexValue = -1;
        if (priorityCharset != null) {
          for (var i = 0; i < this.encoders.length; i++) {
            if (this.encoders[i] != null && priorityCharset.name === this.encoders[i].name) {
              priorityEncoderIndexValue = i;
              break;
            }
          }
        }
        this.priorityEncoderIndex = priorityEncoderIndexValue;
      }
      ECIEncoderSet2.prototype.length = function() {
        return this.encoders.length;
      };
      ECIEncoderSet2.prototype.getCharsetName = function(index) {
        if (!(index < this.length())) {
          throw new Error("index must be less than length");
        }
        return this.encoders[index].name;
      };
      ECIEncoderSet2.prototype.getCharset = function(index) {
        if (!(index < this.length())) {
          throw new Error("index must be less than length");
        }
        return this.encoders[index].charset;
      };
      ECIEncoderSet2.prototype.getECIValue = function(encoderIndex) {
        return this.encoders[encoderIndex].charset.getValueIdentifier();
      };
      ECIEncoderSet2.prototype.getPriorityEncoderIndex = function() {
        return this.priorityEncoderIndex;
      };
      ECIEncoderSet2.prototype.canEncode = function(c, encoderIndex) {
        if (!(encoderIndex < this.length())) {
          throw new Error("index must be less than length");
        }
        return true;
      };
      ECIEncoderSet2.prototype.encode = function(c, encoderIndex) {
        if (!(encoderIndex < this.length())) {
          throw new Error("index must be less than length");
        }
        return StringEncoding_default.encode(StringUtils_default.getCharAt(c), this.encoders[encoderIndex].name);
      };
      return ECIEncoderSet2;
    }()
  );

  // node_modules/@zxing/library/esm/core/common/MinimalECIInput.js
  var COST_PER_ECI = 3;
  var MinimalECIInput = (
    /** @class */
    function() {
      function MinimalECIInput2(stringToEncode, priorityCharset, fnc1) {
        this.fnc1 = fnc1;
        var encoderSet = new ECIEncoderSet(stringToEncode, priorityCharset, fnc1);
        if (encoderSet.length() === 1) {
          for (var i = 0; i < this.bytes.length; i++) {
            var c = stringToEncode.charAt(i).charCodeAt(0);
            this.bytes[i] = c === fnc1 ? 1e3 : c;
          }
        } else {
          this.bytes = this.encodeMinimally(stringToEncode, encoderSet, fnc1);
        }
      }
      MinimalECIInput2.prototype.getFNC1Character = function() {
        return this.fnc1;
      };
      MinimalECIInput2.prototype.length = function() {
        return this.bytes.length;
      };
      MinimalECIInput2.prototype.haveNCharacters = function(index, n) {
        if (index + n - 1 >= this.bytes.length) {
          return false;
        }
        for (var i = 0; i < n; i++) {
          if (this.isECI(index + i)) {
            return false;
          }
        }
        return true;
      };
      MinimalECIInput2.prototype.charAt = function(index) {
        if (index < 0 || index >= this.length()) {
          throw new Error("" + index);
        }
        if (this.isECI(index)) {
          throw new Error("value at " + index + " is not a character but an ECI");
        }
        return this.isFNC1(index) ? this.fnc1 : this.bytes[index];
      };
      MinimalECIInput2.prototype.subSequence = function(start3, end2) {
        if (start3 < 0 || start3 > end2 || end2 > this.length()) {
          throw new Error("" + start3);
        }
        var result = new StringBuilder_default();
        for (var i = start3; i < end2; i++) {
          if (this.isECI(i)) {
            throw new Error("value at " + i + " is not a character but an ECI");
          }
          result.append(this.charAt(i));
        }
        return result.toString();
      };
      MinimalECIInput2.prototype.isECI = function(index) {
        if (index < 0 || index >= this.length()) {
          throw new Error("" + index);
        }
        return this.bytes[index] > 255 && this.bytes[index] <= 999;
      };
      MinimalECIInput2.prototype.isFNC1 = function(index) {
        if (index < 0 || index >= this.length()) {
          throw new Error("" + index);
        }
        return this.bytes[index] === 1e3;
      };
      MinimalECIInput2.prototype.getECIValue = function(index) {
        if (index < 0 || index >= this.length()) {
          throw new Error("" + index);
        }
        if (!this.isECI(index)) {
          throw new Error("value at " + index + " is not an ECI but a character");
        }
        return this.bytes[index] - 256;
      };
      MinimalECIInput2.prototype.addEdge = function(edges, to, edge) {
        if (edges[to][edge.encoderIndex] == null || edges[to][edge.encoderIndex].cachedTotalSize > edge.cachedTotalSize) {
          edges[to][edge.encoderIndex] = edge;
        }
      };
      MinimalECIInput2.prototype.addEdges = function(stringToEncode, encoderSet, edges, from2, previous, fnc1) {
        var ch = stringToEncode.charAt(from2).charCodeAt(0);
        var start3 = 0;
        var end2 = encoderSet.length();
        if (encoderSet.getPriorityEncoderIndex() >= 0 && (ch === fnc1 || encoderSet.canEncode(ch, encoderSet.getPriorityEncoderIndex()))) {
          start3 = encoderSet.getPriorityEncoderIndex();
          end2 = start3 + 1;
        }
        for (var i = start3; i < end2; i++) {
          if (ch === fnc1 || encoderSet.canEncode(ch, i)) {
            this.addEdge(edges, from2 + 1, new InputEdge(ch, encoderSet, i, previous, fnc1));
          }
        }
      };
      MinimalECIInput2.prototype.encodeMinimally = function(stringToEncode, encoderSet, fnc1) {
        var inputLength = stringToEncode.length;
        var edges = new InputEdge[inputLength + 1][encoderSet.length()]();
        this.addEdges(stringToEncode, encoderSet, edges, 0, null, fnc1);
        for (var i = 1; i <= inputLength; i++) {
          for (var j = 0; j < encoderSet.length(); j++) {
            if (edges[i][j] != null && i < inputLength) {
              this.addEdges(stringToEncode, encoderSet, edges, i, edges[i][j], fnc1);
            }
          }
          for (var j = 0; j < encoderSet.length(); j++) {
            edges[i - 1][j] = null;
          }
        }
        var minimalJ = -1;
        var minimalSize = Integer_default.MAX_VALUE;
        for (var j = 0; j < encoderSet.length(); j++) {
          if (edges[inputLength][j] != null) {
            var edge = edges[inputLength][j];
            if (edge.cachedTotalSize < minimalSize) {
              minimalSize = edge.cachedTotalSize;
              minimalJ = j;
            }
          }
        }
        if (minimalJ < 0) {
          throw new Error('Failed to encode "' + stringToEncode + '"');
        }
        var intsAL = [];
        var current = edges[inputLength][minimalJ];
        while (current != null) {
          if (current.isFNC1()) {
            intsAL.unshift(1e3);
          } else {
            var bytes = encoderSet.encode(current.c, current.encoderIndex);
            for (var i = bytes.length - 1; i >= 0; i--) {
              intsAL.unshift(bytes[i] & 255);
            }
          }
          var previousEncoderIndex = current.previous === null ? 0 : current.previous.encoderIndex;
          if (previousEncoderIndex !== current.encoderIndex) {
            intsAL.unshift(256 + encoderSet.getECIValue(current.encoderIndex));
          }
          current = current.previous;
        }
        var ints = [];
        for (var i = 0; i < ints.length; i++) {
          ints[i] = intsAL[i];
        }
        return ints;
      };
      return MinimalECIInput2;
    }()
  );
  var InputEdge = (
    /** @class */
    function() {
      function InputEdge2(c, encoderSet, encoderIndex, previous, fnc1) {
        this.c = c;
        this.encoderSet = encoderSet;
        this.encoderIndex = encoderIndex;
        this.previous = previous;
        this.fnc1 = fnc1;
        this.c = c === fnc1 ? 1e3 : c;
        var size = this.isFNC1() ? 1 : encoderSet.encode(c, encoderIndex).length;
        var previousEncoderIndex = previous === null ? 0 : previous.encoderIndex;
        if (previousEncoderIndex !== encoderIndex) {
          size += COST_PER_ECI;
        }
        if (previous != null) {
          size += previous.cachedTotalSize;
        }
        this.cachedTotalSize = size;
      }
      InputEdge2.prototype.isFNC1 = function() {
        return this.c === 1e3;
      };
      return InputEdge2;
    }()
  );

  // node_modules/@zxing/library/esm/core/datamatrix/encoder/MinimalEncoder.js
  var __extends72 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values43 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spread = function() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read2(arguments[i]));
    return ar;
  };
  var Mode4;
  (function(Mode5) {
    Mode5[Mode5["ASCII"] = 0] = "ASCII";
    Mode5[Mode5["C40"] = 1] = "C40";
    Mode5[Mode5["TEXT"] = 2] = "TEXT";
    Mode5[Mode5["X12"] = 3] = "X12";
    Mode5[Mode5["EDF"] = 4] = "EDF";
    Mode5[Mode5["B256"] = 5] = "B256";
  })(Mode4 || (Mode4 = {}));
  var C40_SHIFT2_CHARS = [
    "!",
    '"',
    "#",
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "?",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_"
  ];
  var MinimalEncoder = (
    /** @class */
    function() {
      function MinimalEncoder2() {
      }
      MinimalEncoder2.isExtendedASCII = function(ch, fnc1) {
        return ch !== fnc1 && ch >= 128 && ch <= 255;
      };
      MinimalEncoder2.isInC40Shift1Set = function(ch) {
        return ch <= 31;
      };
      MinimalEncoder2.isInC40Shift2Set = function(ch, fnc1) {
        var e_1, _a2;
        try {
          for (var C40_SHIFT2_CHARS_1 = __values43(C40_SHIFT2_CHARS), C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next(); !C40_SHIFT2_CHARS_1_1.done; C40_SHIFT2_CHARS_1_1 = C40_SHIFT2_CHARS_1.next()) {
            var c40Shift2Char = C40_SHIFT2_CHARS_1_1.value;
            if (c40Shift2Char.charCodeAt(0) === ch) {
              return true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (C40_SHIFT2_CHARS_1_1 && !C40_SHIFT2_CHARS_1_1.done && (_a2 = C40_SHIFT2_CHARS_1.return)) _a2.call(C40_SHIFT2_CHARS_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return ch === fnc1;
      };
      MinimalEncoder2.isInTextShift1Set = function(ch) {
        return this.isInC40Shift1Set(ch);
      };
      MinimalEncoder2.isInTextShift2Set = function(ch, fnc1) {
        return this.isInC40Shift2Set(ch, fnc1);
      };
      MinimalEncoder2.encodeHighLevel = function(msg, priorityCharset, fnc1, shape) {
        if (priorityCharset === void 0) {
          priorityCharset = null;
        }
        if (fnc1 === void 0) {
          fnc1 = -1;
        }
        if (shape === void 0) {
          shape = 0;
        }
        var macroId = 0;
        if (msg.startsWith(MACRO_05_HEADER) && msg.endsWith(MACRO_TRAILER)) {
          macroId = 5;
          msg = msg.substring(MACRO_05_HEADER.length, msg.length - 2);
        } else if (msg.startsWith(MACRO_06_HEADER) && msg.endsWith(MACRO_TRAILER)) {
          macroId = 6;
          msg = msg.substring(MACRO_06_HEADER.length, msg.length - 2);
        }
        return decodeURIComponent(escape(String.fromCharCode.apply(String, __spread(this.encode(msg, priorityCharset, fnc1, shape, macroId)))));
      };
      MinimalEncoder2.encode = function(input, priorityCharset, fnc1, shape, macroId) {
        return this.encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();
      };
      MinimalEncoder2.addEdge = function(edges, edge) {
        var vertexIndex = edge.fromPosition + edge.characterLength;
        if (edges[vertexIndex][edge.getEndMode()] === null || edges[vertexIndex][edge.getEndMode()].cachedTotalSize > edge.cachedTotalSize) {
          edges[vertexIndex][edge.getEndMode()] = edge;
        }
      };
      MinimalEncoder2.getNumberOfC40Words = function(input, from2, c40, characterLength) {
        var thirdsCount = 0;
        for (var i = from2; i < input.length(); i++) {
          if (input.isECI(i)) {
            characterLength[0] = 0;
            return 0;
          }
          var ci = input.charAt(i);
          if (c40 && HighLevelEncoder_default.isNativeC40(ci) || !c40 && HighLevelEncoder_default.isNativeText(ci)) {
            thirdsCount++;
          } else if (!MinimalEncoder2.isExtendedASCII(ci, input.getFNC1Character())) {
            thirdsCount += 2;
          } else {
            var asciiValue = ci & 255;
            if (asciiValue >= 128 && (c40 && HighLevelEncoder_default.isNativeC40(asciiValue - 128) || !c40 && HighLevelEncoder_default.isNativeText(asciiValue - 128))) {
              thirdsCount += 3;
            } else {
              thirdsCount += 4;
            }
          }
          if (thirdsCount % 3 === 0 || (thirdsCount - 2) % 3 === 0 && i + 1 === input.length()) {
            characterLength[0] = i - from2 + 1;
            return Math.ceil(thirdsCount / 3);
          }
        }
        characterLength[0] = 0;
        return 0;
      };
      MinimalEncoder2.addEdges = function(input, edges, from2, previous) {
        var e_2, _a2;
        if (input.isECI(from2)) {
          this.addEdge(edges, new Edge(input, Mode4.ASCII, from2, 1, previous));
          return;
        }
        var ch = input.charAt(from2);
        if (previous === null || previous.getEndMode() !== Mode4.EDF) {
          if (HighLevelEncoder_default.isDigit(ch) && input.haveNCharacters(from2, 2) && HighLevelEncoder_default.isDigit(input.charAt(from2 + 1))) {
            this.addEdge(edges, new Edge(input, Mode4.ASCII, from2, 2, previous));
          } else {
            this.addEdge(edges, new Edge(input, Mode4.ASCII, from2, 1, previous));
          }
          var modes = [Mode4.C40, Mode4.TEXT];
          try {
            for (var modes_1 = __values43(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {
              var mode = modes_1_1.value;
              var characterLength = [];
              if (MinimalEncoder2.getNumberOfC40Words(input, from2, mode === Mode4.C40, characterLength) > 0) {
                this.addEdge(edges, new Edge(input, mode, from2, characterLength[0], previous));
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (modes_1_1 && !modes_1_1.done && (_a2 = modes_1.return)) _a2.call(modes_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          if (input.haveNCharacters(from2, 3) && HighLevelEncoder_default.isNativeX12(input.charAt(from2)) && HighLevelEncoder_default.isNativeX12(input.charAt(from2 + 1)) && HighLevelEncoder_default.isNativeX12(input.charAt(from2 + 2))) {
            this.addEdge(edges, new Edge(input, Mode4.X12, from2, 3, previous));
          }
          this.addEdge(edges, new Edge(input, Mode4.B256, from2, 1, previous));
        }
        var i;
        for (i = 0; i < 3; i++) {
          var pos = from2 + i;
          if (input.haveNCharacters(pos, 1) && HighLevelEncoder_default.isNativeEDIFACT(input.charAt(pos))) {
            this.addEdge(edges, new Edge(input, Mode4.EDF, from2, i + 1, previous));
          } else {
            break;
          }
        }
        if (i === 3 && input.haveNCharacters(from2, 4) && HighLevelEncoder_default.isNativeEDIFACT(input.charAt(from2 + 3))) {
          this.addEdge(edges, new Edge(input, Mode4.EDF, from2, 4, previous));
        }
      };
      MinimalEncoder2.encodeMinimally = function(input) {
        var inputLength = input.length();
        var edges = Array(inputLength + 1).fill(null).map(function() {
          return Array(6).fill(0);
        });
        this.addEdges(input, edges, 0, null);
        for (var i = 1; i <= inputLength; i++) {
          for (var j = 0; j < 6; j++) {
            if (edges[i][j] !== null && i < inputLength) {
              this.addEdges(input, edges, i, edges[i][j]);
            }
          }
          for (var j = 0; j < 6; j++) {
            edges[i - 1][j] = null;
          }
        }
        var minimalJ = -1;
        var minimalSize = Integer_default.MAX_VALUE;
        for (var j = 0; j < 6; j++) {
          if (edges[inputLength][j] !== null) {
            var edge = edges[inputLength][j];
            var size = j >= 1 && j <= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize;
            if (size < minimalSize) {
              minimalSize = size;
              minimalJ = j;
            }
          }
        }
        if (minimalJ < 0) {
          throw new Error('Failed to encode "' + input + '"');
        }
        return new Result2(edges[inputLength][minimalJ]);
      };
      return MinimalEncoder2;
    }()
  );
  var Result2 = (
    /** @class */
    function() {
      function Result3(solution) {
        var input = solution.input;
        var size = 0;
        var bytesAL = [];
        var randomizePostfixLength = [];
        var randomizeLengths = [];
        if ((solution.mode === Mode4.C40 || solution.mode === Mode4.TEXT || solution.mode === Mode4.X12) && solution.getEndMode() !== Mode4.ASCII) {
          size += this.prepend(Edge.getBytes(254), bytesAL);
        }
        var current = solution;
        while (current !== null) {
          size += this.prepend(current.getDataBytes(), bytesAL);
          if (current.previous === null || current.getPreviousStartMode() !== current.getMode()) {
            if (current.getMode() === Mode4.B256) {
              if (size <= 249) {
                bytesAL.unshift(size);
                size++;
              } else {
                bytesAL.unshift(size % 250);
                bytesAL.unshift(size / 250 + 249);
                size += 2;
              }
              randomizePostfixLength.push(bytesAL.length);
              randomizeLengths.push(size);
            }
            this.prepend(current.getLatchBytes(), bytesAL);
            size = 0;
          }
          current = current.previous;
        }
        if (input.getMacroId() === 5) {
          size += this.prepend(Edge.getBytes(236), bytesAL);
        } else if (input.getMacroId() === 6) {
          size += this.prepend(Edge.getBytes(237), bytesAL);
        }
        if (input.getFNC1Character() > 0) {
          size += this.prepend(Edge.getBytes(232), bytesAL);
        }
        for (var i = 0; i < randomizePostfixLength.length; i++) {
          this.applyRandomPattern(bytesAL, bytesAL.length - randomizePostfixLength[i], randomizeLengths[i]);
        }
        var capacity = solution.getMinSymbolSize(bytesAL.length);
        if (bytesAL.length < capacity) {
          bytesAL.push(129);
        }
        while (bytesAL.length < capacity) {
          bytesAL.push(this.randomize253State(bytesAL.length + 1));
        }
        this.bytes = new Uint8Array(bytesAL.length);
        for (var i = 0; i < this.bytes.length; i++) {
          this.bytes[i] = bytesAL[i];
        }
      }
      Result3.prototype.prepend = function(bytes, into) {
        for (var i = bytes.length - 1; i >= 0; i--) {
          into.unshift(bytes[i]);
        }
        return bytes.length;
      };
      Result3.prototype.randomize253State = function(codewordPosition) {
        var pseudoRandom = 149 * codewordPosition % 253 + 1;
        var tempVariable = 129 + pseudoRandom;
        return tempVariable <= 254 ? tempVariable : tempVariable - 254;
      };
      Result3.prototype.applyRandomPattern = function(bytesAL, startPosition, length) {
        for (var i = 0; i < length; i++) {
          var Pad_codeword_position = startPosition + i;
          var Pad_codeword_value = bytesAL[Pad_codeword_position] & 255;
          var pseudo_random_number = 149 * (Pad_codeword_position + 1) % 255 + 1;
          var temp_variable = Pad_codeword_value + pseudo_random_number;
          bytesAL[Pad_codeword_position] = temp_variable <= 255 ? temp_variable : temp_variable - 256;
        }
      };
      Result3.prototype.getBytes = function() {
        return this.bytes;
      };
      return Result3;
    }()
  );
  var Edge = (
    /** @class */
    function() {
      function Edge2(input, mode, fromPosition, characterLength, previous) {
        this.input = input;
        this.mode = mode;
        this.fromPosition = fromPosition;
        this.characterLength = characterLength;
        this.previous = previous;
        this.allCodewordCapacities = [
          3,
          5,
          8,
          10,
          12,
          16,
          18,
          22,
          30,
          32,
          36,
          44,
          49,
          62,
          86,
          114,
          144,
          174,
          204,
          280,
          368,
          456,
          576,
          696,
          816,
          1050,
          1304,
          1558
        ];
        this.squareCodewordCapacities = [
          3,
          5,
          8,
          12,
          18,
          22,
          30,
          36,
          44,
          62,
          86,
          114,
          144,
          174,
          204,
          280,
          368,
          456,
          576,
          696,
          816,
          1050,
          1304,
          1558
        ];
        this.rectangularCodewordCapacities = [5, 10, 16, 33, 32, 49];
        if (!(fromPosition + characterLength <= input.length())) {
          throw new Error("Invalid edge");
        }
        var size = previous !== null ? previous.cachedTotalSize : 0;
        var previousMode = this.getPreviousMode();
        switch (mode) {
          case Mode4.ASCII:
            size++;
            if (input.isECI(fromPosition) || MinimalEncoder.isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {
              size++;
            }
            if (previousMode === Mode4.C40 || previousMode === Mode4.TEXT || previousMode === Mode4.X12) {
              size++;
            }
            break;
          case Mode4.B256:
            size++;
            if (previousMode !== Mode4.B256) {
              size++;
            } else if (this.getB256Size() === 250) {
              size++;
            }
            if (previousMode === Mode4.ASCII) {
              size++;
            } else if (previousMode === Mode4.C40 || previousMode === Mode4.TEXT || previousMode === Mode4.X12) {
              size += 2;
            }
            break;
          case Mode4.C40:
          case Mode4.TEXT:
          case Mode4.X12:
            if (mode === Mode4.X12) {
              size += 2;
            } else {
              var charLen = [];
              size += MinimalEncoder.getNumberOfC40Words(input, fromPosition, mode === Mode4.C40, charLen) * 2;
            }
            if (previousMode === Mode4.ASCII || previousMode === Mode4.B256) {
              size++;
            } else if (previousMode !== mode && (previousMode === Mode4.C40 || previousMode === Mode4.TEXT || previousMode === Mode4.X12)) {
              size += 2;
            }
            break;
          case Mode4.EDF:
            size += 3;
            if (previousMode === Mode4.ASCII || previousMode === Mode4.B256) {
              size++;
            } else if (previousMode === Mode4.C40 || previousMode === Mode4.TEXT || previousMode === Mode4.X12) {
              size += 2;
            }
            break;
        }
        this.cachedTotalSize = size;
      }
      Edge2.prototype.getB256Size = function() {
        var cnt = 0;
        var current = this;
        while (current !== null && current.mode === Mode4.B256 && cnt <= 250) {
          cnt++;
          current = current.previous;
        }
        return cnt;
      };
      Edge2.prototype.getPreviousStartMode = function() {
        return this.previous === null ? Mode4.ASCII : this.previous.mode;
      };
      Edge2.prototype.getPreviousMode = function() {
        return this.previous === null ? Mode4.ASCII : this.previous.getEndMode();
      };
      Edge2.prototype.getEndMode = function() {
        if (this.mode === Mode4.EDF) {
          if (this.characterLength < 4) {
            return Mode4.ASCII;
          }
          var lastASCII = this.getLastASCII();
          if (lastASCII > 0 && this.getCodewordsRemaining(this.cachedTotalSize + lastASCII) <= 2 - lastASCII) {
            return Mode4.ASCII;
          }
        }
        if (this.mode === Mode4.C40 || this.mode === Mode4.TEXT || this.mode === Mode4.X12) {
          if (this.fromPosition + this.characterLength >= this.input.length() && this.getCodewordsRemaining(this.cachedTotalSize) === 0) {
            return Mode4.ASCII;
          }
          var lastASCII = this.getLastASCII();
          if (lastASCII === 1 && this.getCodewordsRemaining(this.cachedTotalSize + 1) === 0) {
            return Mode4.ASCII;
          }
        }
        return this.mode;
      };
      Edge2.prototype.getMode = function() {
        return this.mode;
      };
      Edge2.prototype.getLastASCII = function() {
        var length = this.input.length();
        var from2 = this.fromPosition + this.characterLength;
        if (length - from2 > 4 || from2 >= length) {
          return 0;
        }
        if (length - from2 === 1) {
          if (MinimalEncoder.isExtendedASCII(this.input.charAt(from2), this.input.getFNC1Character())) {
            return 0;
          }
          return 1;
        }
        if (length - from2 === 2) {
          if (MinimalEncoder.isExtendedASCII(this.input.charAt(from2), this.input.getFNC1Character()) || MinimalEncoder.isExtendedASCII(this.input.charAt(from2 + 1), this.input.getFNC1Character())) {
            return 0;
          }
          if (HighLevelEncoder_default.isDigit(this.input.charAt(from2)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 1))) {
            return 1;
          }
          return 2;
        }
        if (length - from2 === 3) {
          if (HighLevelEncoder_default.isDigit(this.input.charAt(from2)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 1)) && !MinimalEncoder.isExtendedASCII(this.input.charAt(from2 + 2), this.input.getFNC1Character())) {
            return 2;
          }
          if (HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 1)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 2)) && !MinimalEncoder.isExtendedASCII(this.input.charAt(from2), this.input.getFNC1Character())) {
            return 2;
          }
          return 0;
        }
        if (HighLevelEncoder_default.isDigit(this.input.charAt(from2)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 1)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 2)) && HighLevelEncoder_default.isDigit(this.input.charAt(from2 + 3))) {
          return 2;
        }
        return 0;
      };
      Edge2.prototype.getMinSymbolSize = function(minimum) {
        var e_3, _a2, e_4, _b, e_5, _c;
        switch (this.input.getShapeHint()) {
          case 1:
            try {
              for (var _d = __values43(this.squareCodewordCapacities), _e = _d.next(); !_e.done; _e = _d.next()) {
                var capacity = _e.value;
                if (capacity >= minimum) {
                  return capacity;
                }
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (_e && !_e.done && (_a2 = _d.return)) _a2.call(_d);
              } finally {
                if (e_3) throw e_3.error;
              }
            }
            break;
          case 2:
            try {
              for (var _f = __values43(this.rectangularCodewordCapacities), _g = _f.next(); !_g.done; _g = _f.next()) {
                var capacity = _g.value;
                if (capacity >= minimum) {
                  return capacity;
                }
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
            break;
        }
        try {
          for (var _h = __values43(this.allCodewordCapacities), _j = _h.next(); !_j.done; _j = _h.next()) {
            var capacity = _j.value;
            if (capacity >= minimum) {
              return capacity;
            }
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
          } finally {
            if (e_5) throw e_5.error;
          }
        }
        return this.allCodewordCapacities[this.allCodewordCapacities.length - 1];
      };
      Edge2.prototype.getCodewordsRemaining = function(minimum) {
        return this.getMinSymbolSize(minimum) - minimum;
      };
      Edge2.getBytes = function(c1, c2) {
        var result = new Uint8Array(c2 ? 2 : 1);
        result[0] = c1;
        if (c2) {
          result[1] = c2;
        }
        return result;
      };
      Edge2.prototype.setC40Word = function(bytes, offset2, c1, c2, c3) {
        var val16 = 1600 * (c1 & 255) + 40 * (c2 & 255) + (c3 & 255) + 1;
        bytes[offset2] = val16 / 256;
        bytes[offset2 + 1] = val16 % 256;
      };
      Edge2.prototype.getX12Value = function(c) {
        return c === 13 ? 0 : c === 42 ? 1 : c === 62 ? 2 : c === 32 ? 3 : c >= 48 && c <= 57 ? c - 44 : c >= 65 && c <= 90 ? c - 51 : c;
      };
      Edge2.prototype.getX12Words = function() {
        if (!(this.characterLength % 3 === 0)) {
          throw new Error("X12 words must be a multiple of 3");
        }
        var result = new Uint8Array(this.characterLength / 3 * 2);
        for (var i = 0; i < result.length; i += 2) {
          this.setC40Word(result, i, this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3)), this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3 + 1)), this.getX12Value(this.input.charAt(this.fromPosition + i / 2 * 3 + 2)));
        }
        return result;
      };
      Edge2.prototype.getShiftValue = function(c, c40, fnc1) {
        return c40 && MinimalEncoder.isInC40Shift1Set(c) || !c40 && MinimalEncoder.isInTextShift1Set(c) ? 0 : c40 && MinimalEncoder.isInC40Shift2Set(c, fnc1) || !c40 && MinimalEncoder.isInTextShift2Set(c, fnc1) ? 1 : 2;
      };
      Edge2.prototype.getC40Value = function(c40, setIndex, c, fnc1) {
        if (c === fnc1) {
          if (!(setIndex === 2)) {
            throw new Error("FNC1 cannot be used in C40 shift 2");
          }
          return 27;
        }
        if (c40) {
          return c <= 31 ? c : c === 32 ? 3 : c <= 47 ? c - 33 : c <= 57 ? c - 44 : c <= 64 ? c - 43 : c <= 90 ? c - 51 : c <= 95 ? c - 69 : c <= 127 ? c - 96 : c;
        } else {
          return c === 0 ? 0 : setIndex === 0 && c <= 3 ? c - 1 : setIndex === 1 && c <= 31 ? c : c === 32 ? 3 : c >= 33 && c <= 47 ? c - 33 : c >= 48 && c <= 57 ? c - 44 : c >= 58 && c <= 64 ? c - 43 : c >= 65 && c <= 90 ? c - 64 : c >= 91 && c <= 95 ? c - 69 : c === 96 ? 0 : c >= 97 && c <= 122 ? c - 83 : c >= 123 && c <= 127 ? c - 96 : c;
        }
      };
      Edge2.prototype.getC40Words = function(c40, fnc1) {
        var c40Values = [];
        for (var i = 0; i < this.characterLength; i++) {
          var ci = this.input.charAt(this.fromPosition + i);
          if (c40 && HighLevelEncoder_default.isNativeC40(ci) || !c40 && HighLevelEncoder_default.isNativeText(ci)) {
            c40Values.push(this.getC40Value(c40, 0, ci, fnc1));
          } else if (!MinimalEncoder.isExtendedASCII(ci, fnc1)) {
            var shiftValue = this.getShiftValue(ci, c40, fnc1);
            c40Values.push(shiftValue);
            c40Values.push(this.getC40Value(c40, shiftValue, ci, fnc1));
          } else {
            var asciiValue = (ci & 255) - 128;
            if (c40 && HighLevelEncoder_default.isNativeC40(asciiValue) || !c40 && HighLevelEncoder_default.isNativeText(asciiValue)) {
              c40Values.push(1);
              c40Values.push(30);
              c40Values.push(this.getC40Value(c40, 0, asciiValue, fnc1));
            } else {
              c40Values.push(1);
              c40Values.push(30);
              var shiftValue = this.getShiftValue(asciiValue, c40, fnc1);
              c40Values.push(shiftValue);
              c40Values.push(this.getC40Value(c40, shiftValue, asciiValue, fnc1));
            }
          }
        }
        if (c40Values.length % 3 !== 0) {
          if (!((c40Values.length - 2) % 3 === 0 && this.fromPosition + this.characterLength === this.input.length())) {
            throw new Error("C40 words must be a multiple of 3");
          }
          c40Values.push(0);
        }
        var result = new Uint8Array(c40Values.length / 3 * 2);
        var byteIndex = 0;
        for (var i = 0; i < c40Values.length; i += 3) {
          this.setC40Word(result, byteIndex, c40Values[i] & 255, c40Values[i + 1] & 255, c40Values[i + 2] & 255);
          byteIndex += 2;
        }
        return result;
      };
      Edge2.prototype.getEDFBytes = function() {
        var numberOfThirds = Math.ceil(this.characterLength / 4);
        var result = new Uint8Array(numberOfThirds * 3);
        var pos = this.fromPosition;
        var endPos = Math.min(this.fromPosition + this.characterLength - 1, this.input.length() - 1);
        for (var i = 0; i < numberOfThirds; i += 3) {
          var edfValues = [];
          for (var j = 0; j < 4; j++) {
            if (pos <= endPos) {
              edfValues[j] = this.input.charAt(pos++) & 63;
            } else {
              edfValues[j] = pos === endPos + 1 ? 31 : 0;
            }
          }
          var val24 = edfValues[0] << 18;
          val24 |= edfValues[1] << 12;
          val24 |= edfValues[2] << 6;
          val24 |= edfValues[3];
          result[i] = val24 >> 16 & 255;
          result[i + 1] = val24 >> 8 & 255;
          result[i + 2] = val24 & 255;
        }
        return result;
      };
      Edge2.prototype.getLatchBytes = function() {
        switch (this.getPreviousMode()) {
          case Mode4.ASCII:
          case Mode4.B256:
            switch (this.mode) {
              case Mode4.B256:
                return Edge2.getBytes(231);
              case Mode4.C40:
                return Edge2.getBytes(230);
              case Mode4.TEXT:
                return Edge2.getBytes(239);
              case Mode4.X12:
                return Edge2.getBytes(238);
              case Mode4.EDF:
                return Edge2.getBytes(240);
            }
            break;
          case Mode4.C40:
          case Mode4.TEXT:
          case Mode4.X12:
            if (this.mode !== this.getPreviousMode()) {
              switch (this.mode) {
                case Mode4.ASCII:
                  return Edge2.getBytes(254);
                case Mode4.B256:
                  return Edge2.getBytes(254, 231);
                case Mode4.C40:
                  return Edge2.getBytes(254, 230);
                case Mode4.TEXT:
                  return Edge2.getBytes(254, 239);
                case Mode4.X12:
                  return Edge2.getBytes(254, 238);
                case Mode4.EDF:
                  return Edge2.getBytes(254, 240);
              }
            }
            break;
          case Mode4.EDF:
            if (this.mode !== Mode4.EDF) {
              throw new Error("Cannot switch from EDF to " + this.mode);
            }
            break;
        }
        return new Uint8Array(0);
      };
      Edge2.prototype.getDataBytes = function() {
        switch (this.mode) {
          case Mode4.ASCII:
            if (this.input.isECI(this.fromPosition)) {
              return Edge2.getBytes(241, this.input.getECIValue(this.fromPosition) + 1);
            } else if (MinimalEncoder.isExtendedASCII(this.input.charAt(this.fromPosition), this.input.getFNC1Character())) {
              return Edge2.getBytes(235, this.input.charAt(this.fromPosition) - 127);
            } else if (this.characterLength === 2) {
              return Edge2.getBytes(this.input.charAt(this.fromPosition) * 10 + this.input.charAt(this.fromPosition + 1) + 130);
            } else if (this.input.isFNC1(this.fromPosition)) {
              return Edge2.getBytes(232);
            } else {
              return Edge2.getBytes(this.input.charAt(this.fromPosition) + 1);
            }
          case Mode4.B256:
            return Edge2.getBytes(this.input.charAt(this.fromPosition));
          case Mode4.C40:
            return this.getC40Words(true, this.input.getFNC1Character());
          case Mode4.TEXT:
            return this.getC40Words(false, this.input.getFNC1Character());
          case Mode4.X12:
            return this.getX12Words();
          case Mode4.EDF:
            return this.getEDFBytes();
        }
      };
      return Edge2;
    }()
  );
  var Input = (
    /** @class */
    function(_super) {
      __extends72(Input2, _super);
      function Input2(stringToEncode, priorityCharset, fnc1, shape, macroId) {
        var _this = _super.call(this, stringToEncode, priorityCharset, fnc1) || this;
        _this.shape = shape;
        _this.macroId = macroId;
        return _this;
      }
      Input2.prototype.getMacroId = function() {
        return this.macroId;
      };
      Input2.prototype.getShapeHint = function() {
        return this.shape;
      };
      return Input2;
    }(MinimalECIInput)
  );

  // node_modules/@zxing/library/esm/core/datamatrix/DataMatrixWriter.js
  var DataMatrixWriter = (
    /** @class */
    function() {
      function DataMatrixWriter2() {
      }
      DataMatrixWriter2.prototype.encode = function(contents, format, width, height, hints) {
        if (hints === void 0) {
          hints = null;
        }
        if (contents.trim() === "") {
          throw new Error("Found empty contents");
        }
        if (format !== BarcodeFormat_default.DATA_MATRIX) {
          throw new Error("Can only encode DATA_MATRIX, but got " + format);
        }
        if (width < 0 || height < 0) {
          throw new Error("Requested dimensions can't be negative: " + width + "x" + height);
        }
        var shape = 0;
        var minSize = null;
        var maxSize = null;
        if (hints != null) {
          var requestedShape = hints.get(EncodeHintType_default.DATA_MATRIX_SHAPE);
          if (requestedShape != null) {
            shape = requestedShape;
          }
          var requestedMinSize = hints.get(EncodeHintType_default.MIN_SIZE);
          if (requestedMinSize != null) {
            minSize = requestedMinSize;
          }
          var requestedMaxSize = hints.get(EncodeHintType_default.MAX_SIZE);
          if (requestedMaxSize != null) {
            maxSize = requestedMaxSize;
          }
        }
        var encoded;
        var hasCompactionHint = hints != null && hints.has(EncodeHintType_default.DATA_MATRIX_COMPACT) && Boolean(hints.get(EncodeHintType_default.DATA_MATRIX_COMPACT).toString());
        if (hasCompactionHint) {
          var hasGS1FormatHint = hints.has(EncodeHintType_default.GS1_FORMAT) && Boolean(hints.get(EncodeHintType_default.GS1_FORMAT).toString());
          var charset = null;
          var hasEncodingHint = hints.has(EncodeHintType_default.CHARACTER_SET);
          if (hasEncodingHint) {
            charset = Charset_default.forName(hints.get(EncodeHintType_default.CHARACTER_SET).toString());
          }
          encoded = MinimalEncoder.encodeHighLevel(contents, charset, hasGS1FormatHint ? 29 : -1, shape);
        } else {
          var hasForceC40Hint = hints != null && hints.has(EncodeHintType_default.FORCE_C40) && Boolean(hints.get(EncodeHintType_default.FORCE_C40).toString());
          encoded = HighLevelEncoder_default.encodeHighLevel(contents, shape, minSize, maxSize, hasForceC40Hint);
        }
        var symbolInfo = SymbolInfo_default.lookup(encoded.length, shape, minSize, maxSize, true);
        var codewords = ErrorCorrection_default2.encodeECC200(encoded, symbolInfo);
        var placement = new DefaultPlacement_default(codewords, symbolInfo.getSymbolDataWidth(), symbolInfo.getSymbolDataHeight());
        placement.place();
        return this.encodeLowLevel(placement, symbolInfo, width, height);
      };
      DataMatrixWriter2.prototype.encodeLowLevel = function(placement, symbolInfo, width, height) {
        var symbolWidth = symbolInfo.getSymbolDataWidth();
        var symbolHeight = symbolInfo.getSymbolDataHeight();
        var matrix = new ByteMatrix_default(symbolInfo.getSymbolWidth(), symbolInfo.getSymbolHeight());
        var matrixY = 0;
        for (var y = 0; y < symbolHeight; y++) {
          var matrixX = void 0;
          if (y % symbolInfo.matrixHeight === 0) {
            matrixX = 0;
            for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {
              matrix.setBoolean(matrixX, matrixY, x % 2 === 0);
              matrixX++;
            }
            matrixY++;
          }
          matrixX = 0;
          for (var x = 0; x < symbolWidth; x++) {
            if (x % symbolInfo.matrixWidth === 0) {
              matrix.setBoolean(matrixX, matrixY, true);
              matrixX++;
            }
            matrix.setBoolean(matrixX, matrixY, placement.getBit(x, y));
            matrixX++;
            if (x % symbolInfo.matrixWidth === symbolInfo.matrixWidth - 1) {
              matrix.setBoolean(matrixX, matrixY, y % 2 === 0);
              matrixX++;
            }
          }
          matrixY++;
          if (y % symbolInfo.matrixHeight === symbolInfo.matrixHeight - 1) {
            matrixX = 0;
            for (var x = 0; x < symbolInfo.getSymbolWidth(); x++) {
              matrix.setBoolean(matrixX, matrixY, true);
              matrixX++;
            }
            matrixY++;
          }
        }
        return this.convertByteMatrixToBitMatrix(matrix, width, height);
      };
      DataMatrixWriter2.prototype.convertByteMatrixToBitMatrix = function(matrix, reqWidth, reqHeight) {
        var matrixWidth = matrix.getWidth();
        var matrixHeight = matrix.getHeight();
        var outputWidth = Math.max(reqWidth, matrixWidth);
        var outputHeight = Math.max(reqHeight, matrixHeight);
        var multiple = Math.min(outputWidth / matrixWidth, outputHeight / matrixHeight);
        var leftPadding = (outputWidth - matrixWidth * multiple) / 2;
        var topPadding = (outputHeight - matrixHeight * multiple) / 2;
        var output;
        if (reqHeight < matrixHeight || reqWidth < matrixWidth) {
          leftPadding = 0;
          topPadding = 0;
          output = new BitMatrix_default(matrixWidth, matrixHeight);
        } else {
          output = new BitMatrix_default(reqWidth, reqHeight);
        }
        output.clear();
        for (var inputY = 0, outputY = topPadding; inputY < matrixHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < matrixWidth; inputX++, outputX += multiple) {
            if (matrix.get(inputX, inputY) === 1) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      };
      return DataMatrixWriter2;
    }()
  );

  // node_modules/@zxing/library/esm/core/aztec/encoder/AztecCode.js
  var AztecCode = (
    /** @class */
    function() {
      function AztecCode2() {
      }
      AztecCode2.prototype.isCompact = function() {
        return this.compact;
      };
      AztecCode2.prototype.setCompact = function(compact) {
        this.compact = compact;
      };
      AztecCode2.prototype.getSize = function() {
        return this.size;
      };
      AztecCode2.prototype.setSize = function(size) {
        this.size = size;
      };
      AztecCode2.prototype.getLayers = function() {
        return this.layers;
      };
      AztecCode2.prototype.setLayers = function(layers) {
        this.layers = layers;
      };
      AztecCode2.prototype.getCodeWords = function() {
        return this.codeWords;
      };
      AztecCode2.prototype.setCodeWords = function(codeWords) {
        this.codeWords = codeWords;
      };
      AztecCode2.prototype.getMatrix = function() {
        return this.matrix;
      };
      AztecCode2.prototype.setMatrix = function(matrix) {
        this.matrix = matrix;
      };
      return AztecCode2;
    }()
  );
  var AztecCode_default = AztecCode;

  // node_modules/@zxing/library/esm/core/util/Collections.js
  var Collections = (
    /** @class */
    function() {
      function Collections2() {
      }
      Collections2.singletonList = function(item) {
        return [item];
      };
      Collections2.min = function(collection, comparator) {
        return collection.sort(comparator)[0];
      };
      return Collections2;
    }()
  );
  var Collections_default = Collections;

  // node_modules/@zxing/library/esm/core/aztec/encoder/Token.js
  var Token = (
    /** @class */
    function() {
      function Token2(previous) {
        this.previous = previous;
      }
      Token2.prototype.getPrevious = function() {
        return this.previous;
      };
      return Token2;
    }()
  );
  var Token_default = Token;

  // node_modules/@zxing/library/esm/core/aztec/encoder/SimpleToken.js
  var __extends73 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var SimpleToken = (
    /** @class */
    function(_super) {
      __extends73(SimpleToken2, _super);
      function SimpleToken2(previous, value, bitCount) {
        var _this = _super.call(this, previous) || this;
        _this.value = value;
        _this.bitCount = bitCount;
        return _this;
      }
      SimpleToken2.prototype.appendTo = function(bitArray, text) {
        bitArray.appendBits(this.value, this.bitCount);
      };
      SimpleToken2.prototype.add = function(value, bitCount) {
        return new SimpleToken2(this, value, bitCount);
      };
      SimpleToken2.prototype.addBinaryShift = function(start3, byteCount) {
        console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
        return new SimpleToken2(this, start3, byteCount);
      };
      SimpleToken2.prototype.toString = function() {
        var value = this.value & (1 << this.bitCount) - 1;
        value |= 1 << this.bitCount;
        return "<" + Integer_default.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
      };
      return SimpleToken2;
    }(Token_default)
  );
  var SimpleToken_default = SimpleToken;

  // node_modules/@zxing/library/esm/core/aztec/encoder/BinaryShiftToken.js
  var __extends74 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BinaryShiftToken = (
    /** @class */
    function(_super) {
      __extends74(BinaryShiftToken2, _super);
      function BinaryShiftToken2(previous, binaryShiftStart, binaryShiftByteCount) {
        var _this = _super.call(this, previous, 0, 0) || this;
        _this.binaryShiftStart = binaryShiftStart;
        _this.binaryShiftByteCount = binaryShiftByteCount;
        return _this;
      }
      BinaryShiftToken2.prototype.appendTo = function(bitArray, text) {
        for (var i = 0; i < this.binaryShiftByteCount; i++) {
          if (i === 0 || i === 31 && this.binaryShiftByteCount <= 62) {
            bitArray.appendBits(31, 5);
            if (this.binaryShiftByteCount > 62) {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
            } else if (i === 0) {
              bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
            } else {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
            }
          }
          bitArray.appendBits(text[this.binaryShiftStart + i], 8);
        }
      };
      BinaryShiftToken2.prototype.addBinaryShift = function(start3, byteCount) {
        return new BinaryShiftToken2(this, start3, byteCount);
      };
      BinaryShiftToken2.prototype.toString = function() {
        return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
      };
      return BinaryShiftToken2;
    }(SimpleToken_default)
  );
  var BinaryShiftToken_default = BinaryShiftToken;

  // node_modules/@zxing/library/esm/core/aztec/encoder/TokenHelpers.js
  function addBinaryShift(token, start3, byteCount) {
    return new BinaryShiftToken_default(token, start3, byteCount);
  }
  function add2(token, value, bitCount) {
    return new SimpleToken_default(token, value, bitCount);
  }

  // node_modules/@zxing/library/esm/core/aztec/encoder/EncoderConstants.js
  var MODE_NAMES = [
    "UPPER",
    "LOWER",
    "DIGIT",
    "MIXED",
    "PUNCT"
  ];
  var MODE_UPPER = 0;
  var MODE_LOWER = 1;
  var MODE_DIGIT = 2;
  var MODE_MIXED = 3;
  var MODE_PUNCT = 4;
  var EMPTY_TOKEN = new SimpleToken_default(null, 0, 0);

  // node_modules/@zxing/library/esm/core/aztec/encoder/LatchTable.js
  var LATCH_TABLE = [
    Int32Array.from([
      0,
      (5 << 16) + 28,
      (5 << 16) + 30,
      (5 << 16) + 29,
      (10 << 16) + (29 << 5) + 30
      // UPPER -> MIXED -> PUNCT
    ]),
    Int32Array.from([
      (9 << 16) + (30 << 4) + 14,
      0,
      (5 << 16) + 30,
      (5 << 16) + 29,
      (10 << 16) + (29 << 5) + 30
      // LOWER -> MIXED -> PUNCT
    ]),
    Int32Array.from([
      (4 << 16) + 14,
      (9 << 16) + (14 << 5) + 28,
      0,
      (9 << 16) + (14 << 5) + 29,
      (14 << 16) + (14 << 10) + (29 << 5) + 30
      // DIGIT -> UPPER -> MIXED -> PUNCT
    ]),
    Int32Array.from([
      (5 << 16) + 29,
      (5 << 16) + 28,
      (10 << 16) + (29 << 5) + 30,
      0,
      (5 << 16) + 30
      // MIXED -> PUNCT
    ]),
    Int32Array.from([
      (5 << 16) + 31,
      (10 << 16) + (31 << 5) + 28,
      (10 << 16) + (31 << 5) + 30,
      (10 << 16) + (31 << 5) + 29,
      0
    ])
  ];

  // node_modules/@zxing/library/esm/core/aztec/encoder/ShiftTable.js
  var __values44 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  function static_SHIFT_TABLE(SHIFT_TABLE2) {
    var e_1, _a2;
    try {
      for (var SHIFT_TABLE_1 = __values44(SHIFT_TABLE2), SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next(); !SHIFT_TABLE_1_1.done; SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next()) {
        var table = SHIFT_TABLE_1_1.value;
        Arrays_default.fill(table, -1);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (SHIFT_TABLE_1_1 && !SHIFT_TABLE_1_1.done && (_a2 = SHIFT_TABLE_1.return)) _a2.call(SHIFT_TABLE_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
    SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
    SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
    SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
    SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
    SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
    return SHIFT_TABLE2;
  }
  var SHIFT_TABLE = static_SHIFT_TABLE(Arrays_default.createInt32Array(6, 6));

  // node_modules/@zxing/library/esm/core/aztec/encoder/State.js
  var __values45 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var State = (
    /** @class */
    function() {
      function State2(token, mode, binaryBytes, bitCount) {
        this.token = token;
        this.mode = mode;
        this.binaryShiftByteCount = binaryBytes;
        this.bitCount = bitCount;
      }
      State2.prototype.getMode = function() {
        return this.mode;
      };
      State2.prototype.getToken = function() {
        return this.token;
      };
      State2.prototype.getBinaryShiftByteCount = function() {
        return this.binaryShiftByteCount;
      };
      State2.prototype.getBitCount = function() {
        return this.bitCount;
      };
      State2.prototype.latchAndAppend = function(mode, value) {
        var bitCount = this.bitCount;
        var token = this.token;
        if (mode !== this.mode) {
          var latch = LATCH_TABLE[this.mode][mode];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
        }
        var latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, value, latchModeBitCount);
        return new State2(token, mode, 0, bitCount + latchModeBitCount);
      };
      State2.prototype.shiftAndAppend = function(mode, value) {
        var token = this.token;
        var thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
        token = add2(token, value, 5);
        return new State2(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
      };
      State2.prototype.addBinaryShiftChar = function(index) {
        var token = this.token;
        var mode = this.mode;
        var bitCount = this.bitCount;
        if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
          var latch = LATCH_TABLE[mode][MODE_UPPER];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
          mode = MODE_UPPER;
        }
        var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
        var result = new State2(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
        if (result.binaryShiftByteCount === 2047 + 31) {
          result = result.endBinaryShift(index + 1);
        }
        return result;
      };
      State2.prototype.endBinaryShift = function(index) {
        if (this.binaryShiftByteCount === 0) {
          return this;
        }
        var token = this.token;
        token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
        return new State2(token, this.mode, 0, this.bitCount);
      };
      State2.prototype.isBetterThanOrEqualTo = function(other) {
        var newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
          newModeBitCount += State2.calculateBinaryShiftCost(other) - State2.calculateBinaryShiftCost(this);
        } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
          newModeBitCount += 10;
        }
        return newModeBitCount <= other.bitCount;
      };
      State2.prototype.toBitArray = function(text) {
        var e_1, _a2;
        var symbols = [];
        for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
          symbols.unshift(token);
        }
        var bitArray = new BitArray_default();
        try {
          for (var symbols_1 = __values45(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {
            var symbol = symbols_1_1.value;
            symbol.appendTo(bitArray, text);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (symbols_1_1 && !symbols_1_1.done && (_a2 = symbols_1.return)) _a2.call(symbols_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return bitArray;
      };
      State2.prototype.toString = function() {
        return StringUtils_default.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
      };
      State2.calculateBinaryShiftCost = function(state) {
        if (state.binaryShiftByteCount > 62) {
          return 21;
        }
        if (state.binaryShiftByteCount > 31) {
          return 20;
        }
        if (state.binaryShiftByteCount > 0) {
          return 10;
        }
        return 0;
      };
      State2.INITIAL_STATE = new State2(EMPTY_TOKEN, MODE_UPPER, 0, 0);
      return State2;
    }()
  );
  var State_default = State;

  // node_modules/@zxing/library/esm/core/aztec/encoder/CharMap.js
  function static_CHAR_MAP(CHAR_MAP2) {
    var spaceCharCode = StringUtils_default.getCharCode(" ");
    var pointCharCode = StringUtils_default.getCharCode(".");
    var commaCharCode = StringUtils_default.getCharCode(",");
    CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
    var zUpperCharCode = StringUtils_default.getCharCode("Z");
    var aUpperCharCode = StringUtils_default.getCharCode("A");
    for (var c = aUpperCharCode; c <= zUpperCharCode; c++) {
      CHAR_MAP2[MODE_UPPER][c] = c - aUpperCharCode + 2;
    }
    CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
    var zLowerCharCode = StringUtils_default.getCharCode("z");
    var aLowerCharCode = StringUtils_default.getCharCode("a");
    for (var c = aLowerCharCode; c <= zLowerCharCode; c++) {
      CHAR_MAP2[MODE_LOWER][c] = c - aLowerCharCode + 2;
    }
    CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
    var nineCharCode = StringUtils_default.getCharCode("9");
    var zeroCharCode = StringUtils_default.getCharCode("0");
    for (var c = zeroCharCode; c <= nineCharCode; c++) {
      CHAR_MAP2[MODE_DIGIT][c] = c - zeroCharCode + 2;
    }
    CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
    CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
    var mixedTable = [
      "\0",
      " ",
      "",
      "",
      "",
      "",
      "",
      "",
      "\x07",
      "\b",
      "	",
      "\n",
      "\v",
      "\f",
      "\r",
      "\x1B",
      "",
      "",
      "",
      "",
      "@",
      "\\",
      "^",
      "_",
      "`",
      "|",
      "~",
      "\x7F"
    ];
    for (var i = 0; i < mixedTable.length; i++) {
      CHAR_MAP2[MODE_MIXED][StringUtils_default.getCharCode(mixedTable[i])] = i;
    }
    var punctTable = [
      "\0",
      "\r",
      "\0",
      "\0",
      "\0",
      "\0",
      "!",
      "'",
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "[",
      "]",
      "{",
      "}"
    ];
    for (var i = 0; i < punctTable.length; i++) {
      if (StringUtils_default.getCharCode(punctTable[i]) > 0) {
        CHAR_MAP2[MODE_PUNCT][StringUtils_default.getCharCode(punctTable[i])] = i;
      }
    }
    return CHAR_MAP2;
  }
  var CHAR_MAP = static_CHAR_MAP(Arrays_default.createInt32Array(5, 256));

  // node_modules/@zxing/library/esm/core/aztec/encoder/HighLevelEncoder.js
  var __values46 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var HighLevelEncoder2 = (
    /** @class */
    function() {
      function HighLevelEncoder3(text) {
        this.text = text;
      }
      HighLevelEncoder3.prototype.encode = function() {
        var spaceCharCode = StringUtils_default.getCharCode(" ");
        var lineBreakCharCode = StringUtils_default.getCharCode("\n");
        var states = Collections_default.singletonList(State_default.INITIAL_STATE);
        for (var index = 0; index < this.text.length; index++) {
          var pairCode = void 0;
          var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
          switch (this.text[index]) {
            case StringUtils_default.getCharCode("\r"):
              pairCode = nextChar === lineBreakCharCode ? 2 : 0;
              break;
            case StringUtils_default.getCharCode("."):
              pairCode = nextChar === spaceCharCode ? 3 : 0;
              break;
            case StringUtils_default.getCharCode(","):
              pairCode = nextChar === spaceCharCode ? 4 : 0;
              break;
            case StringUtils_default.getCharCode(":"):
              pairCode = nextChar === spaceCharCode ? 5 : 0;
              break;
            default:
              pairCode = 0;
          }
          if (pairCode > 0) {
            states = HighLevelEncoder3.updateStateListForPair(states, index, pairCode);
            index++;
          } else {
            states = this.updateStateListForChar(states, index);
          }
        }
        var minState = Collections_default.min(states, function(a, b) {
          return a.getBitCount() - b.getBitCount();
        });
        return minState.toBitArray(this.text);
      };
      HighLevelEncoder3.prototype.updateStateListForChar = function(states, index) {
        var e_1, _a2;
        var result = [];
        try {
          for (var states_1 = __values46(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {
            var state = states_1_1.value;
            this.updateStateForChar(state, index, result);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (states_1_1 && !states_1_1.done && (_a2 = states_1.return)) _a2.call(states_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return HighLevelEncoder3.simplifyStates(result);
      };
      HighLevelEncoder3.prototype.updateStateForChar = function(state, index, result) {
        var ch = this.text[index] & 255;
        var charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
        var stateNoBinary = null;
        for (var mode = 0; mode <= MODE_PUNCT; mode++) {
          var charInMode = CHAR_MAP[mode][ch];
          if (charInMode > 0) {
            if (stateNoBinary == null) {
              stateNoBinary = state.endBinaryShift(index);
            }
            if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
              var latchState = stateNoBinary.latchAndAppend(mode, charInMode);
              result.push(latchState);
            }
            if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
              var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
              result.push(shiftState);
            }
          }
        }
        if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
          var binaryState = state.addBinaryShiftChar(index);
          result.push(binaryState);
        }
      };
      HighLevelEncoder3.updateStateListForPair = function(states, index, pairCode) {
        var e_2, _a2;
        var result = [];
        try {
          for (var states_2 = __values46(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {
            var state = states_2_1.value;
            this.updateStateForPair(state, index, pairCode, result);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (states_2_1 && !states_2_1.done && (_a2 = states_2.return)) _a2.call(states_2);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return this.simplifyStates(result);
      };
      HighLevelEncoder3.updateStateForPair = function(state, index, pairCode, result) {
        var stateNoBinary = state.endBinaryShift(index);
        result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
        if (state.getMode() !== MODE_PUNCT) {
          result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
        }
        if (pairCode === 3 || pairCode === 4) {
          var digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
          result.push(digitState);
        }
        if (state.getBinaryShiftByteCount() > 0) {
          var binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);
          result.push(binaryState);
        }
      };
      HighLevelEncoder3.simplifyStates = function(states) {
        var e_3, _a2, e_4, _b;
        var result = [];
        try {
          for (var states_3 = __values46(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {
            var newState = states_3_1.value;
            var add3 = true;
            var _loop_1 = function(oldState2) {
              if (oldState2.isBetterThanOrEqualTo(newState)) {
                add3 = false;
                return "break";
              }
              if (newState.isBetterThanOrEqualTo(oldState2)) {
                result = result.filter(function(x) {
                  return x !== oldState2;
                });
              }
            };
            try {
              for (var result_1 = (e_4 = void 0, __values46(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
                var oldState = result_1_1.value;
                var state_1 = _loop_1(oldState);
                if (state_1 === "break")
                  break;
              }
            } catch (e_4_1) {
              e_4 = { error: e_4_1 };
            } finally {
              try {
                if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
            if (add3) {
              result.push(newState);
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (states_3_1 && !states_3_1.done && (_a2 = states_3.return)) _a2.call(states_3);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
        return result;
      };
      return HighLevelEncoder3;
    }()
  );
  var HighLevelEncoder_default2 = HighLevelEncoder2;

  // node_modules/@zxing/library/esm/core/aztec/encoder/Encoder.js
  var __values47 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var Encoder2 = (
    /** @class */
    function() {
      function Encoder3() {
      }
      Encoder3.encodeBytes = function(data) {
        return Encoder3.encode(data, Encoder3.DEFAULT_EC_PERCENT, Encoder3.DEFAULT_AZTEC_LAYERS);
      };
      Encoder3.encode = function(data, minECCPercent, userSpecifiedLayers) {
        var bits = new HighLevelEncoder_default2(data).encode();
        var eccBits = Integer_default.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
        var totalSizeBits = bits.getSize() + eccBits;
        var compact;
        var layers;
        var totalBitsInLayer;
        var wordSize;
        var stuffedBits;
        if (userSpecifiedLayers !== Encoder3.DEFAULT_AZTEC_LAYERS) {
          compact = userSpecifiedLayers < 0;
          layers = Math.abs(userSpecifiedLayers);
          if (layers > (compact ? Encoder3.MAX_NB_BITS_COMPACT : Encoder3.MAX_NB_BITS)) {
            throw new IllegalArgumentException_default(StringUtils_default.format("Illegal value %s for layers", userSpecifiedLayers));
          }
          totalBitsInLayer = Encoder3.totalBitsInLayer(layers, compact);
          wordSize = Encoder3.WORD_SIZE[layers];
          var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
          stuffedBits = Encoder3.stuffBits(bits, wordSize);
          if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
            throw new IllegalArgumentException_default("Data to large for user specified layer");
          }
          if (compact && stuffedBits.getSize() > wordSize * 64) {
            throw new IllegalArgumentException_default("Data to large for user specified layer");
          }
        } else {
          wordSize = 0;
          stuffedBits = null;
          for (var i = 0; ; i++) {
            if (i > Encoder3.MAX_NB_BITS) {
              throw new IllegalArgumentException_default("Data too large for an Aztec code");
            }
            compact = i <= 3;
            layers = compact ? i + 1 : i;
            totalBitsInLayer = Encoder3.totalBitsInLayer(layers, compact);
            if (totalSizeBits > totalBitsInLayer) {
              continue;
            }
            if (stuffedBits == null || wordSize !== Encoder3.WORD_SIZE[layers]) {
              wordSize = Encoder3.WORD_SIZE[layers];
              stuffedBits = Encoder3.stuffBits(bits, wordSize);
            }
            var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
            if (compact && stuffedBits.getSize() > wordSize * 64) {
              continue;
            }
            if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
              break;
            }
          }
        }
        var messageBits = Encoder3.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
        var messageSizeInWords = stuffedBits.getSize() / wordSize;
        var modeMessage = Encoder3.generateModeMessage(compact, layers, messageSizeInWords);
        var baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        var alignmentMap = new Int32Array(baseMatrixSize);
        var matrixSize;
        if (compact) {
          matrixSize = baseMatrixSize;
          for (var i = 0; i < alignmentMap.length; i++) {
            alignmentMap[i] = i;
          }
        } else {
          matrixSize = baseMatrixSize + 1 + 2 * Integer_default.truncDivision(Integer_default.truncDivision(baseMatrixSize, 2) - 1, 15);
          var origCenter = Integer_default.truncDivision(baseMatrixSize, 2);
          var center = Integer_default.truncDivision(matrixSize, 2);
          for (var i = 0; i < origCenter; i++) {
            var newOffset = i + Integer_default.truncDivision(i, 15);
            alignmentMap[origCenter - i - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i] = center + newOffset + 1;
          }
        }
        var matrix = new BitMatrix_default(matrixSize);
        for (var i = 0, rowOffset = 0; i < layers; i++) {
          var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
          for (var j = 0; j < rowSize; j++) {
            var columnOffset = j * 2;
            for (var k = 0; k < 2; k++) {
              if (messageBits.get(rowOffset + columnOffset + k)) {
                matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
              }
              if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
              }
              if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
              }
              if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
              }
            }
          }
          rowOffset += rowSize * 8;
        }
        Encoder3.drawModeMessage(matrix, compact, matrixSize, modeMessage);
        if (compact) {
          Encoder3.drawBullsEye(matrix, Integer_default.truncDivision(matrixSize, 2), 5);
        } else {
          Encoder3.drawBullsEye(matrix, Integer_default.truncDivision(matrixSize, 2), 7);
          for (var i = 0, j = 0; i < Integer_default.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
            for (var k = Integer_default.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
              matrix.set(Integer_default.truncDivision(matrixSize, 2) - j, k);
              matrix.set(Integer_default.truncDivision(matrixSize, 2) + j, k);
              matrix.set(k, Integer_default.truncDivision(matrixSize, 2) - j);
              matrix.set(k, Integer_default.truncDivision(matrixSize, 2) + j);
            }
          }
        }
        var aztec = new AztecCode_default();
        aztec.setCompact(compact);
        aztec.setSize(matrixSize);
        aztec.setLayers(layers);
        aztec.setCodeWords(messageSizeInWords);
        aztec.setMatrix(matrix);
        return aztec;
      };
      Encoder3.drawBullsEye = function(matrix, center, size) {
        for (var i = 0; i < size; i += 2) {
          for (var j = center - i; j <= center + i; j++) {
            matrix.set(j, center - i);
            matrix.set(j, center + i);
            matrix.set(center - i, j);
            matrix.set(center + i, j);
          }
        }
        matrix.set(center - size, center - size);
        matrix.set(center - size + 1, center - size);
        matrix.set(center - size, center - size + 1);
        matrix.set(center + size, center - size);
        matrix.set(center + size, center - size + 1);
        matrix.set(center + size, center + size - 1);
      };
      Encoder3.generateModeMessage = function(compact, layers, messageSizeInWords) {
        var modeMessage = new BitArray_default();
        if (compact) {
          modeMessage.appendBits(layers - 1, 2);
          modeMessage.appendBits(messageSizeInWords - 1, 6);
          modeMessage = Encoder3.generateCheckWords(modeMessage, 28, 4);
        } else {
          modeMessage.appendBits(layers - 1, 5);
          modeMessage.appendBits(messageSizeInWords - 1, 11);
          modeMessage = Encoder3.generateCheckWords(modeMessage, 40, 4);
        }
        return modeMessage;
      };
      Encoder3.drawModeMessage = function(matrix, compact, matrixSize, modeMessage) {
        var center = Integer_default.truncDivision(matrixSize, 2);
        if (compact) {
          for (var i = 0; i < 7; i++) {
            var offset2 = center - 3 + i;
            if (modeMessage.get(i)) {
              matrix.set(offset2, center - 5);
            }
            if (modeMessage.get(i + 7)) {
              matrix.set(center + 5, offset2);
            }
            if (modeMessage.get(20 - i)) {
              matrix.set(offset2, center + 5);
            }
            if (modeMessage.get(27 - i)) {
              matrix.set(center - 5, offset2);
            }
          }
        } else {
          for (var i = 0; i < 10; i++) {
            var offset2 = center - 5 + i + Integer_default.truncDivision(i, 5);
            if (modeMessage.get(i)) {
              matrix.set(offset2, center - 7);
            }
            if (modeMessage.get(i + 10)) {
              matrix.set(center + 7, offset2);
            }
            if (modeMessage.get(29 - i)) {
              matrix.set(offset2, center + 7);
            }
            if (modeMessage.get(39 - i)) {
              matrix.set(center - 7, offset2);
            }
          }
        }
      };
      Encoder3.generateCheckWords = function(bitArray, totalBits, wordSize) {
        var e_1, _a2;
        var messageSizeInWords = bitArray.getSize() / wordSize;
        var rs = new ReedSolomonEncoder_default(Encoder3.getGF(wordSize));
        var totalWords = Integer_default.truncDivision(totalBits, wordSize);
        var messageWords = Encoder3.bitsToWords(bitArray, wordSize, totalWords);
        rs.encode(messageWords, totalWords - messageSizeInWords);
        var startPad = totalBits % wordSize;
        var messageBits = new BitArray_default();
        messageBits.appendBits(0, startPad);
        try {
          for (var _b = __values47(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var messageWord = _c.value;
            messageBits.appendBits(messageWord, wordSize);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return messageBits;
      };
      Encoder3.bitsToWords = function(stuffedBits, wordSize, totalWords) {
        var message = new Int32Array(totalWords);
        var i;
        var n;
        for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
          var value = 0;
          for (var j = 0; j < wordSize; j++) {
            value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;
          }
          message[i] = value;
        }
        return message;
      };
      Encoder3.getGF = function(wordSize) {
        switch (wordSize) {
          case 4:
            return GenericGF_default.AZTEC_PARAM;
          case 6:
            return GenericGF_default.AZTEC_DATA_6;
          case 8:
            return GenericGF_default.AZTEC_DATA_8;
          case 10:
            return GenericGF_default.AZTEC_DATA_10;
          case 12:
            return GenericGF_default.AZTEC_DATA_12;
          default:
            throw new IllegalArgumentException_default("Unsupported word size " + wordSize);
        }
      };
      Encoder3.stuffBits = function(bits, wordSize) {
        var out = new BitArray_default();
        var n = bits.getSize();
        var mask = (1 << wordSize) - 2;
        for (var i = 0; i < n; i += wordSize) {
          var word = 0;
          for (var j = 0; j < wordSize; j++) {
            if (i + j >= n || bits.get(i + j)) {
              word |= 1 << wordSize - 1 - j;
            }
          }
          if ((word & mask) === mask) {
            out.appendBits(word & mask, wordSize);
            i--;
          } else if ((word & mask) === 0) {
            out.appendBits(word | 1, wordSize);
            i--;
          } else {
            out.appendBits(word, wordSize);
          }
        }
        return out;
      };
      Encoder3.totalBitsInLayer = function(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      };
      Encoder3.DEFAULT_EC_PERCENT = 33;
      Encoder3.DEFAULT_AZTEC_LAYERS = 0;
      Encoder3.MAX_NB_BITS = 32;
      Encoder3.MAX_NB_BITS_COMPACT = 4;
      Encoder3.WORD_SIZE = Int32Array.from([
        4,
        6,
        6,
        8,
        8,
        8,
        8,
        8,
        8,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12
      ]);
      return Encoder3;
    }()
  );
  var Encoder_default2 = Encoder2;

  // node_modules/@zxing/library/esm/core/aztec/AztecWriter.js
  var AztecWriter = (
    /** @class */
    function() {
      function AztecWriter2() {
      }
      AztecWriter2.prototype.encode = function(contents, format, width, height) {
        return this.encodeWithHints(contents, format, width, height, null);
      };
      AztecWriter2.prototype.encodeWithHints = function(contents, format, width, height, hints) {
        var charset = StandardCharsets_default.ISO_8859_1;
        var eccPercent = Encoder_default2.DEFAULT_EC_PERCENT;
        var layers = Encoder_default2.DEFAULT_AZTEC_LAYERS;
        if (hints != null) {
          if (hints.has(EncodeHintType_default.CHARACTER_SET)) {
            charset = Charset_default.forName(hints.get(EncodeHintType_default.CHARACTER_SET).toString());
          }
          if (hints.has(EncodeHintType_default.ERROR_CORRECTION)) {
            eccPercent = Integer_default.parseInt(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
          }
          if (hints.has(EncodeHintType_default.AZTEC_LAYERS)) {
            layers = Integer_default.parseInt(hints.get(EncodeHintType_default.AZTEC_LAYERS).toString());
          }
        }
        return AztecWriter2.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
      };
      AztecWriter2.encodeLayers = function(contents, format, width, height, charset, eccPercent, layers) {
        if (format !== BarcodeFormat_default.AZTEC) {
          throw new IllegalArgumentException_default("Can only encode AZTEC, but got " + format);
        }
        var aztec = Encoder_default2.encode(StringUtils_default.getBytes(contents, charset), eccPercent, layers);
        return AztecWriter2.renderResult(aztec, width, height);
      };
      AztecWriter2.renderResult = function(code, width, height) {
        var input = code.getMatrix();
        if (input == null) {
          throw new IllegalStateException_default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var outputWidth = Math.max(width, inputWidth);
        var outputHeight = Math.max(height, inputHeight);
        var multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
        var leftPadding = (outputWidth - inputWidth * multiple) / 2;
        var topPadding = (outputHeight - inputHeight * multiple) / 2;
        var output = new BitMatrix_default(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY)) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      };
      return AztecWriter2;
    }()
  );

  // node_modules/@zxing/browser/esm/common/HTMLCanvasElementLuminanceSource.js
  var __extends75 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var HTMLCanvasElementLuminanceSource2 = (
    /** @class */
    function(_super) {
      __extends75(HTMLCanvasElementLuminanceSource3, _super);
      function HTMLCanvasElementLuminanceSource3(canvas) {
        var _this = _super.call(this, canvas.width, canvas.height) || this;
        _this.canvas = canvas;
        _this.tempCanvasElement = null;
        _this.buffer = HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData(canvas);
        return _this;
      }
      HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData = function(canvas) {
        var canvasCtx;
        try {
          canvasCtx = canvas.getContext("2d", { willReadFrequently: true });
        } catch (e) {
          canvasCtx = canvas.getContext("2d");
        }
        if (!canvasCtx) {
          throw new Error("Couldn't get canvas context.");
        }
        var imageData = canvasCtx.getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource3.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
      };
      HTMLCanvasElementLuminanceSource3.toGrayscaleBuffer = function(imageBuffer, width, height) {
        var grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
          var gray = void 0;
          var alpha = imageBuffer[i + 3];
          if (alpha === 0) {
            gray = 255;
          } else {
            var pixelR = imageBuffer[i];
            var pixelG = imageBuffer[i + 1];
            var pixelB = imageBuffer[i + 2];
            gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
          }
          grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
      };
      HTMLCanvasElementLuminanceSource3.prototype.getRow = function(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
        }
        var width = this.getWidth();
        var start3 = y * width;
        if (row === null) {
          row = this.buffer.slice(start3, start3 + width);
        } else {
          if (row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          row.set(this.buffer.slice(start3, start3 + width));
        }
        return row;
      };
      HTMLCanvasElementLuminanceSource3.prototype.getMatrix = function() {
        return this.buffer;
      };
      HTMLCanvasElementLuminanceSource3.prototype.isCropSupported = function() {
        return true;
      };
      HTMLCanvasElementLuminanceSource3.prototype.crop = function(left2, top2, width, height) {
        _super.prototype.crop.call(this, left2, top2, width, height);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.isRotateSupported = function() {
        return true;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotateCounterClockwise = function() {
        this.rotate(-90);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotateCounterClockwise45 = function() {
        this.rotate(-45);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.prototype.invert = function() {
        return new InvertedLuminanceSource_default(this);
      };
      HTMLCanvasElementLuminanceSource3.prototype.getTempCanvasElement = function() {
        if (null === this.tempCanvasElement) {
          var tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
          tempCanvasElement.width = this.canvas.width;
          tempCanvasElement.height = this.canvas.height;
          this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
      };
      HTMLCanvasElementLuminanceSource3.prototype.rotate = function(angle) {
        var tempCanvasElement = this.getTempCanvasElement();
        if (!tempCanvasElement) {
          throw new Error("Could not create a Canvas element.");
        }
        var angleRadians = angle * HTMLCanvasElementLuminanceSource3.DEGREE_TO_RADIANS;
        var width = this.canvas.width;
        var height = this.canvas.height;
        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        var tempContext = tempCanvasElement.getContext("2d");
        if (!tempContext) {
          throw new Error("Could not create a Canvas Context element.");
        }
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource3.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
      };
      HTMLCanvasElementLuminanceSource3.DEGREE_TO_RADIANS = Math.PI / 180;
      return HTMLCanvasElementLuminanceSource3;
    }(LuminanceSource_default)
  );

  // node_modules/@zxing/browser/esm/common/navigator-utils.js
  function hasNavigator() {
    return typeof navigator !== "undefined";
  }
  function isMediaDevicesSupported() {
    return hasNavigator() && !!navigator.mediaDevices;
  }
  function canEnumerateDevices() {
    return !!(isMediaDevicesSupported() && navigator.mediaDevices.enumerateDevices);
  }

  // node_modules/@zxing/browser/esm/readers/BrowserCodeReader.js
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __values48 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var defaultOptions = {
    delayBetweenScanAttempts: 500,
    delayBetweenScanSuccess: 500,
    tryPlayVideoTimeout: 5e3
  };
  var BrowserCodeReader2 = (
    /** @class */
    function() {
      function BrowserCodeReader3(reader, hints, options) {
        if (hints === void 0) {
          hints = /* @__PURE__ */ new Map();
        }
        if (options === void 0) {
          options = {};
        }
        this.reader = reader;
        this.hints = hints;
        this.options = __assign(__assign({}, defaultOptions), options);
      }
      Object.defineProperty(BrowserCodeReader3.prototype, "possibleFormats", {
        /**
         * Allows to change the possible formats the decoder should
         * search for while scanning some image. Useful for changing
         * the possible formats during BrowserCodeReader::scan.
         */
        set: function(formats) {
          this.hints.set(DecodeHintType_default.POSSIBLE_FORMATS, formats);
        },
        enumerable: false,
        configurable: true
      });
      BrowserCodeReader3.addVideoSource = function(videoElement, stream) {
        try {
          videoElement.srcObject = stream;
        } catch (err) {
          console.error("got interrupted by new loading request");
        }
      };
      BrowserCodeReader3.mediaStreamSetTorch = function(track, onOff) {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, track.applyConstraints({
                  advanced: [{
                    fillLightMode: onOff ? "flash" : "off",
                    torch: onOff ? true : false
                  }]
                })];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.mediaStreamIsTorchCompatible = function(params) {
        var e_1, _a2;
        var tracks = params.getVideoTracks();
        try {
          for (var tracks_1 = __values48(tracks), tracks_1_1 = tracks_1.next(); !tracks_1_1.done; tracks_1_1 = tracks_1.next()) {
            var track = tracks_1_1.value;
            if (BrowserCodeReader3.mediaStreamIsTorchCompatibleTrack(track)) {
              return true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (tracks_1_1 && !tracks_1_1.done && (_a2 = tracks_1.return)) _a2.call(tracks_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return false;
      };
      BrowserCodeReader3.mediaStreamIsTorchCompatibleTrack = function(track) {
        try {
          var capabilities = track.getCapabilities();
          return "torch" in capabilities;
        } catch (err) {
          console.error(err);
          console.warn("Your browser may be not fully compatible with WebRTC and/or ImageCapture specs. Torch will not be available.");
          return false;
        }
      };
      BrowserCodeReader3.isVideoPlaying = function(video) {
        return video.currentTime > 0 && !video.paused && video.readyState > 2;
      };
      BrowserCodeReader3.getMediaElement = function(mediaElementId, type) {
        var mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
          throw new ArgumentException_default("element with id '".concat(mediaElementId, "' not found"));
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
          throw new ArgumentException_default("element with id '".concat(mediaElementId, "' must be an ").concat(type, " element"));
        }
        return mediaElement;
      };
      BrowserCodeReader3.createVideoElement = function(videoThingy) {
        if (videoThingy instanceof HTMLVideoElement) {
          return videoThingy;
        }
        if (typeof videoThingy === "string") {
          return BrowserCodeReader3.getMediaElement(videoThingy, "video");
        }
        if (!videoThingy && typeof document !== "undefined") {
          var videoElement = document.createElement("video");
          videoElement.width = 200;
          videoElement.height = 200;
          return videoElement;
        }
        throw new Error("Couldn't get videoElement from videoSource!");
      };
      BrowserCodeReader3.prepareImageElement = function(imageSource) {
        if (imageSource instanceof HTMLImageElement) {
          return imageSource;
        }
        if (typeof imageSource === "string") {
          return BrowserCodeReader3.getMediaElement(imageSource, "img");
        }
        if (typeof imageSource === "undefined") {
          var imageElement = document.createElement("img");
          imageElement.width = 200;
          imageElement.height = 200;
          return imageElement;
        }
        throw new Error("Couldn't get imageElement from imageSource!");
      };
      BrowserCodeReader3.prepareVideoElement = function(videoElem) {
        var videoElement = BrowserCodeReader3.createVideoElement(videoElem);
        videoElement.setAttribute("autoplay", "true");
        videoElement.setAttribute("muted", "true");
        videoElement.setAttribute("playsinline", "true");
        return videoElement;
      };
      BrowserCodeReader3.isImageLoaded = function(img) {
        if (!img.complete) {
          return false;
        }
        if (img.naturalWidth === 0) {
          return false;
        }
        return true;
      };
      BrowserCodeReader3.createBinaryBitmapFromCanvas = function(canvas) {
        var luminanceSource = new HTMLCanvasElementLuminanceSource2(canvas);
        var hybridBinarizer = new HybridBinarizer_default(luminanceSource);
        return new BinaryBitmap_default(hybridBinarizer);
      };
      BrowserCodeReader3.drawImageOnCanvas = function(canvasElementContext, srcElement) {
        canvasElementContext.drawImage(srcElement, 0, 0);
      };
      BrowserCodeReader3.getMediaElementDimensions = function(mediaElement) {
        if (mediaElement instanceof HTMLVideoElement) {
          return {
            height: mediaElement.videoHeight,
            width: mediaElement.videoWidth
          };
        }
        if (mediaElement instanceof HTMLImageElement) {
          return {
            height: mediaElement.naturalHeight || mediaElement.height,
            width: mediaElement.naturalWidth || mediaElement.width
          };
        }
        throw new Error("Couldn't find the Source's dimensions!");
      };
      BrowserCodeReader3.createCaptureCanvas = function(mediaElement) {
        if (!mediaElement) {
          throw new ArgumentException_default("Cannot create a capture canvas without a media element.");
        }
        if (typeof document === "undefined") {
          throw new Error(`The page "Document" is undefined, make sure you're running in a browser.`);
        }
        var canvasElement = document.createElement("canvas");
        var _a2 = BrowserCodeReader3.getMediaElementDimensions(mediaElement), width = _a2.width, height = _a2.height;
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
      };
      BrowserCodeReader3.tryPlayVideo = function(videoElement) {
        return __awaiter2(this, void 0, void 0, function() {
          var error_1;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (videoElement === null || videoElement === void 0 ? void 0 : videoElement.ended) {
                  console.error("Trying to play video that has ended.");
                  return [2, false];
                }
                if (BrowserCodeReader3.isVideoPlaying(videoElement)) {
                  console.warn("Trying to play video that is already playing.");
                  return [2, true];
                }
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, videoElement.play()];
              case 2:
                _a2.sent();
                return [2, true];
              case 3:
                error_1 = _a2.sent();
                console.warn("It was not possible to play the video.", error_1);
                return [2, false];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.createCanvasFromMediaElement = function(mediaElement) {
        var canvas = BrowserCodeReader3.createCaptureCanvas(mediaElement);
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Couldn't find Canvas 2D Context.");
        }
        BrowserCodeReader3.drawImageOnCanvas(ctx, mediaElement);
        return canvas;
      };
      BrowserCodeReader3.createBinaryBitmapFromMediaElem = function(mediaElement) {
        var canvas = BrowserCodeReader3.createCanvasFromMediaElement(mediaElement);
        return BrowserCodeReader3.createBinaryBitmapFromCanvas(canvas);
      };
      BrowserCodeReader3.destroyImageElement = function(imageElement) {
        imageElement.src = "";
        imageElement.removeAttribute("src");
        imageElement = void 0;
      };
      BrowserCodeReader3.listVideoInputDevices = function() {
        return __awaiter2(this, void 0, void 0, function() {
          var devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;
          var e_2, _a2;
          return __generator2(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!hasNavigator()) {
                  throw new Error("Can't enumerate devices, navigator is not present.");
                }
                if (!canEnumerateDevices()) {
                  throw new Error("Can't enumerate devices, method not supported.");
                }
                return [4, navigator.mediaDevices.enumerateDevices()];
              case 1:
                devices = _b.sent();
                videoDevices = [];
                try {
                  for (devices_1 = __values48(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {
                    device = devices_1_1.value;
                    kind = device.kind === "video" ? "videoinput" : device.kind;
                    if (kind !== "videoinput") {
                      continue;
                    }
                    deviceId = device.deviceId || device.id;
                    label = device.label || "Video device ".concat(videoDevices.length + 1);
                    groupId = device.groupId;
                    videoDevice = { deviceId, label, kind, groupId };
                    videoDevices.push(videoDevice);
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (devices_1_1 && !devices_1_1.done && (_a2 = devices_1.return)) _a2.call(devices_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                return [2, videoDevices];
            }
          });
        });
      };
      BrowserCodeReader3.findDeviceById = function(deviceId) {
        return __awaiter2(this, void 0, void 0, function() {
          var devices;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, BrowserCodeReader3.listVideoInputDevices()];
              case 1:
                devices = _a2.sent();
                if (!devices) {
                  return [
                    2
                    /*return*/
                  ];
                }
                return [2, devices.find(function(x) {
                  return x.deviceId === deviceId;
                })];
            }
          });
        });
      };
      BrowserCodeReader3.cleanVideoSource = function(videoElement) {
        if (!videoElement) {
          return;
        }
        try {
          videoElement.srcObject = null;
        } catch (err) {
          videoElement.src = "";
        }
        if (videoElement) {
          videoElement.removeAttribute("src");
        }
      };
      BrowserCodeReader3.releaseAllStreams = function() {
        if (BrowserCodeReader3.streamTracker.length !== 0) {
          BrowserCodeReader3.streamTracker.forEach(function(mediaStream) {
            mediaStream.getTracks().forEach(function(track) {
              return track.stop();
            });
          });
        }
        BrowserCodeReader3.streamTracker = [];
      };
      BrowserCodeReader3.playVideoOnLoadAsync = function(element, timeout) {
        return __awaiter2(this, void 0, void 0, function() {
          var isPlaying;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, BrowserCodeReader3.tryPlayVideo(element)];
              case 1:
                isPlaying = _a2.sent();
                if (isPlaying) {
                  return [2, true];
                }
                return [2, new Promise(function(resolve, reject) {
                  var timeoutId = setTimeout(function() {
                    if (BrowserCodeReader3.isVideoPlaying(element)) {
                      return;
                    }
                    reject(false);
                    element.removeEventListener("canplay", videoCanPlayListener);
                  }, timeout);
                  var videoCanPlayListener = function() {
                    BrowserCodeReader3.tryPlayVideo(element).then(function(hasPlayed) {
                      clearTimeout(timeoutId);
                      element.removeEventListener("canplay", videoCanPlayListener);
                      resolve(hasPlayed);
                    });
                  };
                  element.addEventListener("canplay", videoCanPlayListener);
                })];
            }
          });
        });
      };
      BrowserCodeReader3.attachStreamToVideo = function(stream, preview, previewPlayTimeout) {
        if (previewPlayTimeout === void 0) {
          previewPlayTimeout = 5e3;
        }
        return __awaiter2(this, void 0, void 0, function() {
          var videoElement;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                videoElement = BrowserCodeReader3.prepareVideoElement(preview);
                BrowserCodeReader3.addVideoSource(videoElement, stream);
                return [4, BrowserCodeReader3.playVideoOnLoadAsync(videoElement, previewPlayTimeout)];
              case 1:
                _a2.sent();
                return [2, videoElement];
            }
          });
        });
      };
      BrowserCodeReader3._waitImageLoad = function(element) {
        return new Promise(function(resolve, reject) {
          var timeout = 1e4;
          var timeoutId = setTimeout(function() {
            if (BrowserCodeReader3.isImageLoaded(element)) {
              return;
            }
            element.removeEventListener("load", imageLoadedListener);
            reject();
          }, timeout);
          var imageLoadedListener = function() {
            clearTimeout(timeoutId);
            element.removeEventListener("load", imageLoadedListener);
            resolve();
          };
          element.addEventListener("load", imageLoadedListener);
        });
      };
      BrowserCodeReader3.checkCallbackFnOrThrow = function(callbackFn) {
        if (!callbackFn) {
          throw new ArgumentException_default("`callbackFn` is a required parameter, you cannot capture results without it.");
        }
      };
      BrowserCodeReader3.disposeMediaStream = function(stream) {
        stream.getVideoTracks().forEach(function(x) {
          return x.stop();
        });
        stream = void 0;
      };
      BrowserCodeReader3.prototype.decode = function(element) {
        var canvas = BrowserCodeReader3.createCanvasFromMediaElement(element);
        return this.decodeFromCanvas(canvas);
      };
      BrowserCodeReader3.prototype.decodeBitmap = function(binaryBitmap) {
        return this.reader.decode(binaryBitmap, this.hints);
      };
      BrowserCodeReader3.prototype.decodeFromCanvas = function(canvas) {
        var binaryBitmap = BrowserCodeReader3.createBinaryBitmapFromCanvas(canvas);
        return this.decodeBitmap(binaryBitmap);
      };
      BrowserCodeReader3.prototype.decodeFromImageElement = function(source) {
        return __awaiter2(this, void 0, void 0, function() {
          var element;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!source) {
                  throw new ArgumentException_default("An image element must be provided.");
                }
                element = BrowserCodeReader3.prepareImageElement(source);
                return [4, this._decodeOnLoadImage(element)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromImageUrl = function(url) {
        return __awaiter2(this, void 0, void 0, function() {
          var element;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!url) {
                  throw new ArgumentException_default("An URL must be provided.");
                }
                element = BrowserCodeReader3.prepareImageElement();
                element.src = url;
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, , 3, 4]);
                return [4, this.decodeFromImageElement(element)];
              case 2:
                return [2, _a2.sent()];
              case 3:
                BrowserCodeReader3.destroyImageElement(element);
                return [
                  7
                  /*endfinally*/
                ];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromConstraints = function(constraints, previewElem, callbackFn) {
        return __awaiter2(this, void 0, void 0, function() {
          var stream, error_2;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
                return [4, this.getUserMedia(constraints)];
              case 1:
                stream = _a2.sent();
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, 4, , 5]);
                return [4, this.decodeFromStream(stream, previewElem, callbackFn)];
              case 3:
                return [2, _a2.sent()];
              case 4:
                error_2 = _a2.sent();
                BrowserCodeReader3.disposeMediaStream(stream);
                throw error_2;
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromStream = function(stream, preview, callbackFn) {
        return __awaiter2(this, void 0, void 0, function() {
          var timeout, video, finalizeCallback, originalControls, videoTracks, controls, isTorchAvailable, torchTrack_1, switchTorch_1;
          var _this = this;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
                timeout = this.options.tryPlayVideoTimeout;
                return [4, BrowserCodeReader3.attachStreamToVideo(stream, preview, timeout)];
              case 1:
                video = _a2.sent();
                finalizeCallback = function() {
                  BrowserCodeReader3.disposeMediaStream(stream);
                  BrowserCodeReader3.cleanVideoSource(video);
                };
                originalControls = this.scan(video, callbackFn, finalizeCallback);
                videoTracks = stream.getVideoTracks();
                controls = __assign(__assign({}, originalControls), { stop: function() {
                  originalControls.stop();
                }, streamVideoConstraintsApply: function(constraints, trackFilter) {
                  return __awaiter2(this, void 0, void 0, function() {
                    var tracks, tracks_2, tracks_2_1, track, e_3_1;
                    var e_3, _a3;
                    return __generator2(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          tracks = trackFilter ? videoTracks.filter(trackFilter) : videoTracks;
                          _b.label = 1;
                        case 1:
                          _b.trys.push([1, 6, 7, 8]);
                          tracks_2 = __values48(tracks), tracks_2_1 = tracks_2.next();
                          _b.label = 2;
                        case 2:
                          if (!!tracks_2_1.done) return [3, 5];
                          track = tracks_2_1.value;
                          return [4, track.applyConstraints(constraints)];
                        case 3:
                          _b.sent();
                          _b.label = 4;
                        case 4:
                          tracks_2_1 = tracks_2.next();
                          return [3, 2];
                        case 5:
                          return [3, 8];
                        case 6:
                          e_3_1 = _b.sent();
                          e_3 = { error: e_3_1 };
                          return [3, 8];
                        case 7:
                          try {
                            if (tracks_2_1 && !tracks_2_1.done && (_a3 = tracks_2.return)) _a3.call(tracks_2);
                          } finally {
                            if (e_3) throw e_3.error;
                          }
                          return [
                            7
                            /*endfinally*/
                          ];
                        case 8:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                }, streamVideoConstraintsGet: function(trackFilter) {
                  return videoTracks.find(trackFilter).getConstraints();
                }, streamVideoSettingsGet: function(trackFilter) {
                  return videoTracks.find(trackFilter).getSettings();
                }, streamVideoCapabilitiesGet: function(trackFilter) {
                  return videoTracks.find(trackFilter).getCapabilities();
                } });
                isTorchAvailable = BrowserCodeReader3.mediaStreamIsTorchCompatible(stream);
                if (isTorchAvailable) {
                  torchTrack_1 = videoTracks === null || videoTracks === void 0 ? void 0 : videoTracks.find(function(t) {
                    return BrowserCodeReader3.mediaStreamIsTorchCompatibleTrack(t);
                  });
                  switchTorch_1 = function(onOff) {
                    return __awaiter2(_this, void 0, void 0, function() {
                      return __generator2(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            return [4, BrowserCodeReader3.mediaStreamSetTorch(torchTrack_1, onOff)];
                          case 1:
                            _a3.sent();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                  controls.switchTorch = switchTorch_1;
                  controls.stop = function() {
                    return __awaiter2(_this, void 0, void 0, function() {
                      return __generator2(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            originalControls.stop();
                            return [4, switchTorch_1(false)];
                          case 1:
                            _a3.sent();
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    });
                  };
                }
                return [2, controls];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromVideoDevice = function(deviceId, previewElem, callbackFn) {
        return __awaiter2(this, void 0, void 0, function() {
          var videoConstraints, constraints;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
                if (!deviceId) {
                  videoConstraints = { facingMode: "environment" };
                } else {
                  videoConstraints = { deviceId: { exact: deviceId } };
                }
                constraints = { video: videoConstraints };
                return [4, this.decodeFromConstraints(constraints, previewElem, callbackFn)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromVideoElement = function(source, callbackFn) {
        return __awaiter2(this, void 0, void 0, function() {
          var element, timeout;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
                if (!source) {
                  throw new ArgumentException_default("A video element must be provided.");
                }
                element = BrowserCodeReader3.prepareVideoElement(source);
                timeout = this.options.tryPlayVideoTimeout;
                return [4, BrowserCodeReader3.playVideoOnLoadAsync(element, timeout)];
              case 1:
                _a2.sent();
                return [2, this.scan(element, callbackFn)];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeFromVideoUrl = function(url, callbackFn) {
        return __awaiter2(this, void 0, void 0, function() {
          var element, finalizeCallback, timeout, controls;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
                if (!url) {
                  throw new ArgumentException_default("An URL must be provided.");
                }
                element = BrowserCodeReader3.prepareVideoElement();
                element.src = url;
                finalizeCallback = function() {
                  BrowserCodeReader3.cleanVideoSource(element);
                };
                timeout = this.options.tryPlayVideoTimeout;
                return [4, BrowserCodeReader3.playVideoOnLoadAsync(element, timeout)];
              case 1:
                _a2.sent();
                controls = this.scan(element, callbackFn, finalizeCallback);
                return [2, controls];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromConstraints = function(constraints, videoSource) {
        return __awaiter2(this, void 0, void 0, function() {
          var stream;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, this.getUserMedia(constraints)];
              case 1:
                stream = _a2.sent();
                return [4, this.decodeOnceFromStream(stream, videoSource)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromStream = function(stream, preview) {
        return __awaiter2(this, void 0, void 0, function() {
          var receivedPreview, video, result;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                receivedPreview = Boolean(preview);
                return [4, BrowserCodeReader3.attachStreamToVideo(stream, preview)];
              case 1:
                video = _a2.sent();
                _a2.label = 2;
              case 2:
                _a2.trys.push([2, , 4, 5]);
                return [4, this.scanOneResult(video)];
              case 3:
                result = _a2.sent();
                return [2, result];
              case 4:
                if (!receivedPreview) {
                  BrowserCodeReader3.cleanVideoSource(video);
                }
                return [
                  7
                  /*endfinally*/
                ];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromVideoDevice = function(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function() {
          var videoConstraints, constraints;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!deviceId) {
                  videoConstraints = { facingMode: "environment" };
                } else {
                  videoConstraints = { deviceId: { exact: deviceId } };
                }
                constraints = { video: videoConstraints };
                return [4, this.decodeOnceFromConstraints(constraints, videoSource)];
              case 1:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromVideoElement = function(source) {
        return __awaiter2(this, void 0, void 0, function() {
          var element, timeout;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!source) {
                  throw new ArgumentException_default("A video element must be provided.");
                }
                element = BrowserCodeReader3.prepareVideoElement(source);
                timeout = this.options.tryPlayVideoTimeout;
                return [4, BrowserCodeReader3.playVideoOnLoadAsync(element, timeout)];
              case 1:
                _a2.sent();
                return [4, this.scanOneResult(element)];
              case 2:
                return [2, _a2.sent()];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.decodeOnceFromVideoUrl = function(url) {
        return __awaiter2(this, void 0, void 0, function() {
          var element, task;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!url) {
                  throw new ArgumentException_default("An URL must be provided.");
                }
                element = BrowserCodeReader3.prepareVideoElement();
                element.src = url;
                task = this.decodeOnceFromVideoElement(element);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, , 3, 4]);
                return [4, task];
              case 2:
                return [2, _a2.sent()];
              case 3:
                BrowserCodeReader3.cleanVideoSource(element);
                return [
                  7
                  /*endfinally*/
                ];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.scanOneResult = function(element, retryIfNotFound, retryIfChecksumError, retryIfFormatError) {
        var _this = this;
        if (retryIfNotFound === void 0) {
          retryIfNotFound = true;
        }
        if (retryIfChecksumError === void 0) {
          retryIfChecksumError = true;
        }
        if (retryIfFormatError === void 0) {
          retryIfFormatError = true;
        }
        return new Promise(function(resolve, reject) {
          _this.scan(element, function(result, error2, controls) {
            if (result) {
              resolve(result);
              controls.stop();
              return;
            }
            if (error2) {
              if (error2 instanceof NotFoundException_default && retryIfNotFound) {
                return;
              }
              if (error2 instanceof ChecksumException_default && retryIfChecksumError) {
                return;
              }
              if (error2 instanceof FormatException_default && retryIfFormatError) {
                return;
              }
              controls.stop();
              reject(error2);
            }
          });
        });
      };
      BrowserCodeReader3.prototype.scan = function(element, callbackFn, finalizeCallback) {
        var _this = this;
        BrowserCodeReader3.checkCallbackFnOrThrow(callbackFn);
        var captureCanvas = BrowserCodeReader3.createCaptureCanvas(element);
        var captureCanvasContext;
        try {
          captureCanvasContext = captureCanvas.getContext("2d", { willReadFrequently: true });
        } catch (e) {
          captureCanvasContext = captureCanvas.getContext("2d");
        }
        if (!captureCanvasContext) {
          throw new Error("Couldn't create canvas for visual element scan.");
        }
        var disposeCanvas = function() {
          captureCanvasContext = void 0;
          captureCanvas = void 0;
        };
        var stopScan = false;
        var lastTimeoutId;
        var stop = function() {
          stopScan = true;
          clearTimeout(lastTimeoutId);
          disposeCanvas();
          if (finalizeCallback) {
            finalizeCallback();
          }
        };
        var controls = { stop };
        var loop = function() {
          if (stopScan) {
            return;
          }
          try {
            BrowserCodeReader3.drawImageOnCanvas(captureCanvasContext, element);
            var result = _this.decodeFromCanvas(captureCanvas);
            callbackFn(result, void 0, controls);
            lastTimeoutId = setTimeout(loop, _this.options.delayBetweenScanSuccess);
          } catch (error2) {
            callbackFn(void 0, error2, controls);
            var isChecksumError = error2 instanceof ChecksumException_default;
            var isFormatError = error2 instanceof FormatException_default;
            var isNotFound = error2 instanceof NotFoundException_default;
            if (isChecksumError || isFormatError || isNotFound) {
              lastTimeoutId = setTimeout(loop, _this.options.delayBetweenScanAttempts);
              return;
            }
            disposeCanvas();
            if (finalizeCallback) {
              finalizeCallback(error2);
            }
          }
        };
        loop();
        return controls;
      };
      BrowserCodeReader3.prototype._decodeOnLoadImage = function(element) {
        return __awaiter2(this, void 0, void 0, function() {
          var isImageLoaded;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isImageLoaded = BrowserCodeReader3.isImageLoaded(element);
                if (!!isImageLoaded) return [3, 2];
                return [4, BrowserCodeReader3._waitImageLoad(element)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                return [2, this.decode(element)];
            }
          });
        });
      };
      BrowserCodeReader3.prototype.getUserMedia = function(constraints) {
        return __awaiter2(this, void 0, void 0, function() {
          var stream;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, navigator.mediaDevices.getUserMedia(constraints)];
              case 1:
                stream = _a2.sent();
                BrowserCodeReader3.streamTracker.push(stream);
                return [2, stream];
            }
          });
        });
      };
      BrowserCodeReader3.streamTracker = [];
      return BrowserCodeReader3;
    }()
  );

  // node_modules/@zxing/browser/esm/readers/BrowserAztecCodeReader.js
  var __extends76 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserAztecCodeReader2 = (
    /** @class */
    function(_super) {
      __extends76(BrowserAztecCodeReader3, _super);
      function BrowserAztecCodeReader3(hints, options) {
        return _super.call(this, new AztecReader_default(), hints, options) || this;
      }
      return BrowserAztecCodeReader3;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/readers/BrowserMultiFormatOneDReader.js
  var __extends77 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserMultiFormatOneDReader = (
    /** @class */
    function(_super) {
      __extends77(BrowserMultiFormatOneDReader2, _super);
      function BrowserMultiFormatOneDReader2(hints, options) {
        return _super.call(this, new MultiFormatOneDReader_default(hints), hints, options) || this;
      }
      return BrowserMultiFormatOneDReader2;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/readers/BrowserDatamatrixCodeReader.js
  var __extends78 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserDatamatrixCodeReader2 = (
    /** @class */
    function(_super) {
      __extends78(BrowserDatamatrixCodeReader3, _super);
      function BrowserDatamatrixCodeReader3(hints, options) {
        return _super.call(this, new DataMatrixReader_default(), hints, options) || this;
      }
      return BrowserDatamatrixCodeReader3;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/readers/BrowserMultiFormatReader.js
  var __extends79 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserMultiFormatReader2 = (
    /** @class */
    function(_super) {
      __extends79(BrowserMultiFormatReader3, _super);
      function BrowserMultiFormatReader3(hints, options) {
        var _this = this;
        var reader = new MultiFormatReader_default();
        reader.setHints(hints);
        _this = _super.call(this, reader, hints, options) || this;
        _this.reader = reader;
        return _this;
      }
      Object.defineProperty(BrowserMultiFormatReader3.prototype, "possibleFormats", {
        set: function(formats) {
          this.hints.set(DecodeHintType_default.POSSIBLE_FORMATS, formats);
          this.reader.setHints(this.hints);
        },
        enumerable: false,
        configurable: true
      });
      BrowserMultiFormatReader3.prototype.decodeBitmap = function(binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
      };
      BrowserMultiFormatReader3.prototype.setHints = function(hints) {
        this.hints = hints;
        this.reader.setHints(this.hints);
      };
      return BrowserMultiFormatReader3;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/readers/BrowserPDF417Reader.js
  var __extends80 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserPDF417Reader2 = (
    /** @class */
    function(_super) {
      __extends80(BrowserPDF417Reader3, _super);
      function BrowserPDF417Reader3(hints, options) {
        return _super.call(this, new PDF417Reader_default(), hints, options) || this;
      }
      return BrowserPDF417Reader3;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/readers/BrowserQRCodeReader.js
  var __extends81 = /* @__PURE__ */ function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var BrowserQRCodeReader2 = (
    /** @class */
    function(_super) {
      __extends81(BrowserQRCodeReader3, _super);
      function BrowserQRCodeReader3(hints, options) {
        return _super.call(this, new QRCodeReader_default(), hints, options) || this;
      }
      return BrowserQRCodeReader3;
    }(BrowserCodeReader2)
  );

  // node_modules/@zxing/browser/esm/writers/BrowserCodeSvgWriter.js
  var svgNs = "http://www.w3.org/2000/svg";
  var BrowserCodeSvgWriter = (
    /** @class */
    function() {
      function BrowserCodeSvgWriter2(containerElement) {
        if (typeof containerElement === "string") {
          var container = document.getElementById(containerElement);
          if (!container) {
            throw new Error("Could not find a Container element with '".concat(containerElement, "'."));
          }
          this.containerElement = container;
        } else {
          this.containerElement = containerElement;
        }
      }
      BrowserCodeSvgWriter2.prototype.write = function(contents, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException_default("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
        }
        var quietZone = hints && hints.get(EncodeHintType_default.MARGIN) !== void 0 ? Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10) : BrowserCodeSvgWriter2.QUIET_ZONE_SIZE;
        var code = this.encode(hints, contents);
        return this.renderResult(code, width, height, quietZone);
      };
      BrowserCodeSvgWriter2.prototype.createSVGElement = function(w, h) {
        var el = document.createElementNS(BrowserCodeSvgWriter2.SVG_NS, "svg");
        el.setAttributeNS(svgNs, "width", h.toString());
        el.setAttributeNS(svgNs, "height", w.toString());
        return el;
      };
      BrowserCodeSvgWriter2.prototype.createSvgPathPlaceholderElement = function(w, h) {
        var el = document.createElementNS(BrowserCodeSvgWriter2.SVG_NS, "path");
        el.setAttributeNS(svgNs, "d", "M0 0h".concat(w, "v").concat(h, "H0z"));
        el.setAttributeNS(svgNs, "fill", "none");
        return el;
      };
      BrowserCodeSvgWriter2.prototype.createSvgRectElement = function(x, y, w, h) {
        var el = document.createElementNS(BrowserCodeSvgWriter2.SVG_NS, "rect");
        el.setAttributeNS(svgNs, "x", x.toString());
        el.setAttributeNS(svgNs, "y", y.toString());
        el.setAttributeNS(svgNs, "height", w.toString());
        el.setAttributeNS(svgNs, "width", h.toString());
        el.setAttributeNS(svgNs, "fill", "#000000");
        return el;
      };
      BrowserCodeSvgWriter2.prototype.encode = function(hints, contents) {
        var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
        if (hints && hints.get(EncodeHintType_default.ERROR_CORRECTION) !== void 0) {
          var correctionStr = hints.get(EncodeHintType_default.ERROR_CORRECTION).toString();
          errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(correctionStr);
        }
        var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
        return code;
      };
      BrowserCodeSvgWriter2.prototype.renderResult = function(code, width, height, quietZone) {
        var input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException_default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + quietZone * 2;
        var qrHeight = inputHeight + quietZone * 2;
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        var svgElement = this.createSVGElement(outputWidth, outputHeight);
        var placeholder = this.createSvgPathPlaceholderElement(width, height);
        svgElement.appendChild(placeholder);
        this.containerElement.appendChild(svgElement);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      };
      BrowserCodeSvgWriter2.QUIET_ZONE_SIZE = 4;
      BrowserCodeSvgWriter2.SVG_NS = "http://www.w3.org/2000/svg";
      return BrowserCodeSvgWriter2;
    }()
  );

  // node_modules/@zxing/browser/esm/writers/BrowserQRCodeSvgWriter.js
  var svgNs2 = "http://www.w3.org/2000/svg";
  var BrowserQRCodeSvgWriter2 = (
    /** @class */
    function() {
      function BrowserQRCodeSvgWriter3() {
      }
      BrowserQRCodeSvgWriter3.prototype.write = function(contents, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException_default("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
        }
        var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
        var quietZone = BrowserQRCodeSvgWriter3.QUIET_ZONE_SIZE;
        if (hints) {
          if (void 0 !== hints.get(EncodeHintType_default.ERROR_CORRECTION)) {
            var correctionStr = hints.get(EncodeHintType_default.ERROR_CORRECTION).toString();
            errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(correctionStr);
          }
          if (void 0 !== hints.get(EncodeHintType_default.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10);
          }
        }
        var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
      };
      BrowserQRCodeSvgWriter3.prototype.writeToDom = function(containerElement, contents, width, height, hints) {
        if (typeof containerElement === "string") {
          var targetEl = document.querySelector(containerElement);
          if (!targetEl) {
            throw new Error("Could no find the target HTML element.");
          }
          containerElement = targetEl;
        }
        var svgElement = this.write(contents, width, height, hints);
        if (containerElement instanceof HTMLElement) {
          containerElement.appendChild(svgElement);
        }
      };
      BrowserQRCodeSvgWriter3.prototype.renderResult = function(code, width, height, quietZone) {
        var input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException_default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + quietZone * 2;
        var qrHeight = inputHeight + quietZone * 2;
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        var svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      };
      BrowserQRCodeSvgWriter3.prototype.createSVGElement = function(w, h) {
        var svgElement = document.createElementNS(svgNs2, "svg");
        var width = w.toString();
        var height = h.toString();
        svgElement.setAttribute("height", height);
        svgElement.setAttribute("width", width);
        svgElement.setAttribute("viewBox", "0 0 " + width + " " + height);
        return svgElement;
      };
      BrowserQRCodeSvgWriter3.prototype.createSvgRectElement = function(x, y, w, h) {
        var rect = document.createElementNS(svgNs2, "rect");
        rect.setAttribute("x", x.toString());
        rect.setAttribute("y", y.toString());
        rect.setAttribute("height", w.toString());
        rect.setAttribute("width", h.toString());
        rect.setAttribute("fill", "#000000");
        return rect;
      };
      BrowserQRCodeSvgWriter3.QUIET_ZONE_SIZE = 4;
      return BrowserQRCodeSvgWriter3;
    }()
  );

  // app/javascript/controllers/barcode_controller.js
  var scannerStarted = false;
  var barcode_controller_default = class extends Controller {
    connect() {
      if (scannerStarted) {
        return;
      }
      scannerStarted = true;
      this.scannedIsbns = /* @__PURE__ */ new Set();
      this.reader = new BrowserMultiFormatReader2();
      this.reader.options = {
        possibleFormats: ["EAN_13"],
        tryHarder: true
      };
      this.cleanupHandler = this.stopCamera.bind(this);
      document.addEventListener("turbo:before-render", this.cleanupHandler);
      this.startScanner();
      this.createScanFrame();
    }
    startScanner() {
      this.reader.decodeFromVideoDevice(null, this.videoTarget, (result, err, controls) => __async(this, null, function* () {
        if (!result) return;
        const isbn = result.getText();
        if (!isbn.startsWith("978") || this.scannedIsbns.has(isbn)) return;
        this.scannedIsbns.add(isbn);
        this.dispatch("scan", {
          detail: { isbn },
          bubbles: true,
          cancelable: true,
          prefix: "barcode",
          target: window
        });
        this.outputTarget.textContent = `ISBN: ${isbn}`;
        setTimeout(() => {
          var _a2;
          (_a2 = controls.resume) == null ? void 0 : _a2.call(controls);
        }, this.debounceValue);
      }));
    }
    disconnect() {
      this.stopCamera();
      document.removeEventListener("turbo:before-render", this.cleanupHandler);
    }
    stopCamera() {
      var _a2, _b;
      if ((_a2 = this.reader) == null ? void 0 : _a2.reset) this.reader.reset();
      const stream = (_b = this.videoTarget) == null ? void 0 : _b.srcObject;
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
        this.videoTarget.srcObject = null;
      }
      scannerStarted = false;
    }
    createScanFrame() {
      const frame = document.createElement("div");
      Object.assign(frame.style, {
        position: "absolute",
        top: "30%",
        left: "28%",
        width: "45%",
        height: "40%",
        border: "4px solid rgba(227, 221, 216, 0.66)",
        borderRadius: "8px",
        boxSizing: "border-box",
        pointerEvents: "none",
        zIndex: "1000"
      });
      this.videoTarget.parentElement.appendChild(frame);
    }
  };
  __publicField(barcode_controller_default, "targets", ["video", "output"]);
  __publicField(barcode_controller_default, "values", { debounce: { type: Number, default: 1500 } });

  // app/javascript/controllers/scan_controller.js
  var scan_controller_default = class extends Controller {
    scan(event) {
      const isbn = event.detail.isbn;
      if (!isbn || !isbn.startsWith("978")) return;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeoutValue);
      fetch(`/search/isbn_turbo?isbn=${isbn}`, {
        headers: {
          Accept: "text/vnd.turbo-stream.html",
          "X-CSRF-Token": this.getCsrfToken(),
          "X-Requested-With": "XMLHttpRequest"
        },
        signal: controller.signal
      }).then((response) => {
        clearTimeout(timeoutId);
        if (!response.ok) {
          throw new Error(`${response.status} ${response.statusText}`);
        }
        return response.text().then((html) => {
          if (typeof html === "string" && html.includes("<turbo-stream")) {
            Turbo.renderStreamMessage(html);
            return html;
          }
          throw new Error("Invalid Turbo Stream response");
        });
      }).catch((error2) => {
        Turbo.renderStreamMessage(
          `<turbo-stream action="prepend" target="scanned-books">
          <template>
            \u901A\u4FE1\u30A8\u30E9\u30FC: ${error2.message}
          </template>
        </turbo-stream>`
        );
      });
    }
    getCsrfToken() {
      return document.querySelector('meta[name="csrf-token"]').content;
    }
  };
  __publicField(scan_controller_default, "values", { timeout: { type: Number, default: 5e3 } });

  // app/javascript/controllers/spinner_controller.js
  var spinner_controller_default = class extends Controller {
    connect() {
      this.showSpinner = this.showSpinner.bind(this);
      this.hideSpinner = this.hideSpinner.bind(this);
      document.addEventListener("turbo:submit-start", this.showSpinner);
      document.addEventListener("turbo:submit-end", this.hideSpinner);
    }
    disconnect() {
      document.removeEventListener("turbo:submit-start", this.showSpinner);
      document.removeEventListener("turbo:submit-end", this.hideSpinner);
    }
    showSpinner() {
      document.getElementById("loading-spinner").classList.remove("d-none");
    }
    hideSpinner() {
      document.getElementById("loading-spinner").classList.add("d-none");
    }
  };

  // app/javascript/rich_editor.js
  var import_react4 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // app/javascript/components/RichEditor.jsx
  var import_react2 = __toESM(require_react());

  // node_modules/orderedmap/dist/index.js
  function OrderedMap(content) {
    this.content = content;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key) {
      for (var i = 0; i < this.content.length; i += 2)
        if (this.content[i] === key) return i;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(key) {
      var found2 = this.find(key);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(key, value, newKey) {
      var self2 = newKey && newKey != key ? this.remove(newKey) : this;
      var found2 = self2.find(key), content = self2.content.slice();
      if (found2 == -1) {
        content.push(newKey || key, value);
      } else {
        content[found2 + 1] = value;
        if (newKey) content[found2] = newKey;
      }
      return new OrderedMap(content);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(key) {
      var found2 = this.find(key);
      if (found2 == -1) return this;
      var content = this.content.slice();
      content.splice(found2, 2);
      return new OrderedMap(content);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(key, value) {
      return new OrderedMap([key, value].concat(this.remove(key).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(key, value) {
      var content = this.remove(key).content.slice();
      content.push(key, value);
      return new OrderedMap(content);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(place, key, value) {
      var without = this.remove(key), content = without.content.slice();
      var found2 = without.find(place);
      content.splice(found2 == -1 ? content.length : found2, 0, key, value);
      return new OrderedMap(content);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(f) {
      for (var i = 0; i < this.content.length; i += 2)
        f(this.content[i], this.content[i + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size) return this;
      return new OrderedMap(map2.content.concat(this.subtract(map2).content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(map2) {
      map2 = OrderedMap.from(map2);
      if (!map2.size) return this;
      return new OrderedMap(this.subtract(map2).content.concat(map2.content));
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(map2) {
      var result = this;
      map2 = OrderedMap.from(map2);
      for (var i = 0; i < map2.content.length; i += 2)
        result = result.remove(map2.content[i]);
      return result;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var result = {};
      this.forEach(function(key, value) {
        result[key] = value;
      });
      return result;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap) return value;
    var content = [];
    if (value) for (var prop in value) content.push(prop, value[prop]);
    return new OrderedMap(content);
  };
  var dist_default = OrderedMap;

  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a.childCount || i == b.childCount)
        return a.childCount == b.childCount ? null : pos;
      let childA = a.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j = 0; childA.text[j] == childB.text[j]; j++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a, b, posA, posB) {
    for (let iA = a.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
      if (childA == childB) {
        posA -= size;
        posB -= size;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size;
      posB -= size;
    }
  }
  var Fragment = class _Fragment {
    /**
    @internal
    */
    constructor(content, size) {
      this.content = content;
      this.size = size || 0;
      if (size == null)
        for (let i = 0; i < content.length; i++)
          this.size += content[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from2, to, f, nodeStart = 0, parent) {
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          let start3 = pos + 1;
          child.nodesBetween(Math.max(0, from2 - start3), Math.min(child.content.size, to - start3), f, nodeStart + start3);
        }
        pos = end2;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from2, to, blockSeparator, leafText) {
      let text = "", first2 = true;
      this.nodesBetween(from2, to, (node, pos) => {
        let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
          if (first2)
            first2 = false;
          else
            text += blockSeparator;
        }
        text += nodeText;
      }, 0);
      return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first2)) {
        content[content.length - 1] = last.withText(last.text + first2.text);
        i = 1;
      }
      for (; i < other.content.length; i++)
        content.push(other.content[i]);
      return new _Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from2, to = this.size) {
      if (from2 == 0 && to == this.size)
        return this;
      let result = [], size = 0;
      if (to > from2)
        for (let i = 0, pos = 0; pos < to; i++) {
          let child = this.content[i], end2 = pos + child.nodeSize;
          if (end2 > from2) {
            if (pos < from2 || end2 > to) {
              if (child.isText)
                child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
              else
                child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
            }
            result.push(child);
            size += child.nodeSize;
          }
          pos = end2;
        }
      return new _Fragment(result, size);
    }
    /**
    @internal
    */
    cutByIndex(from2, to) {
      if (from2 == to)
        return _Fragment.empty;
      if (from2 == 0 && to == this.content.length)
        return this;
      return new _Fragment(this.content.slice(from2, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index, node) {
      let current = this.content[index];
      if (current == node)
        return this;
      let copy2 = this.content.slice();
      let size = this.size + node.nodeSize - current.nodeSize;
      copy2[index] = node;
      return new _Fragment(copy2, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node) {
      return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node) {
      return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i = 0; i < this.content.length; i++)
        if (!this.content[i].eq(other.content[i]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index) {
      let found2 = this.content[index];
      if (!found2)
        throw new RangeError("Index " + index + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i = 0, p = 0; i < this.content.length; i++) {
        let child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. @internal
    */
    findIndex(pos, round2 = -1) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i = 0, curPos = 0; ; i++) {
        let cur = this.child(i), end2 = curPos + cur.nodeSize;
        if (end2 >= pos) {
          if (end2 == pos || round2 > 0)
            return retIndex(i + 1, end2);
          return retIndex(i, curPos);
        }
        curPos = end2;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value)
        return _Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new _Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return _Fragment.empty;
      let joined, size = 0;
      for (let i = 0; i < array.length; i++) {
        let node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined)
            joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new _Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes)
        return _Fragment.empty;
      if (nodes instanceof _Fragment)
        return nodes;
      if (Array.isArray(nodes))
        return this.fromArray(nodes);
      if (nodes.attrs)
        return new _Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  };
  Fragment.empty = new Fragment([], 0);
  var found = { index: 0, offset: 0 };
  function retIndex(index, offset2) {
    found.index = index;
    found.offset = offset2;
    return found;
  }
  function compareDeep(a, b) {
    if (a === b)
      return true;
    if (!(a && typeof a == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!compareDeep(a[i], b[i]))
          return false;
    } else {
      for (let p in a)
        if (!(p in b) || !compareDeep(a[p], b[p]))
          return false;
      for (let p in b)
        if (!(p in a))
          return false;
    }
    return true;
  }
  var Mark = class _Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set) {
      let copy2, placed = false;
      for (let i = 0; i < set.length; i++) {
        let other = set[i];
        if (this.eq(other))
          return set;
        if (this.type.excludes(other.type)) {
          if (!copy2)
            copy2 = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy2)
              copy2 = set.slice(0, i);
            copy2.push(this);
            placed = true;
          }
          if (copy2)
            copy2.push(other);
        }
      }
      if (!copy2)
        copy2 = set.slice();
      if (!placed)
        copy2.push(this);
      return copy2;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return set.slice(0, i).concat(set.slice(i + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++)
        if (this.eq(set[i]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      let mark = type.create(json.attrs);
      type.checkAttrs(mark.attrs);
      return mark;
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a, b) {
      if (a == b)
        return true;
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++)
        if (!a[i].eq(b[i]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0)
        return _Mark.none;
      if (marks instanceof _Mark)
        return [marks];
      let copy2 = marks.slice();
      copy2.sort((a, b) => a.type.rank - b.type.rank);
      return copy2;
    }
  };
  Mark.none = [];
  var ReplaceError = class extends Error {
  };
  var Slice = class _Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragment—i.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content, openStart, openEnd) {
      this.content = content;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment) {
      let content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new _Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from2, to) {
      return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        return _Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new _Slice(fragment, openStart, openEnd);
    }
  };
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content, from2, to) {
    let { index, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index);
    let { index: indexTo, offset: offsetTo } = content.findIndex(to);
    if (offset2 == from2 || child.isText) {
      if (offsetTo != to && !content.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content.cut(0, from2).append(content.cut(to));
    }
    if (index != indexTo)
      throw new RangeError("Removing non-flat range");
    return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
  }
  function insertInto(content, dist, insert, parent) {
    let { index, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index);
    if (offset2 == dist || child.isText) {
      if (parent && !parent.canReplace(index, index, insert))
        return null;
      return content.cut(0, dist).append(insert).append(content.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset2 - 1, insert);
    return inner && content.replaceChild(index, child.copy(inner));
  }
  function replace($from, $to, slice2) {
    if (slice2.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice2, 0);
  }
  function replaceOuter($from, $to, slice2, depth) {
    let index = $from.index(depth), node = $from.node(depth);
    if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
      let inner = replaceOuter($from, $to, slice2, depth + 1);
      return node.copy(node.content.replaceChild(index, inner));
    } else if (!slice2.content.size) {
      return close(node, replaceTwoWay($from, $to, depth));
    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content = parent.content;
      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
    } else {
      let { start: start3, end: end2 } = prepareSliceForReplace(slice2, $from);
      return close(node, replaceThreeWay($from, start3, end2, $to, depth));
    }
  }
  function checkJoin(main2, sub) {
    if (!sub.type.compatibleContent(main2.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
  }
  function joinable($before, $after, depth) {
    let node = $before.node(depth);
    checkJoin(node, $after.node(depth));
    return node;
  }
  function addNode(child, target) {
    let last = target.length - 1;
    if (last >= 0 && child.isText && child.sameMarkup(target[last]))
      target[last] = child.withText(target[last].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++)
      addNode(node.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node, content) {
    node.type.checkContent(content);
    return node.copy(content);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content = [];
    addRange(null, $from, depth, content);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
      addRange($start, $end, depth, content);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function replaceTwoWay($from, $to, depth) {
    let content = [];
    addRange(null, $from, depth, content);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
    }
    addRange($to, null, depth, content);
    return new Fragment(content);
  }
  function prepareSliceForReplace(slice2, $along) {
    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
    let node = parent.copy(slice2.content);
    for (let i = extra - 1; i >= 0; i--)
      node = $along.node(i).copy(Fragment.from(node));
    return {
      start: node.resolveNoCache(slice2.openStart + extra),
      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
    };
  }
  var ResolvedPos = class _ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.parentOffset = parentOffset;
      this.depth = path.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parent—text nodes are ‘flat’ in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i = 0; i < index; i++)
        pos += node.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index = this.index();
      if (parent.content.size == 0)
        return Mark.none;
      if (this.textOffset)
        return parent.child(index).marks;
      let main2 = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      if (!main2) {
        let tmp = main2;
        main2 = other;
        other = tmp;
      }
      let marks = main2.marks;
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i = 1; i <= this.depth; i++)
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc3, pos) {
      if (!(pos >= 0 && pos <= doc3.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path = [];
      let start3 = 0, parentOffset = pos;
      for (let node = doc3; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(parentOffset);
        let rem = parentOffset - offset2;
        path.push(node, index, start3 + offset2);
        if (!rem)
          break;
        node = node.child(index);
        if (node.isText)
          break;
        parentOffset = rem - 1;
        start3 += offset2 + 1;
      }
      return new _ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc3, pos) {
      let cache2 = resolveCache.get(doc3);
      if (cache2) {
        for (let i = 0; i < cache2.elts.length; i++) {
          let elt = cache2.elts[i];
          if (elt.pos == pos)
            return elt;
        }
      } else {
        resolveCache.set(doc3, cache2 = new ResolveCache());
      }
      let result = cache2.elts[cache2.i] = _ResolvedPos.resolve(doc3, pos);
      cache2.i = (cache2.i + 1) % resolveCacheSize;
      return result;
    }
  };
  var ResolveCache = class {
    constructor() {
      this.elts = [];
      this.i = 0;
    }
  };
  var resolveCacheSize = 12;
  var resolveCache = /* @__PURE__ */ new WeakMap();
  var NodeRange = class {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node2 = class _Node {
    /**
    @internal
    */
    constructor(type, attrs, content, marks = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content || Fragment.empty;
    }
    /**
    The array of this node's child nodes.
    */
    get children() {
      return this.content.content;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from2, to, f, startPos = 0) {
      this.content.nodesBetween(from2, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from2, to, blockSeparator, leafText) {
      return this.content.textBetween(from2, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content = null) {
      if (content == this.content)
        return this;
      return new _Node(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from2, to = this.content.size) {
      if (from2 == 0 && to == this.content.size)
        return this;
      return this.copy(this.content.cut(from2, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from2, to = this.content.size, includeParents = false) {
      if (from2 == to)
        return Slice.empty;
      let $from = this.resolve(from2), $to = this.resolve(to);
      let depth = includeParents ? 0 : $from.sharedDepth(to);
      let start3 = $from.start(depth), node = $from.node(depth);
      let content = node.content.cut($from.pos - start3, $to.pos - start3);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from2, to, slice2) {
      return replace(this.resolve(from2), this.resolve(to), slice2);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node = this; ; ) {
        let { index, offset: offset2 } = node.content.findIndex(pos);
        node = node.maybeChild(index);
        if (!node)
          return null;
        if (offset2 == pos || node.isText)
          return node;
        pos -= offset2 + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index, offset: offset2 } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index), index, offset: offset2 };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index, offset: offset2 } = this.content.findIndex(pos);
      if (offset2 < pos)
        return { node: this.content.child(index), index, offset: offset2 };
      let node = this.content.child(index - 1);
      return { node, index: index - 1, offset: offset2 - node.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from2, to, type) {
      let found2 = false;
      if (to > from2)
        this.nodesBetween(from2, to, (node) => {
          if (type.isInSet(node.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from2, to, replacement = Fragment.empty, start3 = 0, end2 = replacement.childCount) {
      let one = this.contentMatchAt(from2).matchFragment(replacement, start3, end2);
      let two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd)
        return false;
      for (let i = start3; i < end2; i++)
        if (!this.type.allowsMarks(replacement.child(i).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from2, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks))
        return false;
      let start3 = this.contentMatchAt(from2).matchType(type);
      let end2 = start3 && start3.matchFragment(this.content, to);
      return end2 ? end2.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise an exception when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      this.type.checkAttrs(this.attrs);
      let copy2 = Mark.none;
      for (let i = 0; i < this.marks.length; i++) {
        let mark = this.marks[i];
        mark.type.checkAttrs(mark.attrs);
        copy2 = mark.addToSet(copy2);
      }
      if (!Mark.sameSet(copy2, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node) => node.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks = void 0;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content = Fragment.fromJSON(schema, json.content);
      let node = schema.nodeType(json.type).create(json.attrs, content, marks);
      node.type.checkAttrs(node.attrs);
      return node;
    }
  };
  Node2.prototype.text = void 0;
  var TextNode = class _TextNode extends Node2 {
    /**
    @internal
    */
    constructor(type, attrs, content, marks) {
      super(type, attrs, null, marks);
      if (!content)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = content;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(from2, to) {
      return this.text.slice(from2, to);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(marks) {
      return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
    }
    withText(text) {
      if (text == this.text)
        return this;
      return new _TextNode(this.type, this.attrs, text, this.marks);
    }
    cut(from2 = 0, to = this.text.length) {
      if (from2 == 0 && to == this.text.length)
        return this;
      return this.withText(this.text.slice(from2, to));
    }
    eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
      let base2 = super.toJSON();
      base2.text = this.text;
      return base2;
    }
  };
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = class _ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string, nodeTypes) {
      let stream = new TokenStream(string, nodeTypes);
      if (stream.next == null)
        return _ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i = 0; i < this.next.length; i++)
        if (this.next[i].type == type)
          return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start3 = 0, end2 = frag.childCount) {
      let cur = this;
      for (let i = start3; cur && i < end2; i++)
        cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i = 0; i < this.next.length; i++) {
        let { type } = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i = 0; i < this.next.length; i++)
        for (let j = 0; j < other.next.length; j++)
          if (this.next[i].type == other.next[j].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            let found2 = search(next, types.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i = 0; i < this.wrapCache.length; i += 2)
        if (this.wrapCache[i] == target)
          return this.wrapCache[i + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i = 0; i < match.next.length; i++) {
          let { type, next } = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_​th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i = 0; i < m.next.length; i++)
          if (seen.indexOf(m.next[i].next) == -1)
            scan(m.next[i].next);
      }
      scan(this);
      return seen.map((m, i) => {
        let out = i + (m.validEnd ? "*" : " ") + " ";
        for (let i2 = 0; i2 < m.next.length; i2++)
          out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
        return out;
      }).join("\n");
    }
  };
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = class {
    constructor(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  };
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.isInGroup(name))
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile(expr, 0), node());
    return nfa2;
    function node() {
      return nfa2.push([]) - 1;
    }
    function edge(from2, to, term) {
      let edge2 = { term, to };
      nfa2[from2].push(edge2);
      return edge2;
    }
    function connect(edges, to) {
      edges.forEach((edge2) => edge2.to = to);
    }
    function compile(expr2, from2) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next = compile(expr2.exprs[i], from2);
          if (i == expr2.exprs.length - 1)
            return next;
          connect(next, from2 = node());
        }
      } else if (expr2.type == "star") {
        let loop = node();
        edge(from2, loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node();
        connect(compile(expr2.expr, from2), loop);
        connect(compile(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from2)].concat(compile(expr2.expr, from2));
      } else if (expr2.type == "range") {
        let cur = from2;
        for (let i = 0; i < expr2.min; i++) {
          let next = node();
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
        if (expr2.max == -1) {
          connect(compile(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next = node();
            edge(cur, next);
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from2, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a, b) {
    return b - a;
  }
  function nullFrom(nfa2, node) {
    let result = [];
    scan(node);
    return result.sort(cmp);
    function scan(node2) {
      let edges = nfa2[node2];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node2);
      for (let i = 0; i < edges.length; i++) {
        let { term, to } = edges[i];
        if (!term && result.indexOf(to) == -1)
          scan(to);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node) => {
        nfa2[node].forEach(({ term, to }) => {
          if (!term)
            return;
          let set;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term)
              set = out[i][1];
          nullFrom(nfa2, to).forEach((node2) => {
            if (!set)
              out.push([term, set = []]);
            if (set.indexOf(node2) == -1)
              set.push(node2);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i], dead = !state.validEnd, nodes = [];
      for (let j = 0; j < state.next.length; j++) {
        let { type, next } = state.next[j];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next) == -1)
          work.push(next);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults[attrName] = attr.default;
    }
    return defaults;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function checkAttrs(attrs, values, type, name) {
    for (let name2 in values)
      if (!(name2 in attrs))
        throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
    for (let name2 in attrs) {
      let attr = attrs[name2];
      if (attr.validate)
        attr.validate(values[name2]);
    }
  }
  function initAttrs(typeName, attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(typeName, name, attrs[name]);
    return result;
  }
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(name, spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    Return true when this node type is part of the given
    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
    */
    isInGroup(group) {
      return this.groups.indexOf(group) > -1;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let n in this.attrs)
        if (this.attrs[n].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs)
        return this.defaultAttrs;
      else
        return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content, marks) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content, marks) {
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content, marks) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        let before = this.contentMatch.fillBefore(content);
        if (!before)
          return null;
        content = before.append(content);
      }
      let matched = this.contentMatch.matchFragment(content);
      let after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after)
        return null;
      return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type.
    */
    validContent(content) {
      let result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd)
        return false;
      for (let i = 0; i < content.childCount; i++)
        if (!this.allowsMarks(content.child(i).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(content) {
      if (!this.validContent(content))
        throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "node", this.name);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks) {
      if (this.markSet == null)
        return true;
      for (let i = 0; i < marks.length; i++)
        if (!this.allowsMarkType(marks[i].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks) {
      if (this.markSet == null)
        return marks;
      let copy2;
      for (let i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy2)
            copy2 = marks.slice(0, i);
        } else if (copy2) {
          copy2.push(marks[i]);
        }
      }
      return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
    }
    /**
    @internal
    */
    static compile(nodes, schema) {
      let result = /* @__PURE__ */ Object.create(null);
      nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
      let topType = schema.spec.topNode || "doc";
      if (!result[topType])
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let _ in result.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return result;
    }
  };
  function validateType(typeName, attrName, type) {
    let types = type.split("|");
    return (value) => {
      let name = value === null ? "null" : typeof value;
      if (types.indexOf(name) < 0)
        throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
    };
  }
  var Attribute = class {
    constructor(typeName, attrName, options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
      this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  };
  var MarkType = class _MarkType {
    /**
    @internal
    */
    constructor(name, rank, schema, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(name, spec.attrs);
      this.excluded = null;
      let defaults = defaultAttrs(this.attrs);
      this.instance = defaults ? new Mark(this, defaults) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
      if (!attrs && this.instance)
        return this.instance;
      return new Mark(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks, schema) {
      let result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
      return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set) {
      for (var i = 0; i < set.length; i++)
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      return set;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set) {
      for (let i = 0; i < set.length; i++)
        if (set[i].type == this)
          return set[i];
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "mark", this.name);
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  };
  var Schema = class {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
      this.linebreakReplacement = null;
      this.cached = /* @__PURE__ */ Object.create(null);
      let instanceSpec = this.spec = {};
      for (let prop in spec)
        instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      let contentExprCache = /* @__PURE__ */ Object.create(null);
      for (let prop in this.nodes) {
        if (prop in this.marks)
          throw new RangeError(prop + " can not be both a node and a mark");
        let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        if (type.spec.linebreakReplacement) {
          if (this.linebreakReplacement)
            throw new RangeError("Multiple linebreak nodes defined");
          if (!type.isInline || !type.isLeaf)
            throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = type;
        }
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (let prop in this.marks) {
        let type = this.marks[prop], excl = type.spec.excludes;
        type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content, marks) {
      if (typeof type == "string")
        type = this.nodeType(type);
      else if (!(type instanceof NodeType))
        throw new RangeError("Invalid node type: " + type);
      else if (type.schema != this)
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text, marks) {
      let type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
      if (typeof type == "string")
        type = this.marks[type];
      return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json) {
      return Node2.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
    /**
    @internal
    */
    nodeType(name) {
      let found2 = this.nodes[name];
      if (!found2)
        throw new RangeError("Unknown node type: " + name);
      return found2;
    }
  };
  function gatherMarks(schema, marks) {
    let found2 = [];
    for (let i = 0; i < marks.length; i++) {
      let name = marks[i], mark = schema.marks[name], ok = mark;
      if (mark) {
        found2.push(mark);
      } else {
        for (let prop in schema.marks) {
          let mark2 = schema.marks[prop];
          if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok = mark2);
        }
      }
      if (!ok)
        throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
    }
    return found2;
  }
  function isTagRule(rule) {
    return rule.tag != null;
  }
  function isStyleRule(rule) {
    return rule.style != null;
  }
  var DOMParser2 = class _DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      let matchedStyles = this.matchedStyles = [];
      rules.forEach((rule) => {
        if (isTagRule(rule)) {
          this.tags.push(rule);
        } else if (isStyleRule(rule)) {
          let prop = /[^=]*/.exec(rule.style)[0];
          if (matchedStyles.indexOf(prop) < 0)
            matchedStyles.push(prop);
          this.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node = schema.nodes[r.node];
        return node.contentMatch.matchType(node);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options = {}) {
      let context = new ParseContext(this, options, false);
      context.addAll(dom, Mark.none, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options = {}) {
      let context = new ParseContext(this, options, true);
      context.addAll(dom, Mark.none, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        let rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        let rule = this.styles[i], style2 = rule.style;
        if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.mark || rule.ignore || rule.clearMark))
              rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.node || rule.ignore || rule.mark))
              rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
    }
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1;
  var OPT_PRESERVE_WS_FULL = 2;
  var OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base2) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
  }
  var NodeContext = class {
    constructor(type, attrs, marks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.solid = solid;
      this.options = options;
      this.content = [];
      this.activeMarks = Mark.none;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start3 = this.type.contentMatch, wrap2;
          if (wrap2 = start3.findWrapping(node.type)) {
            this.match = start3;
            return wrap2;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          let text = last;
          if (last.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }
      let content = Fragment.from(this.content);
      if (!openEnd && this.match)
        content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
    inlineContext(node) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  };
  var ParseContext = class {
    constructor(parser, options, isOpen) {
      this.parser = parser;
      this.options = options;
      this.isOpen = isOpen;
      this.open = 0;
      this.localPreserveWS = false;
      let topNode = options.topNode, topContext;
      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom, marks) {
      if (dom.nodeType == 3)
        this.addTextNode(dom, marks);
      else if (dom.nodeType == 1)
        this.addElement(dom, marks);
    }
    addTextNode(dom, marks) {
      let value = dom.nodeValue;
      let top2 = this.top, preserveWS = top2.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top2.options & OPT_PRESERVE_WS) > 0;
      if (preserveWS === "full" || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!preserveWS) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top2.content[top2.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (preserveWS !== "full") {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, marks, matchAfter) {
      let outerWS = this.localPreserveWS, top2 = this.top;
      if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
        this.localPreserveWS = true;
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top2.content.length && top2.content[0].isInline && this.open) {
            this.open--;
            top2 = this.top;
          }
          sync = true;
          if (!top2.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top2);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
      }
      this.localPreserveWS = outerWS;
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom, marks) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
    }
    // Called for ignored nodes
    ignoreFallback(dom, marks) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"), marks, true);
    }
    // Run any style parser associated with the node's styles. Either
    // return an updated array of marks, or null to indicate some of the
    // styles had a rule with `ignore` set.
    readStyles(dom, marks) {
      let styles = dom.style;
      if (styles && styles.length)
        for (let i = 0; i < this.parser.matchedStyles.length; i++) {
          let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
          if (value)
            for (let after = void 0; ; ) {
              let rule = this.parser.matchStyle(name, value, this, after);
              if (!rule)
                break;
              if (rule.ignore)
                return null;
              if (rule.clearMark)
                marks = marks.filter((m) => !rule.clearMark(m));
              else
                marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
              if (rule.consuming === false)
                after = rule;
              else
                break;
            }
        }
      return marks;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, marks, continueAfter) {
      let sync, nodeType;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
          if (inner) {
            sync = true;
            marks = inner;
          }
        } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
          this.leafFallback(dom, marks);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        marks = marks.concat(markType.create(rule.attrs));
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, marks, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, marks);
        this.findAround(dom, contentDOM, false);
      }
      if (sync && this.sync(startIn))
        this.open--;
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, marks, startIndex, endIndex) {
      let index = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom, marks);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node, marks, cautious) {
      let route, sync;
      for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node);
        if (found2 && (!route || route.length > found2.length + penalty)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid) {
          if (cautious)
            break;
          penalty += 2;
        }
      }
      if (!route)
        return null;
      this.sync(sync);
      for (let i = 0; i < route.length; i++)
        marks = this.enterInner(route[i], null, marks, false);
      return marks;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node, marks, cautious) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block)
          marks = this.enterInner(block, null, marks);
      }
      let innerMarks = this.findPlace(node, marks, cautious);
      if (innerMarks) {
        this.closeExtra();
        let top2 = this.top;
        if (top2.match)
          top2.match = top2.match.matchType(node.type);
        let nodeMarks = Mark.none;
        for (let m of innerMarks.concat(node.marks))
          if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
            nodeMarks = m.addToSet(nodeMarks);
        top2.content.push(node.mark(nodeMarks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, marks, preserveWS) {
      let innerMarks = this.findPlace(type.create(attrs), marks, false);
      if (innerMarks)
        innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
      return innerMarks;
    }
    // Open a node of the given type
    enterInner(type, attrs, marks, solid = false, preserveWS) {
      this.closeExtra();
      let top2 = this.top;
      top2.match = top2.match && top2.match.matchType(type);
      let options = wsOptionsFor(type, preserveWS, top2.options);
      if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
        options |= OPT_OPEN_LEFT;
      let applyMarks = Mark.none;
      marks = marks.filter((m) => {
        if (top2.type ? top2.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
          applyMarks = m.addToSet(applyMarks);
          return false;
        }
        return true;
      });
      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
      this.open++;
      return marks;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--)
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
    }
    sync(to) {
      for (let i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        } else if (this.localPreserveWS) {
          this.nodes[i].options |= OPT_PRESERVE_WS;
        }
      }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i = this.open; i >= 0; i--) {
        let content = this.nodes[i].content;
        for (let j = content.length - 1; j >= 0; j--)
          pos += content[j].nodeSize;
        if (i)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset2) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset2)
            this.find[i].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
            this.find[i].pos = this.currentPos;
        }
    }
    findAround(parent, content, before) {
      if (parent != content && this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            let pos = content.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4))
              this.find[i].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode)
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option = this.options.context;
      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i, depth) => {
        for (; i >= 0; i--) {
          let part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i - 1, depth))
                return true;
            return false;
          } else {
            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && !next.isInGroup(part))
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
  };
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function copy(obj) {
    let copy2 = {};
    for (let prop in obj)
      copy2[prop] = obj[prop];
    return copy2;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i = 0; i < match.edgeCount; i++) {
          let { type, next } = match.edge(i);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next) < 0 && scan(next))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  var DOMSerializer = class _DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes, marks) {
      this.nodes = nodes;
      this.marks = marks;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment, options = {}, target) {
      if (!target)
        target = doc(options).createDocumentFragment();
      let top2 = target, active = [];
      fragment.forEach((node) => {
        if (active.length || node.marks.length) {
          let keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            let next = node.marks[rendered];
            if (!this.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
              break;
            keep++;
            rendered++;
          }
          while (keep < active.length)
            top2 = active.pop()[1];
          while (rendered < node.marks.length) {
            let add3 = node.marks[rendered++];
            let markDOM = this.serializeMark(add3, node.isInline, options);
            if (markDOM) {
              active.push([add3, top2]);
              top2.appendChild(markDOM.dom);
              top2 = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top2.appendChild(this.serializeNodeInner(node, options));
      });
      return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node, options) {
      let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
      if (contentDOM) {
        if (node.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node, options = {}) {
      let dom = this.serializeNodeInner(node, options);
      for (let i = node.marks.length - 1; i >= 0; i--) {
        let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
        if (wrap2) {
          (wrap2.contentDOM || wrap2.dom).appendChild(dom);
          dom = wrap2.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
    serializeMark(mark, inline, options = {}) {
      let toDOM = this.marks[mark.type.name];
      return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
    }
    static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
      return renderSpec(doc3, structure, xmlNS, blockArraysIn);
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema) {
      let result = gatherToDOM(schema.nodes);
      if (!result.text)
        result.text = (node) => node.text;
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  };
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc(options) {
    return options.document || window.document;
  }
  var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
  function suspiciousAttributes(attrs) {
    let value = suspiciousAttributeCache.get(attrs);
    if (value === void 0)
      suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
    return value;
  }
  function suspiciousAttributesInner(attrs) {
    let result = null;
    function scan(value) {
      if (value && typeof value == "object") {
        if (Array.isArray(value)) {
          if (typeof value[0] == "string") {
            if (!result)
              result = [];
            result.push(value);
          } else {
            for (let i = 0; i < value.length; i++)
              scan(value[i]);
          }
        } else {
          for (let prop in value)
            scan(value[prop]);
        }
      }
    }
    scan(attrs);
    return result;
  }
  function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
    if (typeof structure == "string")
      return { dom: doc3.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], suspicious;
    if (typeof tagName != "string")
      throw new RangeError("Invalid array passed to renderSpec");
    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
      throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
    let attrs = structure[1], start3 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start3 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space2 = name.indexOf(" ");
          if (space2 > 0)
            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start3; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start3)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }

  // node_modules/prosemirror-transform/dist/index.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index, offset2) {
    return index + offset2 * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1;
  var DEL_AFTER = 2;
  var DEL_ACROSS = 4;
  var DEL_SIDE = 8;
  var MapResult = class {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  };
  var StepMap = class _StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && _StepMap.empty)
        return _StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index = recoverIndex(value);
      if (!this.inverted)
        for (let i = 0; i < index; i++)
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start3 = this.ranges[i] - (this.inverted ? diff : 0);
        if (start3 > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start3 + oldSize;
        if (pos <= end2) {
          let side = !oldSize ? assoc : pos == start3 ? -1 : pos == end2 ? 1 : assoc;
          let result = start3 + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start3 : end2) ? null : makeRecover(i / 3, pos - start3);
          let del3 = pos == start3 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start3 : pos != end2)
            del3 |= DEL_SIDE;
          return new MapResult(result, del3, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start3 = this.ranges[i] - (this.inverted ? diff : 0);
        if (start3 > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], end2 = start3 + oldSize;
        if (pos <= end2 && i == index * 3)
          return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
        let start3 = this.ranges[i], oldStart = start3 - (this.inverted ? diff : 0), newStart = start3 + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new _StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  };
  StepMap.empty = new StepMap([]);
  var Mapping = class _Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
      this.mirror = mirror;
      this.from = from2;
      this.to = to;
      this._maps = maps || [];
      this.ownData = !(maps || mirror);
    }
    /**
    The step maps in this mapping.
    */
    get maps() {
      return this._maps;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from2 = 0, to = this.maps.length) {
      return new _Mapping(this._maps, this.mirror, from2, to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map2, mirrors) {
      if (!this.ownData) {
        this._maps = this._maps.slice();
        this.mirror = this.mirror && this.mirror.slice();
        this.ownData = true;
      }
      this.to = this._maps.push(map2);
      if (mirrors != null)
        this.setMirror(this._maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
      for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
      if (this.mirror) {
        for (let i = 0; i < this.mirror.length; i++)
          if (this.mirror[i] == n)
            return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(n, m) {
      if (!this.mirror)
        this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
      for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let inverse = new _Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
      if (this.mirror)
        return this._map(pos, assoc, true);
      for (let i = this.from; i < this.to; i++)
        pos = this._maps[i].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let delInfo = 0;
      for (let i = this.from; i < this.to; i++) {
        let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
        if (result.recover != null) {
          let corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this._maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  };
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = class {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id, stepClass) {
      if (id in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  };
  var StepResult = class _StepResult {
    /**
    @internal
    */
    constructor(doc3, failed) {
      this.doc = doc3;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc3) {
      return new _StepResult(doc3, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new _StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc3, from2, to, slice2) {
      try {
        return _StepResult.ok(doc3.replace(from2, to, slice2));
      } catch (e) {
        if (e instanceof ReplaceError)
          return _StepResult.fail(e.message);
        throw e;
      }
    }
  };
  function mapFragment(fragment, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment.childCount; i++) {
      let child = fragment.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = class _AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from2, to, mark) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark;
    }
    apply(doc3) {
      let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node;
        return node.mark(this.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc3, this.from, this.to, slice2);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new _AddMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = class _RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from2, to, mark) {
      super();
      this.from = from2;
      this.to = to;
      this.mark = mark;
    }
    apply(doc3) {
      let oldSlice = doc3.slice(this.from, this.to);
      let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
        return node.mark(this.mark.removeFromSet(node.marks));
      }, doc3), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc3, this.from, this.to, slice2);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deleted && to.deleted || from2.pos >= to.pos)
        return null;
      return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (node) {
        let newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (let i = 0; i < node.marks.length; i++)
            if (!node.marks[i].isInSet(newSet))
              return new _AddNodeMarkStep(this.pos, node.marks[i]);
          return new _AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark) {
      super();
      this.pos = pos;
      this.mark = mark;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at mark step's position");
      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    invert(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = class _ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`—the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from2, to, slice2, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.slice = slice2;
      this.structure = structure;
    }
    apply(doc3) {
      if (this.structure && contentBetween(doc3, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc3) {
      return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      if (from2.deletedAcross && to.deletedAcross)
        return null;
      return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
    }
    merge(other) {
      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new _ReplaceStep(other.from, this.to, slice2, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  };
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
      super();
      this.from = from2;
      this.to = to;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice2;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc3) {
      if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc3.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc3, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc3) {
      let gap = this.gapTo - this.gapFrom;
      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
      let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
      let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
      if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
        return null;
      return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  };
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc3, from2, to) {
    let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next || next.isLeaf)
          return true;
        next = next.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr, from2, to, mark) {
    let removed = [], added = [];
    let removing, adding;
    tr.doc.nodesBetween(from2, to, (node, pos, parent) => {
      if (!node.isInline)
        return;
      let marks = node.marks;
      if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
        let start3 = Math.max(pos, from2), end2 = Math.min(pos + node.nodeSize, to);
        let newSet = mark.addToSet(marks);
        for (let i = 0; i < marks.length; i++) {
          if (!marks[i].isInSet(newSet)) {
            if (removing && removing.to == start3 && removing.mark.eq(marks[i]))
              removing.to = end2;
            else
              removed.push(removing = new RemoveMarkStep(start3, end2, marks[i]));
          }
        }
        if (adding && adding.to == start3)
          adding.to = end2;
        else
          added.push(adding = new AddMarkStep(start3, end2, mark));
      }
    });
    removed.forEach((s) => tr.step(s));
    added.forEach((s) => tr.step(s));
  }
  function removeMark(tr, from2, to, mark) {
    let matched = [], step = 0;
    tr.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark instanceof MarkType) {
        let set = node.marks, found2;
        while (found2 = mark.isInSet(set)) {
          (toRemove || (toRemove = [])).push(found2);
          set = found2.removeFromSet(set);
        }
      } else if (mark) {
        if (mark.isInSet(node.marks))
          toRemove = [mark];
      } else {
        toRemove = node.marks;
      }
      if (toRemove && toRemove.length) {
        let end2 = Math.min(pos + node.nodeSize, to);
        for (let i = 0; i < toRemove.length; i++) {
          let style2 = toRemove[i], found2;
          for (let j = 0; j < matched.length; j++) {
            let m = matched[j];
            if (m.step == step - 1 && style2.eq(matched[j].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end2;
            found2.step = step;
          } else {
            matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
          }
        }
      }
    });
    matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
    let node = tr.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i = 0; i < node.childCount; i++) {
      let child = node.child(i), end2 = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
      } else {
        match = allowed;
        for (let j = 0; j < child.marks.length; j++)
          if (!parentType.allowsMarkType(child.marks[j].type))
            tr.step(new RemoveMarkStep(cur, end2, child.marks[j]));
        if (clearNewlines && child.isText && parentType.whitespace != "pre") {
          let m, newline = /\r?\n|\r/g, slice2;
          while (m = newline.exec(child.text)) {
            if (!slice2)
              slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
          }
        }
      }
      cur = end2;
    }
    if (!match.validEnd) {
      let fill = match.fillBefore(Fragment.empty, true);
      tr.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i = replSteps.length - 1; i >= 0; i--)
      tr.step(replSteps[i]);
  }
  function canCut(node, start3, end2) {
    return (start3 == 0 || node.canReplace(start3, node.childCount)) && (end2 == node.childCount || node.canReplace(0, end2));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node = range.$from.node(depth);
      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node.canReplace(index, endIndex, content))
        return depth;
      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
        break;
    }
    return null;
  }
  function lift(tr, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start3 = gapStart, end2 = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start3--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end2++;
      }
    tr.step(new ReplaceAroundStep(start3, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around2 = findWrappingOutside(range, nodeType);
    let inner = around2 && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around2.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around2 = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around2)
      return null;
    let outer = around2.length ? around2[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around2 : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap(tr, range, wrappers) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--) {
      if (content.size) {
        let match = wrappers[i].type.contentMatch.matchFragment(content);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    }
    let start3 = range.start, end2 = range.end;
    tr.step(new ReplaceAroundStep(start3, end2, start3, end2, new Slice(content, 0, 0), wrappers.length, true));
  }
  function setBlockType(tr, from2, to, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr.steps.length;
    tr.doc.nodesBetween(from2, to, (node, pos) => {
      let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
      if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
        let convertNewlines = null;
        if (type.schema.linebreakReplacement) {
          let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
          if (pre && !supportLinebreak)
            convertNewlines = false;
          else if (!pre && supportLinebreak)
            convertNewlines = true;
        }
        if (convertNewlines === false)
          replaceLinebreaks(tr, node, pos, mapFrom);
        clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
        let mapping = tr.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
        if (convertNewlines === true)
          replaceNewlines(tr, node, pos, mapFrom);
        return false;
      }
    });
  }
  function replaceNewlines(tr, node, pos, mapFrom) {
    node.forEach((child, offset2) => {
      if (child.isText) {
        let m, newline = /\r?\n|\r/g;
        while (m = newline.exec(child.text)) {
          let start3 = tr.mapping.slice(mapFrom).map(pos + 1 + offset2 + m.index);
          tr.replaceWith(start3, start3 + 1, node.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function replaceLinebreaks(tr, node, pos, mapFrom) {
    node.forEach((child, offset2) => {
      if (child.type == child.type.schema.linebreakReplacement) {
        let start3 = tr.mapping.slice(mapFrom).map(pos + 1 + offset2);
        tr.replaceWith(start3, start3 + 1, node.type.schema.text("\n"));
      }
    });
  }
  function canChangeType(doc3, pos, type) {
    let $pos = doc3.resolve(pos), index = $pos.index();
    return $pos.parent.canReplaceWith(index, index + 1, type);
  }
  function setNodeMarkup(tr, pos, type, attrs, marks) {
    let node = tr.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at given position");
    if (!type)
      type = node.type;
    let newNode = type.create(attrs, null, marks || node.marks);
    if (node.isLeaf)
      return tr.replaceWith(pos, pos + node.nodeSize, newNode);
    if (!type.validContent(node.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc3, pos, depth = 1, typesAfter) {
    let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
      let node = $pos.node(d), index2 = $pos.index(d);
      if (node.type.spec.isolating)
        return false;
      let rest = node.content.cutByIndex(index2, node.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i] || node;
      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index = $pos.indexAfter(base2);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
  }
  function split(tr, pos, depth = 1, typesAfter) {
    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc3, pos) {
    let $pos = doc3.resolve(pos), index = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
  }
  function canAppendWithSubstitutedLinebreaks(a, b) {
    if (!b.content.size)
      a.type.compatibleContent(b.type);
    let match = a.contentMatchAt(a.childCount);
    let { linebreakReplacement } = a.type.schema;
    for (let i = 0; i < b.childCount; i++) {
      let child = b.child(i);
      let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
      match = match.matchType(type);
      if (!match)
        return false;
      if (!a.type.allowsMarks(child.marks))
        return false;
    }
    return match.validEnd;
  }
  function joinable2(a, b) {
    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
  }
  function joinPoint(doc3, pos, dir = -1) {
    let $pos = doc3.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index++;
        after = $pos.node(d).maybeChild(index);
      } else {
        before = $pos.node(d).maybeChild(index - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function join(tr, pos, depth) {
    let convertNewlines = null;
    let { linebreakReplacement } = tr.doc.type.schema;
    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
    if (linebreakReplacement && beforeType.inlineContent) {
      let pre = beforeType.whitespace == "pre";
      let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
      if (pre && !supportLinebreak)
        convertNewlines = false;
      else if (!pre && supportLinebreak)
        convertNewlines = true;
    }
    let mapFrom = tr.steps.length;
    if (convertNewlines === false) {
      let $after = tr.doc.resolve(pos + depth);
      replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
    }
    if (beforeType.inlineContent)
      clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
    let mapping = tr.mapping.slice(mapFrom), start3 = mapping.map(pos - depth);
    tr.step(new ReplaceStep(start3, mapping.map(pos + depth, -1), Slice.empty, true));
    if (convertNewlines === true) {
      let $full = tr.doc.resolve(start3);
      replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
    }
    return tr;
  }
  function insertPoint(doc3, pos, nodeType) {
    let $pos = doc3.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.before(d + 1);
        if (index > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index, index, nodeType))
          return $pos.after(d + 1);
        if (index < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc3, pos, slice2) {
    let $pos = doc3.resolve(pos);
    if (!slice2.content.size)
      return pos;
    let content = slice2.content;
    for (let i = 0; i < slice2.openStart; i++)
      content = content.firstChild.content;
    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
    if (from2 == to && !slice2.size)
      return null;
    let $from = doc3.resolve(from2), $to = doc3.resolve(to);
    if (fitsTrivially($from, $to, slice2))
      return new ReplaceStep(from2, to, slice2);
    return new Fitter($from, $to, slice2).fit();
  }
  function fitsTrivially($from, $to, slice2) {
    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
  }
  var Fitter = class {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i = 0; i <= $from.depth; i++) {
        let node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i))
        });
      }
      for (let i = $from.depth; i > 0; i--)
        this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice2 = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
      if (slice2.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice2);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          let first2 = fragment.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
            if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap2)
        for (let i = 0; i < wrap2.length; i++)
          this.openFrontierNode(wrap2[i]);
      let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
      let openStart = slice2.openStart - sliceDepth;
      let taken = 0, add3 = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i = 0; i < inject.childCount; i++)
          add3.push(inject.child(i));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
      while (taken < fragment.childCount) {
        let next = fragment.child(taken), matches2 = match.matchType(next.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches2;
          add3.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i = 0, cur = fragment; i < openEndCount; i++) {
        let node = cur.lastChild;
        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
        cur = node.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top2 = this.frontier[this.depth], level;
      if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node = $to.node(d), add3 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add3);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content) {
      let top2 = this.frontier[this.depth];
      top2.match = top2.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add3 = open.match.fillBefore(Fragment.empty, true);
      if (add3.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add3);
    }
  };
  function dropFromFragment(fragment, depth, count) {
    if (depth == 0)
      return fragment.cutByIndex(count, fragment.childCount);
    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment, depth, content) {
    if (depth == 0)
      return fragment.append(content);
    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
  }
  function contentAt(fragment, depth) {
    for (let i = 0; i < depth; i++)
      fragment = fragment.firstChild.content;
    return fragment;
  }
  function closeNodeStart(node, openStart, openEnd) {
    if (openStart <= 0)
      return node;
    let frag = node.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index == node.childCount && !type.compatibleContent(node.type))
      return null;
    let fit = match.fillBefore(node.content, true, index);
    return fit && !invalidMarks(type, node.content, index) ? fit : null;
  }
  function invalidMarks(type, fragment, start3) {
    for (let i = start3; i < fragment.childCount; i++)
      if (!type.allowsMarks(fragment.child(i).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr, from2, to, slice2) {
    if (!slice2.size)
      return tr.deleteRange(from2, to);
    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
    if (fitsTrivially($from, $to, slice2))
      return tr.step(new ReplaceStep(from2, to, slice2));
    let targetDepths = coveredDepths($from, tr.doc.resolve(to));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice2.openStart;
    for (let content = slice2.content, i = 0; ; i++) {
      let node = content.firstChild;
      leftNodes.push(node);
      if (i == slice2.openStart)
        break;
      content = node.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j = slice2.openStart; j >= 0; j--) {
      let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i = 0; i < targetDepths.length; i++) {
        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index, index, insert.type, insert.marks))
          return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
      }
    }
    let startSteps = tr.steps.length;
    for (let i = targetDepths.length - 1; i >= 0; i--) {
      tr.replace(from2, to, slice2);
      if (tr.steps.length > startSteps)
        break;
      let depth = targetDepths[i];
      if (depth < 0)
        continue;
      from2 = $from.before(depth);
      to = $to.after(depth);
    }
  }
  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first2 = fragment.firstChild;
      fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start3 = match.fillBefore(fragment).append(fragment);
      fragment = start3.append(match.matchFragment(start3).fillBefore(Fragment.empty, true));
    }
    return fragment;
  }
  function replaceRangeWith(tr, from2, to, node) {
    if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
      let point = insertPoint(tr.doc, from2, node.type);
      if (point != null)
        from2 = to = point;
    }
    tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
  }
  function deleteRange(tr, from2, to) {
    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
    let covered = coveredDepths($from, $to);
    for (let i = 0; i < covered.length; i++) {
      let depth = covered[i], last = i == covered.length - 1;
      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
        return tr.delete($from.before(d), to);
    }
    tr.delete(from2, to);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start3 = $from.start(d);
      if (start3 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start3 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start3 - 1)
        result.push(d);
    }
    return result;
  }
  var AttrStep = class _AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc3) {
      let node = doc3.nodeAt(this.pos);
      if (!node)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node.attrs)
        attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc3) {
      return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new _AttrStep(json.pos, json.attr, json.value);
    }
  };
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = class _DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc3) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc3.attrs)
        attrs[name] = doc3.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc3) {
      return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new _DocAttrStep(json.attr, json.value);
    }
  };
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  var Transform = class {
    /**
    Create a transform that starts with the given document.
    */
    constructor(doc3) {
      this.doc = doc3;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
      let result = this.maybeStep(step);
      if (result.failed)
        throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
      let result = step.apply(this.doc);
      if (!result.failed)
        this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc3) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc3;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from2, to = from2, slice2 = Slice.empty) {
      let step = replaceStep(this.doc, from2, to, slice2);
      if (step)
        this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from2, to, content) {
      return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from2, to) {
      return this.replace(from2, to, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from2, to, slice2) {
      replaceRange(this, from2, to, slice2);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from2, to, node) {
      replaceRangeWith(this, from2, to, node);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from2, to) {
      deleteRange(this, from2, to);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
      lift(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
      join(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
      wrap(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from2, to = from2, type, attrs = null) {
      setBlockType(this, from2, to, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks) {
      setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Remove a mark (or all marks of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(pos, mark) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      if (mark instanceof Mark) {
        if (mark.isInSet(node.marks))
          this.step(new RemoveNodeMarkStep(pos, mark));
      } else {
        let set = node.marks, found2, steps = [];
        while (found2 = mark.isInSet(set)) {
          steps.push(new RemoveNodeMarkStep(pos, found2));
          set = found2.removeFromSet(set);
        }
        for (let i = steps.length - 1; i >= 0; i--)
          this.step(steps[i]);
      }
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split (with the outermost nodes coming first).
    */
    split(pos, depth = 1, typesAfter) {
      split(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from2, to, mark) {
      addMark(this, from2, to, mark);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from2, to, mark) {
      removeMark(this, from2, to, mark);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
      clearIncompatible(this, pos, parentType, match);
      return this;
    }
  };

  // node_modules/prosemirror-state/dist/index.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = class {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++)
        if (ranges[i].$from.pos != ranges[i].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr, content = Slice.empty) {
      let lastNode = content.content.lastChild, lastParent = null;
      for (let i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
        if (i == 0)
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr, node) {
      let mapFrom = tr.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
        let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from2, to);
        } else {
          tr.replaceRangeWith(from2, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc3) {
      return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc3) {
      return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc3, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc3, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id, selectionClass) {
      if (id in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Selection.prototype.visible = true;
  var SelectionRange = class {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  var TextSelection = class _TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc3, mapping) {
      let $head = doc3.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc3.resolve(mapping.map(this.anchor));
      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr, content = Slice.empty) {
      super.replace(tr, content);
      if (content == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks)
          tr.ensureMarks(marks);
      }
    }
    eq(other) {
      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc3, anchor, head = anchor) {
      let $anchor = doc3.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new _TextSelection($anchor, $head);
    }
  };
  Selection.jsonID("text", TextSelection);
  var TextBookmark = class _TextBookmark {
    constructor(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    }
    map(mapping) {
      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc3) {
      return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
    }
  };
  var NodeSelection = class _NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
      super($pos, $end);
      this.node = node;
    }
    map(doc3, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc3.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new _NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof _NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new _NodeSelection(doc3.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc3, from2) {
      return new _NodeSelection(doc3.resolve(from2));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  };
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = class _NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
    }
    resolve(doc3) {
      let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  };
  var AllSelection = class _AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc3) {
      super(doc3.resolve(0), doc3.resolve(doc3.content.size));
    }
    replace(tr, content = Slice.empty) {
      if (content == Slice.empty) {
        tr.delete(0, tr.doc.content.size);
        let sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection))
          tr.setSelection(sel);
      } else {
        super.replace(tr, content);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc3) {
      return new _AllSelection(doc3);
    }
    map(doc3) {
      return new _AllSelection(doc3);
    }
    eq(other) {
      return other instanceof _AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  };
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map() {
      return this;
    },
    resolve(doc3) {
      return new AllSelection(doc3);
    }
  };
  function findSelectionIn(doc3, node, pos, index, dir, text = false) {
    if (node.inlineContent)
      return TextSelection.create(doc3, pos);
    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
      let child = node.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
        if (inner)
          return inner;
      } else if (!text && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr, startLen, bias) {
    let last = tr.steps.length - 1;
    if (last < startLen)
      return;
    let step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map2 = tr.mapping.maps[last], end2;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 == null)
        end2 = newTo;
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
  }
  var UPDATED_SEL = 1;
  var UPDATED_MARKS = 2;
  var UPDATED_SCROLL = 4;
  var Transaction = class extends Transform {
    /**
    @internal
    */
    constructor(state) {
      super(state.doc);
      this.curSelectionFor = 0;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
      if (selection.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks) {
      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
        this.setStoredMarks(marks);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc3) {
      super.addStep(step, doc3);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice2) {
      this.selection.replace(this, slice2);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node, inheritMarks = true) {
      let selection = this.selection;
      if (inheritMarks)
        node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text, from2, to) {
      let schema = this.doc.type.schema;
      if (from2 == null) {
        if (!text)
          return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null)
          to = from2;
        to = to == null ? from2 : to;
        if (!text)
          return this.deleteRange(from2, to);
        let marks = this.storedMarks;
        if (!marks) {
          let $from = this.doc.resolve(from2);
          marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from2, to, schema.text(text, marks));
        if (!this.selection.empty)
          this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let _ in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  };
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  var FieldDesc = class {
    constructor(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    }
  };
  var baseFields = [
    new FieldDesc("doc", {
      init(config2) {
        return config2.doc || config2.schema.topNodeType.createAndFill();
      },
      apply(tr) {
        return tr.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config2, instance) {
        return config2.selection || Selection.atStart(instance.doc);
      },
      apply(tr) {
        return tr.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config2) {
        return config2.storedMarks || null;
      },
      apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  var Configuration = class {
    constructor(schema, plugins) {
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach((plugin) => {
          if (this.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          this.plugins.push(plugin);
          this.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    }
  };
  var EditorState = class _EditorState {
    /**
    @internal
    */
    constructor(config2) {
      this.config = config2;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr) {
      return this.applyTransaction(tr).state;
    }
    /**
    @internal
    */
    filterTransaction(tr, ignore = -1) {
      for (let i = 0; i < this.config.plugins.length; i++)
        if (i != ignore) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr))
        return { state: this, transactions: [] };
      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        let haveNew = false;
        for (let i = 0; i < this.config.plugins.length; i++) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (let j = 0; j < this.config.plugins.length; j++)
                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen)
              seen[i] = { state: newState, n: trs.length };
          }
        }
        if (!haveNew)
          return { state: newState, transactions: trs };
      }
    }
    /**
    @internal
    */
    applyInner(tr) {
      if (!tr.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let newInstance = new _EditorState(this.config), fields = this.config.fields;
      for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Transaction(this);
    }
    /**
    Create a new state.
    */
    static create(config2) {
      let $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
      let instance = new _EditorState($config);
      for (let i = 0; i < $config.fields.length; i++)
        instance[$config.fields[i].name] = $config.fields[i].init(config2, instance);
      return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config2) {
      let $config = new Configuration(this.schema, config2.plugins);
      let fields = $config.fields, instance = new _EditorState($config);
      for (let i = 0; i < fields.length; i++) {
        let name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config2, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks)
        result.storedMarks = this.storedMarks.map((m) => m.toJSON());
      if (pluginFields && typeof pluginFields == "object")
        for (let prop in pluginFields) {
          if (prop == "doc" || prop == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON)
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config2, json, pluginFields) {
      if (!json)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config2.schema)
        throw new RangeError("Required config field 'schema' missing");
      let $config = new Configuration(config2.schema, config2.plugins);
      let instance = new _EditorState($config);
      $config.fields.forEach((field) => {
        if (field.name == "doc") {
          instance.doc = Node2.fromJSON(config2.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks)
            instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
        } else {
          if (pluginFields)
            for (let prop in pluginFields) {
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config2, json[prop], instance);
                return;
              }
            }
          instance[field.name] = field.init(config2, instance);
        }
      });
      return instance;
    }
  };
  function bindProps(obj, self2, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self2);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = class {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };
  var keys = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys)
      return name + "$" + ++keys[name];
    keys[name] = 0;
    return name + "$";
  }
  var PluginKey = class {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };

  // node_modules/prosemirror-view/dist/index.js
  var domIndex = function(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  };
  var parentNode = function(node) {
    let parent = node.assignedSlot || node.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  var reusedRange = null;
  var textRange = function(node, from2, to) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node, to == null ? node.nodeValue.length : to);
    range.setStart(node, from2 || 0);
    return range;
  };
  var clearReusedRange = function() {
    reusedRange = null;
  };
  var isEquivalentPosition = function(node, off, targetNode, targetOff) {
    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
  };
  var atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : nodeSize(node))) {
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.contentEditable == "false")
          return false;
        off = dir < 0 ? nodeSize(node) : 0;
      } else {
        return false;
      }
    }
  }
  function nodeSize(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function textNodeBefore$1(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3 && offset2)
        return node;
      if (node.nodeType == 1 && offset2 > 0) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2 - 1];
        offset2 = nodeSize(node);
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset2 = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter$1(node, offset2) {
    for (; ; ) {
      if (node.nodeType == 3 && offset2 < node.nodeValue.length)
        return node;
      if (node.nodeType == 1 && offset2 < node.childNodes.length) {
        if (node.contentEditable == "false")
          return null;
        node = node.childNodes[offset2];
        offset2 = 0;
      } else if (node.parentNode && !hasBlockDesc(node)) {
        offset2 = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function isOnEdge(node, offset2, parent) {
    for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
      if (node == parent)
        return true;
      let index = domIndex(node);
      node = node.parentNode;
      if (!node)
        return false;
      atStart = atStart && index == 0;
      atEnd = atEnd && index == nodeSize(node);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  var selectionCollapsed = function(domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key;
    return event;
  }
  function deepActiveElement(doc3) {
    let elt = doc3.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc3, x, y) {
    if (doc3.caretPositionFromPoint) {
      try {
        let pos = doc3.caretPositionFromPoint(x, y);
        if (pos)
          return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
      } catch (_) {
      }
    }
    if (doc3.caretRangeFromPoint) {
      let range = doc3.caretRangeFromPoint(x, y);
      if (range)
        return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
    }
  }
  var nav = typeof navigator != "undefined" ? navigator : null;
  var doc2 = typeof document != "undefined" ? document : null;
  var agent = nav && nav.userAgent || "";
  var ie_edge = /Edge\/(\d+)/.exec(agent);
  var ie_upto10 = /MSIE \d/.exec(agent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  var ie = !!(ie_upto10 || ie_11up || ie_edge);
  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  var gecko = !ie && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
  var chrome = !!_chrome;
  var chrome_version = _chrome ? +_chrome[1] : 0;
  var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
  var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
  var windows = nav ? /Win/.test(nav.platform) : false;
  var android = /Android \d/.test(agent);
  var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
  var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc3) {
    let vp = doc3.defaultView && doc3.defaultView.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: doc3.documentElement.clientWidth,
      top: 0,
      bottom: doc3.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node) {
    let rect = node.getBoundingClientRect();
    let scaleX = rect.width / node.offsetWidth || 1;
    let scaleY = rect.height / node.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc3 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; ) {
      if (!parent)
        break;
      if (parent.nodeType != 1) {
        parent = parentNode(parent);
        continue;
      }
      let elt = parent;
      let atTop = elt == doc3.body;
      let bounding = atTop ? windowRect(doc3) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc3.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      let pos = atTop ? "fixed" : getComputedStyle(parent).position;
      if (/^(fixed|sticky)$/.test(pos))
        break;
      parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc3 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc3)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i = 0; i < stack.length; i++) {
      let { dom, top: top2, left: left2 } = stack[i];
      if (dom.scrollTop != top2 + dTop)
        dom.scrollTop = top2 + dTop;
      if (dom.scrollLeft != left2)
        dom.scrollLeft = left2;
    }
  }
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset2 = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3)
      return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1)
      return { node, offset: offset2 };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node, coords) {
    let len = node.nodeValue.length;
    let range = document.createRange();
    for (let i = 0; i < len; i++) {
      range.setEnd(node, i + 1);
      range.setStart(node, i);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
    if (node.nodeType == 1 && !node.firstChild) {
      let rect = node.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node, offset2, bias);
  }
  function posFromCaret(view, node, offset2, coords) {
    let outsideBlock = -1;
    for (let cur = node, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true), rect;
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
      ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
        if (desc.node.isBlock && desc.parent) {
          if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
          sawBlock = true;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
  }
  function elementFromPoint(element, coords, box) {
    let len = element.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
        let child = element.childNodes[i];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i = (i + 1) % len) == startI)
          break;
      }
    }
    return element;
  }
  function posAtCoords(view, coords) {
    let doc3 = view.dom.ownerDocument, node, offset2 = 0;
    let caret = caretFromPoint(doc3, coords.left, coords.top);
    if (caret)
      ({ node, offset: offset2 } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p = elt; node && p; p = parentNode(p))
        if (p.draggable)
          node = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node) {
      if (gecko && node.nodeType == 1) {
        offset2 = Math.min(offset2, node.childNodes.length);
        if (offset2 < node.childNodes.length) {
          let next = node.childNodes[offset2], box;
          if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset2++;
        }
      }
      let prev;
      if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset2--;
      if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
        pos = posFromCaret(view, node, offset2, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first2 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first2))
        return first2;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
        let rect = singleRect(textRange(node, offset2, offset2), side);
        if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
          let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset2) {
          to++;
          takeSide = -1;
        } else if (side >= 0 && offset2 == node.nodeValue.length) {
          from2--;
          takeSide = 1;
        } else if (side < 0) {
          from2--;
        } else {
          to++;
        }
        return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
        let before = node.childNodes[offset2 - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset2 < nodeSize(node)) {
        let after = node.childNodes[offset2];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
  }
  function flattenV(rect, left2) {
    if (rect.width == 0)
      return rect;
    let x = left2 ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top2) {
    if (rect.height == 0)
      return rect;
    let y = top2 ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i = 0; i < boxes.length; i++) {
          let box = boxes[i];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  var maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
    let sel = view.domSelection();
    if (!sel)
      return $head.pos == $head.start() || $head.pos == $head.end();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  var cachedState = null;
  var cachedDir = null;
  var cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  var NOT_DIRTY = 0;
  var CHILD_DIRTY = 1;
  var CONTENT_DIRTY = 2;
  var NODE_DIRTY = 3;
  var ViewDesc = class {
    constructor(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) {
      return false;
    }
    matchesMark(mark) {
      return false;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
    matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let size = 0;
      for (let i = 0; i < this.children.length; i++)
        size += this.children[i].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this)
        this.dom.pmViewDesc = void 0;
      for (let i = 0; i < this.children.length; i++)
        this.children[i].destroy();
    }
    posBeforeChild(child) {
      for (let i = 0, pos = this.posAtStart; ; i++) {
        let cur = this.children[i];
        if (cur == child)
          return pos;
        pos += cur.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset2, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          let domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset2 - 1];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
            domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          let domAfter, desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset2];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
            domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
        }
      }
      let atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset2 > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset2 == 0)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = false;
              break;
            }
            if (search.previousSibling)
              break;
          }
        if (atEnd == null && offset2 == dom.childNodes.length)
          for (let search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd = true;
              break;
            }
            if (search.nextSibling)
              break;
          }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(dom, onlyNodes = false) {
      for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
        let desc = this.getDesc(cur), nodeDOM;
        if (desc && (!onlyNodes || desc.node)) {
          if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
            first2 = false;
          else
            return desc;
        }
      }
    }
    getDesc(dom) {
      let desc = dom.pmViewDesc;
      for (let cur = desc; cur; cur = cur.parent)
        if (cur == this)
          return desc;
    }
    posFromDOM(dom, offset2, bias) {
      for (let scan = dom; scan; scan = scan.parentNode) {
        let desc = this.getDesc(scan);
        if (desc)
          return desc.localPosFromDOM(dom, offset2, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
      for (let i = 0, offset2 = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (offset2 == pos && end2 != offset2) {
          while (!child.border && child.children.length) {
            for (let i2 = 0; i2 < child.children.length; i2++) {
              let inner = child.children[i2];
              if (inner.size) {
                child = inner;
                break;
              }
            }
          }
          return child;
        }
        if (pos < end2)
          return child.descAt(pos - offset2 - child.border);
        offset2 = end2;
      }
    }
    domFromPos(pos, side) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: pos + 1 };
      let i = 0, offset2 = 0;
      for (let curPos = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = curPos + child.size;
        if (end2 > pos || child instanceof TrailingHackViewDesc) {
          offset2 = pos - curPos;
          break;
        }
        curPos = end2;
      }
      if (offset2)
        return this.children[i].domFromPos(offset2 - this.children[i].border, side);
      for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
      }
      if (side <= 0) {
        let prev, enter2 = true;
        for (; ; i--, enter2 = false) {
          prev = i ? this.children[i - 1] : null;
          if (!prev || prev.dom.parentNode == this.contentDOM)
            break;
        }
        if (prev && side && enter2 && !prev.border && !prev.domAtom)
          return prev.domFromPos(prev.size, side);
        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
      } else {
        let next, enter2 = true;
        for (; ; i++, enter2 = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM)
            break;
        }
        if (next && enter2 && !next.border && !next.domAtom)
          return next.domFromPos(0, side);
        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from2, to, base2 = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let fromOffset = -1, toOffset = -1;
      for (let offset2 = base2, i = 0; ; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (fromOffset == -1 && from2 <= end2) {
          let childBase = offset2 + child.border;
          if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
            return child.parseRange(from2, to, childBase);
          from2 = offset2;
          for (let j = i; j > 0; j--) {
            let prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from2 -= prev.size;
          }
          if (fromOffset == -1)
            fromOffset = 0;
        }
        if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
          to = end2;
          for (let j = i + 1; j < this.children.length; j++) {
            let next = this.children[j];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1)
            toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset2 = end2;
      }
      return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
    }
    emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
      let { node, offset: offset2 } = this.domFromPos(pos, 0);
      if (node.nodeType != 1 || offset2 == node.childNodes.length)
        throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset2];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head, view, force = false) {
      let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
      for (let i = 0, offset2 = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (from2 > offset2 && to < end2)
          return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
        offset2 = end2;
      }
      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      let domSel = view.root.getSelection();
      let selRange = view.domSelectionRange();
      let brKludge = false;
      if ((gecko || safari) && anchor == head) {
        let { node, offset: offset2 } = anchorDOM;
        if (node.nodeType == 3) {
          brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
          if (brKludge && offset2 == node.nodeValue.length) {
            for (let scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR")
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                break;
              }
              let desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock)
                break;
            }
          }
        } else {
          let prev = node.childNodes[offset2 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
        let after = selRange.focusNode.childNodes[selRange.focusOffset];
        if (after && after.contentEditable == "false")
          force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
        return;
      let domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head)
            domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          let tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        let range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
    ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from2, to) {
      for (let offset2 = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = offset2 + child.size;
        if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
          let startInside = offset2 + child.border, endInside = end2 - child.border;
          if (from2 >= startInside && to <= endInside) {
            this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
              child.dirty = NODE_DIRTY;
            else
              child.markDirty(from2 - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset2 = end2;
      }
      this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
      let level = 1;
      for (let node = this.parent; node; node = node.parent, level++) {
        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty)
          node.dirty = dirty;
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    isText(text) {
      return false;
    }
  };
  var WidgetViewDesc = class extends ViewDesc {
    constructor(parent, widget, view, pos) {
      let self2, dom = widget.type.toDOM;
      if (typeof dom == "function")
        dom = dom(view, () => {
          if (!self2)
            return pos;
          if (self2.parent)
            return self2.parent.posBeforeChild(self2);
        });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          let wrap2 = document.createElement("span");
          wrap2.appendChild(dom);
          dom = wrap2;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      super(parent, [], dom, null);
      this.widget = widget;
      this.widget = widget;
      self2 = this;
    }
    matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(event) {
      let stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom);
      super.destroy();
    }
    get domAtom() {
      return true;
    }
    get side() {
      return this.widget.type.side;
    }
  };
  var CompositionViewDesc = class extends ViewDesc {
    constructor(parent, dom, textDOM, text) {
      super(parent, [], dom, null);
      this.textDOM = textDOM;
      this.text = text;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(dom, offset2) {
      if (dom != this.textDOM)
        return this.posAtStart + (offset2 ? this.size : 0);
      return this.posAtStart + offset2;
    }
    domFromPos(pos) {
      return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    }
  };
  var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
    constructor(parent, mark, dom, contentDOM, spec) {
      super(parent, [], dom, contentDOM);
      this.mark = mark;
      this.spec = spec;
    }
    static create(parent, mark, inline, view) {
      let custom = view.nodeViews[mark.type.name];
      let spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom)
        spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
      return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
    }
    parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
        return null;
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dirty != NOT_DIRTY) {
        let parent = this.parent;
        while (!parent.node)
          parent = parent.parent;
        if (parent.dirty < this.dirty)
          parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
    slice(from2, to, view) {
      let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
      let nodes = this.children, size = this.size;
      if (to < size)
        nodes = replaceNodes(nodes, to, size, view);
      if (from2 > 0)
        nodes = replaceNodes(nodes, 0, from2, view);
      for (let i = 0; i < nodes.length; i++)
        nodes[i].parent = copy2;
      copy2.children = nodes;
      return copy2;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
  };
  var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      super(parent, [], dom, contentDOM);
      this.node = node;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      this.nodeDOM = nodeDOM;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node, outerDeco, innerDeco, view, pos) {
      let custom = view.nodeViews[node.type.name], descObj;
      let spec = custom && custom(node, view, () => {
        if (!descObj)
          return pos;
        if (descObj.parent)
          return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node.isText) {
        if (!dom)
          dom = document.createTextNode(node.text);
        else if (dom.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
        ({ dom, contentDOM } = spec2);
      }
      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable"))
          dom.contentEditable = "false";
        if (node.type.spec.draggable)
          dom.draggable = true;
      }
      let nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec)
        return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
      else if (node.isText)
        return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
      else
        return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre")
        rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = () => this.node.content;
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (let i = this.children.length - 1; i >= 0; i--) {
          let child = this.children[i];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement)
          rule.getContent = () => Fragment.empty;
      }
      return rule;
    }
    matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
      let inline = this.node.inlineContent, off = pos;
      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      let localComposition = composition && composition.pos > -1 ? composition : null;
      let compositionInChild = composition && composition.pos < 0;
      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
        if (widget.spec.marks)
          updater.syncToMarks(widget.spec.marks, inline, view);
        else if (widget.type.side >= 0 && !insideNode)
          updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, (child, outerDeco, innerDeco, i) => {
        updater.syncToMarks(child.marks, inline, view);
        let compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
        else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock)
        updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition)
          this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios)
          iosHacks(this.dom);
      }
    }
    localCompositionInfo(view, pos) {
      let { from: from2, to } = view.state.selection;
      if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
        return null;
      let textNode = view.input.compositionNode;
      if (!textNode || !this.dom.contains(textNode.parentNode))
        return null;
      if (this.node.inlineContent) {
        let text = textNode.nodeValue;
        let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text };
      } else {
        return { node: textNode, pos: -1, text: "" };
      }
    }
    protectLocalComposition(view, { node, pos, text }) {
      if (this.getDesc(node))
        return;
      let topNode = node;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM)
          break;
        while (topNode.previousSibling)
          topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling)
          topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc)
          topNode.pmViewDesc = void 0;
      }
      let desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
        return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
    updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM)
        this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco))
        return;
      let needsWrap = this.nodeDOM.nodeType != 1;
      let oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
      if (this.nodeDOM.nodeType == 1) {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
          this.dom.removeAttribute("draggable");
      }
    }
    get domAtom() {
      return this.node.isAtom;
    }
  };
  function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc3);
    let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
      super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
      let skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco)
        skip = skip.parentNode;
      return { skip: skip || true };
    }
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
        return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM)
          view.trackWrites = null;
      }
      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
    inParent() {
      let parentDOM = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == parentDOM)
          return true;
      return false;
    }
    domFromPos(pos) {
      return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset2, bias) {
      if (dom == this.nodeDOM)
        return this.posAtStart + Math.min(offset2, this.node.text.length);
      return super.localPosFromDOM(dom, offset2, bias);
    }
    ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from2, to, view) {
      let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
      return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from2, to) {
      super.markDirty(from2, to);
      if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
        this.dirty = NODE_DIRTY;
    }
    get domAtom() {
      return false;
    }
    isText(text) {
      return this.node.text == text;
    }
  };
  var TrailingHackViewDesc = class extends ViewDesc {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  };
  var CustomNodeViewDesc = class extends NodeViewDesc {
    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
      this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY)
        return false;
      if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
        let result = this.spec.update(node, outerDeco, innerDeco);
        if (result)
          this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return super.update(node, outerDeco, innerDeco, view);
      }
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head, view, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
    stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
  };
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i = 0; i < descs.length; i++) {
      let desc = descs[i], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  var OuterDecoLevel = function(nodeName) {
    if (nodeName)
      this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  var noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
    for (let i = 0; i < outerDeco.length; i++) {
      let attrs = outerDeco[i].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top2 = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
        if (name == "class")
          top2.class = (top2.class ? top2.class + " " : "") + val;
        else if (name == "style")
          top2.style = (top2.style ? top2.style + ";" : "") + val;
        else if (name != "nodeName")
          top2[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i = 0; i < curComputed.length; i++) {
      let deco = curComputed[i], prev = prevComputed[i];
      if (i) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i = 0; i < prevList.length; i++)
        if (curList.indexOf(prevList[i]) == -1)
          dom.classList.remove(prevList[i]);
      for (let i = 0; i < curList.length; i++)
        if (prevList.indexOf(curList[i]) == -1)
          dom.classList.add(curList[i]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
  }
  function sameOuterDeco(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].type.eq(b[i].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  var ViewTreeUpdater = class {
    constructor(top2, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top2;
      this.preMatch = preMatch(top2.node.content, top2);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start3, end2) {
      if (start3 == end2)
        return;
      for (let i = start3; i < end2; i++)
        this.top.children[i].destroy();
      this.top.children.splice(start3, end2 - start3);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks, inline, view) {
      let keep = 0, depth = this.stack.length >> 1;
      let maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
        keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        let found2 = -1;
        for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          let next = this.top.children[i];
          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found2 = i;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node, outerDeco, innerDeco, index) {
      let found2 = -1, targetDesc;
      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          let child = this.top.children[i];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = i;
            break;
          }
        }
      }
      if (found2 < 0)
        return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    }
    updateNodeAt(node, outerDeco, innerDeco, index, view) {
      let child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
        child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view))
        return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    }
    findIndexWithChild(domNode) {
      for (; ; ) {
        let parent = domNode.parentNode;
        if (!parent)
          return -1;
        if (parent == this.top.contentDOM) {
          let desc = domNode.pmViewDesc;
          if (desc)
            for (let i = this.index; i < this.top.children.length; i++) {
              if (this.top.children[i] == desc)
                return i;
            }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (let i = this.index; i < this.top.children.length; i++) {
        let next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          let preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index)
            return false;
          let nextDOM = next.dom, updated;
          let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM)
              this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.destroyBetween(this.index, i);
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
        return null;
      let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        for (let ch of wrapper.children)
          ch.parent = wrapper;
      }
      next.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
    addNode(node, outerDeco, innerDeco, view, pos) {
      let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM)
        desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
    placeWidget(widget, view, pos) {
      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        let desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let lastChild = this.top.children[this.index - 1], parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
          this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
    addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        let dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR")
          dom.className = "ProseMirror-trailingBreak";
        let hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top)
          parent.children.push(hack);
        else
          parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
    isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    }
  };
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer: while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a, b) {
    return a.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset2 = 0;
    if (locals.length == 0) {
      for (let i = 0; i < parent.childCount; i++) {
        let child = parent.child(i);
        onNode(child, locals, deco.forChild(offset2, child), i);
        offset2 += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
        let next = locals[decoIndex++];
        if (next.widget) {
          if (!widget)
            widget = next;
          else
            (widgets || (widgets = [widget])).push(next);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i = 0; i < widgets.length; i++)
            onWidget(widgets[i], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index;
      if (restNode) {
        index = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i = 0; i < active.length; i++)
        if (active[i].to <= offset2)
          active.splice(i--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
        active.push(locals[decoIndex++]);
      let end2 = offset2 + child.nodeSize;
      if (child.isText) {
        let cutAt = end2;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i = 0; i < active.length; i++)
          if (active[i].to < cutAt)
            cutAt = active[i].to;
        if (cutAt < end2) {
          restNode = child.cut(cutAt - offset2);
          child = child.cut(0, cutAt - offset2);
          end2 = cutAt;
          index = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end2)
          decoIndex++;
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset2, child), index);
      offset2 = end2;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function findTextInFragment(frag, text, from2, to) {
    for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
      let child = frag.child(i++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i < frag.childCount) {
        let next = frag.child(i++);
        pos += next.nodeSize;
        if (!next.isText)
          break;
        str += next.text;
      }
      if (pos >= from2) {
        if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
          return to - text.length;
        let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text.length + childStart >= from2)
          return childStart + found2;
        if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
          return to;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from2, to, view, replacement) {
    let result = [];
    for (let i = 0, off = 0; i < nodes.length; i++) {
      let child = nodes[i], start3 = off, end2 = off += child.size;
      if (start3 >= to || end2 <= from2) {
        result.push(child);
      } else {
        if (start3 < from2)
          result.push(child.slice(0, from2 - start3, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end2 > to)
          result.push(child.slice(to - start3, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelectionRange(), doc3 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head < 0)
      return null;
    let $head = doc3.resolve(head), anchor, selection;
    if (selectionCollapsed(domSel)) {
      anchor = head;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
      }
    } else {
      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
        let min2 = head, max2 = head;
        for (let i = 0; i < domSel.rangeCount; i++) {
          let range = domSel.getRangeAt(i);
          min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
          max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
        }
        if (min2 < 0)
          return null;
        [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
        $head = doc3.resolve(head);
      } else {
        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      }
      if (anchor < 0)
        return null;
    }
    let $anchor = doc3.resolve(anchor);
    if (!selection) {
      let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head, view, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
    let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
    let before = offset2 ? node.childNodes[offset2 - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element) {
    element.contentEditable = "true";
    if (safari && element.draggable) {
      element.draggable = false;
      element.wasDraggable = true;
    }
    return element;
  }
  function resetEditable(element) {
    element.contentEditable = "false";
    if (element.wasDraggable) {
      element.draggable = true;
      element.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc3 = view.dom.ownerDocument;
    doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
    doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
        doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    if (!domSel)
      return;
    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
    if (img)
      range.setStart(node.parentNode, domIndex(node) + 1);
    else
      range.setStart(node, 0);
    range.collapse(true);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
      node.disabled = true;
      node.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node || node.isText || !node.isLeaf)
          return false;
        let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
        return false;
      } else if (!(mac && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node || node.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next = moveSelectionBlock(view.state, dir);
      if (next)
        return apply(view, next);
      return false;
    }
  }
  function nodeLen(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
      force = true;
    for (; ; ) {
      if (offset2 > 0) {
        if (node.nodeType != 1) {
          break;
        } else {
          let before = node.childNodes[offset2 - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node;
            moveOffset = --offset2;
          } else if (before.nodeType == 3) {
            node = before;
            offset2 = node.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node)) {
        break;
      } else {
        let prev = node.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = 0;
        } else {
          node = prev;
          offset2 = nodeLen(node);
        }
      }
    }
    if (force)
      setSelFocus(view, node, offset2);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node = sel.focusNode, offset2 = sel.focusOffset;
    if (!node)
      return;
    let len = nodeLen(node);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset2 < len) {
        if (node.nodeType != 1)
          break;
        let after = node.childNodes[offset2];
        if (isIgnorable(after, 1)) {
          moveNode = node;
          moveOffset = ++offset2;
        } else
          break;
      } else if (isBlockNode(node)) {
        break;
      } else {
        let next = node.nextSibling;
        while (next && isIgnorable(next, 1)) {
          moveNode = next.parentNode;
          moveOffset = domIndex(next) + 1;
          next = next.nextSibling;
        }
        if (!next) {
          node = node.parentNode;
          if (node == view.dom)
            break;
          offset2 = len = 0;
        } else {
          node = next;
          offset2 = 0;
          len = nodeLen(node);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node, offset2) {
    while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    }
    while (node && offset2 < node.childNodes.length) {
      let next = node.childNodes[offset2];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = 0;
    }
  }
  function textNodeBefore(node, offset2) {
    while (node && !offset2 && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    }
    while (node && offset2) {
      let next = node.childNodes[offset2 - 1];
      if (next.nodeType == 3)
        return next;
      if (next.nodeType == 1 && next.contentEditable == "false")
        break;
      node = next;
      offset2 = node.childNodes.length;
    }
  }
  function setSelFocus(view, node, offset2) {
    if (node.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node, offset2)) {
        node = after;
        offset2 = 0;
      } else if (before = textNodeBefore(node, offset2)) {
        node = before;
        offset2 = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (!sel)
      return;
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node, offset2);
      range.setStart(node, offset2);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node, offset2);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty2 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty2)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr = view.state.tr;
      if (dir < 0)
        tr.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr);
      return true;
    }
    return false;
  }
  function switchEditable(view, node, state) {
    view.domObserver.stop();
    node.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code = event.keyCode, mods = getMods(event);
    if (code == 8 || mac && code == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code == 13 || code == 27) {
      return true;
    } else if (code == 37 || mac && code == 66 && mods == "c") {
      let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 39 || mac && code == 70 && mods == "c") {
      let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code == 38 || mac && code == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code == 40 || mac && code == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice2) {
    view.someProp("transformCopied", (f) => {
      slice2 = f(slice2, view);
    });
    let context = [], { content, openStart, openEnd } = slice2;
    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node = content.firstChild;
      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
      content = node.content;
    }
    let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
    wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i = needsWrap.length - 1; i >= 0; i--) {
        let wrapper = doc3.createElement(needsWrap[i]);
        while (wrap2.firstChild)
          wrapper.appendChild(wrap2.firstChild);
        wrap2.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap2.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
    return { dom: wrap2, text, slice: slice2 };
  }
  function parseFromClipboard(view, text, html, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice2;
    if (!html && !text)
      return null;
    let asText = text && (plainText || inCode || !html);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text = f(text, inCode || plainText, view);
      });
      if (inCode)
        return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
      if (parsed) {
        slice2 = parsed;
      } else {
        let marks = $context.marks();
        let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text.split(/(?:\r\n?|\n)+/).forEach((block) => {
          let p = dom.appendChild(document.createElement("p"));
          if (block)
            p.appendChild(serializer.serializeNode(schema.text(block, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html = f(html, view);
      });
      dom = readHTML(html);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i = +sliceData[3]; i > 0; i--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice2) {
      let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
      slice2 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
      if (slice2.openStart || slice2.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
        }
        for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
        }
        slice2 = closeSlice(slice2, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
    return slice2;
  }
  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment, $context) {
    if (fragment.childCount < 2)
      return fragment;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment.forEach((node) => {
        if (!result)
          return;
        let wrap2 = match.findWrapping(node.type), inLast;
        if (!wrap2)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node, wrap2);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap2;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment;
  }
  function withWrappers(node, wrap2, from2 = 0) {
    for (let i = wrap2.length - 1; i >= from2; i--)
      node = wrap2[i].create(null, Fragment.from(node));
    return node;
  }
  function addToSibling(wrap2, lastWrap, node, sibling, depth) {
    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
    }
  }
  function closeRight(node, depth) {
    if (depth == 0)
      return node;
    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
    return node.copy(fragment.append(fill));
  }
  function closeRange(fragment, side, from2, to, depth, openEnd) {
    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
    if (fragment.childCount > 1)
      openEnd = 0;
    if (depth < to - 1)
      inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
    if (depth >= from2)
      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
  }
  function closeSlice(slice2, openStart, openEnd) {
    if (openStart < slice2.openStart)
      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
    if (openEnd < slice2.openEnd)
      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
    return slice2;
  }
  var wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  var _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  var _policy = null;
  function maybeWrapTrusted(html) {
    let trustedTypes = window.trustedTypes;
    if (!trustedTypes)
      return html;
    if (!_policy)
      _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
    return _policy.createHTML(html);
  }
  function readHTML(html) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html);
    if (metas)
      html = html.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = maybeWrapTrusted(html);
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        elt = elt.querySelector(wrap2[i]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];
      if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
    }
  }
  function addContext(slice2, context) {
    if (!slice2.size)
      return slice2;
    let schema = slice2.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice2;
    }
    let { content, openStart, openEnd } = slice2;
    for (let i = array.length - 2; i >= 0; i -= 2) {
      let type = schema.nodes[array[i]];
      if (!type || type.hasRequiredAttrs())
        break;
      content = Fragment.from(type.create(array[i + 1], content));
      openStart++;
      openEnd++;
    }
    return new Slice(content, openStart, openEnd);
  }
  var handlers = {};
  var editHandlers = {};
  var passiveHandlers = { touchstart: true, touchmove: true };
  var InputState = class {
    constructor() {
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastChromeDelete = 0;
      this.composing = false;
      this.compositionNode = null;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    }
  };
  function initInput(view) {
    for (let event in handlers) {
      let handler = handlers[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers2) => {
      let handler = handlers2[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target; node != view.dom; node = node.parentNode)
      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent2(view, event) {
    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers[event.type](view, event);
  }
  editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
      return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13)
      return;
    if (event.keyCode != 229)
      view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      let now = Date.now();
      view.input.lastIOSEnter = now;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        if (view.input.lastIOSEnter == now) {
          view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
      view.input.shiftKey = false;
  };
  editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
      return;
    if (view.someProp("handleKeyPress", (f) => f(view, event))) {
      event.preventDefault();
      return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      let text = String.fromCharCode(event.charCode);
      if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
        view.dispatch(view.state.tr.insertText(text).scrollIntoView());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused)
      view.focus();
    if (view.state.selection.eq(selection))
      return;
    let tr = view.state.tr.setSelection(selection);
    if (origin == "pointer")
      tr.setMeta("pointer", true);
    view.dispatch(tr);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
    if (node && node.isAtom && NodeSelection.isSelectable(node)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      if (NodeSelection.isSelectable(node)) {
        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc3 = view.state.doc;
    if (inside == -1) {
      if (doc3.inlineContent) {
        updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
        return true;
      }
      return false;
    }
    let $pos = doc3.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      let nodePos = $pos.before(i);
      if (node.inlineContent)
        updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
      else if (NodeSelection.isSelectable(node))
        updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
  handlers.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
      if (view.input.lastClick.type == "singleClick")
        type = "doubleClick";
      else if (view.input.lastClick.type == "doubleClick")
        type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
      return;
    if (type == "singleClick") {
      if (view.input.mouseDown)
        view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  var MouseDown = class {
    constructor(view, pos, event, flushed) {
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      let targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        let $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      const target = flushed ? null : event.target;
      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
      let { selection } = view.state;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.draggable = true;
        if (this.mightDrag.setUneditable)
          setTimeout(() => {
            if (this.view.input.mouseDown == this)
              this.target.setAttribute("contentEditable", "false");
          }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable)
          this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync)
        setTimeout(() => selectionToDOM(this.view));
      this.view.input.mouseDown = null;
    }
    up(event) {
      this.done();
      if (!this.view.dom.contains(event.target))
        return;
      let pos = this.pos;
      if (this.view.state.doc != this.startDoc)
        pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
    move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0)
        this.done();
    }
    updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
        this.allowDefault = true;
    }
  };
  handlers.touchstart = (view) => {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers.touchmove = (view) => {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers.contextmenu = (view) => forceDOMFlush(view);
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  var timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
    if (!view.composing) {
      view.domObserver.flush();
      let { state } = view, $pos = state.selection.$to;
      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view, !state.selection.empty);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          let sel = view.domSelectionRange();
          for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
            let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
            if (!before)
              break;
            if (before.nodeType == 3) {
              let sel2 = view.domSelection();
              if (sel2)
                sel2.collapse(before, before.nodeValue.length);
              break;
            } else {
              node = before;
              offset2 = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = (view, event) => {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      view.input.compositionNode = null;
      if (view.input.compositionPendingChanges)
        Promise.resolve().then(() => view.domObserver.flush());
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function findCompositionNode(view) {
    let sel = view.domSelectionRange();
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
    if (textBefore && textAfter && textBefore != textAfter) {
      let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
      if (textBefore == lastChanged || textAfter == lastChanged)
        return lastChanged;
      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
        return textAfter;
      } else if (view.input.compositionNode == textAfter) {
        let descBefore = textBefore.pmViewDesc;
        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
          return textAfter;
      }
    }
    return textBefore || textAfter;
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, restarting = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (restarting || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view), cur = view.state.selection;
      if (sel && !sel.eq(cur))
        view.dispatch(view.state.tr.setSelection(sel));
      else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
        view.dispatch(view.state.tr.deleteSelection());
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap2.appendChild(dom);
    wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap2.parentNode)
        wrap2.parentNode.removeChild(wrap2);
      view.focus();
    }, 50);
  }
  var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
  handlers.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut2 = event.type == "cut";
    if (sel.empty)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text);
    } else {
      captureCopy(view, dom);
    }
    if (cut2)
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice2) {
    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text, html, preferPlain, event) {
    let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
      return true;
    if (!slice2)
      return false;
    let singleNode = sliceSingleNode(slice2);
    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText(clipboardData) {
    let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text)
      return text;
    let uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  editHandlers.paste = (view, _event) => {
    let event = _event;
    if (view.composing && !android)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
      event.preventDefault();
    else
      capturePaste(view, event);
  };
  var Dragging = class {
    constructor(slice2, move, node) {
      this.slice = slice2;
      this.move = move;
      this.node = node;
    }
  };
  var dragCopyModifier = mac ? "altKey" : "ctrlKey";
  function dragMoves(view, event) {
    let moves = view.someProp("dragCopies", (test) => !test(event));
    return moves != null ? moves : !event[dragCopyModifier];
  }
  handlers.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
      mouseDown.done();
    if (!event.dataTransfer)
      return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    let node;
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
    else if (mouseDown && mouseDown.mightDrag) {
      node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
    } else if (event.target && event.target.nodeType == 1) {
      let desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView)
        node = NodeSelection.create(view.state.doc, desc.posBefore);
    }
    let draggedSlice = (node || view.state.selection).content();
    let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
      event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
      event.dataTransfer.setData("text/plain", text);
    view.dragging = new Dragging(slice2, dragMoves(view, event), node);
  };
  handlers.dragend = (view) => {
    let dragging = view.dragging;
    window.setTimeout(() => {
      if (view.dragging == dragging)
        view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
  editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
      return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
      return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    let slice2 = dragging && dragging.slice;
    if (slice2) {
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view);
      });
    } else {
      slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && dragMoves(view, event));
    if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
      event.preventDefault();
      return;
    }
    if (!slice2)
      return;
    event.preventDefault();
    let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
    if (insertPos == null)
      insertPos = $mouse.pos;
    let tr = view.state.tr;
    if (move) {
      let { node } = dragging;
      if (node)
        node.replace(tr);
      else
        tr.deleteSelection();
    }
    let pos = tr.mapping.map(insertPos);
    let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
    let beforeInsert = tr.doc;
    if (isNode)
      tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
    else
      tr.replaceRange(pos, pos, slice2);
    if (tr.doc.eq(beforeInsert))
      return;
    let $pos = tr.doc.resolve(pos);
    if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
      tr.setSelection(new NodeSelection($pos));
    } else {
      let end2 = tr.mapping.map(insertPos);
      tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
    }
    view.focus();
    view.dispatch(tr.setMeta("uiEvent", "drop"));
  };
  handlers.focus = (view) => {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(() => {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
          selectionToDOM(view);
      }, 20);
    }
  };
  handlers.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget))
        view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers.beforeinput = (view, _event) => {
    let event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      let { domChangeCount } = view.input;
      setTimeout(() => {
        if (view.input.domChangeCount != domChangeCount)
          return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
          return;
        let { $cursor } = view.state.selection;
        if ($cursor && $cursor.pos > 0)
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let prop in editHandlers)
    handlers[prop] = editHandlers[prop];
  function compareObjs(a, b) {
    if (a == b)
      return true;
    for (let p in a)
      if (a[p] !== b[p])
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
    return true;
  }
  var WidgetType = class _WidgetType {
    constructor(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    map(mapping, span, offset2, oldOffset) {
      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
    }
    valid() {
      return true;
    }
    eq(other) {
      return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
    destroy(node) {
      if (this.spec.destroy)
        this.spec.destroy(node);
    }
  };
  var InlineType = class _InlineType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
      return from2 >= to ? null : new Decoration(from2, to, this);
    }
    valid(_, span) {
      return span.from < span.to;
    }
    eq(other) {
      return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    static is(span) {
      return span.type instanceof _InlineType;
    }
    destroy() {
    }
  };
  var NodeType2 = class _NodeType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset2, oldOffset) {
      let from2 = mapping.mapResult(span.from + oldOffset, 1);
      if (from2.deleted)
        return null;
      let to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from2.pos)
        return null;
      return new Decoration(from2.pos - offset2, to.pos - offset2, this);
    }
    valid(node, span) {
      let { index, offset: offset2 } = node.content.findIndex(span.from), child;
      return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
    }
    eq(other) {
      return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    destroy() {
    }
  };
  var Decoration = class _Decoration {
    /**
    @internal
    */
    constructor(from2, to, type) {
      this.from = from2;
      this.to = to;
      this.type = type;
    }
    /**
    @internal
    */
    copy(from2, to) {
      return new _Decoration(from2, to, this.type);
    }
    /**
    @internal
    */
    eq(other, offset2 = 0) {
      return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset2, oldOffset) {
      return this.type.map(mapping, this, offset2, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
      return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from2, to, attrs, spec) {
      return new _Decoration(from2, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from2, to, attrs, spec) {
      return new _Decoration(from2, to, new NodeType2(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof WidgetType;
    }
  };
  var none = [];
  var noSpec = {};
  var DecorationSet = class _DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(doc3, decorations) {
      return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start3, end2, predicate) {
      let result = [];
      this.findInner(start3 == null ? 0 : start3, end2 == null ? 1e9 : end2, result, 0, predicate);
      return result;
    }
    findInner(start3, end2, result, offset2, predicate) {
      for (let i = 0; i < this.local.length; i++) {
        let span = this.local[i];
        if (span.from <= end2 && span.to >= start3 && (!predicate || predicate(span.spec)))
          result.push(span.copy(span.from + offset2, span.to + offset2));
      }
      for (let i = 0; i < this.children.length; i += 3) {
        if (this.children[i] < end2 && this.children[i + 1] > start3) {
          let childOff = this.children[i] + 1;
          this.children[i + 2].findInner(start3 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc3, options) {
      if (this == empty || mapping.maps.length == 0)
        return this;
      return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node, offset2, oldOffset, options) {
      let newLocal;
      for (let i = 0; i < this.local.length; i++) {
        let mapped = this.local[i].map(mapping, offset2, oldOffset);
        if (mapped && mapped.type.valid(node, mapped))
          (newLocal || (newLocal = [])).push(mapped);
        else if (options.onRemove)
          options.onRemove(this.local[i].spec);
      }
      if (this.children.length)
        return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
      else
        return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(doc3, decorations) {
      if (!decorations.length)
        return this;
      if (this == empty)
        return _DecorationSet.create(doc3, decorations);
      return this.addInner(doc3, decorations, 0);
    }
    addInner(doc3, decorations, offset2) {
      let children, childIndex = 0;
      doc3.forEach((childNode, childOffset) => {
        let baseOffset = childOffset + offset2, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
          return;
        if (!children)
          children = this.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset)
          childIndex += 3;
        if (children[childIndex] == childOffset)
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        else
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
      for (let i = 0; i < local.length; i++)
        if (!local[i].type.valid(doc3, local[i]))
          local.splice(i--, 1);
      return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
      if (decorations.length == 0 || this == empty)
        return this;
      return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset2) {
      let children = this.children, local = this.local;
      for (let i = 0; i < children.length; i += 3) {
        let found2;
        let from2 = children[i] + offset2, to = children[i + 1] + offset2;
        for (let j = 0, span; j < decorations.length; j++)
          if (span = decorations[j]) {
            if (span.from > from2 && span.to < to) {
              decorations[j] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        if (!found2)
          continue;
        if (children == this.children)
          children = this.children.slice();
        let removed = children[i + 2].removeInner(found2, from2 + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (let i = 0, span; i < decorations.length; i++)
          if (span = decorations[i]) {
            for (let j = 0; j < local.length; j++)
              if (local[j].eq(span, offset2)) {
                if (local == this.local)
                  local = this.local.slice();
                local.splice(j--, 1);
              }
          }
      }
      if (children == this.children && local == this.local)
        return this;
      return local.length || children.length ? new _DecorationSet(local, children) : empty;
    }
    forChild(offset2, node) {
      if (this == empty)
        return this;
      if (node.isLeaf)
        return _DecorationSet.empty;
      let child, local;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] >= offset2) {
          if (this.children[i] == offset2)
            child = this.children[i + 2];
          break;
        }
      let start3 = offset2 + 1, end2 = start3 + node.content.size;
      for (let i = 0; i < this.local.length; i++) {
        let dec = this.local[i];
        if (dec.from < end2 && dec.to > start3 && dec.type instanceof InlineType) {
          let from2 = Math.max(start3, dec.from) - start3, to = Math.min(end2, dec.to) - start3;
          if (from2 < to)
            (local || (local = [])).push(dec.copy(from2, to));
        }
      }
      if (local) {
        let localSet = new _DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    }
    /**
    @internal
    */
    eq(other) {
      if (this == other)
        return true;
      if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
        return false;
      for (let i = 0; i < this.local.length; i++)
        if (!this.local[i].eq(other.local[i]))
          return false;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(node) {
      return removeOverlap(this.localsInner(node));
    }
    /**
    @internal
    */
    localsInner(node) {
      if (this == empty)
        return none;
      if (node.inlineContent || !this.local.some(InlineType.is))
        return this.local;
      let result = [];
      for (let i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType))
          result.push(this.local[i]);
      }
      return result;
    }
    forEachSet(f) {
      f(this);
    }
  };
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  var empty = DecorationSet.empty;
  var DecorationGroup = class _DecorationGroup {
    constructor(members) {
      this.members = members;
    }
    map(mapping, doc3) {
      const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
      return _DecorationGroup.from(mappedDecos);
    }
    forChild(offset2, child) {
      if (child.isLeaf)
        return DecorationSet.empty;
      let found2 = [];
      for (let i = 0; i < this.members.length; i++) {
        let result = this.members[i].forChild(offset2, child);
        if (result == empty)
          continue;
        if (result instanceof _DecorationGroup)
          found2 = found2.concat(result.members);
        else
          found2.push(result);
      }
      return _DecorationGroup.from(found2);
    }
    eq(other) {
      if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
        return false;
      for (let i = 0; i < this.members.length; i++)
        if (!this.members[i].eq(other.members[i]))
          return false;
      return true;
    }
    locals(node) {
      let result, sorted = true;
      for (let i = 0; i < this.members.length; i++) {
        let locals = this.members[i].localsInner(node);
        if (!locals.length)
          continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (let j = 0; j < locals.length; j++)
            result.push(locals[j]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
      }
    }
    forEachSet(f) {
      for (let i = 0; i < this.members.length; i++)
        this.members[i].forEachSet(f);
    }
  };
  function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
    let children = oldChildren.slice();
    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
      let moved = 0;
      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let end2 = children[i2 + 1];
          if (end2 < 0 || oldStart > end2 + baseOffset - moved)
            continue;
          let start3 = children[i2] + baseOffset - moved;
          if (oldEnd >= start3) {
            children[i2 + 1] = oldStart <= start3 ? -2 : -1;
          } else if (oldStart >= baseOffset && dSize) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      baseOffset = mapping.maps[i].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        if (children[i + 1] == -2) {
          mustRebuild = true;
          children[i + 1] = -1;
          continue;
        }
        let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue;
        }
        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
        let { index, offset: childOffset } = node.content.findIndex(fromLocal);
        let childNode = node.maybeChild(index);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i] = fromLocal;
            children[i + 1] = toLocal;
            children[i + 2] = mapped;
          } else {
            children[i + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
      let built = buildTree(decorations, node, 0, options);
      newLocal = built.local;
      for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] < 0) {
          children.splice(i, 3);
          i -= 3;
        }
      for (let i = 0, j = 0; i < built.children.length; i += 3) {
        let from2 = built.children[i];
        while (j < children.length && children[j] < from2)
          j += 3;
        children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset2) {
    if (!offset2 || !spans.length)
      return spans;
    let result = [];
    for (let i = 0; i < spans.length; i++) {
      let span = spans[i];
      result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
    function gather(set, oldOffset2) {
      for (let i = 0; i < set.local.length; i++) {
        let mapped = set.local[i].map(mapping, offset2, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options.onRemove)
          options.onRemove(set.local[i].spec);
      }
      for (let i = 0; i < set.children.length; i += 3)
        gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
    }
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] == -1)
        gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node, offset2) {
    if (node.isLeaf)
      return null;
    let end2 = offset2 + node.nodeSize, found2 = null;
    for (let i = 0, span; i < spans.length; i++) {
      if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
        (found2 || (found2 = [])).push(span);
        spans[i] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i = 0; i < array.length; i++)
      if (array[i] != null)
        result.push(array[i]);
    return result;
  }
  function buildTree(spans, node, offset2, options) {
    let children = [], hasNulls = false;
    node.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
        if (subtree != empty)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
    for (let i = 0; i < locals.length; i++)
      if (!locals[i].type.valid(node, locals[i])) {
        if (options.onRemove)
          options.onRemove(locals[i].spec);
        locals.splice(i--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty;
  }
  function byPos(a, b) {
    return a.from - b.from || a.to - b.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i = 0; i < working.length - 1; i++) {
      let span = working[i];
      if (span.from != span.to)
        for (let j = i + 1; j < working.length; j++) {
          let next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue;
          } else {
            if (next.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0)
      i++;
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  var useCharData = ie && ie_version <= 11;
  var SelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  };
  var DOMObserver = class {
    constructor(view, handleDOMChange) {
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.lastChangedTextNode = null;
      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
        for (let i = 0; i < mutations.length; i++)
          this.queue.push(mutations[i]);
        if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData) {
        this.onCharData = (e) => {
          this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      if (this.flushingSoon < 0)
        this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
    start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData)
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let take = this.observer.takeRecords();
        if (take.length) {
          for (let i = 0; i < take.length; i++)
            this.queue.push(take[i]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData)
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true;
      setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (!hasFocusAndSelection(this.view))
        return;
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        let sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(sel) {
      if (!sel.focusNode)
        return true;
      let ancestors = /* @__PURE__ */ new Set(), container;
      for (let scan = sel.focusNode; scan; scan = parentNode(scan))
        ancestors.add(scan);
      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
        if (ancestors.has(scan)) {
          container = scan;
          break;
        }
      let desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
    pendingRecords() {
      if (this.observer)
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
      return this.queue;
    }
    flush() {
      let { view } = this;
      if (!view.docView || this.flushingSoon > -1)
        return;
      let mutations = this.pendingRecords();
      if (mutations.length)
        this.queue = [];
      let sel = view.domSelectionRange();
      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      let from2 = -1, to = -1, typeOver = false, added = [];
      if (view.editable) {
        for (let i = 0; i < mutations.length; i++) {
          let result = this.registerMutation(mutations[i], added);
          if (result) {
            from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver)
              typeOver = true;
          }
        }
      }
      if (gecko && added.length) {
        let brs = added.filter((n) => n.nodeName == "BR");
        if (brs.length == 2) {
          let [a, b] = brs;
          if (a.parentNode && a.parentNode.parentNode == b.parentNode)
            b.remove();
          else
            a.remove();
        } else {
          let { focusNode } = this.currentSelection;
          for (let br of brs) {
            let parent = br.parentNode;
            if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
              br.remove();
          }
        }
      }
      let readSel = null;
      if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from2 > -1 || newSel) {
        if (from2 > -1) {
          view.docView.markDirty(from2, to);
          checkCSS(view);
        }
        this.handleDOMChange(from2, to, typeOver, added);
        if (view.docView && view.docView.dirty)
          view.updateState(view.state);
        else if (!this.currentSelection.eq(sel))
          selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
    registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1)
        return null;
      let desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
        return null;
      if (!desc || desc.ignoreMutation(mut))
        return null;
      if (mut.type == "childList") {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let node = mut.addedNodes[i];
          added.push(node);
          if (node.nodeType == 3)
            this.lastChangedTextNode = node;
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
          return { from: desc.posBefore, to: desc.posAfter };
        let prev = mut.previousSibling, next = mut.nextSibling;
        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (let i = 0; i < mut.addedNodes.length; i++) {
            let { previousSibling, nextSibling } = mut.addedNodes[i];
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
              prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
              next = nextSibling;
          }
        }
        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        let to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from2, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        this.lastChangedTextNode = mut.target;
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  };
  var cssChecked = /* @__PURE__ */ new WeakMap();
  var cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function rangeToSelectionRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariShadowSelectionRange(view, selection) {
    if (selection.getComposedRanges) {
      let range = selection.getComposedRanges(view.root)[0];
      if (range)
        return rangeToSelectionRange(view, range);
    }
    let found2;
    function read2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read2, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read2, true);
    return found2 ? rangeToSelectionRange(view, found2) : null;
  }
  function blockParent(view, node) {
    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
      let desc = view.docView.nearestDesc(p, true);
      if (desc && desc.node.isBlock)
        return p;
    }
    return null;
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off = toOffset; off > fromOffset; off--) {
        let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
        if (node.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from2);
    let sel = null, doc3 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find,
      ruleFromNode,
      context: $from
    });
    if (find && find[0].pos != null) {
      let anchor2 = find[0].pos, head = find[1] && find[1].pos;
      if (head == null)
        head = anchor2;
      sel = { anchor: anchor2 + from2, head: head + from2 };
    }
    return { doc: doc3, sel, from: from2, to };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from2, to, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from2 < 0) {
      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr2 = view.state.tr.setSelection(newSel);
        if (origin == "pointer")
          tr2.setMeta("pointer", true);
        else if (origin == "key")
          tr2.scrollIntoView();
        if (compositionID)
          tr2.setMeta("composition", compositionID);
        view.dispatch(tr2);
      }
      return;
    }
    let $before = view.state.doc.resolve(from2);
    let shared = $before.sharedDepth(to);
    from2 = $before.before(shared + 1);
    to = view.state.doc.resolve(to).after(shared + 1);
    let sel = view.state.selection;
    let parse = parseBetween(view, from2, to);
    let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
    if (change)
      view.input.domChangeCount++;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr2 = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr2.setMeta("composition", compositionID);
            view.dispatch(tr2);
          }
        }
        return;
      }
    }
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse.doc.resolveNoCache(change.start - parse.from);
    let $to = parse.doc.resolveNoCache(change.endB - parse.from);
    let $fromA = doc3.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && change.endB == change.start)
      view.input.lastChromeDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse.doc.resolveNoCache(change.endB - parse.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let tr, storedMarks, markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        tr = view.state.tr.delete(chFrom, chTo);
        storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        tr = view.state.tr;
        if (markChange.type == "add")
          tr.addMark(chFrom, chTo, markChange.mark);
        else
          tr.removeMark(chFrom, chTo, markChange.mark);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
          return;
        tr = view.state.tr.insertText(text, chFrom, chTo);
      }
    }
    if (!tr)
      tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (storedMarks)
      tr.ensureMarks(storedMarks);
    if (compositionID)
      tr.setMeta("composition", compositionID);
    view.dispatch(tr.scrollIntoView());
  }
  function resolveSelection(view, doc3, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
      return null;
    return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark, update;
    for (let i = 0; i < prevMarks.length; i++)
      added = prevMarks[i].removeFromSet(added);
    for (let i = 0; i < curMarks.length; i++)
      removed = curMarks[i].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark = added[0];
      type = "add";
      update = (node) => node.mark(mark.addToSet(node.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark = removed[0];
      type = "remove";
      update = (node) => node.mark(mark.removeFromSet(node.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i = 0; i < prev.childCount; i++)
      updated.push(update(prev.child(i)));
    if (Fragment.from(updated).eq(cur))
      return { mark, type };
  }
  function looksLikeBackspace(old, start3, end2, $newStart, $newEnd) {
    if (
      // The content must have shrunk
      end2 - start3 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos
    )
      return false;
    let $start = old.resolve(start3);
    if (!$newStart.parent.isTextblock) {
      let after = $start.nodeAfter;
      return after != null && end2 == start3 + after.nodeSize;
    }
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end2++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next && !next.isLeaf) {
        next = next.firstChild;
        end2++;
      }
    }
    return end2;
  }
  function findDiff(a, b, pos, preferredPos, preferredSide) {
    let start3 = a.findDiffStart(b, pos);
    if (start3 == null)
      return null;
    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start3 - Math.min(endA, endB));
      preferredPos -= endA + adjust - start3;
    }
    if (endA < start3 && a.size < b.size) {
      let move = preferredPos <= start3 && preferredPos >= endA ? start3 - preferredPos : 0;
      start3 -= move;
      if (start3 && start3 < b.size && isSurrogatePair(b.textBetween(start3 - 1, start3 + 1)))
        start3 += move ? 1 : -1;
      endB = start3 + (endB - endA);
      endA = start3;
    } else if (endB < start3) {
      let move = preferredPos <= start3 && preferredPos >= endB ? start3 - preferredPos : 0;
      start3 -= move;
      if (start3 && start3 < a.size && isSurrogatePair(a.textBetween(start3 - 1, start3 + 1)))
        start3 += move ? 1 : -1;
      endA = start3 + (endA - endB);
      endB = start3;
    }
    return { start: start3, endA, endB };
  }
  function isSurrogatePair(str) {
    if (str.length != 2)
      return false;
    let a = str.charCodeAt(0), b = str.charCodeAt(1);
    return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
  }
  var EditorView = class {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild)
          place.appendChild(this.dom);
        else if (typeof place == "function")
          place(this.dom);
        else if (place.mount)
          this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let prev = this._props;
        this._props = {};
        for (let name in prev)
          this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents)
        ensureListeners(this);
      let prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
      let updated = {};
      for (let name in this._props)
        updated[name] = this._props[name];
      updated.state = this.state;
      for (let name in props)
        updated[name] = props[name];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
      this.updateStateInner(state, this._props);
    }
    updateStateInner(state, prevProps) {
      var _a2;
      let prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        let nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection))
        updateSel = true;
      let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (this.composing)
            this.input.compositionNode = findCompositionNode(this);
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco(outerDeco);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites)
            forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc))
        this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
    scrollToSelection() {
      let startDOM = this.domSelectionRange().focusNode;
      if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
      else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
      else if (this.state.selection instanceof NodeSelection) {
        let target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1)
          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
    destroyPluginViews() {
      let view;
      while (view = this.pluginViews.pop())
        if (view.destroy)
          view.destroy();
    }
    updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (let i = 0; i < this.directPlugins.length; i++) {
          let plugin = this.directPlugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
        for (let i = 0; i < this.state.plugins.length; i++) {
          let plugin = this.state.plugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
      } else {
        for (let i = 0; i < this.pluginViews.length; i++) {
          let pluginView = this.pluginViews[i];
          if (pluginView.update)
            pluginView.update(this, prevState);
        }
      }
    }
    updateDraggedNode(dragging, prev) {
      let sel = dragging.node, found2 = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found2 = sel.from;
      } else {
        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node)
          found2 = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
    }
    someProp(propName, f) {
      let prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop))
        return value;
      for (let i = 0; i < this.directPlugins.length; i++) {
        let prop2 = this.directPlugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
      let plugins = this.state.plugins;
      if (plugins)
        for (let i = 0; i < plugins.length; i++) {
          let prop2 = plugins[i].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (ie) {
        let node = this.root.activeElement;
        if (node == this.dom)
          return true;
        if (!node || !this.dom.contains(node))
          return false;
        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == "false")
            return false;
          node = node.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop();
      if (this.editable)
        focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let cached = this._root;
      if (cached == null)
        for (let search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection)
              Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
            return this._root = search;
          }
        }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
      return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
      return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
      let desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimes—for example when interpreting an event
    target—you don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node, offset2, bias = -1) {
      let pos = this.docView.posFromDOM(node, offset2, bias);
      if (pos == null)
        throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html, event) {
      return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text, event) {
      return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Serialize the given slice as it would be if it was copied from
    this editor. Returns a DOM element that contains a
    representation of the slice as its children, a textual
    representation, and the transformed slice (which can be
    different from the given input due to hooks like
    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
    */
    serializeForClipboard(slice2) {
      return serializeForClipboard(this, slice2);
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      if (!this.docView)
        return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
      clearReusedRange();
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
      return dispatchEvent2(this, event);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
    dispatch(tr) {
      let dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction)
        dispatchTransaction.call(this, tr);
      else
        this.updateState(this.state.apply(tr));
    }
    /**
    @internal
    */
    domSelectionRange() {
      let sel = this.domSelection();
      if (!sel)
        return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  };
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add3(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add3);
    view.someProp("markViews", add3);
    return result;
  }
  function changedNodeViews(a, b) {
    let nA = 0, nB = 0;
    for (let prop in a) {
      if (a[prop] != b[prop])
        return true;
      nA++;
    }
    for (let _ in b)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }

  // node_modules/w3c-keyname/index.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc") name = "Escape";
    if (name == "Del") name = "Delete";
    if (name == "Left") name = "ArrowLeft";
    if (name == "Up") name = "ArrowUp";
    if (name == "Right") name = "ArrowRight";
    if (name == "Down") name = "ArrowDown";
    return name;
  }

  // node_modules/prosemirror-keymap/dist/index.js
  var mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
  var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
  function normalizeKeyName(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta;
    for (let i = 0; i < parts.length - 1; i++) {
      let mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac3)
          meta = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize(map2) {
    let copy2 = /* @__PURE__ */ Object.create(null);
    for (let prop in map2)
      copy2[normalizeKeyName(prop)] = map2[prop];
    return copy2;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map2 = normalize(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map2[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
        !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
          let fromCode = map2[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }

  // node_modules/prosemirror-commands/dist/index.js
  var deleteSelection = (state, dispatch2) => {
    if (state.selection.empty)
      return false;
    if (dispatch2)
      dispatch2(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  var joinBackward = (state, dispatch2, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch2)
        dispatch2(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (deleteBarrier(state, $cut, dispatch2, -1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      for (let depth = $cursor.depth; ; depth--) {
        let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch2) {
            let tr = state.tr.step(delStep);
            tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
            dispatch2(tr.scrollIntoView());
          }
          return true;
        }
        if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
          break;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch2)
        dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  var joinTextblockBackward = (state, dispatch2, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
  };
  var joinTextblockForward = (state, dispatch2, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
  };
  function joinTextblocksAround(state, $cut, dispatch2) {
    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
    for (; !beforeText.isTextblock; beforePos--) {
      if (beforeText.type.spec.isolating)
        return false;
      let child = beforeText.lastChild;
      if (!child)
        return false;
      beforeText = child;
    }
    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
    for (; !afterText.isTextblock; afterPos++) {
      if (afterText.type.spec.isolating)
        return false;
      let child = afterText.firstChild;
      if (!child)
        return false;
      afterText = child;
    }
    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
    if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
      return false;
    if (dispatch2) {
      let tr = state.tr.step(step);
      tr.setSelection(TextSelection.create(tr.doc, beforePos));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  function textblockAt(node, side, only = false) {
    for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  var selectNodeBackward = (state, dispatch2, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node = $cut && $cut.nodeBefore;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0)
          return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  var joinForward = (state, dispatch2, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch2, 1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch2) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch2(tr.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch2)
        dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  var selectNodeForward = (state, dispatch2, view) => {
    let { $head, empty: empty2 } = state.selection, $cut = $head;
    if (!empty2)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node = $cut && $cut.nodeAfter;
    if (!node || !NodeSelection.isSelectable(node))
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  var joinUp = (state, dispatch2) => {
    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
        return false;
      point = sel.from;
    } else {
      point = joinPoint(state.doc, sel.from, -1);
      if (point == null)
        return false;
    }
    if (dispatch2) {
      let tr = state.tr.join(point);
      if (nodeSel)
        tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  };
  var joinDown = (state, dispatch2) => {
    let sel = state.selection, point;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
        return false;
      point = sel.to;
    } else {
      point = joinPoint(state.doc, sel.to, 1);
      if (point == null)
        return false;
    }
    if (dispatch2)
      dispatch2(state.tr.join(point).scrollIntoView());
    return true;
  };
  var lift2 = (state, dispatch2) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode = (state, dispatch2) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch2)
      dispatch2(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  var exitCode = (state, dispatch2) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch2) {
      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear = (state, dispatch2) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch2) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr = state.tr.insert(side, type.createAndFill());
      tr.setSelection(TextSelection.create(tr.doc, side + 1));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock = (state, dispatch2) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch2)
          dispatch2(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch2) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch2)
          dispatch2(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.depth)
        return false;
      let types = [];
      let splitDepth, deflt, atEnd = false, atStart = false;
      for (let d = $from.depth; ; d--) {
        let node = $from.node(d);
        if (node.isBlock) {
          atEnd = $from.end(d) == $from.pos + ($from.depth - d);
          atStart = $from.start(d) == $from.pos - ($from.depth - d);
          deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
          let splitType = splitNode && splitNode($to.parent, atEnd, $from);
          types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
          splitDepth = d;
          break;
        } else {
          if (d == 1)
            return false;
          types.unshift(null);
        }
      }
      let tr = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr.deleteSelection();
      let splitPos = tr.mapping.map($from.pos);
      let can = canSplit(tr.doc, splitPos, types.length, types);
      if (!can) {
        types[0] = deflt ? { type: deflt } : null;
        can = canSplit(tr.doc, splitPos, types.length, types);
      }
      if (!can)
        return false;
      tr.split(splitPos, types.length, types);
      if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
        let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
        if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
      }
      if (dispatch2)
        dispatch2(tr.scrollIntoView());
      return true;
    };
  }
  var splitBlock = splitBlockAs();
  var selectParentNode = (state, dispatch2) => {
    let { $from, to } = state.selection, pos;
    let same = $from.sharedDepth(to);
    if (same == 0)
      return false;
    pos = $from.before(same);
    if (dispatch2)
      dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  var selectAll = (state, dispatch2) => {
    if (dispatch2)
      dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch2) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
      if (dispatch2)
        dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch2)
      dispatch2(state.tr.join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch2, dir) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    let isolated = before.type.spec.isolating || after.type.spec.isolating;
    if (!isolated && joinMaybeClear(state, $cut, dispatch2))
      return true;
    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch2) {
        let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap2 = Fragment.from(conn[i].create(null, wrap2));
        wrap2 = Fragment.from(before.copy(wrap2));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
        let $joinAt = tr.doc.resolve(end2 + 2 * conn.length);
        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
          tr.join($joinAt.pos);
        dispatch2(tr.scrollIntoView());
      }
      return true;
    }
    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch2)
        dispatch2(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at = before, wrap2 = [];
      for (; ; ) {
        wrap2.push(at);
        if (at.isTextblock)
          break;
        at = at.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
        if (dispatch2) {
          let end2 = Fragment.empty;
          for (let i = wrap2.length - 1; i >= 0; i--)
            end2 = Fragment.from(wrap2[i].copy(end2));
          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
          dispatch2(tr.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch2) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch2)
        dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch2)
        dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType2(nodeType, attrs = null) {
    return function(state, dispatch2) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (applicable)
            return false;
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
            return;
          if (node.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch2) {
        let tr = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
          tr.setBlockType(from2, to, nodeType, attrs);
        }
        dispatch2(tr.scrollIntoView());
      }
      return true;
    };
  }
  function chainCommands(...commands2) {
    return function(state, dispatch2, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch2, view))
          return true;
      return false;
    };
  }
  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  var del2 = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del2,
    "Mod-Delete": del2,
    "Mod-a": selectAll
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (let key in pcBaseKeymap)
    macBaseKeymap[key] = pcBaseKeymap[key];
  var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

  // node_modules/prosemirror-schema-list/dist/index.js
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to);
      if (!range)
        return false;
      let tr = dispatch2 ? state.tr : null;
      if (!wrapRangeInList(tr, range, listType, attrs))
        return false;
      if (dispatch2)
        dispatch2(tr.scrollIntoView());
      return true;
    };
  }
  function wrapRangeInList(tr, range, listType, attrs = null) {
    let doJoin = false, outerRange = range, doc3 = range.$from.doc;
    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if (range.$from.index(range.depth - 1) == 0)
        return false;
      let $insert = doc3.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap2)
      return false;
    if (tr)
      doWrapInList(tr, range, wrap2, doJoin, listType);
    return true;
  }
  function doWrapInList(tr, range, wrappers, joinBefore, listType) {
    let content = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType)
        found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
      if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
        tr.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr;
  }
  function liftListItem(itemType) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch2)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch2, itemType, range);
      else
        return liftOutOfList(state, dispatch2, range);
    };
  }
  function liftToOuterList(state, dispatch2, itemType, range) {
    let tr = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
    if (end2 < endOfList) {
      tr.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr.lift(range, target);
    let $after = tr.doc.resolve(tr.mapping.map(end2, -1) - 1);
    if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
      tr.join($after.pos);
    dispatch2(tr.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch2, range) {
    let tr = state.tr, list = range.parent;
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list.child(i).nodeSize;
      tr.delete(pos - 1, pos + 1);
    }
    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
      return false;
    let start3 = $start.pos, end2 = start3 + item.nodeSize;
    tr.step(new ReplaceAroundStep(start3 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start3 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch2(tr.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch2) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch2) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
      }
      return true;
    };
  }

  // node_modules/@tiptap/core/dist/index.js
  function createChainableState(config2) {
    const { state, transaction } = config2;
    let { selection } = transaction;
    let { doc: doc3 } = transaction;
    let { storedMarks } = transaction;
    return __spreadProps(__spreadValues({}, state), {
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc3;
      },
      get tr() {
        selection = transaction.selection;
        doc3 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    });
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr } = state;
      const props = this.buildProps(tr);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr = startTr || state.tr;
      const run2 = () => {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      }))), {
        run: run2
      });
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch2 = false;
      const tr = startTr || state.tr;
      const props = this.buildProps(tr, dispatch2);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)(__spreadProps(__spreadValues({}, props), { dispatch: void 0 }))];
      }));
      return __spreadProps(__spreadValues({}, formattedCommands), {
        chain: () => this.createChain(tr, dispatch2)
      });
    }
    buildProps(tr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const props = {
        tr,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr, shouldDispatch),
        can: () => this.createCan(tr),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          }));
        }
      };
      return props;
    }
  };
  var EventEmitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(event, fn2) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn2);
      return this;
    }
    emit(event, ...args) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args));
      }
      return this;
    }
    off(event, fn2) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn2) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
    once(event, fn2) {
      const onceFn = (...args) => {
        this.off(event, onceFn);
        fn2.apply(this, args);
      };
      return this.on(event, onceFn);
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  function getExtensionField(extension, field, context) {
    if (extension.config[field] === void 0 && extension.parent) {
      return getExtensionField(extension.parent, field, context);
    }
    if (typeof extension.config[field] === "function") {
      const value = extension.config[field].bind(__spreadProps(__spreadValues({}, context), {
        parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
      }));
      return value;
    }
    return extension.config[field];
  }
  function splitExtensions(extensions) {
    const baseExtensions = extensions.filter((extension) => extension.type === "extension");
    const nodeExtensions = extensions.filter((extension) => extension.type === "node");
    const markExtensions = extensions.filter((extension) => extension.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        extensions: nodeAndMarkExtensions
      };
      const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute)
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addAttributes = getExtensionField(extension, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        const mergedAttr = __spreadValues(__spreadValues({}, defaultAttribute), attribute);
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension.name,
          name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = __spreadValues({}, items);
      Object.entries(item).forEach(([key, value]) => {
        const exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          return;
        }
        if (key === "class") {
          const valueClasses = value ? String(value).split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
          const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
          const styleMap = /* @__PURE__ */ new Map();
          existingStyles.forEach((style2) => {
            const [property, val] = style2.split(":").map((part) => part.trim());
            styleMap.set(property, val);
          });
          newStyles.forEach((style2) => {
            const [property, val] = style2.split(":").map((part) => part.trim());
            styleMap.set(property, val);
          });
          mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return __spreadProps(__spreadValues({}, parseRule), {
      getAttrs: (node) => {
        const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return __spreadProps(__spreadValues({}, items), {
            [item.name]: value
          });
        }, {});
        return __spreadValues(__spreadValues({}, oldAttributes), newAttributes);
      }
    });
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(
      // @ts-ignore
      Object.entries(data).filter(([key, value]) => {
        if (key === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      })
    );
  }
  function getSchemaByResolvedExtensions(extensions, editor) {
    var _a2;
    const allAttributes = getAttributesFromExtensions(extensions);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a2 === void 0 ? void 0 : _a2.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return __spreadValues(__spreadValues({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
      }, {});
      const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraNodeFields), {
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a3;
          return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
        }))
      }));
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return __spreadValues(__spreadValues({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
      }, {});
      const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraMarkFields), {
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a3;
          return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
        }))
      }));
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    }));
    return new Schema({
      topNode,
      nodes,
      marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension.name;
      });
    }
    return enabled;
  }
  function getHTMLFromFragment(fragment, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  var getTextContentFromNodes = ($from, maxMatch = 500) => {
    let textBefore = "";
    const sliceEndPos = $from.parentOffset;
    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
      var _a2, _b;
      const chunk = ((_b = (_a2 = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a2, {
        node,
        pos,
        parent,
        index
      })) || node.textContent || "%leaf%";
      textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
    });
    return textBefore;
  };
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var InputRule = class {
    constructor(config2) {
      this.find = config2.find;
      this.handler = config2.handler;
    }
  };
  var inputRuleMatcherHandler = (text, find) => {
    if (isRegExp(find)) {
      return find.exec(text);
    }
    const inputRuleMatch = find(text);
    if (!inputRuleMatch) {
      return null;
    }
    const result = [inputRuleMatch.text];
    result.index = inputRuleMatch.index;
    result.input = text;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result.push(inputRuleMatch.replaceWith);
    }
    return result;
  };
  function run$1(config2) {
    var _a2;
    const { editor, from: from2, to, text, rules, plugin } = config2;
    const { view } = editor;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from2);
    if (
      // check for code node
      $from.parent.type.spec.code || !!((_a2 = $from.nodeBefore || $from.nodeAfter) === null || _a2 === void 0 ? void 0 : _a2.marks.find((mark) => mark.type.spec.code))
    ) {
      return false;
    }
    let matched = false;
    const textBefore = getTextContentFromNodes($from) + text;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr
      });
      const range = {
        from: from2 - (match[0].length - text.length),
        to
      };
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can
      });
      if (handler === null || !tr.steps.length) {
        return;
      }
      tr.setMeta(plugin, {
        transform: tr,
        from: from2,
        to,
        text
      });
      view.dispatch(tr);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr, prev, state) {
          const stored = tr.getMeta(plugin);
          if (stored) {
            return stored;
          }
          const simulatedInputMeta = tr.getMeta("applyInputRules");
          const isSimulatedInput = !!simulatedInputMeta;
          if (isSimulatedInput) {
            setTimeout(() => {
              let { text } = simulatedInputMeta;
              if (typeof text === "string") {
                text = text;
              } else {
                text = getHTMLFromFragment(Fragment.from(text), state.schema);
              }
              const { from: from2 } = simulatedInputMeta;
              const to = from2 + text.length;
              run$1({
                editor,
                from: from2,
                to,
                text,
                rules,
                plugin
              });
            });
          }
          return tr.selectionSet || tr.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from2, to, text) {
          return run$1({
            editor,
            from: from2,
            to,
            text,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1({
                  editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1({
              editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      // @ts-ignore
      isInputRules: true
    });
    return plugin;
  }
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source) {
    const output = __spreadValues({}, target);
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        if (isPlainObject(source[key]) && isPlainObject(target[key])) {
          output[key] = mergeDeep(target[key], source[key]);
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }
  var Mark2 = class _Mark {
    constructor(config2 = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = __spreadValues(__spreadValues({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Mark(config2);
    }
    configure(options = {}) {
      const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
        addOptions: () => {
          return mergeDeep(this.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Mark(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
    static handleExit({ editor, mark }) {
      const { tr } = editor.state;
      const currentPos = editor.state.selection.$from;
      const isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        const currentMarks = currentPos.marks();
        const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (!isInMark) {
          return false;
        }
        const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
        if (removeMark2) {
          tr.removeStoredMark(removeMark2);
        }
        tr.insertText(" ", currentPos.pos);
        editor.view.dispatch(tr);
        return true;
      }
      return false;
    }
  };
  function isNumber(value) {
    return typeof value === "number";
  }
  var PasteRule = class {
    constructor(config2) {
      this.find = config2.find;
      this.handler = config2.handler;
    }
  };
  var pasteRuleMatcherHandler = (text, find, event) => {
    if (isRegExp(find)) {
      return [...text.matchAll(find)];
    }
    const matches2 = find(text, event);
    if (!matches2) {
      return [];
    }
    return matches2.map((pasteRuleMatch) => {
      const result = [pasteRuleMatch.text];
      result.index = pasteRuleMatch.index;
      result.input = text;
      result.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result.push(pasteRuleMatch.replaceWith);
      }
      return result;
    });
  };
  function run(config2) {
    const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config2;
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handlers2 = [];
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isTextblock || node.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from2, pos);
      const resolvedTo = Math.min(to, pos + node.content.size);
      const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
      matches2.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start3 = resolvedFrom + match.index + 1;
        const end2 = start3 + match[0].length;
        const range = {
          from: state.tr.mapping.map(start3),
          to: state.tr.mapping.map(end2)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can,
          pasteEvent,
          dropEvent
        });
        handlers2.push(handler);
      });
    });
    const success = handlers2.every((handler) => handler !== null);
    return success;
  }
  var tiptapDragFromOtherEditor = null;
  var createClipboardPasteEvent = (text) => {
    var _a2;
    const event = new ClipboardEvent("paste", {
      clipboardData: new DataTransfer()
    });
    (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.setData("text/html", text);
    return event;
  };
  function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    let dropEvent;
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch (e) {
      dropEvent = null;
    }
    const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
      const tr = state.tr;
      const chainableState = createChainableState({
        state,
        transaction: tr
      });
      const handler = run({
        editor,
        state: chainableState,
        from: Math.max(from2 - 1, 0),
        to: to.b - 1,
        rule,
        pasteEvent: pasteEvt,
        dropEvent
      });
      if (!handler || !tr.steps.length) {
        return;
      }
      try {
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      } catch (e) {
        dropEvent = null;
      }
      pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      return tr;
    };
    const plugins = rules.map((rule) => {
      return new Plugin({
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a2;
            dragSourceElement = ((_a2 = view.dom.parentElement) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
            if (dragSourceElement) {
              tiptapDragFromOtherEditor = editor;
            }
          };
          const handleDragend = () => {
            if (tiptapDragFromOtherEditor) {
              tiptapDragFromOtherEditor = null;
            }
          };
          window.addEventListener("dragstart", handleDragstart);
          window.addEventListener("dragend", handleDragend);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
              window.removeEventListener("dragend", handleDragend);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view, event) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              dropEvent = event;
              if (!isDroppedFromProseMirror) {
                const dragFromOtherEditor = tiptapDragFromOtherEditor;
                if (dragFromOtherEditor) {
                  setTimeout(() => {
                    const selection = dragFromOtherEditor.state.selection;
                    if (selection) {
                      dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                    }
                  }, 10);
                }
              }
              return false;
            },
            paste: (_view, event) => {
              var _a2;
              const html = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/html");
              pasteEvent = event;
              isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
          const isSimulatedPaste = !!simulatedPasteMeta;
          if (!isPaste && !isDrop && !isSimulatedPaste) {
            return;
          }
          if (isSimulatedPaste) {
            let { text } = simulatedPasteMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from3 } = simulatedPasteMeta;
            const to2 = from3 + text.length;
            const pasteEvt = createClipboardPasteEvent(text);
            return processEvent({
              rule,
              state,
              from: from3,
              to: { b: to2 },
              pasteEvt
            });
          }
          const from2 = oldState.doc.content.findDiffStart(state.doc.content);
          const to = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber(from2) || !to || from2 === to.b) {
            return;
          }
          return processEvent({
            rule,
            state,
            from: from2,
            to,
            pasteEvt: pasteEvent
          });
        }
      });
    });
    return plugins;
  }
  function findDuplicates(items) {
    const filtered = items.filter((el, index) => items.indexOf(el) !== index);
    return Array.from(new Set(filtered));
  }
  var ExtensionManager = class _ExtensionManager {
    constructor(extensions, editor) {
      this.splittableMarks = [];
      this.editor = editor;
      this.extensions = _ExtensionManager.resolve(extensions);
      this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
      this.setupExtensions();
    }
    /**
     * Returns a flattened and sorted extension list while
     * also checking for duplicated extensions and warns the user.
     * @param extensions An array of Tiptap extensions
     * @returns An flattened and sorted array of Tiptap extensions
     */
    static resolve(extensions) {
      const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
      const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
      if (duplicatedNames.length) {
        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
      }
      return resolvedExtensions;
    }
    /**
     * Create a flattened array of extensions by traversing the `addExtensions` field.
     * @param extensions An array of Tiptap extensions
     * @returns A flattened array of Tiptap extensions
     */
    static flatten(extensions) {
      return extensions.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addExtensions = getExtensionField(extension, "addExtensions", context);
        if (addExtensions) {
          return [extension, ...this.flatten(addExtensions())];
        }
        return extension;
      }).flat(10);
    }
    /**
     * Sort extensions by priority.
     * @param extensions An array of Tiptap extensions
     * @returns A sorted array of Tiptap extensions by priority
     */
    static sort(extensions) {
      const defaultPriority = 100;
      return extensions.sort((a, b) => {
        const priorityA = getExtensionField(a, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    /**
     * Get all commands from the extensions.
     * @returns An object with all commands where the key is the command name and the value is the command function
     */
    get commands() {
      return this.extensions.reduce((commands2, extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const addCommands = getExtensionField(extension, "addCommands", context);
        if (!addCommands) {
          return commands2;
        }
        return __spreadValues(__spreadValues({}, commands2), addCommands());
      }, {});
    }
    /**
     * Get all registered Prosemirror plugins from the extensions.
     * @returns An array of Prosemirror plugins
     */
    get plugins() {
      const { editor } = this;
      const extensions = _ExtensionManager.sort([...this.extensions].reverse());
      const inputRules = [];
      const pasteRules = [];
      const allPlugins = extensions.map((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        const plugins = [];
        const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
        let defaultBindings = {};
        if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
          defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
        }
        if (addKeyboardShortcuts) {
          const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          }));
          defaultBindings = __spreadValues(__spreadValues({}, defaultBindings), bindings);
        }
        const keyMapPlugin = keymap(defaultBindings);
        plugins.push(keyMapPlugin);
        const addInputRules = getExtensionField(extension, "addInputRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPasteRules = getExtensionField(extension, "addPasteRules", context);
        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
          pasteRules.push(...addPasteRules());
        }
        const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
        if (addProseMirrorPlugins) {
          const proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push(...proseMirrorPlugins);
        }
        return plugins;
      }).flat();
      return [
        inputRulesPlugin({
          editor,
          rules: inputRules
        }),
        ...pasteRulesPlugin({
          editor,
          rules: pasteRules
        }),
        ...allPlugins
      ];
    }
    /**
     * Get all attributes from the extensions.
     * @returns An array of attributes
     */
    get attributes() {
      return getAttributesFromExtensions(this.extensions);
    }
    /**
     * Get all node views from the extensions.
     * @returns An object with all node views where the key is the node name and the value is the node view function
     */
    get nodeViews() {
      const { editor } = this;
      const { nodeExtensions } = splitExtensions(this.extensions);
      return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return addNodeView()({
            // pass-through
            node,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, nodeview];
      }));
    }
    /**
     * Go through all extensions, create extension storages & setup marks
     * & bind editor event listener.
     */
    setupExtensions() {
      this.extensions.forEach((extension) => {
        var _a2;
        this.editor.extensionStorage[extension.name] = extension.storage;
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension.name, this.schema)
        };
        if (extension.type === "mark") {
          const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a2 !== void 0 ? _a2 : true;
          if (keepOnSplit) {
            this.splittableMarks.push(extension.name);
          }
        }
        const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
        const onCreate2 = getExtensionField(extension, "onCreate", context);
        const onUpdate = getExtensionField(extension, "onUpdate", context);
        const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
        const onTransaction = getExtensionField(extension, "onTransaction", context);
        const onFocus = getExtensionField(extension, "onFocus", context);
        const onBlur = getExtensionField(extension, "onBlur", context);
        const onDestroy2 = getExtensionField(extension, "onDestroy", context);
        if (onBeforeCreate) {
          this.editor.on("beforeCreate", onBeforeCreate);
        }
        if (onCreate2) {
          this.editor.on("create", onCreate2);
        }
        if (onUpdate) {
          this.editor.on("update", onUpdate);
        }
        if (onSelectionUpdate) {
          this.editor.on("selectionUpdate", onSelectionUpdate);
        }
        if (onTransaction) {
          this.editor.on("transaction", onTransaction);
        }
        if (onFocus) {
          this.editor.on("focus", onFocus);
        }
        if (onBlur) {
          this.editor.on("blur", onBlur);
        }
        if (onDestroy2) {
          this.editor.on("destroy", onDestroy2);
        }
      });
    }
  };
  var Extension = class _Extension {
    constructor(config2 = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = __spreadValues(__spreadValues({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Extension(config2);
    }
    configure(options = {}) {
      const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
        addOptions: () => {
          return mergeDeep(this.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Extension(__spreadValues(__spreadValues({}, this.config), extendedConfig));
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function getTextBetween(startNode, range, options) {
    const { from: from2, to } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    let text = "";
    startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
      var _a2;
      if (node.isBlock && pos > from2) {
        text += blockSeparator;
      }
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
      if (textSerializer) {
        if (parent) {
          text += textSerializer({
            node,
            pos,
            parent,
            index,
            range
          });
        }
        return false;
      }
      if (node.isText) {
        text += (_a2 = node === null || node === void 0 ? void 0 : node.text) === null || _a2 === void 0 ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
      }
    });
    return text;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return {
        blockSeparator: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc: doc3, selection } = state;
              const { ranges } = selection;
              const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from: from2, to };
              return getTextBetween(doc3, range, __spreadProps(__spreadValues({}, this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}), {
                textSerializers
              }));
            }
          }
        })
      ];
    }
  });
  var blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
      var _a2;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a2 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
      }
    });
    return true;
  };
  var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
    return commands2.setContent("", emitUpdate);
  };
  var clearNodes = () => ({ state, tr, dispatch: dispatch2 }) => {
    const { selection } = tr;
    const { ranges } = selection;
    if (!dispatch2) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
        if (node.type.isText) {
          return;
        }
        const { doc: doc3, mapping } = tr;
        const $mappedFrom = doc3.resolve(mapping.map(pos));
        const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  var command = (fn2) => (props) => {
    return fn2(props);
  };
  var createParagraphNear2 = () => ({ state, dispatch: dispatch2 }) => {
    return createParagraphNear(state, dispatch2);
  };
  var cut = (originRange, targetPos) => ({ editor, tr }) => {
    const { state } = editor;
    const contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr.deleteRange(originRange.from, originRange.to);
    const newPos = tr.mapping.map(targetPos);
    tr.insert(newPos, contentSlice.content);
    tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
    return true;
  };
  var deleteCurrentNode = () => ({ tr, dispatch: dispatch2 }) => {
    const { selection } = tr;
    const currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === currentNode.type) {
        if (dispatch2) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteNode = (typeOrName) => ({ tr, state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node = $pos.node(depth);
      if (node.type === type) {
        if (dispatch2) {
          const from2 = $pos.before(depth);
          const to = $pos.after(depth);
          tr.delete(from2, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteRange2 = (range) => ({ tr, dispatch: dispatch2 }) => {
    const { from: from2, to } = range;
    if (dispatch2) {
      tr.delete(from2, to);
    }
    return true;
  };
  var deleteSelection2 = () => ({ state, dispatch: dispatch2 }) => {
    return deleteSelection(state, dispatch2);
  };
  var enter = () => ({ commands: commands2 }) => {
    return commands2.keyboardShortcut("Enter");
  };
  var exitCode2 = () => ({ state, dispatch: dispatch2 }) => {
    return exitCode(state, dispatch2);
  };
  function objectIncludes(object1, object2, options = { strict: true }) {
    const keys2 = Object.keys(object2);
    if (!keys2.length) {
      return true;
    }
    return keys2.every((key) => {
      if (options.strict) {
        return object2[key] === object1[key];
      }
      if (isRegExp(object2[key])) {
        return object2[key].test(object1[key]);
      }
      return object2[key] === object1[key];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
        attributes
      );
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes) {
    var _a2;
    if (!$pos || !type) {
      return;
    }
    let start3 = $pos.parent.childAfter($pos.parentOffset);
    if (!start3.node || !start3.node.marks.some((mark2) => mark2.type === type)) {
      start3 = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start3.node || !start3.node.marks.some((mark2) => mark2.type === type)) {
      return;
    }
    attributes = attributes || ((_a2 = start3.node.marks[0]) === null || _a2 === void 0 ? void 0 : _a2.attrs);
    const mark = findMarkInSet([...start3.node.marks], type, attributes);
    if (!mark) {
      return;
    }
    let startIndex = start3.index;
    let startPos = $pos.start() + start3.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start3.node.nodeSize;
    while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc: doc3, selection } = tr;
    const { $from, from: from2, to } = selection;
    if (dispatch2) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from2 && range.to >= to) {
        const newSelection = TextSelection.create(doc3, range.from, range.to);
        tr.setSelection(newSelection);
      }
    }
    return true;
  };
  var first = (commands2) => (props) => {
    const items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min2 = 0, max2 = 0) {
    return Math.min(Math.max(value, min2), max2);
  }
  function resolveFocusPosition(doc3, position = null) {
    if (!position) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc3);
    const selectionAtEnd = Selection.atEnd(doc3);
    if (position === "start" || position === true) {
      return selectionAtStart;
    }
    if (position === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position === "all") {
      return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
  }
  function isAndroid() {
    return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch: dispatch2 }) => {
    options = __spreadValues({
      scrollIntoView: true
    }, options);
    const delayedFocus = () => {
      if (isiOS() || isAndroid()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch2) {
      if (!isSameSelection) {
        tr.setSelection(selection);
      }
      if (isSameSelection && tr.storedMarks) {
        tr.setStoredMarks(tr.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  var forEach = (items, fn2) => (props) => {
    return items.every((item, index) => fn2(item, __spreadProps(__spreadValues({}, props), { index })));
  };
  var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
    return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
  };
  var removeWhitespaces = (node) => {
    const children = node.childNodes;
    for (let i = children.length - 1; i >= 0; i -= 1) {
      const child = children[i];
      if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
        node.removeChild(child);
      } else if (child.nodeType === 1) {
        removeWhitespaces(child);
      }
    }
    return node;
  };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    return removeWhitespaces(html);
  }
  function createNodeFromContent(content, schema, options) {
    if (content instanceof Node2 || content instanceof Fragment) {
      return content;
    }
    options = __spreadValues({
      slice: true,
      parseOptions: {}
    }, options);
    const isJSONContent = typeof content === "object" && content !== null;
    const isTextContent = typeof content === "string";
    if (isJSONContent) {
      try {
        const isArrayContent = Array.isArray(content) && content.length > 0;
        if (isArrayContent) {
          return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
        }
        const node = schema.nodeFromJSON(content);
        if (options.errorOnInvalidContent) {
          node.check();
        }
        return node;
      } catch (error2) {
        if (options.errorOnInvalidContent) {
          throw new Error("[tiptap error]: Invalid JSON content", { cause: error2 });
        }
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error2);
        return createNodeFromContent("", schema, options);
      }
    }
    if (isTextContent) {
      if (options.errorOnInvalidContent) {
        let hasInvalidContent = false;
        let invalidContent = "";
        const contentCheckSchema = new Schema({
          topNode: schema.spec.topNode,
          marks: schema.spec.marks,
          // Prosemirror's schemas are executed such that: the last to execute, matches last
          // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
          nodes: schema.spec.nodes.append({
            __tiptap__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [
                {
                  tag: "*",
                  getAttrs: (e) => {
                    hasInvalidContent = true;
                    invalidContent = typeof e === "string" ? e : e.outerHTML;
                    return null;
                  }
                }
              ]
            }
          })
        });
        if (options.slice) {
          DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
        } else {
          DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
        }
        if (options.errorOnInvalidContent && hasInvalidContent) {
          throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
        }
      }
      const parser = DOMParser2.fromSchema(schema);
      if (options.slice) {
        return parser.parseSlice(elementFromString(content), options.parseOptions).content;
      }
      return parser.parse(elementFromString(content), options.parseOptions);
    }
    return createNodeFromContent("", schema, options);
  }
  function selectionToInsertionEnd2(tr, startLen, bias) {
    const last = tr.steps.length - 1;
    if (last < startLen) {
      return;
    }
    const step = tr.steps[last];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map2 = tr.mapping.maps[last];
    let end2 = 0;
    map2.forEach((_from, _to, _newFrom, newTo) => {
      if (end2 === 0) {
        end2 = newTo;
      }
    });
    tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return !("type" in nodeOrFragment);
  };
  var insertContentAt = (position, value, options) => ({ tr, dispatch: dispatch2, editor }) => {
    var _a2;
    if (dispatch2) {
      options = __spreadValues({
        parseOptions: editor.options.parseOptions,
        updateSelection: true,
        applyInputRules: false,
        applyPasteRules: false
      }, options);
      let content;
      try {
        content = createNodeFromContent(value, editor.schema, {
          parseOptions: __spreadValues({
            preserveWhitespace: "full"
          }, options.parseOptions),
          errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
        });
      } catch (e) {
        editor.emit("contentError", {
          editor,
          error: e,
          disableCollaboration: () => {
            if (editor.storage.collaboration) {
              editor.storage.collaboration.isDisabled = true;
            }
          }
        });
        return false;
      }
      let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content) ? content : [content];
      nodes.forEach((node) => {
        node.check();
        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
      });
      if (from2 === to && isOnlyBlockContent) {
        const { parent } = tr.doc.resolve(from2);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from2 -= 1;
          to += 1;
        }
      }
      let newContent;
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          newContent = value.map((v) => v.text || "").join("");
        } else if (value instanceof Fragment) {
          let text = "";
          value.forEach((node) => {
            if (node.text) {
              text += node.text;
            }
          });
          newContent = text;
        } else if (typeof value === "object" && !!value && !!value.text) {
          newContent = value.text;
        } else {
          newContent = value;
        }
        tr.insertText(newContent, from2, to);
      } else {
        newContent = content;
        tr.replaceWith(from2, to, newContent);
      }
      if (options.updateSelection) {
        selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
      }
      if (options.applyInputRules) {
        tr.setMeta("applyInputRules", { from: from2, text: newContent });
      }
      if (options.applyPasteRules) {
        tr.setMeta("applyPasteRules", { from: from2, text: newContent });
      }
    }
    return true;
  };
  var joinUp2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinUp(state, dispatch2);
  };
  var joinDown2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinDown(state, dispatch2);
  };
  var joinBackward2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinBackward(state, dispatch2);
  };
  var joinForward2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinForward(state, dispatch2);
  };
  var joinItemBackward = () => ({ state, dispatch: dispatch2, tr }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch2) {
        dispatch2(tr);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
  var joinItemForward = () => ({ state, dispatch: dispatch2, tr }) => {
    try {
      const point = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point === null || point === void 0) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch2) {
        dispatch2(tr);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
  var joinTextblockBackward2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinTextblockBackward(state, dispatch2);
  };
  var joinTextblockForward2 = () => ({ state, dispatch: dispatch2 }) => {
    return joinTextblockForward(state, dispatch2);
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName2(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta) {
      result = `Meta-${result}`;
    }
    if (shift2) {
      result = `Shift-${result}`;
    }
    return result;
  }
  var keyboardShortcut = (name) => ({ editor, view, tr, dispatch: dispatch2 }) => {
    const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
    const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key === "Space" ? " " : key,
      altKey: keys2.includes("Alt"),
      ctrlKey: keys2.includes("Ctrl"),
      metaKey: keys2.includes("Meta"),
      shiftKey: keys2.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
      const newStep = step.map(tr.mapping);
      if (newStep && dispatch2) {
        tr.maybeStep(newStep);
      }
    });
    return true;
  };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from2, to, empty: empty2 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isText) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      nodeRanges.push({
        node,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to - from2;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty2) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (!isActive2) {
      return false;
    }
    return lift2(state, dispatch2);
  };
  var liftEmptyBlock2 = () => ({ state, dispatch: dispatch2 }) => {
    return liftEmptyBlock(state, dispatch2);
  };
  var liftListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem(type)(state, dispatch2);
  };
  var newlineInCode2 = () => ({ state, dispatch: dispatch2 }) => {
    return newlineInCode(state, dispatch2);
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch: dispatch2 }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch2) {
      tr.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach((mark) => {
              if (markType === mark.type) {
                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var scrollIntoView = () => ({ tr, dispatch: dispatch2 }) => {
    if (dispatch2) {
      tr.scrollIntoView();
    }
    return true;
  };
  var selectAll2 = () => ({ tr, dispatch: dispatch2 }) => {
    if (dispatch2) {
      const selection = new AllSelection(tr.doc);
      tr.setSelection(selection);
    }
    return true;
  };
  var selectNodeBackward2 = () => ({ state, dispatch: dispatch2 }) => {
    return selectNodeBackward(state, dispatch2);
  };
  var selectNodeForward2 = () => ({ state, dispatch: dispatch2 }) => {
    return selectNodeForward(state, dispatch2);
  };
  var selectParentNode2 = () => ({ state, dispatch: dispatch2 }) => {
    return selectParentNode(state, dispatch2);
  };
  var selectTextblockEnd2 = () => ({ state, dispatch: dispatch2 }) => {
    return selectTextblockEnd(state, dispatch2);
  };
  var selectTextblockStart2 = () => ({ state, dispatch: dispatch2 }) => {
    return selectTextblockStart(state, dispatch2);
  };
  function createDocument(content, schema, parseOptions = {}, options = {}) {
    return createNodeFromContent(content, schema, {
      slice: false,
      parseOptions,
      errorOnInvalidContent: options.errorOnInvalidContent
    });
  }
  var setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch: dispatch2, commands: commands2 }) => {
    var _a2, _b;
    const { doc: doc3 } = tr;
    if (parseOptions.preserveWhitespace !== "full") {
      const document2 = createDocument(content, editor.schema, parseOptions, {
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
      });
      if (dispatch2) {
        tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
      }
      return true;
    }
    if (dispatch2) {
      tr.setMeta("preventUpdate", !emitUpdate);
    }
    return commands2.insertContentAt({ from: 0, to: doc3.content.size }, content, {
      parseOptions,
      errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
    });
  };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from2, to, empty: empty2 } = state.selection;
    const marks = [];
    if (empty2) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from2, to, (node) => {
        marks.push(...node.marks);
      });
    }
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) {
      return {};
    }
    return __spreadValues({}, mark.attrs);
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node = $pos.node(i);
      if (predicate(node)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getText2(node, options) {
    const range = {
      from: 0,
      to: node.content.size
    };
    return getTextBetween(node, range, options);
  }
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from2, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from2, to, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) {
      return {};
    }
    return __spreadValues({}, node.attrs);
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function getMarksBetween(from2, to, doc3) {
    const marks = [];
    if (from2 === to) {
      doc3.resolve(from2).marks().forEach((mark) => {
        const $pos = doc3.resolve(from2);
        const range = getMarkRange($pos, mark.type);
        if (!range) {
          return;
        }
        marks.push(__spreadValues({
          mark
        }, range));
      });
    } else {
      doc3.nodesBetween(from2, to, (node, pos) => {
        if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
          return;
        }
        marks.push(...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        })));
      });
    }
    return marks;
  }
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty2, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty2) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
        if (!type) {
          return true;
        }
        return type.name === mark.type.name;
      }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from2 = $from.pos;
      const to = $to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (!node.isText && !node.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from2, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  function isList(name, extensions) {
    const { nodeExtensions } = splitExtensions(extensions);
    const extension = nodeExtensions.find((item) => item.name === name);
    if (!extension) {
      return false;
    }
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const group = callOrReturn(getExtensionField(extension, "group", context));
    if (typeof group !== "string") {
      return false;
    }
    return group.split(" ").includes("list");
  }
  function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
    var _a2;
    if (ignoreWhitespace) {
      if (node.type.name === "hardBreak") {
        return true;
      }
      if (node.isText) {
        return /^\s*$/m.test((_a2 = node.text) !== null && _a2 !== void 0 ? _a2 : "");
      }
    }
    if (node.isText) {
      return !node.text;
    }
    if (node.isAtom || node.isLeaf) {
      return false;
    }
    if (node.content.childCount === 0) {
      return true;
    }
    if (checkChildren) {
      let isContentEmpty = true;
      node.content.forEach((childNode) => {
        if (isContentEmpty === false) {
          return;
        }
        if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
          isContentEmpty = false;
        }
      });
      return isContentEmpty;
    }
    return false;
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function posToDOMRect(view, from2, to) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const start3 = view.coordsAtPos(resolvedFrom);
    const end2 = view.coordsAtPos(resolvedEnd, -1);
    const top2 = Math.min(start3.top, end2.top);
    const bottom2 = Math.max(start3.bottom, end2.bottom);
    const left2 = Math.min(start3.left, end2.left);
    const right2 = Math.max(start3.right, end2.right);
    const width = right2 - left2;
    const height = bottom2 - top2;
    const x = left2;
    const y = top2;
    const data = {
      top: top2,
      bottom: bottom2,
      left: left2,
      right: right2,
      width,
      height,
      x,
      y
    };
    return __spreadProps(__spreadValues({}, data), {
      toJSON: () => data
    });
  }
  function canSetMark(state, tr, newMarkType) {
    var _a2;
    const { selection } = tr;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a2 = state.storedMarks) !== null && _a2 !== void 0 ? _a2 : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch2) {
      if (empty2) {
        const oldAttributes = getMarkAttributes(state, type);
        tr.addStoredMark(type.create(__spreadValues(__spreadValues({}, oldAttributes), attributes)));
      } else {
        ranges.forEach((range) => {
          const from2 = range.$from.pos;
          const to = range.$to.pos;
          state.doc.nodesBetween(from2, to, (node, pos) => {
            const trimmedFrom = Math.max(pos, from2);
            const trimmedTo = Math.min(pos + node.nodeSize, to);
            const someHasMark = node.marks.find((mark) => mark.type === type);
            if (someHasMark) {
              node.marks.forEach((mark) => {
                if (type === mark.type) {
                  tr.addMark(trimmedFrom, trimmedTo, type.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr, type);
  };
  var setMeta = (key, value) => ({ tr }) => {
    tr.setMeta(key, value);
    return true;
  };
  var setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    let attributesToCopy;
    if (state.selection.$anchor.sameParent(state.selection.$head)) {
      attributesToCopy = state.selection.$anchor.parent.attrs;
    }
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands: commands2 }) => {
      const canSetBlock = setBlockType2(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes))(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType2(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes))(updatedState, dispatch2);
    }).run();
  };
  var setNodeSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
    if (dispatch2) {
      const { doc: doc3 } = tr;
      const from2 = minMax(position, 0, doc3.content.size);
      const selection = NodeSelection.create(doc3, from2);
      tr.setSelection(selection);
    }
    return true;
  };
  var setTextSelection = (position) => ({ tr, dispatch: dispatch2 }) => {
    if (dispatch2) {
      const { doc: doc3 } = tr;
      const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
      const minPos = TextSelection.atStart(doc3).from;
      const maxPos = TextSelection.atEnd(doc3).to;
      const resolvedFrom = minMax(from2, minPos, maxPos);
      const resolvedEnd = minMax(to, minPos, maxPos);
      const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
      tr.setSelection(selection);
    }
    return true;
  };
  var sinkListItem2 = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem(type)(state, dispatch2);
  };
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch: dispatch2, editor }) => {
    const { selection, doc: doc3 } = tr;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
        return false;
      }
      if (dispatch2) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    const atEnd = $to.parentOffset === $to.parent.content.size;
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (dispatch2) {
      if (can) {
        if (selection instanceof TextSelection) {
          tr.deleteSelection();
        }
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first2 = tr.mapping.map($from.before());
          const $first = tr.doc.resolve(first2);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.scrollIntoView();
    }
    return can;
  };
  var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch: dispatch2, editor }) => {
    var _a2;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node = state.selection.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch2) {
        let wrap2 = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap2 = Fragment.from($from.node(d).copy(wrap2));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
        const nextType2 = ((_a2 = type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start3 = $from.before($from.depth - (depthBefore - 1));
        tr.replace(start3, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
        let sel = -1;
        tr.doc.nodesBetween(start3, tr.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
        }
        tr.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs)), overrideAttrs);
    const newNextTypeAttributes = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
    tr.delete($from.pos, $to.pos);
    const types = nextType ? [
      { type, attrs: newTypeAttributes },
      { type: nextType, attrs: newNextTypeAttributes }
    ] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch2) {
      const { selection, storedMarks } = state;
      const { splittableMarks } = editor.extensionManager;
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch2) {
        return true;
      }
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
    }
    return true;
  };
  var joinListBackwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr.doc.nodeAt(before);
    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr.join(list.pos);
    return true;
  };
  var joinListForwards = (tr, listType) => {
    const list = findParentNode((node) => node.type === listType)(tr.selection);
    if (!list) {
      return true;
    }
    const after = tr.doc.resolve(list.start).after(list.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr.doc.nodeAt(after);
    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr.join(after);
    return true;
  };
  var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch: dispatch2, chain, commands: commands2, can }) => {
    const { extensions, splittableMarks } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection, storedMarks } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
        return chain().command(() => {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
    }
    if (!keepMarks || !marks || !dispatch2) {
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
      tr.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  };
  var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attributes);
    if (isActive2) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
  var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    let attributesToCopy;
    if (state.selection.$anchor.sameParent(state.selection.$head)) {
      attributesToCopy = state.selection.$anchor.parent.attrs;
    }
    if (isActive2) {
      return commands2.setNode(toggleType, attributesToCopy);
    }
    return commands2.setNode(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes));
  };
  var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
  var undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch2) {
          const tr = state.tr;
          const toUndo = undoable.transform;
          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            const marks = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  var unsetAllMarks = () => ({ tr, dispatch: dispatch2 }) => {
    const { selection } = tr;
    const { empty: empty2, ranges } = selection;
    if (empty2) {
      return true;
    }
    if (dispatch2) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch: dispatch2 }) => {
    var _a2;
    const { extendEmptyMarkRange = false } = options;
    const { selection } = tr;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty: empty2, ranges } = selection;
    if (!dispatch2) {
      return true;
    }
    if (empty2 && extendEmptyMarkRange) {
      let { from: from2, to } = selection;
      const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) === null || _a2 === void 0 ? void 0 : _a2.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from2 = range.from;
        to = range.to;
      }
      tr.removeMark(from2, to, type);
    } else {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
  var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch: dispatch2 }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch2) {
      tr.selection.ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        let lastPos;
        let lastNode;
        let trimmedFrom;
        let trimmedTo;
        if (tr.selection.empty) {
          state.doc.nodesBetween(from2, to, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              trimmedFrom = Math.max(pos, from2);
              trimmedTo = Math.min(pos + node.nodeSize, to);
              lastPos = pos;
              lastNode = node;
            }
          });
        } else {
          state.doc.nodesBetween(from2, to, (node, pos) => {
            if (pos < from2 && nodeType && nodeType === node.type) {
              trimmedFrom = Math.max(pos, from2);
              trimmedTo = Math.min(pos + node.nodeSize, to);
              lastPos = pos;
              lastNode = node;
            }
            if (pos >= from2 && pos <= to) {
              if (nodeType && nodeType === node.type) {
                tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, node.attrs), attributes));
              }
              if (markType && node.marks.length) {
                node.marks.forEach((mark) => {
                  if (markType === mark.type) {
                    const trimmedFrom2 = Math.max(pos, from2);
                    const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                    tr.addMark(trimmedFrom2, trimmedTo2, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
                  }
                });
              }
            }
          });
        }
        if (lastNode) {
          if (lastPos !== void 0) {
            tr.setNodeMarkup(lastPos, void 0, __spreadValues(__spreadValues({}, lastNode.attrs), attributes));
          }
          if (markType && lastNode.marks.length) {
            lastNode.marks.forEach((mark) => {
              if (markType === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
              }
            });
          }
        }
      });
    }
    return true;
  };
  var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn(type, attributes)(state, dispatch2);
  };
  var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList(type, attributes)(state, dispatch2);
  };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear: createParagraphNear2,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange: deleteRange2,
    deleteSelection: deleteSelection2,
    enter,
    exitCode: exitCode2,
    extendMarkRange,
    first,
    focus,
    forEach,
    insertContent,
    insertContentAt,
    joinBackward: joinBackward2,
    joinDown: joinDown2,
    joinForward: joinForward2,
    joinItemBackward,
    joinItemForward,
    joinTextblockBackward: joinTextblockBackward2,
    joinTextblockForward: joinTextblockForward2,
    joinUp: joinUp2,
    keyboardShortcut,
    lift: lift3,
    liftEmptyBlock: liftEmptyBlock2,
    liftListItem: liftListItem2,
    newlineInCode: newlineInCode2,
    resetAttributes,
    scrollIntoView,
    selectAll: selectAll2,
    selectNodeBackward: selectNodeBackward2,
    selectNodeForward: selectNodeForward2,
    selectParentNode: selectParentNode2,
    selectTextblockEnd: selectTextblockEnd2,
    selectTextblockStart: selectTextblockStart2,
    setContent,
    setMark,
    setMeta,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem: sinkListItem2,
    splitBlock: splitBlock2,
    splitListItem,
    toggleList,
    toggleMark,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn: wrapIn2,
    wrapInList: wrapInList2
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return __spreadValues({}, commands);
    }
  });
  var Drop = Extension.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tiptapDrop"),
          props: {
            handleDrop: (_, e, slice2, moved) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: e,
                slice: slice2,
                moved
              });
            }
          }
        })
      ];
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  var focusEventsPluginKey = new PluginKey("focusEvents");
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: focusEventsPluginKey,
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.undoInputRule(),
        // maybe convert first text block node to default node
        () => commands2.command(({ tr }) => {
          const { selection, doc: doc3 } = tr;
          const { empty: empty2, $anchor } = selection;
          const { pos, parent } = $anchor;
          const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
          const parentIsIsolating = $parentPos.parent.type.spec.isolating;
          const parentPos = $anchor.pos - $anchor.parentOffset;
          const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
          if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
            return false;
          }
          return commands2.clearNodes();
        }),
        () => commands2.deleteSelection(),
        () => commands2.joinBackward(),
        () => commands2.selectNodeBackward()
      ]);
      const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.deleteSelection(),
        () => commands2.deleteCurrentNode(),
        () => commands2.joinForward(),
        () => commands2.selectNodeForward()
      ]);
      const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.newlineInCode(),
        () => commands2.createParagraphNear(),
        () => commands2.liftEmptyBlock(),
        () => commands2.splitBlock()
      ]);
      const baseKeymap = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete,
        "Mod-Delete": handleDelete,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = __spreadValues({}, baseKeymap);
      const macKeymap = __spreadProps(__spreadValues({}, baseKeymap), {
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete,
        "Ctrl-Alt-Backspace": handleDelete,
        "Alt-Delete": handleDelete,
        "Alt-d": handleDelete,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      });
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            if (transactions.some((tr2) => tr2.getMeta("composition"))) {
              return;
            }
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
            if (!docChanges || ignoreTr) {
              return;
            }
            const { empty: empty2, from: from2, to } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from2 === allFrom && to === allEnd;
            if (empty2 || !allWasSelected) {
              return;
            }
            const isEmpty = isNodeEmpty(newState.doc);
            if (!isEmpty) {
              return;
            }
            const tr = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state
            });
            commands2.clearNodes();
            if (!tr.steps.length) {
              return;
            }
            return tr;
          }
        })
      ];
    }
  });
  var Paste = Extension.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tiptapPaste"),
          props: {
            handlePaste: (_view, e, slice2) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: e,
                slice: slice2
              });
            }
          }
        })
      ];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
          }
        })
      ];
    }
  });
  var NodePos = class _NodePos {
    get name() {
      return this.node.type.name;
    }
    constructor(pos, editor, isBlock = false, node = null) {
      this.currentNode = null;
      this.actualDepth = null;
      this.isBlock = isBlock;
      this.resolvedPos = pos;
      this.editor = editor;
      this.currentNode = node;
    }
    get node() {
      return this.currentNode || this.resolvedPos.node();
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node;
    }
    get depth() {
      var _a2;
      return (_a2 = this.actualDepth) !== null && _a2 !== void 0 ? _a2 : this.resolvedPos.depth;
    }
    get pos() {
      return this.resolvedPos.pos;
    }
    get content() {
      return this.node.content;
    }
    set content(content) {
      let from2 = this.from;
      let to = this.to;
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
          return;
        }
        from2 = this.from + 1;
        to = this.to - 1;
      }
      this.editor.commands.insertContentAt({ from: from2, to }, content);
    }
    get attributes() {
      return this.node.attrs;
    }
    get textContent() {
      return this.node.textContent;
    }
    get size() {
      return this.node.nodeSize;
    }
    get from() {
      if (this.isBlock) {
        return this.pos;
      }
      return this.resolvedPos.start(this.resolvedPos.depth);
    }
    get range() {
      return {
        from: this.from,
        to: this.to
      };
    }
    get to() {
      if (this.isBlock) {
        return this.pos + this.size;
      }
      return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
    }
    get parent() {
      if (this.depth === 0) {
        return null;
      }
      const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
      const $pos = this.resolvedPos.doc.resolve(parentPos);
      return new _NodePos($pos, this.editor);
    }
    get before() {
      let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.from - 3);
      }
      return new _NodePos($pos, this.editor);
    }
    get after() {
      let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.to + 3);
      }
      return new _NodePos($pos, this.editor);
    }
    get children() {
      const children = [];
      this.node.content.forEach((node, offset2) => {
        const isBlock = node.isBlock && !node.isTextblock;
        const isNonTextAtom = node.isAtom && !node.isText;
        const targetPos = this.pos + offset2 + (isNonTextAtom ? 0 : 1);
        const $pos = this.resolvedPos.doc.resolve(targetPos);
        if (!isBlock && $pos.depth <= this.depth) {
          return;
        }
        const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
        if (isBlock) {
          childNodePos.actualDepth = this.depth + 1;
        }
        children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
      });
      return children;
    }
    get firstChild() {
      return this.children[0] || null;
    }
    get lastChild() {
      const children = this.children;
      return children[children.length - 1] || null;
    }
    closest(selector, attributes = {}) {
      let node = null;
      let currentNode = this.parent;
      while (currentNode && !node) {
        if (currentNode.node.type.name === selector) {
          if (Object.keys(attributes).length > 0) {
            const nodeAttributes = currentNode.node.attrs;
            const attrKeys = Object.keys(attributes);
            for (let index = 0; index < attrKeys.length; index += 1) {
              const key = attrKeys[index];
              if (nodeAttributes[key] !== attributes[key]) {
                break;
              }
            }
          } else {
            node = currentNode;
          }
        }
        currentNode = currentNode.parent;
      }
      return node;
    }
    querySelector(selector, attributes = {}) {
      return this.querySelectorAll(selector, attributes, true)[0] || null;
    }
    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
      let nodes = [];
      if (!this.children || this.children.length === 0) {
        return nodes;
      }
      const attrKeys = Object.keys(attributes);
      this.children.forEach((childPos) => {
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        if (childPos.node.type.name === selector) {
          const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
          if (doesAllAttributesMatch) {
            nodes.push(childPos);
          }
        }
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
      });
      return nodes;
    }
    setAttribute(attributes) {
      const { tr } = this.editor.state;
      tr.setNodeMarkup(this.from, void 0, __spreadValues(__spreadValues({}, this.node.attrs), attributes));
      this.editor.view.dispatch(tr);
    }
  };
  var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function createStyleTag(style2, nonce, suffix) {
    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    const styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
    styleNode.innerHTML = style2;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  var Editor = class extends EventEmitter {
    constructor(options = {}) {
      super();
      this.isFocused = false;
      this.isInitialized = false;
      this.extensionStorage = {};
      this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        enableContentCheck: false,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error: error2 }) => {
          throw error2;
        },
        onPaste: () => null,
        onDrop: () => null
      };
      this.isCapturingTransaction = false;
      this.capturedTransaction = null;
      this.setOptions(options);
      this.createExtensionManager();
      this.createCommandManager();
      this.createSchema();
      this.on("beforeCreate", this.options.onBeforeCreate);
      this.emit("beforeCreate", { editor: this });
      this.on("contentError", this.options.onContentError);
      this.createView();
      this.injectCSS();
      this.on("create", this.options.onCreate);
      this.on("update", this.options.onUpdate);
      this.on("selectionUpdate", this.options.onSelectionUpdate);
      this.on("transaction", this.options.onTransaction);
      this.on("focus", this.options.onFocus);
      this.on("blur", this.options.onBlur);
      this.on("destroy", this.options.onDestroy);
      this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
      this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
      window.setTimeout(() => {
        if (this.isDestroyed) {
          return;
        }
        this.commands.focus(this.options.autofocus);
        this.emit("create", { editor: this });
        this.isInitialized = true;
      }, 0);
    }
    /**
     * Returns the editor storage.
     */
    get storage() {
      return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
    get commands() {
      return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain() {
      return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can() {
      return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
    injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style, this.options.injectNonce);
      }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options = {}) {
      this.options = __spreadValues(__spreadValues({}, this.options), options);
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
    setEditable(editable, emitUpdate = true) {
      this.setOptions({ editable });
      if (emitUpdate) {
        this.emit("update", { editor: this, transaction: this.state.tr });
      }
    }
    /**
     * Returns whether the editor is editable.
     */
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
    get state() {
      return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     * @returns The new editor state
     */
    registerPlugin(plugin, handlePlugins) {
      const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
      const state = this.state.reconfigure({ plugins });
      this.view.updateState(state);
      return state;
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKeyToRemove The plugins name
     * @returns The new editor state or undefined if the editor is destroyed
     */
    unregisterPlugin(nameOrPluginKeyToRemove) {
      if (this.isDestroyed) {
        return void 0;
      }
      const prevPlugins = this.state.plugins;
      let plugins = prevPlugins;
      [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
        const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
        plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
      });
      if (prevPlugins.length === plugins.length) {
        return void 0;
      }
      const state = this.state.reconfigure({
        plugins
      });
      this.view.updateState(state);
      return state;
    }
    /**
     * Creates an extension manager.
     */
    createExtensionManager() {
      var _a2, _b;
      const coreExtensions = this.options.enableCoreExtensions ? [
        Editable,
        ClipboardTextSerializer.configure({
          blockSeparator: (_b = (_a2 = this.options.coreExtensionOptions) === null || _a2 === void 0 ? void 0 : _a2.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
        }),
        Commands,
        FocusEvents,
        Keymap,
        Tabindex,
        Drop,
        Paste
      ].filter((ext) => {
        if (typeof this.options.enableCoreExtensions === "object") {
          return this.options.enableCoreExtensions[ext.name] !== false;
        }
        return true;
      }) : [];
      const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
        return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
    createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    /**
     * Creates a ProseMirror schema.
     */
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
    createView() {
      var _a2;
      let doc3;
      try {
        doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
      } catch (e) {
        if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
          throw e;
        }
        this.emit("contentError", {
          editor: this,
          error: e,
          disableCollaboration: () => {
            if (this.storage.collaboration) {
              this.storage.collaboration.isDisabled = true;
            }
            this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
            this.createExtensionManager();
          }
        });
        doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
      }
      const selection = resolveFocusPosition(doc3, this.options.autofocus);
      this.view = new EditorView(this.options.element, __spreadProps(__spreadValues({}, this.options.editorProps), {
        attributes: __spreadValues({
          // add `role="textbox"` to the editor element
          role: "textbox"
        }, (_a2 = this.options.editorProps) === null || _a2 === void 0 ? void 0 : _a2.attributes),
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc3,
          selection: selection || void 0
        })
      }));
      const newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      const dom = this.view.dom;
      dom.editor = this;
    }
    /**
     * Creates all node views.
     */
    createNodeViews() {
      if (this.view.isDestroyed) {
        return;
      }
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    /**
     * Prepend class name to element.
     */
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(fn2) {
      this.isCapturingTransaction = true;
      fn2();
      this.isCapturingTransaction = false;
      const tr = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    dispatchTransaction(transaction) {
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach((step) => {
          var _a2;
          return (_a2 = this.capturedTransaction) === null || _a2 === void 0 ? void 0 : _a2.step(step);
        });
        return;
      }
      const state = this.state.apply(transaction);
      const selectionHasChanged = !this.state.selection.eq(state.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction,
        nextState: state
      });
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction
        });
      }
      const focus2 = transaction.getMeta("focus");
      const blur2 = transaction.getMeta("blur");
      if (focus2) {
        this.emit("focus", {
          editor: this,
          event: focus2.event,
          transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction
      });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType) {
      return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
      const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
    getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
    getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
    getText(options) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      return getText2(this.state.doc, {
        blockSeparator,
        textSerializers: __spreadValues(__spreadValues({}, getTextSerializersFromSchema(this.schema)), textSerializers)
      });
    }
    /**
     * Check if there is no content.
     */
    get isEmpty() {
      return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
    destroy() {
      this.emit("destroy");
      if (this.view) {
        const dom = this.view.dom;
        if (dom && dom.editor) {
          delete dom.editor;
        }
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed() {
      var _a2;
      return !((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.docView);
    }
    $node(selector, attributes) {
      var _a2;
      return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector, attributes)) || null;
    }
    $nodes(selector, attributes) {
      var _a2;
      return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
    }
    $pos(pos) {
      const $pos = this.state.doc.resolve(pos);
      return new NodePos($pos, this);
    }
    get $doc() {
      return this.$pos(0);
    }
  };
  function markInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config2.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          const markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }
  function nodeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        const { tr } = state;
        const start3 = range.from;
        let end2 = range.to;
        const newNode = config2.type.create(attributes);
        if (match[1]) {
          const offset2 = match[0].lastIndexOf(match[1]);
          let matchStart = start3 + offset2;
          if (matchStart > end2) {
            matchStart = end2;
          } else {
            end2 = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr.insertText(lastChar, start3 + match[0].length - 1);
          tr.replaceWith(matchStart, end2, newNode);
        } else if (match[0]) {
          const insertionStart = config2.type.isInline ? start3 : start3 - 1;
          tr.insert(insertionStart, config2.type.create(attributes)).delete(tr.mapping.map(start3), tr.mapping.map(end2));
        }
        tr.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config2.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config2.type, attributes);
      }
    });
  }
  function wrappingInputRule(config2) {
    return new InputRule({
      find: config2.find,
      handler: ({ state, range, match, chain }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match) || {};
        const tr = state.tr.delete(range.from, range.to);
        const $start = tr.doc.resolve(range.from);
        const blockRange = $start.blockRange();
        const wrapping = blockRange && findWrapping(blockRange, config2.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr.wrap(blockRange, wrapping);
        if (config2.keepMarks && config2.editor) {
          const { selection, storedMarks } = state;
          const { splittableMarks } = config2.editor.extensionManager;
          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          if (marks) {
            const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
            tr.ensureMarks(filteredMarks);
          }
        }
        if (config2.keepAttributes) {
          const nodeType = config2.type.name === "bulletList" || config2.type.name === "orderedList" ? "listItem" : "taskList";
          chain().updateAttributes(nodeType, attributes).run();
        }
        const before = tr.doc.resolve(range.from - 1).nodeBefore;
        if (before && before.type === config2.type && canJoin(tr.doc, range.from - 1) && (!config2.joinPredicate || config2.joinPredicate(match, before))) {
          tr.join(range.from - 1);
        }
      }
    });
  }
  var Node3 = class _Node {
    constructor(config2 = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = __spreadValues(__spreadValues({}, this.config), config2);
      this.name = this.config.name;
      if (config2.defaultOptions && Object.keys(config2.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config2 = {}) {
      return new _Node(config2);
    }
    configure(options = {}) {
      const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
        addOptions: () => {
          return mergeDeep(this.options, options);
        }
      }));
      extension.name = this.name;
      extension.parent = this.parent;
      return extension;
    }
    extend(extendedConfig = {}) {
      const extension = new _Node(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
      }
      extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  };
  function markPasteRule(config2) {
    return new PasteRule({
      find: config2.find,
      handler: ({ state, range, match, pasteEvent }) => {
        const attributes = callOrReturn(config2.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config2.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr.addMark(range.from + startSpaces, markEnd, config2.type.create(attributes || {}));
          tr.removeStoredMark(config2.type);
        }
      }
    });
  }

  // node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain,
    afterRead: () => afterRead,
    afterWrite: () => afterWrite,
    applyStyles: () => applyStyles_default,
    arrow: () => arrow_default,
    auto: () => auto,
    basePlacements: () => basePlacements,
    beforeMain: () => beforeMain,
    beforeRead: () => beforeRead,
    beforeWrite: () => beforeWrite,
    bottom: () => bottom,
    clippingParents: () => clippingParents,
    computeStyles: () => computeStyles_default,
    createPopper: () => createPopper3,
    createPopperBase: () => createPopper,
    createPopperLite: () => createPopper2,
    detectOverflow: () => detectOverflow,
    end: () => end,
    eventListeners: () => eventListeners_default,
    flip: () => flip_default,
    hide: () => hide_default,
    left: () => left,
    main: () => main,
    modifierPhases: () => modifierPhases,
    offset: () => offset_default,
    placements: () => placements,
    popper: () => popper,
    popperGenerator: () => popperGenerator,
    popperOffsets: () => popperOffsets_default,
    preventOverflow: () => preventOverflow_default,
    read: () => read,
    reference: () => reference,
    right: () => right,
    start: () => start,
    top: () => top,
    variationPlacements: () => variationPlacements,
    viewport: () => viewport,
    write: () => write
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style2 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect2 = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect2.width / scaleX;
    var height = clientRect2.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect2 = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect2.width - width) <= 1) {
      width = clientRect2.width;
    }
    if (Math.abs(clientRect2.height - height) <= 1) {
      height = clientRect2.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers2) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers2.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers2.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers2) {
    var orderedModifiers = order(modifiers2);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers2) {
    var merged = modifiers2.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions3 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper4(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions3;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions3),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions3, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect5 = _ref.effect;
          if (typeof effect5 === "function") {
            var cleanupFn = effect5({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var createPopper = /* @__PURE__ */ popperGenerator();

  // node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper2 = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper3 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers2
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
    return document.body;
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys2) {
    var clone = Object.assign({}, obj);
    keys2.forEach(function(key) {
      delete clone[key];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  function actualContains(parent, child) {
    var target = child;
    while (target) {
      var _target$getRootNode;
      if (parent.contains(target)) {
        return true;
      }
      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }
    return false;
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var isIE11 = isBrowser ? (
    // @ts-ignore
    !!window.msCrypto
  ) : false;
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      // title
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      // message
      "line-height: 1.5",
      // footer
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        var _name;
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys2 = Object.keys(partialProps);
    keys2.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow3 = div();
    if (value === true) {
      arrow3.className = ARROW_CLASS;
    } else {
      arrow3.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow3.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow3, value);
      }
    }
    return arrow3;
  }
  function setContent2(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent2(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow3 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent2(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow3) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow3);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow3) {
        box2.removeChild(arrow3);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      // methods
      clearDelayTimeouts,
      setProps,
      setContent: setContent3,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function() {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }
      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
      if (instance.props.interactive && actualContains(popper2, actualTarget)) {
        return;
      }
      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc3 = getDocument();
      doc3.addEventListener("mousedown", onDocumentPress, true);
      doc3.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc3 = getDocument();
      doc3.removeEventListener("mousedown", onDocumentPress, true);
      doc3.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc3.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc3.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger2, {
          passive: true
        });
        on("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow3 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers2 = [{
        name: "offset",
        options: {
          offset: offset2
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow3) {
        modifiers2.push({
          name: "arrow",
          options: {
            element: arrow3,
            padding: 3
          }
        });
      }
      modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper3(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers: modifiers2
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode2;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
        parentNode2 = node.parentNode;
      } else {
        parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
      }
      if (!parentNode2.contains(popper2)) {
        parentNode2.appendChild(popper2);
      }
      instance.state.isMounted = true;
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent3(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled2 = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled2 || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled2 = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled2) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances[0] : instances;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  var applyStylesModifier = Object.assign({}, applyStyles_default, {
    effect: function effect4(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    }
  });
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // node_modules/@tiptap/extension-bubble-menu/dist/index.js
  var BubbleMenuView = class {
    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
      this.preventHide = false;
      this.shouldShow = ({ view: view2, state, from: from2, to }) => {
        const { doc: doc3, selection } = state;
        const { empty: empty2 } = selection;
        const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
        const isChildOfMenu = this.element.contains(document.activeElement);
        const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
        if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
          return false;
        }
        return true;
      };
      this.mousedownHandler = () => {
        this.preventHide = true;
      };
      this.dragstartHandler = () => {
        this.hide();
      };
      this.focusHandler = () => {
        setTimeout(() => this.update(this.editor.view));
      };
      this.blurHandler = ({ event }) => {
        var _a2;
        if (this.preventHide) {
          this.preventHide = false;
          return;
        }
        if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a2 = this.element.parentNode) === null || _a2 === void 0 ? void 0 : _a2.contains(event.relatedTarget))) {
          return;
        }
        if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {
          return;
        }
        this.hide();
      };
      this.tippyBlurHandler = (event) => {
        this.blurHandler({ event });
      };
      this.handleDebouncedUpdate = (view2, oldState) => {
        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view2.state.selection));
        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view2.state.doc));
        if (!selectionChanged && !docChanged) {
          return;
        }
        if (this.updateDebounceTimer) {
          clearTimeout(this.updateDebounceTimer);
        }
        this.updateDebounceTimer = window.setTimeout(() => {
          this.updateHandler(view2, selectionChanged, docChanged, oldState);
        }, this.updateDelay);
      };
      this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
        var _a2, _b, _c;
        const { state, composing } = view2;
        const { selection } = state;
        const isSame = !selectionChanged && !docChanged;
        if (composing || isSame) {
          return;
        }
        this.createTooltip();
        const { ranges } = selection;
        const from2 = Math.min(...ranges.map((range) => range.$from.pos));
        const to = Math.max(...ranges.map((range) => range.$to.pos));
        const shouldShow2 = (_a2 = this.shouldShow) === null || _a2 === void 0 ? void 0 : _a2.call(this, {
          editor: this.editor,
          element: this.element,
          view: view2,
          state,
          oldState,
          from: from2,
          to
        });
        if (!shouldShow2) {
          this.hide();
          return;
        }
        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
          getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
            if (isNodeSelection(state.selection)) {
              let node = view2.nodeDOM(from2);
              if (node) {
                const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector("[data-node-view-wrapper]");
                if (nodeViewWrapper) {
                  node = nodeViewWrapper.firstChild;
                }
                if (node) {
                  return node.getBoundingClientRect();
                }
              }
            }
            return posToDOMRect(view2, from2, to);
          })
        });
        this.show();
      };
      this.editor = editor;
      this.element = element;
      this.view = view;
      this.updateDelay = updateDelay;
      if (shouldShow) {
        this.shouldShow = shouldShow;
      }
      this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.addEventListener("dragstart", this.dragstartHandler);
      this.editor.on("focus", this.focusHandler);
      this.editor.on("blur", this.blurHandler);
      this.tippyOptions = tippyOptions;
      this.element.remove();
      this.element.style.visibility = "visible";
    }
    createTooltip() {
      const { element: editorElement } = this.editor.options;
      const editorIsAttached = !!editorElement.parentElement;
      if (this.tippy || !editorIsAttached) {
        return;
      }
      this.tippy = tippy_esm_default(editorElement, __spreadValues({
        duration: 0,
        getReferenceClientRect: null,
        content: this.element,
        interactive: true,
        trigger: "manual",
        placement: "top",
        hideOnClick: "toggle"
      }, this.tippyOptions));
      if (this.tippy.popper.firstChild) {
        this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
      }
    }
    update(view, oldState) {
      const { state } = view;
      const hasValidSelection = state.selection.from !== state.selection.to;
      if (this.updateDelay > 0 && hasValidSelection) {
        this.handleDebouncedUpdate(view, oldState);
        return;
      }
      const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));
      const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));
      this.updateHandler(view, selectionChanged, docChanged, oldState);
    }
    show() {
      var _a2;
      (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.show();
    }
    hide() {
      var _a2;
      (_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.hide();
    }
    destroy() {
      var _a2, _b;
      if ((_a2 = this.tippy) === null || _a2 === void 0 ? void 0 : _a2.popper.firstChild) {
        this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
      this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
      this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
      this.editor.off("focus", this.focusHandler);
      this.editor.off("blur", this.blurHandler);
    }
  };
  var BubbleMenuPlugin = (options) => {
    return new Plugin({
      key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
      view: (view) => new BubbleMenuView(__spreadValues({ view }, options))
    });
  };
  var BubbleMenu = Extension.create({
    name: "bubbleMenu",
    addOptions() {
      return {
        element: null,
        tippyOptions: {},
        pluginKey: "bubbleMenu",
        updateDelay: void 0,
        shouldShow: null
      };
    },
    addProseMirrorPlugins() {
      if (!this.options.element) {
        return [];
      }
      return [
        BubbleMenuPlugin({
          pluginKey: this.options.pluginKey,
          editor: this.editor,
          element: this.options.element,
          tippyOptions: this.options.tippyOptions,
          updateDelay: this.options.updateDelay,
          shouldShow: this.options.shouldShow
        })
      ];
    }
  });

  // node_modules/@tiptap/react/dist/index.js
  var import_react = __toESM(require_react(), 1);
  var import_react_dom = __toESM(require_react_dom(), 1);
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var shim = { exports: {} };
  var useSyncExternalStoreShim_development = {};
  var hasRequiredUseSyncExternalStoreShim_development;
  function requireUseSyncExternalStoreShim_development() {
    if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
    hasRequiredUseSyncExternalStoreShim_development = 1;
    if (true) {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React$1 = import_react.default;
        var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState2 = React$1.useState, useEffect3 = React$1.useEffect, useLayoutEffect2 = React$1.useLayoutEffect, useDebugValue2 = React$1.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React$1.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error2("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState2({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect2(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect3(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
        useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
    return useSyncExternalStoreShim_development;
  }
  if (false) {
    shim.exports = requireUseSyncExternalStoreShim_production_min();
  } else {
    shim.exports = requireUseSyncExternalStoreShim_development();
  }
  var shimExports = shim.exports;
  var mergeRefs = (...refs) => {
    return (node) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(node);
        } else if (ref) {
          ref.current = node;
        }
      });
    };
  };
  var Portals = ({ contentComponent }) => {
    const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
    return import_react.default.createElement(import_react.default.Fragment, null, Object.values(renderers));
  };
  function getInstance() {
    const subscribers = /* @__PURE__ */ new Set();
    let renderers = {};
    return {
      /**
       * Subscribe to the editor instance's changes.
       */
      subscribe(callback) {
        subscribers.add(callback);
        return () => {
          subscribers.delete(callback);
        };
      },
      getSnapshot() {
        return renderers;
      },
      getServerSnapshot() {
        return renderers;
      },
      /**
       * Adds a new NodeView Renderer to the editor.
       */
      setRenderer(id, renderer) {
        renderers = __spreadProps(__spreadValues({}, renderers), {
          [id]: import_react_dom.default.createPortal(renderer.reactElement, renderer.element, id)
        });
        subscribers.forEach((subscriber) => subscriber());
      },
      /**
       * Removes a NodeView Renderer from the editor.
       */
      removeRenderer(id) {
        const nextRenderers = __spreadValues({}, renderers);
        delete nextRenderers[id];
        renderers = nextRenderers;
        subscribers.forEach((subscriber) => subscriber());
      }
    };
  }
  var PureEditorContent = class extends import_react.default.Component {
    constructor(props) {
      var _a2;
      super(props);
      this.editorContentRef = import_react.default.createRef();
      this.initialized = false;
      this.state = {
        hasContentComponentInitialized: Boolean((_a2 = props.editor) === null || _a2 === void 0 ? void 0 : _a2.contentComponent)
      };
    }
    componentDidMount() {
      this.init();
    }
    componentDidUpdate() {
      this.init();
    }
    init() {
      const editor = this.props.editor;
      if (editor && !editor.isDestroyed && editor.options.element) {
        if (editor.contentComponent) {
          return;
        }
        const element = this.editorContentRef.current;
        element.append(...editor.options.element.childNodes);
        editor.setOptions({
          element
        });
        editor.contentComponent = getInstance();
        if (!this.state.hasContentComponentInitialized) {
          this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
            this.setState((prevState) => {
              if (!prevState.hasContentComponentInitialized) {
                return {
                  hasContentComponentInitialized: true
                };
              }
              return prevState;
            });
            if (this.unsubscribeToContentComponent) {
              this.unsubscribeToContentComponent();
            }
          });
        }
        editor.createNodeViews();
        this.initialized = true;
      }
    }
    componentWillUnmount() {
      const editor = this.props.editor;
      if (!editor) {
        return;
      }
      this.initialized = false;
      if (!editor.isDestroyed) {
        editor.view.setProps({
          nodeViews: {}
        });
      }
      if (this.unsubscribeToContentComponent) {
        this.unsubscribeToContentComponent();
      }
      editor.contentComponent = null;
      if (!editor.options.element.firstChild) {
        return;
      }
      const newElement = document.createElement("div");
      newElement.append(...editor.options.element.childNodes);
      editor.setOptions({
        element: newElement
      });
    }
    render() {
      const _a2 = this.props, { editor, innerRef } = _a2, rest = __objRest(_a2, ["editor", "innerRef"]);
      return import_react.default.createElement(
        import_react.default.Fragment,
        null,
        import_react.default.createElement("div", __spreadValues({ ref: mergeRefs(innerRef, this.editorContentRef) }, rest)),
        (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && import_react.default.createElement(Portals, { contentComponent: editor.contentComponent })
      );
    }
  };
  var EditorContentWithKey = (0, import_react.forwardRef)((props, ref) => {
    const key = import_react.default.useMemo(() => {
      return Math.floor(Math.random() * 4294967295).toString();
    }, [props.editor]);
    return import_react.default.createElement(PureEditorContent, __spreadValues({
      key,
      innerRef: ref
    }, props));
  });
  var EditorContent = import_react.default.memo(EditorContentWithKey);
  var react = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys2;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return false;
        for (i of a.entries())
          if (!b.has(i[0])) return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0]))) return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return false;
        for (i of a.entries())
          if (!b.has(i[0])) return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; )
          if (a[i] !== b[i]) return false;
        return true;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      keys2 = Object.keys(a);
      length = keys2.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys2[i];
        if (key === "_owner" && a.$$typeof) {
          continue;
        }
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
  var deepEqual = /* @__PURE__ */ getDefaultExportFromCjs(react);
  var withSelector = { exports: {} };
  var withSelector_development = {};
  var hasRequiredWithSelector_development;
  function requireWithSelector_development() {
    if (hasRequiredWithSelector_development) return withSelector_development;
    hasRequiredWithSelector_development = 1;
    if (true) {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React$1 = import_react.default;
        var shim2 = shimExports;
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim2.useSyncExternalStore;
        var useRef3 = React$1.useRef, useEffect3 = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue2 = React$1.useDebugValue;
        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef3(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection2 = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection2, getServerSelection);
          useEffect3(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue2(value);
          return value;
        }
        withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
    return withSelector_development;
  }
  if (false) {
    withSelector.exports = requireWithSelector_production_min();
  } else {
    withSelector.exports = requireWithSelector_development();
  }
  var withSelectorExports = withSelector.exports;
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
  var EditorStateManager = class {
    constructor(initialEditor) {
      this.transactionNumber = 0;
      this.lastTransactionNumber = 0;
      this.subscribers = /* @__PURE__ */ new Set();
      this.editor = initialEditor;
      this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
      this.getSnapshot = this.getSnapshot.bind(this);
      this.getServerSnapshot = this.getServerSnapshot.bind(this);
      this.watch = this.watch.bind(this);
      this.subscribe = this.subscribe.bind(this);
    }
    /**
     * Get the current editor instance.
     */
    getSnapshot() {
      if (this.transactionNumber === this.lastTransactionNumber) {
        return this.lastSnapshot;
      }
      this.lastTransactionNumber = this.transactionNumber;
      this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };
      return this.lastSnapshot;
    }
    /**
     * Always disable the editor on the server-side.
     */
    getServerSnapshot() {
      return { editor: null, transactionNumber: 0 };
    }
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(callback) {
      this.subscribers.add(callback);
      return () => {
        this.subscribers.delete(callback);
      };
    }
    /**
     * Watch the editor instance for changes.
     */
    watch(nextEditor) {
      this.editor = nextEditor;
      if (this.editor) {
        const fn2 = () => {
          this.transactionNumber += 1;
          this.subscribers.forEach((callback) => callback());
        };
        const currentEditor = this.editor;
        currentEditor.on("transaction", fn2);
        return () => {
          currentEditor.off("transaction", fn2);
        };
      }
      return void 0;
    }
  };
  function useEditorState(options) {
    var _a2;
    const [editorStateManager] = (0, import_react.useState)(() => new EditorStateManager(options.editor));
    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a2 = options.equalityFn) !== null && _a2 !== void 0 ? _a2 : deepEqual);
    useIsomorphicLayoutEffect(() => {
      return editorStateManager.watch(options.editor);
    }, [options.editor, editorStateManager]);
    (0, import_react.useDebugValue)(selectedState);
    return selectedState;
  }
  var isDev = true;
  var isSSR = typeof window === "undefined";
  var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
  var EditorInstanceManager = class _EditorInstanceManager {
    constructor(options) {
      this.editor = null;
      this.subscriptions = /* @__PURE__ */ new Set();
      this.isComponentMounted = false;
      this.previousDeps = null;
      this.instanceId = "";
      this.options = options;
      this.subscriptions = /* @__PURE__ */ new Set();
      this.setEditor(this.getInitialEditor());
      this.scheduleDestroy();
      this.getEditor = this.getEditor.bind(this);
      this.getServerSnapshot = this.getServerSnapshot.bind(this);
      this.subscribe = this.subscribe.bind(this);
      this.refreshEditorInstance = this.refreshEditorInstance.bind(this);
      this.scheduleDestroy = this.scheduleDestroy.bind(this);
      this.onRender = this.onRender.bind(this);
      this.createEditor = this.createEditor.bind(this);
    }
    setEditor(editor) {
      this.editor = editor;
      this.instanceId = Math.random().toString(36).slice(2, 9);
      this.subscriptions.forEach((cb) => cb());
    }
    getInitialEditor() {
      if (this.options.current.immediatelyRender === void 0) {
        if (isSSR || isNext) {
          if (isDev) {
            console.warn("Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.");
          }
          return null;
        }
        return this.createEditor();
      }
      if (this.options.current.immediatelyRender && isSSR && isDev) {
        throw new Error("Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.");
      }
      if (this.options.current.immediatelyRender) {
        return this.createEditor();
      }
      return null;
    }
    /**
     * Create a new editor instance. And attach event listeners.
     */
    createEditor() {
      const optionsToApply = __spreadProps(__spreadValues({}, this.options.current), {
        // Always call the most recent version of the callback function by default
        onBeforeCreate: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onBlur: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onCreate: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onDestroy: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onFocus: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onSelectionUpdate: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onTransaction: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onUpdate: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onContentError: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onDrop: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        },
        onPaste: (...args) => {
          var _a2, _b;
          return (_b = (_a2 = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a2, ...args);
        }
      });
      const editor = new Editor(optionsToApply);
      return editor;
    }
    /**
     * Get the current editor instance.
     */
    getEditor() {
      return this.editor;
    }
    /**
     * Always disable the editor on the server-side.
     */
    getServerSnapshot() {
      return null;
    }
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(onStoreChange) {
      this.subscriptions.add(onStoreChange);
      return () => {
        this.subscriptions.delete(onStoreChange);
      };
    }
    static compareOptions(a, b) {
      return Object.keys(a).every((key) => {
        if (["onCreate", "onBeforeCreate", "onDestroy", "onUpdate", "onTransaction", "onFocus", "onBlur", "onSelectionUpdate", "onContentError", "onDrop", "onPaste"].includes(key)) {
          return true;
        }
        if (key === "extensions" && a.extensions && b.extensions) {
          if (a.extensions.length !== b.extensions.length) {
            return false;
          }
          return a.extensions.every((extension, index) => {
            var _a2;
            if (extension !== ((_a2 = b.extensions) === null || _a2 === void 0 ? void 0 : _a2[index])) {
              return false;
            }
            return true;
          });
        }
        if (a[key] !== b[key]) {
          return false;
        }
        return true;
      });
    }
    /**
     * On each render, we will create, update, or destroy the editor instance.
     * @param deps The dependencies to watch for changes
     * @returns A cleanup function
     */
    onRender(deps) {
      return () => {
        this.isComponentMounted = true;
        clearTimeout(this.scheduledDestructionTimeout);
        if (this.editor && !this.editor.isDestroyed && deps.length === 0) {
          if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {
            this.editor.setOptions(__spreadProps(__spreadValues({}, this.options.current), {
              editable: this.editor.isEditable
            }));
          }
        } else {
          this.refreshEditorInstance(deps);
        }
        return () => {
          this.isComponentMounted = false;
          this.scheduleDestroy();
        };
      };
    }
    /**
     * Recreate the editor instance if the dependencies have changed.
     */
    refreshEditorInstance(deps) {
      if (this.editor && !this.editor.isDestroyed) {
        if (this.previousDeps === null) {
          this.previousDeps = deps;
          return;
        }
        const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);
        if (depsAreEqual) {
          return;
        }
      }
      if (this.editor && !this.editor.isDestroyed) {
        this.editor.destroy();
      }
      this.setEditor(this.createEditor());
      this.previousDeps = deps;
    }
    /**
     * Schedule the destruction of the editor instance.
     * This will only destroy the editor if it was not mounted on the next tick.
     * This is to avoid destroying the editor instance when it's actually still mounted.
     */
    scheduleDestroy() {
      const currentInstanceId = this.instanceId;
      const currentEditor = this.editor;
      this.scheduledDestructionTimeout = setTimeout(() => {
        if (this.isComponentMounted && this.instanceId === currentInstanceId) {
          if (currentEditor) {
            currentEditor.setOptions(this.options.current);
          }
          return;
        }
        if (currentEditor && !currentEditor.isDestroyed) {
          currentEditor.destroy();
          if (this.instanceId === currentInstanceId) {
            this.setEditor(null);
          }
        }
      }, 1);
    }
  };
  function useEditor(options = {}, deps = []) {
    const mostRecentOptions = (0, import_react.useRef)(options);
    mostRecentOptions.current = options;
    const [instanceManager] = (0, import_react.useState)(() => new EditorInstanceManager(mostRecentOptions));
    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);
    (0, import_react.useDebugValue)(editor);
    (0, import_react.useEffect)(instanceManager.onRender(deps));
    useEditorState({
      editor,
      selector: ({ transactionNumber }) => {
        if (options.shouldRerenderOnTransaction === false) {
          return null;
        }
        if (options.immediatelyRender && transactionNumber === 0) {
          return 0;
        }
        return transactionNumber + 1;
      }
    });
    return editor;
  }
  var EditorContext = (0, import_react.createContext)({
    editor: null
  });
  var EditorConsumer = EditorContext.Consumer;
  var useCurrentEditor = () => (0, import_react.useContext)(EditorContext);
  var BubbleMenu2 = (props) => {
    const [element, setElement] = (0, import_react.useState)(null);
    const { editor: currentEditor } = useCurrentEditor();
    (0, import_react.useEffect)(() => {
      var _a2;
      if (!element) {
        return;
      }
      if (((_a2 = props.editor) === null || _a2 === void 0 ? void 0 : _a2.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {
        return;
      }
      const { pluginKey = "bubbleMenu", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;
      const menuEditor = editor || currentEditor;
      if (!menuEditor) {
        console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
        return;
      }
      const plugin = BubbleMenuPlugin({
        updateDelay,
        editor: menuEditor,
        element,
        pluginKey,
        shouldShow,
        tippyOptions
      });
      menuEditor.registerPlugin(plugin);
      return () => {
        menuEditor.unregisterPlugin(pluginKey);
      };
    }, [props.editor, currentEditor, element]);
    return import_react.default.createElement("div", { ref: setElement, className: props.className, style: { visibility: "hidden" } }, props.children);
  };
  var ReactNodeViewContext = (0, import_react.createContext)({
    onDragStart: void 0
  });
  var useReactNodeView = () => (0, import_react.useContext)(ReactNodeViewContext);
  var NodeViewWrapper = import_react.default.forwardRef((props, ref) => {
    const { onDragStart } = useReactNodeView();
    const Tag2 = props.as || "div";
    return (
      // @ts-ignore
      import_react.default.createElement(Tag2, __spreadProps(__spreadValues({}, props), { ref, "data-node-view-wrapper": "", onDragStart, style: __spreadValues({
        whiteSpace: "normal"
      }, props.style) }))
    );
  });

  // node_modules/@tiptap/extension-blockquote/dist/index.js
  var inputRegex = /^\s*>\s$/;
  var Blockquote = Node3.create({
    name: "blockquote",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    group: "block",
    defining: true,
    parseHTML() {
      return [
        { tag: "blockquote" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBlockquote: () => ({ commands: commands2 }) => {
          return commands2.wrapIn(this.name);
        },
        toggleBlockquote: () => ({ commands: commands2 }) => {
          return commands2.toggleWrap(this.name);
        },
        unsetBlockquote: () => ({ commands: commands2 }) => {
          return commands2.lift(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
      };
    },
    addInputRules() {
      return [
        wrappingInputRule({
          find: inputRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bold/dist/index.js
  var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
  var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
  var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
  var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
  var Bold = Mark2.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (node) => node.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight=400",
          clearMark: (mark) => mark.type.name === this.name
        },
        {
          style: "font-weight",
          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBold: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleBold: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetBold: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-bullet-list/dist/index.js
  var ListItemName = "listItem";
  var TextStyleName = "textStyle";
  var inputRegex2 = /^\s*([-+*])\s$/;
  var BulletList = Node3.create({
    name: "bulletList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    parseHTML() {
      return [
        { tag: "ul" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleBulletList: () => ({ commands: commands2, chain }) => {
          if (this.options.keepAttributes) {
            return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
          }
          return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
      };
    },
    addInputRules() {
      let inputRule = wrappingInputRule({
        find: inputRegex2,
        type: this.type
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex2,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: () => {
            return this.editor.getAttributes(TextStyleName);
          },
          editor: this.editor
        });
      }
      return [
        inputRule
      ];
    }
  });

  // node_modules/@tiptap/extension-code/dist/index.js
  var inputRegex3 = /(^|[^`])`([^`]+)`(?!`)/;
  var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
  var Code = Mark2.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML() {
      return [
        { tag: "code" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setCode: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleCode: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetCode: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex3,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-code-block/dist/index.js
  var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
  var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
  var CodeBlock = Node3.create({
    name: "codeBlock",
    addOptions() {
      return {
        languageClassPrefix: "language-",
        exitOnTripleEnter: true,
        exitOnArrowDown: true,
        defaultLanguage: null,
        HTMLAttributes: {}
      };
    },
    content: "text*",
    marks: "",
    group: "block",
    code: true,
    defining: true,
    addAttributes() {
      return {
        language: {
          default: this.options.defaultLanguage,
          parseHTML: (element) => {
            var _a2;
            const { languageClassPrefix } = this.options;
            const classNames = [...((_a2 = element.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.classList) || []];
            const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
            const language = languages[0];
            if (!language) {
              return null;
            }
            return language;
          },
          rendered: false
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "pre",
          preserveWhitespace: "full"
        }
      ];
    },
    renderHTML({ node, HTMLAttributes }) {
      return [
        "pre",
        mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
        [
          "code",
          {
            class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
          },
          0
        ]
      ];
    },
    addCommands() {
      return {
        setCodeBlock: (attributes) => ({ commands: commands2 }) => {
          return commands2.setNode(this.name, attributes);
        },
        toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
          return commands2.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
        // remove code block when at start of document or code block is empty
        Backspace: () => {
          const { empty: empty2, $anchor } = this.editor.state.selection;
          const isAtStart = $anchor.pos === 1;
          if (!empty2 || $anchor.parent.type.name !== this.name) {
            return false;
          }
          if (isAtStart || !$anchor.parent.textContent.length) {
            return this.editor.commands.clearNodes();
          }
          return false;
        },
        // exit node on triple enter
        Enter: ({ editor }) => {
          if (!this.options.exitOnTripleEnter) {
            return false;
          }
          const { state } = editor;
          const { selection } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
          if (!isAtEnd || !endsWithDoubleNewline) {
            return false;
          }
          return editor.chain().command(({ tr }) => {
            tr.delete($from.pos - 2, $from.pos);
            return true;
          }).exitCode().run();
        },
        // exit node on arrow down
        ArrowDown: ({ editor }) => {
          if (!this.options.exitOnArrowDown) {
            return false;
          }
          const { state } = editor;
          const { selection, doc: doc3 } = state;
          const { $from, empty: empty2 } = selection;
          if (!empty2 || $from.parent.type !== this.type) {
            return false;
          }
          const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
          if (!isAtEnd) {
            return false;
          }
          const after = $from.after();
          if (after === void 0) {
            return false;
          }
          const nodeAfter = doc3.nodeAt(after);
          if (nodeAfter) {
            return editor.commands.command(({ tr }) => {
              tr.setSelection(Selection.near(doc3.resolve(after)));
              return true;
            });
          }
          return editor.commands.exitCode();
        }
      };
    },
    addInputRules() {
      return [
        textblockTypeInputRule({
          find: backtickInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        }),
        textblockTypeInputRule({
          find: tildeInputRegex,
          type: this.type,
          getAttributes: (match) => ({
            language: match[1]
          })
        })
      ];
    },
    addProseMirrorPlugins() {
      return [
        // this plugin creates a code block for pasted content from VS Code
        // we can also detect the copied code language
        new Plugin({
          key: new PluginKey("codeBlockVSCodeHandler"),
          props: {
            handlePaste: (view, event) => {
              if (!event.clipboardData) {
                return false;
              }
              if (this.editor.isActive(this.type.name)) {
                return false;
              }
              const text = event.clipboardData.getData("text/plain");
              const vscode = event.clipboardData.getData("vscode-editor-data");
              const vscodeData = vscode ? JSON.parse(vscode) : void 0;
              const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
              if (!text || !language) {
                return false;
              }
              const { tr, schema } = view.state;
              const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
              tr.replaceSelectionWith(this.type.create({ language }, textNode));
              if (tr.selection.$from.parent.type !== this.type) {
                tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
              }
              tr.setMeta("paste", true);
              view.dispatch(tr);
              return true;
            }
          }
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-document/dist/index.js
  var Document2 = Node3.create({
    name: "doc",
    topNode: true,
    content: "block+"
  });

  // node_modules/prosemirror-dropcursor/dist/index.js
  function dropCursor(options = {}) {
    return new Plugin({
      view(editorView) {
        return new DropCursorView(editorView, options);
      }
    });
  }
  var DropCursorView = class {
    constructor(editorView, options) {
      var _a2;
      this.editorView = editorView;
      this.cursorPos = null;
      this.element = null;
      this.timeout = -1;
      this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : 1;
      this.color = options.color === false ? void 0 : options.color || "black";
      this.class = options.class;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
        let handler = (e) => {
          this[name](e);
        };
        editorView.dom.addEventListener(name, handler);
        return { name, handler };
      });
    }
    destroy() {
      this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
    }
    update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size)
          this.setCursor(null);
        else
          this.updateOverlay();
      }
    }
    setCursor(pos) {
      if (pos == this.cursorPos)
        return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
    updateOverlay() {
      let $pos = this.editorView.state.doc.resolve(this.cursorPos);
      let isBlock = !$pos.parent.inlineContent, rect;
      let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
      let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
      if (isBlock) {
        let before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node) {
            let nodeRect = node.getBoundingClientRect();
            let top2 = before ? nodeRect.bottom : nodeRect.top;
            if (before && after)
              top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            let halfWidth = this.width / 2 * scaleY;
            rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - halfWidth, bottom: top2 + halfWidth };
          }
        }
      }
      if (!rect) {
        let coords = this.editorView.coordsAtPos(this.cursorPos);
        let halfWidth = this.width / 2 * scaleX;
        rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
      }
      let parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class)
          this.element.className = this.class;
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      let parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        let rect2 = parent.getBoundingClientRect();
        let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
        parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
        parentTop = rect2.top - parent.scrollTop * parentScaleY;
      }
      this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
      this.element.style.top = (rect.top - parentTop) / scaleY + "px";
      this.element.style.width = (rect.right - rect.left) / scaleX + "px";
      this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
    }
    scheduleRemoval(timeout) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => this.setCursor(null), timeout);
    }
    dragover(event) {
      if (!this.editorView.editable)
        return;
      let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
      let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      let disableDropCursor = node && node.type.spec.disableDropCursor;
      let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        let target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point != null)
            target = point;
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(event) {
      if (!this.editorView.dom.contains(event.relatedTarget))
        this.setCursor(null);
    }
  };

  // node_modules/@tiptap/extension-dropcursor/dist/index.js
  var Dropcursor = Extension.create({
    name: "dropCursor",
    addOptions() {
      return {
        color: "currentColor",
        width: 1,
        class: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        dropCursor(this.options)
      ];
    }
  });

  // node_modules/prosemirror-gapcursor/dist/index.js
  var GapCursor = class _GapCursor extends Selection {
    /**
    Create a gap cursor.
    */
    constructor($pos) {
      super($pos, $pos);
    }
    map(doc3, mapping) {
      let $pos = doc3.resolve(mapping.map(this.head));
      return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
    }
    content() {
      return Slice.empty;
    }
    eq(other) {
      return other instanceof _GapCursor && other.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc3, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new _GapCursor(doc3.resolve(json.pos));
    }
    /**
    @internal
    */
    getBookmark() {
      return new GapBookmark(this.anchor);
    }
    /**
    @internal
    */
    static valid($pos) {
      let parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
        return false;
      let override = parent.type.spec.allowGapCursor;
      if (override != null)
        return override;
      let deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom($pos, dir, mustMove = false) {
      search: for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
    }
  };
  GapCursor.prototype.visible = false;
  GapCursor.findFrom = GapCursor.findGapCursorFrom;
  Selection.jsonID("gapcursor", GapCursor);
  var GapBookmark = class _GapBookmark {
    constructor(pos) {
      this.pos = pos;
    }
    map(mapping) {
      return new _GapBookmark(mapping.map(this.pos));
    }
    resolve(doc3) {
      let $pos = doc3.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
  };
  function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index = $pos.index(d), parent = $pos.node(d);
      if (index == 0) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let before = parent.child(index - 1); ; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
          return true;
        if (before.inlineContent)
          return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index = $pos.indexAfter(d), parent = $pos.node(d);
      if (index == parent.childCount) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let after = parent.child(index); ; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
          return true;
        if (after.inlineContent)
          return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween(_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick,
        handleKeyDown,
        handleDOMEvents: { beforeinput }
      }
    });
  }
  var handleKeyDown = keydownHandler({
    "ArrowLeft": arrow2("horiz", -1),
    "ArrowRight": arrow2("horiz", 1),
    "ArrowUp": arrow2("vert", -1),
    "ArrowDown": arrow2("vert", 1)
  });
  function arrow2(axis, dir) {
    const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch2, view) {
      let sel = state.selection;
      let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0)
          return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found)
        return false;
      if (dispatch2)
        dispatch2(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable)
      return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
      return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
      return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
      return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
      return false;
    let frag = Fragment.empty;
    for (let i = insert.length - 1; i >= 0; i--)
      frag = Fragment.from(insert[i].createAndFill(null, frag));
    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
    view.dispatch(tr);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
      return null;
    let node = document.createElement("div");
    node.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
  }

  // node_modules/@tiptap/extension-gapcursor/dist/index.js
  var Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        gapCursor()
      ];
    },
    extendNodeSchema(extension) {
      var _a2;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      return {
        allowGapCursor: (_a2 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a2 !== void 0 ? _a2 : null
      };
    }
  });

  // node_modules/@tiptap/extension-hard-break/dist/index.js
  var HardBreak = Node3.create({
    name: "hardBreak",
    addOptions() {
      return {
        keepMarks: true,
        HTMLAttributes: {}
      };
    },
    inline: true,
    group: "inline",
    selectable: false,
    linebreakReplacement: true,
    parseHTML() {
      return [
        { tag: "br" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    renderText() {
      return "\n";
    },
    addCommands() {
      return {
        setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
          return commands2.first([
            () => commands2.exitCode(),
            () => commands2.command(() => {
              const { selection, storedMarks } = state;
              if (selection.$from.parent.type.spec.isolating) {
                return false;
              }
              const { keepMarks } = this.options;
              const { splittableMarks } = editor.extensionManager;
              const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
              return chain().insertContent({ type: this.name }).command(({ tr, dispatch: dispatch2 }) => {
                if (dispatch2 && marks && keepMarks) {
                  const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                  tr.ensureMarks(filteredMarks);
                }
                return true;
              }).run();
            })
          ]);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Enter": () => this.editor.commands.setHardBreak(),
        "Shift-Enter": () => this.editor.commands.setHardBreak()
      };
    }
  });

  // node_modules/@tiptap/extension-heading/dist/index.js
  var Heading = Node3.create({
    name: "heading",
    addOptions() {
      return {
        levels: [1, 2, 3, 4, 5, 6],
        HTMLAttributes: {}
      };
    },
    content: "inline*",
    group: "block",
    defining: true,
    addAttributes() {
      return {
        level: {
          default: 1,
          rendered: false
        }
      };
    },
    parseHTML() {
      return this.options.levels.map((level) => ({
        tag: `h${level}`,
        attrs: { level }
      }));
    },
    renderHTML({ node, HTMLAttributes }) {
      const hasLevel = this.options.levels.includes(node.attrs.level);
      const level = hasLevel ? node.attrs.level : this.options.levels[0];
      return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setHeading: (attributes) => ({ commands: commands2 }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands2.setNode(this.name, attributes);
        },
        toggleHeading: (attributes) => ({ commands: commands2 }) => {
          if (!this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands2.toggleNode(this.name, "paragraph", attributes);
        }
      };
    },
    addKeyboardShortcuts() {
      return this.options.levels.reduce((items, level) => __spreadValues(__spreadValues({}, items), {
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }), {});
    },
    addInputRules() {
      return this.options.levels.map((level) => {
        return textblockTypeInputRule({
          find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
          type: this.type,
          getAttributes: {
            level
          }
        });
      });
    }
  });

  // node_modules/rope-sequence/dist/index.js
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    if (from2 >= to) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
  };
  RopeSequence.prototype.get = function get(i) {
    if (i < 0 || i >= this.length) {
      return void 0;
    }
    return this.getInner(i);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    if (from2 <= to) {
      this.forEachInner(f, from2, to, 0);
    } else {
      this.forEachInvertedInner(f, from2, to, 0);
    }
  };
  RopeSequence.prototype.map = function map(f, from2, to) {
    if (from2 === void 0) from2 = 0;
    if (to === void 0) to = this.length;
    var result = [];
    this.forEach(function(elt, i) {
      return result.push(f(elt, i));
    }, from2, to);
    return result;
  };
  RopeSequence.from = function from(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence3) {
    function Leaf3(values) {
      RopeSequence3.call(this);
      this.values = values;
    }
    if (RopeSequence3) Leaf3.__proto__ = RopeSequence3;
    Leaf3.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Leaf3.prototype.constructor = Leaf3;
    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
    Leaf3.prototype.flatten = function flatten() {
      return this.values;
    };
    Leaf3.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      return new Leaf3(this.values.slice(from2, to));
    };
    Leaf3.prototype.getInner = function getInner(i) {
      return this.values[i];
    };
    Leaf3.prototype.forEachInner = function forEachInner(f, from2, to, start3) {
      for (var i = from2; i < to; i++) {
        if (f(this.values[i], start3 + i) === false) {
          return false;
        }
      }
    };
    Leaf3.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start3) {
      for (var i = from2 - 1; i >= to; i--) {
        if (f(this.values[i], start3 + i) === false) {
          return false;
        }
      }
    };
    Leaf3.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf3(this.values.concat(other.flatten()));
      }
    };
    Leaf3.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf3(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf3.prototype, prototypeAccessors);
    return Leaf3;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence3) {
    function Append2(left2, right2) {
      RopeSequence3.call(this);
      this.left = left2;
      this.right = right2;
      this.length = left2.length + right2.length;
      this.depth = Math.max(left2.depth, right2.depth) + 1;
    }
    if (RopeSequence3) Append2.__proto__ = RopeSequence3;
    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i) {
      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from2, to, start3) {
      var leftLen = this.left.length;
      if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start3) === false) {
        return false;
      }
      if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start3 + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start3) {
      var leftLen = this.left.length;
      if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start3 + leftLen) === false) {
        return false;
      }
      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start3) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from2, to) {
      if (from2 == 0 && to == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to <= leftLen) {
        return this.left.slice(from2, to);
      }
      if (from2 >= leftLen) {
        return this.right.slice(from2 - leftLen, to - leftLen);
      }
      return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner2(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  var dist_default2 = RopeSequence;

  // node_modules/prosemirror-history/dist/index.js
  var max_empty_items = 500;
  var Branch = class _Branch {
    constructor(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
      if (this.eventCount == 0)
        return null;
      let end2 = this.items.length;
      for (; ; end2--) {
        let next = this.items.get(end2 - 1);
        if (next.selection) {
          --end2;
          break;
        }
      }
      let remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end2, this.items.length);
        mapFrom = remap.maps.length;
      }
      let transform = state.tr;
      let selection, remaining;
      let addAfter = [], addBefore = [];
      this.items.forEach((item, i) => {
        if (!item.step) {
          if (!remap) {
            remap = this.remapping(end2, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          let step = item.step.map(remap.slice(mapFrom)), map2;
          if (step && transform.maybeStep(step).doc) {
            map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new _Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform, selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform, selection, histOptions, preserveItems) {
      let newItems = [], eventCount = this.eventCount;
      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (let i = 0; i < transform.steps.length; i++) {
        let step = transform.steps[i].invert(transform.docs[i]);
        let item = new Item(transform.mapping.maps[i], step, selection), merged;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i)
            newItems.pop();
          else
            oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems)
          lastItem = item;
      }
      let overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new _Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from2, to) {
      let maps = new Mapping();
      this.items.forEach((item, i) => {
        let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from2, to);
      return maps;
    }
    addMaps(array) {
      if (this.eventCount == 0)
        return this;
      return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount)
        return this;
      let rebasedItems = [], start3 = Math.max(0, this.items.length - rebasedCount);
      let mapping = rebasedTransform.mapping;
      let newUntil = rebasedTransform.steps.length;
      let eventCount = this.eventCount;
      this.items.forEach((item) => {
        if (item.selection)
          eventCount--;
      }, start3);
      let iRebased = rebasedCount;
      this.items.forEach((item) => {
        let pos = mapping.getMirror(--iRebased);
        if (pos == null)
          return;
        newUntil = Math.min(newUntil, pos);
        let map2 = mapping.maps[pos];
        if (item.step) {
          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection)
            eventCount++;
          rebasedItems.push(new Item(map2, step, selection));
        } else {
          rebasedItems.push(new Item(map2));
        }
      }, start3);
      let newMaps = [];
      for (let i = rebasedCount; i < newUntil; i++)
        newMaps.push(new Item(mapping.maps[i]));
      let items = this.items.slice(0, start3).append(newMaps).append(rebasedItems);
      let branch = new _Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items)
        branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
    emptyItemCount() {
      let count = 0;
      this.items.forEach((item) => {
        if (!item.step)
          count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      let items = [], events = 0;
      this.items.forEach((item, i) => {
        if (i >= upto) {
          items.push(item);
          if (item.selection)
            events++;
        } else if (item.step) {
          let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
          mapFrom--;
          if (map2)
            remap.appendMap(map2, mapFrom);
          if (step) {
            let selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection)
              events++;
            let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem))
              items[last] = merged;
            else
              items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new _Branch(dist_default2.from(items.reverse()), events);
    }
  };
  Branch.empty = new Branch(dist_default2.empty, 0);
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i) => {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  var Item = class _Item {
    constructor(map2, step, selection, mirrorOffset) {
      this.map = map2;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
      if (this.step && other.step && !other.selection) {
        let step = other.step.merge(this.step);
        if (step)
          return new _Item(step.getMap().invert(), step, this.selection);
      }
    }
  };
  var HistoryState = class {
    constructor(done, undone, prevRanges, prevTime, prevComposition) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    }
  };
  var DEPTH_OVERFLOW = 20;
  function applyTransaction(history3, state, tr, options) {
    let historyTr = tr.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr.getMeta(closeHistoryKey))
      history3 = new HistoryState(history3.done, history3.undone, null, 0, -1);
    let appended = tr.getMeta("appendedTransaction");
    if (tr.steps.length == 0) {
      return history3;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history3.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history3.undone, rangesFor(tr.mapping.maps), history3.prevTime, history3.prevComposition);
      else
        return new HistoryState(history3.done, history3.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history3.prevTime, history3.prevComposition);
    } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr.getMeta("composition");
      let newGroup = history3.prevTime == 0 || !appended && history3.prevComposition != composition && (history3.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history3.prevRanges));
      let prevRanges = appended ? mapRanges(history3.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
      return new HistoryState(history3.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history3.prevComposition : composition);
    } else if (rebased = tr.getMeta("rebased")) {
      return new HistoryState(history3.done.rebased(tr, rebased), history3.undone.rebased(tr, rebased), mapRanges(history3.prevRanges, tr.mapping), history3.prevTime, history3.prevComposition);
    } else {
      return new HistoryState(history3.done.addMaps(tr.mapping.maps), history3.undone.addMaps(tr.mapping.maps), mapRanges(history3.prevRanges, tr.mapping), history3.prevTime, history3.prevComposition);
    }
  }
  function isAdjacentTo(transform, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform.docChanged)
      return true;
    let adjacent = false;
    transform.mapping.maps[0].forEach((start3, end2) => {
      for (let i = 0; i < prevRanges.length; i += 2)
        if (start3 <= prevRanges[i + 1] && end2 >= prevRanges[i])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(maps) {
    let result = [];
    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
      maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i = 0; i < ranges.length; i += 2) {
      let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
      if (from2 <= to)
        result.push(from2, to);
    }
    return result;
  }
  function histTransaction(history3, state, redo2) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo2 ? history3.undone : history3.done).popEvent(state, preserveItems);
    if (!pop)
      return null;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo2 ? history3.done : history3.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
  }
  var cachedPreserveItems = false;
  var cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (let i = 0; i < plugins.length; i++)
        if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  var historyKey = new PluginKey("history");
  var closeHistoryKey = new PluginKey("closeHistory");
  function history2(config2 = {}) {
    config2 = {
      depth: config2.depth || 100,
      newGroupDelay: config2.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr, hist, state) {
          return applyTransaction(hist, state, tr, config2);
        }
      },
      config: config2,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  function buildCommand(redo2, scroll) {
    return (state, dispatch2) => {
      let hist = historyKey.getState(state);
      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
        return false;
      if (dispatch2) {
        let tr = histTransaction(hist, state, redo2);
        if (tr)
          dispatch2(scroll ? tr.scrollIntoView() : tr);
      }
      return true;
    };
  }
  var undo = buildCommand(false, true);
  var redo = buildCommand(true, true);
  var undoNoScroll = buildCommand(false, false);
  var redoNoScroll = buildCommand(true, false);

  // node_modules/@tiptap/extension-history/dist/index.js
  var History = Extension.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state, dispatch: dispatch2 }) => {
          return undo(state, dispatch2);
        },
        redo: () => ({ state, dispatch: dispatch2 }) => {
          return redo(state, dispatch2);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        history2(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        // Russian keyboard layouts
        "Mod-\u044F": () => this.editor.commands.undo(),
        "Shift-Mod-\u044F": () => this.editor.commands.redo()
      };
    }
  });

  // node_modules/@tiptap/extension-horizontal-rule/dist/index.js
  var HorizontalRule = Node3.create({
    name: "horizontalRule",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    parseHTML() {
      return [{ tag: "hr" }];
    },
    renderHTML({ HTMLAttributes }) {
      return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
      return {
        setHorizontalRule: () => ({ chain, state }) => {
          const { selection } = state;
          const { $from: $originFrom, $to: $originTo } = selection;
          const currentChain = chain();
          if ($originFrom.parentOffset === 0) {
            currentChain.insertContentAt({
              from: Math.max($originFrom.pos - 1, 0),
              to: $originTo.pos
            }, {
              type: this.name
            });
          } else if (isNodeSelection(selection)) {
            currentChain.insertContentAt($originTo.pos, {
              type: this.name
            });
          } else {
            currentChain.insertContent({ type: this.name });
          }
          return currentChain.command(({ tr, dispatch: dispatch2 }) => {
            var _a2;
            if (dispatch2) {
              const { $to } = tr.selection;
              const posAfter = $to.end();
              if ($to.nodeAfter) {
                if ($to.nodeAfter.isTextblock) {
                  tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
                } else if ($to.nodeAfter.isBlock) {
                  tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
                } else {
                  tr.setSelection(TextSelection.create(tr.doc, $to.pos));
                }
              } else {
                const node = (_a2 = $to.parent.type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.create();
                if (node) {
                  tr.insert(posAfter, node);
                  tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
                }
              }
              tr.scrollIntoView();
            }
            return true;
          }).run();
        }
      };
    },
    addInputRules() {
      return [
        nodeInputRule({
          find: /^(?:---|—-|___\s|\*\*\*\s)$/,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-italic/dist/index.js
  var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
  var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
  var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
  var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
  var Italic = Mark2.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (node) => node.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=normal",
          clearMark: (mark) => mark.type.name === this.name
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleItalic: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetItalic: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex2,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex2,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-list-item/dist/index.js
  var ListItem = Node3.create({
    name: "listItem",
    addOptions() {
      return {
        HTMLAttributes: {},
        bulletListTypeName: "bulletList",
        orderedListTypeName: "orderedList"
      };
    },
    content: "paragraph block*",
    defining: true,
    parseHTML() {
      return [
        {
          tag: "li"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => this.editor.commands.splitListItem(this.name),
        Tab: () => this.editor.commands.sinkListItem(this.name),
        "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
      };
    }
  });

  // node_modules/@tiptap/extension-ordered-list/dist/index.js
  var ListItemName2 = "listItem";
  var TextStyleName2 = "textStyle";
  var inputRegex4 = /^(\d+)\.\s$/;
  var OrderedList = Node3.create({
    name: "orderedList",
    addOptions() {
      return {
        itemTypeName: "listItem",
        HTMLAttributes: {},
        keepMarks: false,
        keepAttributes: false
      };
    },
    group: "block list",
    content() {
      return `${this.options.itemTypeName}+`;
    },
    addAttributes() {
      return {
        start: {
          default: 1,
          parseHTML: (element) => {
            return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
          }
        },
        type: {
          default: null,
          parseHTML: (element) => element.getAttribute("type")
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "ol"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      const _a2 = HTMLAttributes, { start: start3 } = _a2, attributesWithoutStart = __objRest(_a2, ["start"]);
      return start3 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        toggleOrderedList: () => ({ commands: commands2, chain }) => {
          if (this.options.keepAttributes) {
            return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
          }
          return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
      };
    },
    addInputRules() {
      let inputRule = wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        getAttributes: (match) => ({ start: +match[1] }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
      });
      if (this.options.keepMarks || this.options.keepAttributes) {
        inputRule = wrappingInputRule({
          find: inputRegex4,
          type: this.type,
          keepMarks: this.options.keepMarks,
          keepAttributes: this.options.keepAttributes,
          getAttributes: (match) => __spreadValues({ start: +match[1] }, this.editor.getAttributes(TextStyleName2)),
          joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
          editor: this.editor
        });
      }
      return [
        inputRule
      ];
    }
  });

  // node_modules/@tiptap/extension-paragraph/dist/index.js
  var Paragraph = Node3.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    group: "block",
    content: "inline*",
    parseHTML() {
      return [
        { tag: "p" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setParagraph: () => ({ commands: commands2 }) => {
          return commands2.setNode(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => this.editor.commands.setParagraph()
      };
    }
  });

  // node_modules/@tiptap/extension-strike/dist/index.js
  var inputRegex5 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
  var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
  var Strike = Mark2.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style2) => style2.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleStrike: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetStrike: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-s": () => this.editor.commands.toggleStrike()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex5,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-text/dist/index.js
  var Text = Node3.create({
    name: "text",
    group: "inline"
  });

  // node_modules/@tiptap/starter-kit/dist/index.js
  var StarterKit = Extension.create({
    name: "starterKit",
    addExtensions() {
      const extensions = [];
      if (this.options.bold !== false) {
        extensions.push(Bold.configure(this.options.bold));
      }
      if (this.options.blockquote !== false) {
        extensions.push(Blockquote.configure(this.options.blockquote));
      }
      if (this.options.bulletList !== false) {
        extensions.push(BulletList.configure(this.options.bulletList));
      }
      if (this.options.code !== false) {
        extensions.push(Code.configure(this.options.code));
      }
      if (this.options.codeBlock !== false) {
        extensions.push(CodeBlock.configure(this.options.codeBlock));
      }
      if (this.options.document !== false) {
        extensions.push(Document2.configure(this.options.document));
      }
      if (this.options.dropcursor !== false) {
        extensions.push(Dropcursor.configure(this.options.dropcursor));
      }
      if (this.options.gapcursor !== false) {
        extensions.push(Gapcursor.configure(this.options.gapcursor));
      }
      if (this.options.hardBreak !== false) {
        extensions.push(HardBreak.configure(this.options.hardBreak));
      }
      if (this.options.heading !== false) {
        extensions.push(Heading.configure(this.options.heading));
      }
      if (this.options.history !== false) {
        extensions.push(History.configure(this.options.history));
      }
      if (this.options.horizontalRule !== false) {
        extensions.push(HorizontalRule.configure(this.options.horizontalRule));
      }
      if (this.options.italic !== false) {
        extensions.push(Italic.configure(this.options.italic));
      }
      if (this.options.listItem !== false) {
        extensions.push(ListItem.configure(this.options.listItem));
      }
      if (this.options.orderedList !== false) {
        extensions.push(OrderedList.configure(this.options.orderedList));
      }
      if (this.options.paragraph !== false) {
        extensions.push(Paragraph.configure(this.options.paragraph));
      }
      if (this.options.strike !== false) {
        extensions.push(Strike.configure(this.options.strike));
      }
      if (this.options.text !== false) {
        extensions.push(Text.configure(this.options.text));
      }
      return extensions;
    }
  });

  // node_modules/@tiptap/extension-character-count/dist/index.js
  var CharacterCount = Extension.create({
    name: "characterCount",
    addOptions() {
      return {
        limit: null,
        mode: "textSize",
        textCounter: (text) => text.length,
        wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
      };
    },
    addStorage() {
      return {
        characters: () => 0,
        words: () => 0
      };
    },
    onBeforeCreate() {
      this.storage.characters = (options) => {
        const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
        const mode = (options === null || options === void 0 ? void 0 : options.mode) || this.options.mode;
        if (mode === "textSize") {
          const text = node.textBetween(0, node.content.size, void 0, " ");
          return this.options.textCounter(text);
        }
        return node.nodeSize;
      };
      this.storage.words = (options) => {
        const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;
        const text = node.textBetween(0, node.content.size, " ", " ");
        return this.options.wordCounter(text);
      };
    },
    addProseMirrorPlugins() {
      let initialEvaluationDone = false;
      return [
        new Plugin({
          key: new PluginKey("characterCount"),
          appendTransaction: (transactions, oldState, newState) => {
            if (initialEvaluationDone) {
              return;
            }
            const limit = this.options.limit;
            if (limit === null || limit === void 0 || limit === 0) {
              initialEvaluationDone = true;
              return;
            }
            const initialContentSize = this.storage.characters({ node: newState.doc });
            if (initialContentSize > limit) {
              const over = initialContentSize - limit;
              const from2 = 0;
              const to = over;
              console.warn(`[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`);
              const tr = newState.tr.deleteRange(from2, to);
              initialEvaluationDone = true;
              return tr;
            }
            initialEvaluationDone = true;
          },
          filterTransaction: (transaction, state) => {
            const limit = this.options.limit;
            if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
              return true;
            }
            const oldSize = this.storage.characters({ node: state.doc });
            const newSize = this.storage.characters({ node: transaction.doc });
            if (newSize <= limit) {
              return true;
            }
            if (oldSize > limit && newSize > limit && newSize <= oldSize) {
              return true;
            }
            if (oldSize > limit && newSize > limit && newSize > oldSize) {
              return false;
            }
            const isPaste = transaction.getMeta("paste");
            if (!isPaste) {
              return false;
            }
            const pos = transaction.selection.$head.pos;
            const over = newSize - limit;
            const from2 = pos - over;
            const to = pos;
            transaction.deleteRange(from2, to);
            const updatedSize = this.storage.characters({ node: transaction.doc });
            if (updatedSize > limit) {
              return false;
            }
            return true;
          }
        })
      ];
    }
  });

  // app/javascript/components/RichEditor.jsx
  var RichEditor = ({ element }) => {
    var _a2;
    const initialContent = ((_a2 = element == null ? void 0 : element.dataset) == null ? void 0 : _a2.initialContent) || "";
    const decodeHTML = (html) => {
      const textarea = document.createElement("textarea");
      textarea.innerHTML = html;
      return textarea.value;
    };
    const cleanHTML = (html) => {
      return html.replace(/<p><br(?: class="ProseMirror-trailingBreak")?><\/p>\s*$/g, "").replace(/(<p><br><\/p>\s*)+$/g, "").replace(/(<p>(<br\s*\/?>)*<\/p>\s*)+$/g, "");
    };
    const editor = useEditor({
      extensions: [
        StarterKit,
        BubbleMenu,
        CharacterCount.configure({
          limit: 1e5
        })
      ],
      content: decodeHTML(initialContent),
      autofocus: true,
      editable: true,
      onUpdate: ({ editor: editor2 }) => {
        const html = cleanHTML(editor2.getHTML());
        const charCountEl = document.getElementById("char-count");
        if (charCountEl) {
          charCountEl.textContent = `${editor2.storage.characterCount.characters()} \u6587\u5B57`;
        }
        const hiddenField = document.getElementById("memo_content_input");
        if (hiddenField) hiddenField.value = html;
        window.hasUnsavedChanges = true;
      }
    });
    (0, import_react2.useEffect)(() => {
      if (!editor) return;
      const hiddenField = document.getElementById("memo_content_input");
      let previousHTML = cleanHTML(editor.getHTML());
      if (hiddenField) hiddenField.value = previousHTML;
      if (hiddenField) hiddenField.value = cleanHTML(editor.getHTML());
      const updateHandler = () => {
        const currentHTML = cleanHTML(editor.getHTML());
        if (hiddenField && currentHTML !== previousHTML) {
          hiddenField.value = currentHTML;
          previousHTML = currentHTML;
          window.hasUnsavedChanges = true;
          console.log("\u270F\uFE0F [update] \u5185\u5BB9\u304C\u5909\u5316 \u2192 hasUnsavedChanges = true");
        }
        const charCountEl = document.getElementById("char-count");
        if (charCountEl) {
          charCountEl.textContent = `${editor.storage.characterCount.characters()} \u6587\u5B57`;
        }
      };
      updateHandler();
      editor.on("update", updateHandler);
      return () => editor.off("update", updateHandler);
    }, [editor]);
    if (!editor) return null;
    return /* @__PURE__ */ import_react2.default.createElement("div", { className: "rhodia-grid-bg", style: { overflowY: "auto", position: "relative" } }, /* @__PURE__ */ import_react2.default.createElement(BubbleMenu2, { editor, tippyOptions: { duration: 150 } }, /* @__PURE__ */ import_react2.default.createElement("div", { className: "bubble-menu bg-white border rounded shadow-sm p-2 d-flex flex-wrap gap-2" }, /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().undo().run(),
        className: "btn btn-sm btn-outline-secondary",
        title: "\u5143\u306B\u623B\u3059"
      },
      /* @__PURE__ */ import_react2.default.createElement("i", { class: "bi bi-arrow-left" })
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().redo().run(),
        className: "btn btn-sm btn-outline-secondary",
        title: "\u3084\u308A\u76F4\u3059"
      },
      /* @__PURE__ */ import_react2.default.createElement("i", { class: "bi bi-arrow-right" })
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleBold().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("bold") ? "active" : ""}`
      },
      /* @__PURE__ */ import_react2.default.createElement("b", null, "B")
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleItalic().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("italic") ? "active" : ""}`
      },
      /* @__PURE__ */ import_react2.default.createElement("i", null, "I")
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleHeading({ level: 1 }).run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("heading", { level: 1 }) ? "active" : ""}`
      },
      "H1"
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleHeading({ level: 2 }).run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("heading", { level: 2 }) ? "active" : ""}`
      },
      "H2"
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleBulletList().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("bulletList") ? "active" : ""}`
      },
      "\u2022 List"
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleOrderedList().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("orderedList") ? "active" : ""}`
      },
      "1. List"
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleBlockquote().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("blockquote") ? "active" : ""}`
      },
      "> \u5F15\u7528"
    ), /* @__PURE__ */ import_react2.default.createElement(
      "button",
      {
        type: "button",
        onClick: () => editor.chain().focus().toggleCodeBlock().run(),
        className: `btn btn-sm btn-outline-secondary ${editor.isActive("codeBlock") ? "active" : ""}`
      },
      "</>"
    ))), /* @__PURE__ */ import_react2.default.createElement(EditorContent, { editor, className: "w-100 ProseMirror" }));
  };
  var RichEditor_default = RichEditor;

  // app/javascript/rich_editor.js
  var mountedRoots = /* @__PURE__ */ new Map();
  function mountRichEditor(selectorOrElement) {
    const element = typeof selectorOrElement === "string" ? document.querySelector(selectorOrElement) : selectorOrElement;
    if (!element) return;
    const prevRoot = mountedRoots.get(element);
    if (prevRoot) {
      prevRoot.unmount();
      mountedRoots.delete(element);
    }
    const root = (0, import_client.createRoot)(element);
    root.render(/* @__PURE__ */ import_react4.default.createElement(RichEditor_default, { element }));
    mountedRoots.set(element, root);
  }
  document.addEventListener("turbo:load", () => {
    document.querySelectorAll(".rich-editor-root").forEach((el) => {
      mountRichEditor(el);
    });
  });

  // app/javascript/controllers/memo_modal_controller.js
  var memo_modal_controller_default = class extends Controller {
    connect() {
      console.log("\u{1F50C} memo-modal connected!");
      this.submitHandler = this.handleSubmit.bind(this);
      this.expanded = false;
    }
    open(event) {
      var _a2, _b;
      (_b = (_a2 = document.activeElement) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
      const trigger = event.currentTarget;
      const memoId = trigger.dataset.memoModalMemoIdValue;
      const bookId = trigger.dataset.memoModalBookIdValue;
      const createdAtFull = trigger.dataset.memoModalCreatedAtValue;
      const updatedAtFull = trigger.dataset.memoModalUpdatedAtValue;
      const createdAtShort = trigger.dataset.memoModalCreatedDateValue;
      const updatedAtShort = trigger.dataset.memoModalUpdatedDateValue;
      const contentElement = this.element.querySelector(".card-body");
      const contentHTML = (contentElement == null ? void 0 : contentElement.innerHTML) || "";
      const isPlaceholder = contentHTML.includes("PLACEHOLDER_TOKEN_9fz3!ifhdas094hfgfygq@_$2x");
      const initialContent = isPlaceholder ? "" : contentHTML;
      const editorRoot = document.getElementById("rich-editor-root");
      if (editorRoot) {
        window.hasUnsavedChanges = false;
        editorRoot.dataset.initialContent = initialContent;
        editorRoot.dataset.memoId = memoId;
        mountRichEditor(editorRoot);
        const observer = new MutationObserver(() => {
          const proseMirror = editorRoot.querySelector(".ProseMirror");
          if (proseMirror) {
            proseMirror.classList.add("editing");
            observer.disconnect();
          }
        });
        observer.observe(editorRoot, { childList: true, subtree: true });
      }
      const hiddenField = document.getElementById("memo_content_input");
      if (hiddenField) hiddenField.value = initialContent;
      const form = document.getElementById("memo-edit-form");
      if (form) {
        form.setAttribute("action", memoId === "new" ? `/books/${bookId}/memos` : `/books/${bookId}/memos/${memoId}`);
        form.setAttribute("method", "post");
        let methodInput = form.querySelector("input[name='_method']");
        if (memoId !== "new") {
          if (!methodInput) {
            methodInput = document.createElement("input");
            methodInput.type = "hidden";
            methodInput.name = "_method";
            form.appendChild(methodInput);
          }
          methodInput.value = "patch";
        } else {
          if (methodInput) methodInput.remove();
        }
        form.removeEventListener("submit", this.submitHandler);
        form.addEventListener("submit", this.submitHandler);
        form.scrollIntoView({ behavior: "smooth", block: "center" });
      }
      const createdAtEl = document.getElementById("modal-created-at");
      const updatedAtEl = document.getElementById("modal-updated-at");
      const isMobile = window.innerWidth < 576;
      const fallbackDate = (full) => (full == null ? void 0 : full.split(" ")[0]) || "";
      if (createdAtEl) {
        createdAtEl.textContent = createdAtFull ? `\u4F5C\u6210\u65E5: ${isMobile ? createdAtShort || fallbackDate(createdAtFull) : createdAtFull}` : "";
      }
      if (updatedAtEl) {
        updatedAtEl.textContent = updatedAtFull ? `\u66F4\u65B0\u65E5: ${isMobile ? updatedAtShort || fallbackDate(updatedAtFull) : updatedAtFull}` : "";
      }
      const modalElement = document.getElementById("memoEditModal");
      if (!modalElement) {
        console.error("\u274C \u30E2\u30FC\u30C0\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: memoEditModal");
        return;
      }
      const modal = new bootstrap.Modal(modalElement);
      modal.show();
    }
    toggle(event) {
      event.stopPropagation();
      this.expanded = !this.expanded;
      this.bodyTarget.classList.toggle("expanded", this.expanded);
      this.iconTarget.classList.toggle("bi-arrows-angle-expand", !this.expanded);
      this.iconTarget.classList.toggle("bi-arrows-angle-contract", this.expanded);
    }
    handleSubmit() {
      var _a2;
      const editorRoot = document.getElementById("rich-editor-root");
      const trailingBreaks = editorRoot == null ? void 0 : editorRoot.querySelectorAll(".ProseMirror-trailingBreak");
      trailingBreaks == null ? void 0 : trailingBreaks.forEach((br) => br.remove());
      const updatedContent = ((_a2 = editorRoot == null ? void 0 : editorRoot.querySelector(".ProseMirror")) == null ? void 0 : _a2.innerHTML) || "";
      const hiddenField = document.getElementById("memo_content_input");
      if (hiddenField) hiddenField.value = updatedContent;
      console.log("\u{1F4DC} \u30D5\u30A9\u30FC\u30E0\u9001\u4FE1\u76F4\u524D: content =", updatedContent);
    }
    stop(event) {
      event.stopPropagation();
    }
    disconnect() {
      const editorRoot = document.getElementById("rich-editor-root");
      const proseMirror = editorRoot == null ? void 0 : editorRoot.querySelector(".ProseMirror");
      if (proseMirror) {
        proseMirror.classList.remove("editing");
      }
    }
  };
  __publicField(memo_modal_controller_default, "values", {
    initialContent: String,
    memoId: String,
    bookId: String,
    createdAt: String,
    updatedAt: String
  });
  __publicField(memo_modal_controller_default, "targets", ["body", "icon"]);

  // app/javascript/controllers/modal_swipe_controller.js
  var modal_swipe_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "onTouchStart", (e) => {
        this.startY = e.touches[0].clientY;
      });
      __publicField(this, "onTouchEnd", (e) => {
        var _a2;
        const endY = e.changedTouches[0].clientY;
        const deltaY = endY - this.startY;
        if (Math.abs(deltaY) > this.threshold) {
          if (window.hasUnsavedChanges) {
            this.shouldShowConfirmOnClose = true;
          }
          (_a2 = bootstrap.Modal.getInstance(this.modalTarget)) == null ? void 0 : _a2.hide();
        }
        this.startY = null;
      });
      __publicField(this, "onModalHidden", () => {
        if (this.skipNextConfirmation) {
          this.skipNextConfirmation = false;
          return;
        }
        if (window.hasUnsavedChanges || this.shouldShowConfirmOnClose) {
          this.shouldShowConfirmOnClose = false;
          const confirm2 = new bootstrap.Modal(document.getElementById("confirmModal"));
          confirm2.show();
        }
      });
    }
    connect() {
      this.startY = null;
      this.threshold = 250;
      this.skipNextConfirmation = false;
      this.modalTarget.addEventListener("touchstart", this.onTouchStart);
      this.modalTarget.addEventListener("touchend", this.onTouchEnd);
      this.modalTarget.addEventListener("hidden.bs.modal", this.onModalHidden);
      this.modalTarget.addEventListener("shown.bs.modal", () => {
        this.skipNextConfirmation = false;
      });
    }
    disconnect() {
      this.modalTarget.removeEventListener("touchstart", this.onTouchStart);
      this.modalTarget.removeEventListener("touchend", this.onTouchEnd);
      this.modalTarget.removeEventListener("hidden.bs.modal", this.onModalHidden);
    }
    skipConfirmationOnce() {
      this.skipNextConfirmation = true;
    }
  };
  __publicField(modal_swipe_controller_default, "targets", ["modal"]);

  // app/javascript/utils/memo_modal.js
  var isModalAnimating = false;
  function removeBackdrop() {
    document.querySelectorAll(".modal-backdrop").forEach((el) => el.remove());
  }
  function hideConfirmModal(callback) {
    const confirmModalEl = document.getElementById("confirmModal");
    const confirmInstance = bootstrap.Modal.getInstance(confirmModalEl);
    if (confirmInstance) {
      confirmModalEl.addEventListener(
        "hidden.bs.modal",
        () => {
          removeBackdrop();
          setTimeout(() => {
            isModalAnimating = false;
            callback == null ? void 0 : callback();
          }, 200);
        },
        { once: true }
      );
      isModalAnimating = true;
      confirmInstance.hide();
    } else {
      removeBackdrop();
      isModalAnimating = false;
      callback == null ? void 0 : callback();
    }
  }
  function discardChanges() {
    if (isModalAnimating) return;
    hideConfirmModal(() => {
      var _a2;
      const modalEl = document.getElementById("memoEditModal");
      const instance = bootstrap.Modal.getInstance(modalEl);
      if (instance) {
        instance.hide();
      }
      const controller = application.getControllerForElementAndIdentifier(modalEl, "modal-swipe");
      (_a2 = controller == null ? void 0 : controller.skipConfirmationOnce) == null ? void 0 : _a2.call(controller);
      setTimeout(() => {
        removeBackdrop();
        bootstrap.Modal.getOrCreateInstance(modalEl).hide();
        window.hasUnsavedChanges = false;
      }, 200);
    });
  }
  function saveAndClose() {
    if (isModalAnimating) return;
    const form = document.getElementById("memo-edit-form");
    if (form) form.requestSubmit();
    hideConfirmModal(() => {
      var _a2;
      const modalEl = document.getElementById("memoEditModal");
      const controller = application.getControllerForElementAndIdentifier(modalEl, "modal-swipe");
      (_a2 = controller == null ? void 0 : controller.skipConfirmationOnce) == null ? void 0 : _a2.call(controller);
      setTimeout(() => {
        removeBackdrop();
        bootstrap.Modal.getOrCreateInstance(modalEl).hide();
        window.hasUnsavedChanges = false;
      }, 200);
    });
  }
  window.returnToEditor = function() {
    if (isModalAnimating) return;
    hideConfirmModal(() => {
      const editorModal = document.getElementById("memoEditModal");
      const instance = bootstrap.Modal.getInstance(editorModal);
      if (instance) instance.hide();
      setTimeout(() => {
        removeBackdrop();
        const newInstance = bootstrap.Modal.getOrCreateInstance(editorModal);
        newInstance.show();
      }, 200);
    });
  };

  // app/javascript/controllers/confirm_modal_controller.js
  var confirm_modal_controller_default = class extends Controller {
    cancel() {
      const confirmModalEl = this.element;
      const editorModalEl = document.getElementById("memoEditModal");
      if (!editorModalEl) return;
      confirmModalEl.addEventListener("hidden.bs.modal", () => {
        setTimeout(() => {
          document.querySelectorAll(".modal-backdrop").forEach((el) => el.remove());
          const editorModal = new bootstrap.Modal(editorModalEl);
          editorModal.show();
        }, 10);
      }, { once: true });
      this.instance().hide();
    }
    discard() {
      discardChanges();
    }
    save() {
      saveAndClose();
    }
    instance() {
      return bootstrap.Modal.getInstance(this.element);
    }
  };
  __publicField(confirm_modal_controller_default, "targets", ["modal"]);

  // app/javascript/controllers/image_upload_controller.js
  var image_upload_controller_default = class extends Controller {
    connect() {
      console.log("\u{1F5BC} image upload controller connected");
    }
    triggerUpload() {
      const file = this.fileInputTarget.files[0];
      if (file) {
        this.formTarget.requestSubmit();
      }
    }
  };
  __publicField(image_upload_controller_default, "targets", ["fileInput", "form"]);

  // app/javascript/controllers/tag_toggle_controller.js
  var tag_toggle_controller_default = class extends Controller {
    connect() {
      this.selectedSet = new Set((this.selectedTagsValue || "").split(",").filter(Boolean));
      this.updateUI();
    }
    toggle(event) {
      const name = event.target.dataset.tagToggleNameParam;
      if (this.selectedSet.has(name)) {
        this.selectedSet.delete(name);
      } else {
        this.selectedSet.add(name);
      }
      this.updateUI();
      this.redirect();
    }
    redirect() {
      const url = new URL(window.location.href);
      url.searchParams.delete("tags[]");
      this.selectedSet.forEach((tag) => {
        url.searchParams.append("tags[]", tag);
      });
      Turbo.visit(url.toString(), { frame: "books_frame" });
    }
    updateUI() {
      this.element.querySelectorAll(".tag-btn").forEach((btn) => {
        const name = btn.dataset.tagToggleNameParam;
        btn.style.opacity = this.selectedSet.has(name) ? "1.0" : "0.5";
      });
    }
  };
  __publicField(tag_toggle_controller_default, "values", { selectedTags: String });

  // app/javascript/controllers/ui_toggle_controller.js
  var ui_toggle_controller_default = class extends Controller {
    connect() {
      this.hide();
    }
    toggle() {
      this.isVisible ? this.hide() : this.show();
    }
    show() {
      this.contentTarget.classList.add("show");
      this.contentTarget.hidden = false;
      this.isVisible = true;
    }
    hide() {
      this.contentTarget.classList.remove("show");
      this.contentTarget.hidden = true;
      this.isVisible = false;
    }
  };
  __publicField(ui_toggle_controller_default, "targets", ["content"]);

  // app/javascript/controllers/column_selector_controller.js
  var column_selector_controller_default = class extends Controller {
    connect() {
      this.defaultClass = this.gridTarget.className;
      const hiddenInput = document.getElementById("hiddenColumnInput");
      if (hiddenInput && hiddenInput.value) {
        const cols = hiddenInput.value;
        this.gridTarget.classList.add(`cols-${cols}`);
      }
    }
    change(event) {
      const cols = event.target.value;
      this.gridTarget.className = this.defaultClass;
      this.gridTarget.classList.add(`cols-${cols}`);
      const hiddenInput = document.getElementById("hiddenColumnInput");
      if (hiddenInput) {
        hiddenInput.value = cols;
      }
      const form = document.getElementById("columnForm");
      if (form) {
        form.requestSubmit();
      }
    }
  };
  __publicField(column_selector_controller_default, "targets", ["selector", "grid"]);

  // app/javascript/controllers/auto_remove_controller.js
  var auto_remove_controller_default = class extends Controller {
    connect() {
      setTimeout(() => {
        this.element.remove();
      }, 3e3);
    }
  };

  // app/javascript/controllers/auto_submit_controller.js
  var auto_submit_controller_default = class extends Controller {
    change(event) {
      this.element.requestSubmit();
    }
  };
  __publicField(auto_submit_controller_default, "targets", ["select"]);

  // app/javascript/controllers/infinite_scroll_controller.js
  var infinite_scroll_controller_default = class extends Controller {
    connect() {
      if ("IntersectionObserver" in window) {
        this.observer = new IntersectionObserver((entries) => {
          if (entries[0].isIntersecting) {
            this.loadMore();
          }
        });
        this.observer.observe(this.element);
      }
    }
    loadMore() {
      if (this.urlValue) {
        this.element.innerHTML = `
        <div class="text-center my-4">
          <div class="spinner-border text-secondary" role="status"></div>
        </div>
      `;
        Turbo.visit(this.urlValue, { frame: "books_frame" });
      }
    }
    disconnect() {
      if (this.observer) this.observer.disconnect();
    }
  };
  __publicField(infinite_scroll_controller_default, "values", {
    url: String
  });

  // app/javascript/controllers/safari_click_fix_controller.js
  var safari_click_fix_controller_default = class extends Controller {
    connect() {
      setTimeout(() => {
        const elements = this.element.querySelectorAll(
          ".safari-fix-button, button[type='submit'], input[type='submit'], a.btn, a.modal-action-button"
        );
        elements.forEach((el) => {
          if (document.activeElement === el) {
            el.blur();
          }
        });
      }, 100);
    }
  };

  // app/javascript/controllers/detail_card_column_selector_controller.js
  var detail_card_column_selector_controller_default = class extends Controller {
    change(event) {
      const cols = event.target.value;
      const hiddenInput = document.getElementById("hiddenColumnInput");
      if (hiddenInput) {
        hiddenInput.value = cols;
      }
      const form = document.getElementById("columnForm");
      if (form) {
        form.requestSubmit();
      }
    }
  };
  __publicField(detail_card_column_selector_controller_default, "targets", ["selector"]);

  // app/javascript/controllers/book_edit_controller.js
  var book_edit_controller_default = class extends Controller {
    startEdit() {
      this.titleTarget.innerHTML = `<input class="form-control form-control-sm" name="title" value="${this.titleTarget.textContent.trim()}" />`;
      this.authorTarget.innerHTML = `<input class="form-control form-control-sm" name="author" value="${this.authorTarget.textContent.trim()}" />`;
      this.publisherTarget.innerHTML = `<input class="form-control form-control-sm" name="publisher" value="${this.publisherTarget.textContent.trim()}" />`;
      this.element.querySelector("td:last-child").innerHTML = `
      <button class="btn btn-success btn-sm d-flex align-items-center" data-action="click->book-edit#save">
        <i class="bi bi-check-lg"></i>
      </button>
      <button class="btn btn-secondary btn-sm d-flex align-items-center" data-action="click->book-edit#cancel">
        <i class="bi bi-x-lg"></i>
      </button>
    `;
    }
    cancel() {
      window.location.reload();
    }
    save() {
      const id = this.idValue;
      const index = this.indexValue;
      const row = this.element;
      const title = row.querySelector("input[name='title']").value;
      const author = row.querySelector("input[name='author']").value;
      const publisher = row.querySelector("input[name='publisher']").value;
      const csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
      fetch(`/books/${id}/update_row`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Accept: "text/vnd.turbo-stream.html",
          "X-CSRF-Token": csrfToken
        },
        body: JSON.stringify({
          book: { title, author, publisher },
          index
        })
      }).then((response) => {
        if (response.ok) {
          return response.text();
        } else {
          throw new Error("\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
        }
      }).then((html) => {
        this.element.outerHTML = html;
      }).catch((error2) => {
        alert(error2.message);
      });
    }
  };
  __publicField(book_edit_controller_default, "targets", ["title", "author", "publisher"]);
  __publicField(book_edit_controller_default, "values", { id: Number, index: Number });

  // node_modules/bootstrap/dist/js/bootstrap.esm.js
  var bootstrap_esm_exports = {};
  __export(bootstrap_esm_exports, {
    Alert: () => Alert,
    Button: () => Button,
    Carousel: () => Carousel,
    Collapse: () => Collapse,
    Dropdown: () => Dropdown,
    Modal: () => Modal,
    Offcanvas: () => Offcanvas,
    Popover: () => Popover,
    ScrollSpy: () => ScrollSpy,
    Tab: () => Tab,
    Toast: () => Toast,
    Tooltip: () => Tooltip
  });
  var elementMap = /* @__PURE__ */ new Map();
  var Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };
  var MAX_UID = 1e6;
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var parseSelector = (selector) => {
    if (selector && window.CSS && window.CSS.escape) {
      selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
    }
    return selector;
  };
  var toType = (object) => {
    if (object === null || object === void 0) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement3 = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  var getElement = (object) => {
    if (isElement3(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  var isVisible = (element) => {
    if (!isElement3(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback2 of DOMContentLoadedCallbacks) {
            callback2();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
    return typeof possibleCallback === "function" ? possibleCallback.call(...args) : defaultValue;
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn2) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn2);
      }
      return fn2.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn2) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn3) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn3.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers2 = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers2, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn2.delegationSelector = isDelegated ? handler : null;
    fn2.callable = callable;
    fn2.oneOff = oneOff;
    fn2.uidEvent = uid;
    handlers2[uid] = fn2;
    element.addEventListener(typeEvent, fn2, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn2) {
      return;
    }
    element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
    delete events[typeEvent][fn2.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(new Event(event, {
        bubbles,
        cancelable: true
      }), args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }
  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };
  var Config = class {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config2) {
      config2 = this._mergeConfigObj(config2);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    _configAfterMerge(config2) {
      return config2;
    }
    _mergeConfigObj(config2, element) {
      const jsonConfig = isElement3(element) ? Manipulator.getDataAttribute(element, "config") : {};
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.constructor.Default), typeof jsonConfig === "object" ? jsonConfig : {}), isElement3(element) ? Manipulator.getDataAttributes(element) : {}), typeof config2 === "object" ? config2 : {});
    }
    _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config2[property];
        const valueType = isElement3(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  };
  var VERSION = "5.3.6";
  var BaseComponent = class extends Config {
    constructor(element, config2) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config2);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    // Private
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config2) {
      config2 = this._mergeConfigObj(config2, this._element);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config2 = {}) {
      return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  };
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");
      if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
        return null;
      }
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
    }
    return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
  };
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    }
  };
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };
  var NAME$f = "alert";
  var DATA_KEY$a = "bs.alert";
  var EVENT_KEY$b = `.${DATA_KEY$a}`;
  var EVENT_CLOSE = `close${EVENT_KEY$b}`;
  var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  var CLASS_NAME_FADE$5 = "fade";
  var CLASS_NAME_SHOW$8 = "show";
  var Alert = class _Alert extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }
    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Alert.getOrCreateInstance(this);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      });
    }
  };
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  var NAME$e = "button";
  var DATA_KEY$9 = "bs.button";
  var EVENT_KEY$a = `.${DATA_KEY$9}`;
  var DATA_API_KEY$6 = ".data-api";
  var CLASS_NAME_ACTIVE$3 = "active";
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var Button = class _Button extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }
    // Public
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Button.getOrCreateInstance(this);
        if (config2 === "toggle") {
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  defineJQueryPlugin(Button);
  var NAME$d = "swipe";
  var EVENT_KEY$9 = ".bs.swipe";
  var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  var POINTER_TYPE_TOUCH = "touch";
  var POINTER_TYPE_PEN = "pen";
  var CLASS_NAME_POINTER_EVENT = "pointer-event";
  var SWIPE_THRESHOLD = 40;
  var Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  var DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
  };
  var Swipe = class _Swipe extends Config {
    constructor(element, config2) {
      super();
      this._element = element;
      if (!element || !_Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config2);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }
    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }
    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  };
  var NAME$c = "carousel";
  var DATA_KEY$8 = "bs.carousel";
  var EVENT_KEY$8 = `.${DATA_KEY$8}`;
  var DATA_API_KEY$5 = ".data-api";
  var ARROW_LEFT_KEY$1 = "ArrowLeft";
  var ARROW_RIGHT_KEY$1 = "ArrowRight";
  var TOUCHEVENT_COMPAT_WAIT = 500;
  var ORDER_NEXT = "next";
  var ORDER_PREV = "prev";
  var DIRECTION_LEFT = "left";
  var DIRECTION_RIGHT = "right";
  var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  var EVENT_SLID = `slid${EVENT_KEY$8}`;
  var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var CLASS_NAME_CAROUSEL = "carousel";
  var CLASS_NAME_ACTIVE$2 = "active";
  var CLASS_NAME_SLIDE = "slide";
  var CLASS_NAME_END = "carousel-item-end";
  var CLASS_NAME_START = "carousel-item-start";
  var CLASS_NAME_NEXT = "carousel-item-next";
  var CLASS_NAME_PREV = "carousel-item-prev";
  var SELECTOR_ACTIVE = ".active";
  var SELECTOR_ITEM = ".carousel-item";
  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  var SELECTOR_ITEM_IMG = ".carousel-item img";
  var SELECTOR_INDICATORS = ".carousel-indicators";
  var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  var Default$b = {
    interval: 5e3,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true
  };
  var DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
  };
  var Carousel = class _Carousel extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }
    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }
    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order2, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }
    // Private
    _configAfterMerge(config2) {
      config2.defaultInterval = config2.interval;
      return config2;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== "hover") {
          return;
        }
        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute("aria-current");
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute("aria-current", "true");
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order2, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext2 = order2 === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext2, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = (eventName) => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order2),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext2 ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext2 ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order2) {
      if (isRTL()) {
        return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Carousel.getOrCreateInstance(this, config2);
        if (typeof config2 === "number") {
          data.to(config2);
          return;
        }
        if (typeof config2 === "string") {
          if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute("data-bs-slide-to");
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });
  defineJQueryPlugin(Carousel);
  var NAME$b = "collapse";
  var DATA_KEY$7 = "bs.collapse";
  var EVENT_KEY$7 = `.${DATA_KEY$7}`;
  var DATA_API_KEY$4 = ".data-api";
  var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  var CLASS_NAME_SHOW$7 = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Default$a = {
    parent: null,
    toggle: true
  };
  var DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  var Collapse = class _Collapse extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList2 = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList2) {
        const selector = SelectorEngine.getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }
    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => _Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = SelectorEngine.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    // Private
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    _configAfterMerge(config2) {
      config2.toggle = Boolean(config2.toggle);
      config2.parent = getElement(config2.parent);
      return config2;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = SelectorEngine.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }
    // Static
    static jQueryInterface(config2) {
      const _config = {};
      if (typeof config2 === "string" && /show|hide/.test(config2)) {
        _config.toggle = false;
      }
      return this.each(function() {
        const data = _Collapse.getOrCreateInstance(this, _config);
        if (typeof config2 === "string") {
          if (typeof data[config2] === "undefined") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });
  defineJQueryPlugin(Collapse);
  var NAME$a = "dropdown";
  var DATA_KEY$6 = "bs.dropdown";
  var EVENT_KEY$6 = `.${DATA_KEY$6}`;
  var DATA_API_KEY$3 = ".data-api";
  var ESCAPE_KEY$2 = "Escape";
  var TAB_KEY$1 = "Tab";
  var ARROW_UP_KEY$1 = "ArrowUp";
  var ARROW_DOWN_KEY$1 = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var CLASS_NAME_SHOW$6 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_DROPUP_CENTER = "dropup-center";
  var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR = ".navbar";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var PLACEMENT_TOPCENTER = "top";
  var PLACEMENT_BOTTOMCENTER = "bottom";
  var Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  };
  var DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  var Dropdown = class _Dropdown extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._popper = null;
      this._parent = this._element.parentNode;
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();
      if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
      this._element.focus();
    }
    _getConfig(config2) {
      config2 = super._getConfig(config2);
      if (typeof config2.reference === "object" && !isElement3(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config2;
    }
    _createPopper() {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement3(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper3(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._inNavbar || this._config.display === "static") {
        Manipulator.setDataAttribute(this._menu, "popper", "static");
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return __spreadValues(__spreadValues({}, defaultBsPopperConfig), execute(this._config.popperConfig, [void 0, defaultBsPopperConfig]));
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Dropdown.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = _Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = _Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  };
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);
  var NAME$9 = "backdrop";
  var CLASS_NAME_FADE$4 = "fade";
  var CLASS_NAME_SHOW$5 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  var Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  };
  var DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  var Backdrop = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
      this._isAppended = false;
      this._element = null;
    }
    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }
    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config2) {
      config2.rootElement = getElement(config2.rootElement);
      return config2;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var NAME$8 = "focustrap";
  var DATA_KEY$5 = "bs.focustrap";
  var EVENT_KEY$5 = `.${DATA_KEY$5}`;
  var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  var TAB_KEY = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var Default$7 = {
    autofocus: true,
    trapElement: null
    // The element to trap focus inside of
  };
  var DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  var FocusTrap = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }
    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5);
      EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  };
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var PROPERTY_PADDING = "padding-right";
  var PROPERTY_MARGIN = "margin-right";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement3(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  };
  var NAME$7 = "modal";
  var DATA_KEY$4 = "bs.modal";
  var EVENT_KEY$4 = `.${DATA_KEY$4}`;
  var DATA_API_KEY$2 = ".data-api";
  var ESCAPE_KEY$1 = "Escape";
  var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE$3 = "fade";
  var CLASS_NAME_SHOW$4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR$1 = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  var Modal = class _Modal extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config2, relatedTarget) {
      return this.each(function() {
        const data = _Modal.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](relatedTarget);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  var NAME$6 = "offcanvas";
  var DATA_KEY$3 = "bs.offcanvas";
  var EVENT_KEY$3 = `.${DATA_KEY$3}`;
  var DATA_API_KEY$1 = ".data-api";
  var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var ESCAPE_KEY = "Escape";
  var CLASS_NAME_SHOW$3 = "show";
  var CLASS_NAME_SHOWING$1 = "showing";
  var CLASS_NAME_HIDING = "hiding";
  var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  var OPEN_SELECTOR = ".offcanvas.show";
  var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
  };
  var Offcanvas = class _Offcanvas extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === "static") {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };
      const isVisible2 = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: isVisible2,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible2 ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      });
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Offcanvas.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
      if (getComputedStyle(element).position !== "fixed") {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  var allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }
    return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === "function") {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }
  var NAME$5 = "TemplateFactory";
  var Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>"
  };
  var DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
  };
  var DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
  };
  var TemplateFactory = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
    }
    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }
    // Public
    getContent() {
      return Object.values(this._config.content).map((config2) => this._resolvePossibleFunction(config2)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = __spreadValues(__spreadValues({}, this._config.content), content);
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement("div");
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(" "));
      }
      return template;
    }
    // Private
    _typeCheckConfig(config2) {
      super._typeCheckConfig(config2);
      this._checkContent(config2.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement3(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [void 0, this]);
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = "";
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  };
  var NAME$4 = "tooltip";
  var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var CLASS_NAME_FADE$2 = "fade";
  var CLASS_NAME_MODAL = "modal";
  var CLASS_NAME_SHOW$2 = "show";
  var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  var EVENT_MODAL_HIDE = "hide.bs.modal";
  var TRIGGER_HOVER = "hover";
  var TRIGGER_FOCUS = "focus";
  var TRIGGER_CLICK = "click";
  var TRIGGER_MANUAL = "manual";
  var EVENT_HIDE$2 = "hide";
  var EVENT_HIDDEN$2 = "hidden";
  var EVENT_SHOW$2 = "show";
  var EVENT_SHOWN$2 = "shown";
  var EVENT_INSERTED = "inserted";
  var EVENT_CLICK$1 = "click";
  var EVENT_FOCUSIN$1 = "focusin";
  var EVENT_FOCUSOUT$1 = "focusout";
  var EVENT_MOUSEENTER = "mouseenter";
  var EVENT_MOUSELEAVE = "mouseleave";
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
  };
  var Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: false,
    offset: [0, 6],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
  };
  var DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
  };
  var Tooltip = class _Tooltip extends BaseComponent {
    constructor(element, config2) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
      }
      super(element, config2);
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }
    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }
    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute("data-bs-original-title")) {
        this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null;
      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }
    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute("id", tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory(__spreadProps(__spreadValues({}, this._config), {
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        }));
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = execute(this._config.placement, [this, tip, this._element]);
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper3(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this._element, this._element]);
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: true,
          phase: "beforeMain",
          fn: (data) => {
            this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
          }
        }]
      };
      return __spreadValues(__spreadValues({}, defaultBsPopperConfig), execute(this._config.popperConfig, [void 0, defaultBsPopperConfig]));
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      for (const trigger of triggers) {
        if (trigger === "click") {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      if (!title) {
        return;
      }
      if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("data-bs-original-title", title);
      this._element.removeAttribute("title");
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config2) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config2 = __spreadValues(__spreadValues({}, dataAttributes), typeof config2 === "object" && config2 ? config2 : {});
      config2 = this._mergeConfigObj(config2);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    _configAfterMerge(config2) {
      config2.container = config2.container === false ? document.body : getElement(config2.container);
      if (typeof config2.delay === "number") {
        config2.delay = {
          show: config2.delay,
          hide: config2.delay
        };
      }
      if (typeof config2.title === "number") {
        config2.title = config2.title.toString();
      }
      if (typeof config2.content === "number") {
        config2.content = config2.content.toString();
      }
      return config2;
    }
    _getDelegateConfig() {
      const config2 = {};
      for (const [key, value] of Object.entries(this._config)) {
        if (this.constructor.Default[key] !== value) {
          config2[key] = value;
        }
      }
      config2.selector = false;
      config2.trigger = "manual";
      return config2;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Tooltip.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  defineJQueryPlugin(Tooltip);
  var NAME$3 = "popover";
  var SELECTOR_TITLE = ".popover-header";
  var SELECTOR_CONTENT = ".popover-body";
  var Default$2 = __spreadProps(__spreadValues({}, Tooltip.Default), {
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
  });
  var DefaultType$2 = __spreadProps(__spreadValues({}, Tooltip.DefaultType), {
    content: "(null|string|element|function)"
  });
  var Popover = class _Popover extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }
    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Popover.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  defineJQueryPlugin(Popover);
  var NAME$2 = "scrollspy";
  var DATA_KEY$2 = "bs.scrollspy";
  var EVENT_KEY$2 = `.${DATA_KEY$2}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  var EVENT_CLICK = `click${EVENT_KEY$2}`;
  var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE$1 = "active";
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_TARGET_LINKS = "[href]";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  var SELECTOR_DROPDOWN = ".dropdown";
  var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  var Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  var DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
  };
  var ScrollSpy = class _ScrollSpy extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh();
    }
    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }
    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }
    // Private
    _configAfterMerge(config2) {
      config2.target = getElement(config2.target) || document.body;
      config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
      if (typeof config2.threshold === "string") {
        config2.threshold = config2.threshold.split(",").map((value) => Number.parseFloat(value));
      }
      return config2;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: "smooth"
            });
            return;
          }
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver((entries) => this._observerCallback(entries), options);
    }
    // The logic of selection
    _observerCallback(entries) {
      const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
      const activate = (entry) => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          if (!parentScrollTop) {
            return;
          }
          continue;
        }
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
        if (isVisible(observableSection)) {
          this._targetLinks.set(decodeURI(anchor.hash), anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _ScrollSpy.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });
  defineJQueryPlugin(ScrollSpy);
  var NAME$1 = "tab";
  var DATA_KEY$1 = "bs.tab";
  var EVENT_KEY$1 = `.${DATA_KEY$1}`;
  var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var HOME_KEY = "Home";
  var END_KEY = "End";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE$1 = "fade";
  var CLASS_NAME_SHOW$1 = "show";
  var CLASS_DROPDOWN = "dropdown";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = ".nav-item, .list-group-item";
  var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  var Tab = class _Tab extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
      }
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
    }
    // Getters
    static get NAME() {
      return NAME$1;
    }
    // Public
    show() {
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const children = this._getChildren().filter((element) => !isDisabled(element));
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext2 = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext2, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        _Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((child) => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive2 = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive2);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive2) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element2 = SelectorEngine.findOne(selector, outerElem);
        if (element2) {
          element2.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Tab.getOrCreateInstance(this);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  defineJQueryPlugin(Tab);
  var NAME = "toast";
  var DATA_KEY = "bs.toast";
  var EVENT_KEY = `.${DATA_KEY}`;
  var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_HIDE = "hide";
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_SHOWING = "showing";
  var DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5e3
  };
  var Toast = class _Toast extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }
    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE);
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE);
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = isInteracting;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = _Toast.getOrCreateInstance(this, config2);
        if (typeof config2 === "string") {
          if (typeof data[config2] === "undefined") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2](this);
        }
      });
    }
  };
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    config: () => config,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start2,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter2) {
      if (submitter2) {
        validateSubmitter(submitter2, this);
        submitter2.click();
      } else {
        submitter2 = document.createElement("input");
        submitter2.type = "submit";
        submitter2.hidden = true;
        this.appendChild(submitter2);
        submitter2.click();
        this.removeChild(submitter2);
      }
    };
    function validateSubmitter(submitter2, form) {
      submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter2.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate == null ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter2 = findSubmitterFromClickTarget(event.target);
    if (submitter2 && submitter2.form) {
      submittersByForm.set(submitter2.form, submitter2);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var _FrameElement = class _FrameElement extends HTMLElement {
    constructor() {
      super();
      __publicField(this, "loaded", Promise.resolve());
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else if (name == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    get shouldReloadWithMorph() {
      return this.src && this.refresh === "morph";
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      var _a2, _b;
      return (_b = (_a2 = this.ownerDocument) == null ? void 0 : _a2.documentElement) == null ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  __publicField(_FrameElement, "delegateConstructor");
  var FrameElement = _FrameElement;
  function frameLoadingStyleFromString(style2) {
    switch (style2.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  var drive = {
    enabled: true,
    progressBarDelay: 500,
    unvisitableExtensions: /* @__PURE__ */ new Set(
      [
        ".7z",
        ".aac",
        ".apk",
        ".avi",
        ".bmp",
        ".bz2",
        ".css",
        ".csv",
        ".deb",
        ".dmg",
        ".doc",
        ".docx",
        ".exe",
        ".gif",
        ".gz",
        ".heic",
        ".heif",
        ".ico",
        ".iso",
        ".jpeg",
        ".jpg",
        ".js",
        ".json",
        ".m4a",
        ".mkv",
        ".mov",
        ".mp3",
        ".mp4",
        ".mpeg",
        ".mpg",
        ".msi",
        ".ogg",
        ".ogv",
        ".pdf",
        ".pkg",
        ".png",
        ".ppt",
        ".pptx",
        ".rar",
        ".rtf",
        ".svg",
        ".tar",
        ".tif",
        ".tiff",
        ".txt",
        ".wav",
        ".webm",
        ".webp",
        ".wma",
        ".wmv",
        ".xls",
        ".xlsx",
        ".xml",
        ".zip"
      ]
    )
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getCspNonce();
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function cancelEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value = values[i] == void 0 ? "" : values[i];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element == null ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string") return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function getCspNonce() {
    const element = getMetaElement("csp-nonce");
    if (element) {
      const { nonce, content } = element;
      return nonce == "" ? content : nonce;
    }
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    var _a2;
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_a2 = element.getRootNode()) == null ? void 0 : _a2.host), selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  function around(callback, reader) {
    return __async(this, null, function* () {
      const before = reader();
      callback();
      yield nextAnimationFrame();
      const after = reader();
      return [before, after];
    });
  }
  function doesNotTargetIFrame(name) {
    if (name === "_blank") {
      return false;
    } else if (name) {
      for (const element of document.getElementsByName(name)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  function debounce3(fn2, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn2.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var submitter = {
    "aria-disabled": {
      beforeSubmit: (submitter2) => {
        submitter2.setAttribute("aria-disabled", "true");
        submitter2.addEventListener("click", cancelEvent);
      },
      afterSubmit: (submitter2) => {
        submitter2.removeAttribute("aria-disabled");
        submitter2.removeEventListener("click", cancelEvent);
      }
    },
    "disabled": {
      beforeSubmit: (submitter2) => submitter2.disabled = true,
      afterSubmit: (submitter2) => submitter2.disabled = false
    }
  };
  var _submitter;
  var Config2 = class {
    constructor(config2) {
      __privateAdd(this, _submitter, null);
      Object.assign(this, config2);
    }
    get submitter() {
      return __privateGet(this, _submitter);
    }
    set submitter(value) {
      __privateSet(this, _submitter, submitter[value] || value);
    }
  };
  _submitter = new WeakMap();
  var forms = new Config2({
    mode: "on",
    submitter: "disabled"
  });
  var config = {
    drive,
    forms
  };
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter2) {
    const action = (submitter2 == null ? void 0 : submitter2.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, __spreadProps(__spreadValues({}, options), {
      headers: modifiedHeaders
    }));
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var _resolveRequestPromise, _FetchRequest_instances, allowRequestToBeIntercepted_fn, willDelegateErrorHandling_fn;
  var FetchRequest = class {
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      __privateAdd(this, _FetchRequest_instances);
      __publicField(this, "abortController", new AbortController());
      __privateAdd(this, _resolveRequestPromise, (_value) => {
      });
      var _a2;
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method: method.toUpperCase(),
        headers: __spreadValues({}, this.defaultHeaders),
        body,
        signal: this.abortSignal,
        referrer: (_a2 = this.delegate.referrer) == null ? void 0 : _a2.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod.toUpperCase();
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    perform() {
      return __async(this, null, function* () {
        const { fetchOptions } = this;
        this.delegate.prepareRequest(this);
        const event = yield __privateMethod(this, _FetchRequest_instances, allowRequestToBeIntercepted_fn).call(this, fetchOptions);
        try {
          this.delegate.requestStarted(this);
          if (event.detail.fetchRequest) {
            this.response = event.detail.fetchRequest.response;
          } else {
            this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
          }
          const response = yield this.response;
          return yield this.receive(response);
        } catch (error2) {
          if (error2.name !== "AbortError") {
            if (__privateMethod(this, _FetchRequest_instances, willDelegateErrorHandling_fn).call(this, error2)) {
              this.delegate.requestErrored(this, error2);
            }
            throw error2;
          }
        } finally {
          this.delegate.requestFinished(this);
        }
      });
    }
    receive(response) {
      return __async(this, null, function* () {
        const fetchResponse = new FetchResponse(response);
        const event = dispatch("turbo:before-fetch-response", {
          cancelable: true,
          detail: { fetchResponse },
          target: this.target
        });
        if (event.defaultPrevented) {
          this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
        } else if (fetchResponse.succeeded) {
          this.delegate.requestSucceededWithResponse(this, fetchResponse);
        } else {
          this.delegate.requestFailedWithResponse(this, fetchResponse);
        }
        return fetchResponse;
      });
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
  };
  _resolveRequestPromise = new WeakMap();
  _FetchRequest_instances = new WeakSet();
  allowRequestToBeIntercepted_fn = function(fetchOptions) {
    return __async(this, null, function* () {
      const requestInterception = new Promise((resolve) => __privateSet(this, _resolveRequestPromise, resolve));
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: __privateGet(this, _resolveRequestPromise)
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented) yield requestInterception;
      return event;
    });
  };
  willDelegateErrorHandling_fn = function(error2) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error: error2 }
    });
    return !event.defaultPrevented;
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File) continue;
      else entries.push([name, value]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    constructor(delegate, element) {
      __publicField(this, "started", false);
      __publicField(this, "intersect", (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry == null ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      });
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  __publicField(StreamMessage, "contentType", "text/vnd.turbo-stream.html");
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var _prefetchTimeout, _prefetched;
  var PrefetchCache = class {
    constructor() {
      __privateAdd(this, _prefetchTimeout, null);
      __privateAdd(this, _prefetched, null);
    }
    get(url) {
      if (__privateGet(this, _prefetched) && __privateGet(this, _prefetched).url === url && __privateGet(this, _prefetched).expire > Date.now()) {
        return __privateGet(this, _prefetched).request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      __privateSet(this, _prefetchTimeout, setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        __privateSet(this, _prefetchTimeout, null);
      }, PREFETCH_DELAY));
    }
    set(url, request, ttl) {
      __privateSet(this, _prefetched, { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) });
    }
    clear() {
      if (__privateGet(this, _prefetchTimeout)) clearTimeout(__privateGet(this, _prefetchTimeout));
      __privateSet(this, _prefetched, null);
    }
  };
  _prefetchTimeout = new WeakMap();
  _prefetched = new WeakMap();
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    constructor(delegate, formElement, submitter2, mustRedirect = false) {
      __publicField(this, "state", FormSubmissionState.initialized);
      const method = getMethod(formElement, submitter2);
      const action = getAction(getFormAction(formElement, submitter2), method);
      const body = buildFormData(formElement, submitter2);
      const enctype = getEnctype(formElement, submitter2);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter2;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message) {
      return Promise.resolve(confirm(message));
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    start() {
      return __async(this, null, function* () {
        const { initialized, requesting } = FormSubmissionState;
        const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
        if (typeof confirmationMessage === "string") {
          const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
          const answer = yield confirmMethod(confirmationMessage, this.formElement, this.submitter);
          if (!answer) {
            return;
          }
        }
        if (this.state == initialized) {
          this.state = requesting;
          return this.fetchRequest.perform();
        }
      });
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: __spreadValues({ formSubmission: this }, this.result)
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      var _a2;
      return (_a2 = this.submitter) == null ? void 0 : _a2.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter2) {
    const formData = new FormData(formElement);
    const name = submitter2 == null ? void 0 : submitter2.getAttribute("name");
    const value = submitter2 == null ? void 0 : submitter2.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter2) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter2 == null ? void 0 : submitter2.hasAttribute("formaction")) {
      return submitter2.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter2) {
    const method = (submitter2 == null ? void 0 : submitter2.getAttribute("formmethod")) || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter2) {
    return fetchEnctypeFromString((submitter2 == null ? void 0 : submitter2.getAttribute("formenctype")) || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    constructor(delegate, eventTarget) {
      __publicField(this, "started", false);
      __publicField(this, "submitCaptured", () => {
        this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
        this.eventTarget.addEventListener("submit", this.submitBubbled, false);
      });
      __publicField(this, "submitBubbled", (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter2 = event.submitter || void 0;
          if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmitted(form, submitter2);
          }
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  function submissionDoesNotDismissDialog(form, submitter2) {
    const method = (submitter2 == null ? void 0 : submitter2.getAttribute("formmethod")) || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter2) {
    const target = (submitter2 == null ? void 0 : submitter2.getAttribute("formtarget")) || form.getAttribute("target");
    return doesNotTargetIFrame(target);
  }
  var _resolveRenderPromise, _resolveInterceptionPromise;
  var View = class {
    constructor(delegate, element) {
      __privateAdd(this, _resolveRenderPromise, (_value) => {
      });
      __privateAdd(this, _resolveInterceptionPromise, (_value) => {
      });
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    render(renderer) {
      return __async(this, null, function* () {
        const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
        const shouldInvalidate = willRender;
        if (shouldRender) {
          try {
            this.renderPromise = new Promise((resolve) => __privateSet(this, _resolveRenderPromise, resolve));
            this.renderer = renderer;
            yield this.prepareToRenderSnapshot(renderer);
            const renderInterception = new Promise((resolve) => __privateSet(this, _resolveInterceptionPromise, resolve));
            const options = { resume: __privateGet(this, _resolveInterceptionPromise), render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
            const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
            if (!immediateRender) yield renderInterception;
            yield this.renderSnapshot(renderer);
            this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
            this.delegate.preloadOnLoadLinksForView(this.element);
            this.finishRenderingSnapshot(renderer);
          } finally {
            delete this.renderer;
            __privateGet(this, _resolveRenderPromise).call(this, void 0);
            delete this.renderPromise;
          }
        } else if (shouldInvalidate) {
          this.invalidate(renderer.reloadReason);
        }
      });
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    prepareToRenderSnapshot(renderer) {
      return __async(this, null, function* () {
        this.markAsPreview(renderer.isPreview);
        yield renderer.prepareToRender();
      });
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    renderSnapshot(renderer) {
      return __async(this, null, function* () {
        yield renderer.render();
      });
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  _resolveRenderPromise = new WeakMap();
  _resolveInterceptionPromise = new WeakMap();
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      __publicField(this, "clickBubbled", (event) => {
        if (this.clickEventIsSignificant(event)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      });
      __publicField(this, "linkClicked", (event) => {
        if (this.clickEvent && this.clickEventIsSignificant(event)) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
          }
        }
        delete this.clickEvent;
      });
      __publicField(this, "willVisit", (_event) => {
        delete this.clickEvent;
      });
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickEventIsSignificant(event) {
      var _a2;
      const target = event.composed ? (_a2 = event.target) == null ? void 0 : _a2.parentElement : event.target;
      const element = findLinkFromClickTarget(target) || target;
      return element instanceof Element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    constructor(delegate, eventTarget) {
      __publicField(this, "started", false);
      __publicField(this, "clickCaptured", () => {
        this.eventTarget.removeEventListener("click", this.clickBubbled, false);
        this.eventTarget.addEventListener("click", this.clickBubbled, false);
      });
      __publicField(this, "clickBubbled", (event) => {
        if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = findLinkFromClickTarget(target);
          if (link && doesNotTargetIFrame(link.target)) {
            const location2 = getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static preservingPermanentElements(delegate, permanentElementMap, callback) {
      return __async(this, null, function* () {
        const bardo = new this(delegate, permanentElementMap);
        bardo.enter();
        yield callback();
        bardo.leave();
      });
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder == null ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var _activeElement;
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      __privateAdd(this, _activeElement, null);
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = this.constructor.renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    static renderElement(currentElement, newElement) {
    }
    get shouldRender() {
      return true;
    }
    get shouldAutofocus() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    preservingPermanentElements(callback) {
      return __async(this, null, function* () {
        yield Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
      });
    }
    focusFirstAutofocusableElement() {
      if (this.shouldAutofocus) {
        const element = this.connectedSnapshot.firstAutofocusableElement;
        if (element) {
          element.focus();
        }
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (__privateGet(this, _activeElement)) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        __privateSet(this, _activeElement, this.currentSnapshot.activeElement);
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(__privateGet(this, _activeElement)) && __privateGet(this, _activeElement) instanceof HTMLElement) {
        __privateGet(this, _activeElement).focus();
        __privateSet(this, _activeElement, null);
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  _activeElement = new WeakMap();
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      var _a2;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = (_a2 = frameElement.ownerDocument) == null ? void 0 : _a2.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    render() {
      return __async(this, null, function* () {
        yield nextRepaint();
        this.preservingPermanentElements(() => {
          this.loadFrameElement();
        });
        this.scrollFrameIntoView();
        yield nextRepaint();
        this.focusFirstAutofocusableElement();
        yield nextRepaint();
        this.activateScriptElements();
      });
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var Idiomorph = function() {
    const noOp = () => {
    };
    const defaults = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: (elt) => elt.getAttribute("im-preserve") === "true",
        shouldReAppend: (elt) => elt.getAttribute("im-re-append") === "true",
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      },
      restoreFocus: true
    };
    function morph(oldNode, newContent, config2 = {}) {
      oldNode = normalizeElement(oldNode);
      const newNode = normalizeParent(newContent);
      const ctx = createMorphContext(oldNode, newNode, config2);
      const morphedNodes = saveAndRestoreFocus(ctx, () => {
        return withHeadBlocking(
          ctx,
          oldNode,
          newNode,
          /** @param {MorphContext} ctx */
          (ctx2) => {
            if (ctx2.morphStyle === "innerHTML") {
              morphChildren2(ctx2, oldNode, newNode);
              return Array.from(oldNode.childNodes);
            } else {
              return morphOuterHTML(ctx2, oldNode, newNode);
            }
          }
        );
      });
      ctx.pantry.remove();
      return morphedNodes;
    }
    function morphOuterHTML(ctx, oldNode, newNode) {
      const oldParent = normalizeParent(oldNode);
      let childNodes = Array.from(oldParent.childNodes);
      const index = childNodes.indexOf(oldNode);
      const rightMargin = childNodes.length - (index + 1);
      morphChildren2(
        ctx,
        oldParent,
        newNode,
        // these two optional params are the secret sauce
        oldNode,
        // start point for iteration
        oldNode.nextSibling
        // end point for iteration
      );
      childNodes = Array.from(oldParent.childNodes);
      return childNodes.slice(index, childNodes.length - rightMargin);
    }
    function saveAndRestoreFocus(ctx, fn2) {
      var _a2;
      if (!ctx.config.restoreFocus) return fn2();
      let activeElement = (
        /** @type {HTMLInputElement|HTMLTextAreaElement|null} */
        document.activeElement
      );
      if (!(activeElement instanceof HTMLInputElement || activeElement instanceof HTMLTextAreaElement)) {
        return fn2();
      }
      const { id: activeElementId, selectionStart, selectionEnd } = activeElement;
      const results = fn2();
      if (activeElementId && activeElementId !== ((_a2 = document.activeElement) == null ? void 0 : _a2.id)) {
        activeElement = ctx.target.querySelector(`#${activeElementId}`);
        activeElement == null ? void 0 : activeElement.focus();
      }
      if (activeElement && !activeElement.selectionEnd && selectionEnd) {
        activeElement.setSelectionRange(selectionStart, selectionEnd);
      }
      return results;
    }
    const morphChildren2 = /* @__PURE__ */ function() {
      function morphChildren3(ctx, oldParent, newParent, insertionPoint = null, endPoint = null) {
        if (oldParent instanceof HTMLTemplateElement && newParent instanceof HTMLTemplateElement) {
          oldParent = oldParent.content;
          newParent = newParent.content;
        }
        insertionPoint || (insertionPoint = oldParent.firstChild);
        for (const newChild of newParent.childNodes) {
          if (insertionPoint && insertionPoint != endPoint) {
            const bestMatch = findBestMatch(
              ctx,
              newChild,
              insertionPoint,
              endPoint
            );
            if (bestMatch) {
              if (bestMatch !== insertionPoint) {
                removeNodesBetween(ctx, insertionPoint, bestMatch);
              }
              morphNode(bestMatch, newChild, ctx);
              insertionPoint = bestMatch.nextSibling;
              continue;
            }
          }
          if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {
            const movedChild = moveBeforeById(
              oldParent,
              newChild.id,
              insertionPoint,
              ctx
            );
            morphNode(movedChild, newChild, ctx);
            insertionPoint = movedChild.nextSibling;
            continue;
          }
          const insertedNode = createNode(
            oldParent,
            newChild,
            insertionPoint,
            ctx
          );
          if (insertedNode) {
            insertionPoint = insertedNode.nextSibling;
          }
        }
        while (insertionPoint && insertionPoint != endPoint) {
          const tempNode = insertionPoint;
          insertionPoint = insertionPoint.nextSibling;
          removeNode(ctx, tempNode);
        }
      }
      function createNode(oldParent, newChild, insertionPoint, ctx) {
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;
        if (ctx.idMap.has(newChild)) {
          const newEmptyChild = document.createElement(
            /** @type {Element} */
            newChild.tagName
          );
          oldParent.insertBefore(newEmptyChild, insertionPoint);
          morphNode(newEmptyChild, newChild, ctx);
          ctx.callbacks.afterNodeAdded(newEmptyChild);
          return newEmptyChild;
        } else {
          const newClonedChild = document.importNode(newChild, true);
          oldParent.insertBefore(newClonedChild, insertionPoint);
          ctx.callbacks.afterNodeAdded(newClonedChild);
          return newClonedChild;
        }
      }
      const findBestMatch = /* @__PURE__ */ function() {
        function findBestMatch2(ctx, node, startPoint, endPoint) {
          let softMatch = null;
          let nextSibling = node.nextSibling;
          let siblingSoftMatchCount = 0;
          let cursor = startPoint;
          while (cursor && cursor != endPoint) {
            if (isSoftMatch(cursor, node)) {
              if (isIdSetMatch(ctx, cursor, node)) {
                return cursor;
              }
              if (softMatch === null) {
                if (!ctx.idMap.has(cursor)) {
                  softMatch = cursor;
                }
              }
            }
            if (softMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {
              siblingSoftMatchCount++;
              nextSibling = nextSibling.nextSibling;
              if (siblingSoftMatchCount >= 2) {
                softMatch = void 0;
              }
            }
            if (cursor.contains(document.activeElement)) break;
            cursor = cursor.nextSibling;
          }
          return softMatch || null;
        }
        function isIdSetMatch(ctx, oldNode, newNode) {
          let oldSet = ctx.idMap.get(oldNode);
          let newSet = ctx.idMap.get(newNode);
          if (!newSet || !oldSet) return false;
          for (const id of oldSet) {
            if (newSet.has(id)) {
              return true;
            }
          }
          return false;
        }
        function isSoftMatch(oldNode, newNode) {
          const oldElt = (
            /** @type {Element} */
            oldNode
          );
          const newElt = (
            /** @type {Element} */
            newNode
          );
          return oldElt.nodeType === newElt.nodeType && oldElt.tagName === newElt.tagName && // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.
          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,
          // its not persistent, and new nodes can't have any hidden state.
          (!oldElt.id || oldElt.id === newElt.id);
        }
        return findBestMatch2;
      }();
      function removeNode(ctx, node) {
        var _a2;
        if (ctx.idMap.has(node)) {
          moveBefore(ctx.pantry, node, null);
        } else {
          if (ctx.callbacks.beforeNodeRemoved(node) === false) return;
          (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
          ctx.callbacks.afterNodeRemoved(node);
        }
      }
      function removeNodesBetween(ctx, startInclusive, endExclusive) {
        let cursor = startInclusive;
        while (cursor && cursor !== endExclusive) {
          let tempNode = (
            /** @type {Node} */
            cursor
          );
          cursor = cursor.nextSibling;
          removeNode(ctx, tempNode);
        }
        return cursor;
      }
      function moveBeforeById(parentNode2, id, after, ctx) {
        const target = (
          /** @type {Element} - will always be found */
          ctx.target.querySelector(`#${id}`) || ctx.pantry.querySelector(`#${id}`)
        );
        removeElementFromAncestorsIdMaps(target, ctx);
        moveBefore(parentNode2, target, after);
        return target;
      }
      function removeElementFromAncestorsIdMaps(element, ctx) {
        const id = element.id;
        while (element = element.parentNode) {
          let idSet = ctx.idMap.get(element);
          if (idSet) {
            idSet.delete(id);
            if (!idSet.size) {
              ctx.idMap.delete(element);
            }
          }
        }
      }
      function moveBefore(parentNode2, element, after) {
        if (parentNode2.moveBefore) {
          try {
            parentNode2.moveBefore(element, after);
          } catch (e) {
            parentNode2.insertBefore(element, after);
          }
        } else {
          parentNode2.insertBefore(element, after);
        }
      }
      return morphChildren3;
    }();
    const morphNode = /* @__PURE__ */ function() {
      function morphNode2(oldNode, newContent, ctx) {
        if (ctx.ignoreActive && oldNode === document.activeElement) {
          return null;
        }
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {
          return oldNode;
        }
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(
            oldNode,
            /** @type {HTMLHeadElement} */
            newContent,
            ctx
          );
        } else {
          morphAttributes(oldNode, newContent, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren2(ctx, oldNode, newContent);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
      function morphAttributes(oldNode, newNode, ctx) {
        let type = newNode.nodeType;
        if (type === 1) {
          const oldElt = (
            /** @type {Element} */
            oldNode
          );
          const newElt = (
            /** @type {Element} */
            newNode
          );
          const oldAttributes = oldElt.attributes;
          const newAttributes = newElt.attributes;
          for (const newAttribute of newAttributes) {
            if (ignoreAttribute(newAttribute.name, oldElt, "update", ctx)) {
              continue;
            }
            if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {
              oldElt.setAttribute(newAttribute.name, newAttribute.value);
            }
          }
          for (let i = oldAttributes.length - 1; 0 <= i; i--) {
            const oldAttribute = oldAttributes[i];
            if (!oldAttribute) continue;
            if (!newElt.hasAttribute(oldAttribute.name)) {
              if (ignoreAttribute(oldAttribute.name, oldElt, "remove", ctx)) {
                continue;
              }
              oldElt.removeAttribute(oldAttribute.name);
            }
          }
          if (!ignoreValueOfActiveElement(oldElt, ctx)) {
            syncInputValue(oldElt, newElt, ctx);
          }
        }
        if (type === 8 || type === 3) {
          if (oldNode.nodeValue !== newNode.nodeValue) {
            oldNode.nodeValue = newNode.nodeValue;
          }
        }
      }
      function syncInputValue(oldElement, newElement, ctx) {
        if (oldElement instanceof HTMLInputElement && newElement instanceof HTMLInputElement && newElement.type !== "file") {
          let newValue = newElement.value;
          let oldValue = oldElement.value;
          syncBooleanAttribute(oldElement, newElement, "checked", ctx);
          syncBooleanAttribute(oldElement, newElement, "disabled", ctx);
          if (!newElement.hasAttribute("value")) {
            if (!ignoreAttribute("value", oldElement, "remove", ctx)) {
              oldElement.value = "";
              oldElement.removeAttribute("value");
            }
          } else if (oldValue !== newValue) {
            if (!ignoreAttribute("value", oldElement, "update", ctx)) {
              oldElement.setAttribute("value", newValue);
              oldElement.value = newValue;
            }
          }
        } else if (oldElement instanceof HTMLOptionElement && newElement instanceof HTMLOptionElement) {
          syncBooleanAttribute(oldElement, newElement, "selected", ctx);
        } else if (oldElement instanceof HTMLTextAreaElement && newElement instanceof HTMLTextAreaElement) {
          let newValue = newElement.value;
          let oldValue = oldElement.value;
          if (ignoreAttribute("value", oldElement, "update", ctx)) {
            return;
          }
          if (newValue !== oldValue) {
            oldElement.value = newValue;
          }
          if (oldElement.firstChild && oldElement.firstChild.nodeValue !== newValue) {
            oldElement.firstChild.nodeValue = newValue;
          }
        }
      }
      function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {
        const newLiveValue = newElement[attributeName], oldLiveValue = oldElement[attributeName];
        if (newLiveValue !== oldLiveValue) {
          const ignoreUpdate = ignoreAttribute(
            attributeName,
            oldElement,
            "update",
            ctx
          );
          if (!ignoreUpdate) {
            oldElement[attributeName] = newElement[attributeName];
          }
          if (newLiveValue) {
            if (!ignoreUpdate) {
              oldElement.setAttribute(attributeName, "");
            }
          } else {
            if (!ignoreAttribute(attributeName, oldElement, "remove", ctx)) {
              oldElement.removeAttribute(attributeName);
            }
          }
        }
      }
      function ignoreAttribute(attr, element, updateType, ctx) {
        if (attr === "value" && ctx.ignoreActiveValue && element === document.activeElement) {
          return true;
        }
        return ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) === false;
      }
      function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
        return !!ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
      }
      return morphNode2;
    }();
    function withHeadBlocking(ctx, oldNode, newNode, callback) {
      if (ctx.head.block) {
        const oldHead = oldNode.querySelector("head");
        const newHead = newNode.querySelector("head");
        if (oldHead && newHead) {
          const promises = handleHeadElement(oldHead, newHead, ctx);
          return Promise.all(promises).then(() => {
            const newCtx = Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            });
            return callback(newCtx);
          });
        }
      }
      return callback(ctx);
    }
    function handleHeadElement(oldHead, newHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHead.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of oldHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (ctx.head.style === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = (
          /** @type {ChildNode} */
          document.createRange().createContextualFragment(newNode.outerHTML).firstChild
        );
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if ("href" in newElt && newElt.href || "src" in newElt && newElt.src) {
            let resolve;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          oldHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          oldHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(oldHead, {
        added,
        kept: preserved,
        removed
      });
      return promises;
    }
    const createMorphContext = /* @__PURE__ */ function() {
      function createMorphContext2(oldNode, newContent, config2) {
        const { persistentIds, idMap } = createIdMaps(oldNode, newContent);
        const mergedConfig = mergeDefaults(config2);
        const morphStyle = mergedConfig.morphStyle || "outerHTML";
        if (!["innerHTML", "outerHTML"].includes(morphStyle)) {
          throw `Do not understand how to morph style ${morphStyle}`;
        }
        return {
          target: oldNode,
          newContent,
          config: mergedConfig,
          morphStyle,
          ignoreActive: mergedConfig.ignoreActive,
          ignoreActiveValue: mergedConfig.ignoreActiveValue,
          restoreFocus: mergedConfig.restoreFocus,
          idMap,
          persistentIds,
          pantry: createPantry(),
          callbacks: mergedConfig.callbacks,
          head: mergedConfig.head
        };
      }
      function mergeDefaults(config2) {
        let finalConfig = Object.assign({}, defaults);
        Object.assign(finalConfig, config2);
        finalConfig.callbacks = Object.assign(
          {},
          defaults.callbacks,
          config2.callbacks
        );
        finalConfig.head = Object.assign({}, defaults.head, config2.head);
        return finalConfig;
      }
      function createPantry() {
        const pantry = document.createElement("div");
        pantry.hidden = true;
        document.body.insertAdjacentElement("afterend", pantry);
        return pantry;
      }
      function findIdElements(root) {
        let elements = Array.from(root.querySelectorAll("[id]"));
        if (root.id) {
          elements.push(root);
        }
        return elements;
      }
      function populateIdMapWithTree(idMap, persistentIds, root, elements) {
        for (const elt of elements) {
          if (persistentIds.has(elt.id)) {
            let current = elt;
            while (current) {
              let idSet = idMap.get(current);
              if (idSet == null) {
                idSet = /* @__PURE__ */ new Set();
                idMap.set(current, idSet);
              }
              idSet.add(elt.id);
              if (current === root) break;
              current = current.parentElement;
            }
          }
        }
      }
      function createIdMaps(oldContent, newContent) {
        const oldIdElements = findIdElements(oldContent);
        const newIdElements = findIdElements(newContent);
        const persistentIds = createPersistentIds(oldIdElements, newIdElements);
        let idMap = /* @__PURE__ */ new Map();
        populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);
        const newRoot = newContent.__idiomorphRoot || newContent;
        populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);
        return { persistentIds, idMap };
      }
      function createPersistentIds(oldIdElements, newIdElements) {
        let duplicateIds = /* @__PURE__ */ new Set();
        let oldIdTagNameMap = /* @__PURE__ */ new Map();
        for (const { id, tagName } of oldIdElements) {
          if (oldIdTagNameMap.has(id)) {
            duplicateIds.add(id);
          } else {
            oldIdTagNameMap.set(id, tagName);
          }
        }
        let persistentIds = /* @__PURE__ */ new Set();
        for (const { id, tagName } of newIdElements) {
          if (persistentIds.has(id)) {
            duplicateIds.add(id);
          } else if (oldIdTagNameMap.get(id) === tagName) {
            persistentIds.add(id);
          }
        }
        for (const id of duplicateIds) {
          persistentIds.delete(id);
        }
        return persistentIds;
      }
      return createMorphContext2;
    }();
    const { normalizeElement, normalizeParent } = /* @__PURE__ */ function() {
      const generatedByIdiomorph = /* @__PURE__ */ new WeakSet();
      function normalizeElement2(content) {
        if (content instanceof Document) {
          return content.documentElement;
        } else {
          return content;
        }
      }
      function normalizeParent2(newContent) {
        if (newContent == null) {
          return document.createElement("div");
        } else if (typeof newContent === "string") {
          return normalizeParent2(parseContent(newContent));
        } else if (generatedByIdiomorph.has(
          /** @type {Element} */
          newContent
        )) {
          return (
            /** @type {Element} */
            newContent
          );
        } else if (newContent instanceof Node) {
          if (newContent.parentNode) {
            return createDuckTypedParent(newContent);
          } else {
            const dummyParent = document.createElement("div");
            dummyParent.append(newContent);
            return dummyParent;
          }
        } else {
          const dummyParent = document.createElement("div");
          for (const elt of [...newContent]) {
            dummyParent.append(elt);
          }
          return dummyParent;
        }
      }
      function createDuckTypedParent(newContent) {
        return (
          /** @type {Element} */
          /** @type {unknown} */
          {
            childNodes: [newContent],
            /** @ts-ignore - cover your eyes for a minute, tsc */
            querySelectorAll: (s) => {
              const elements = newContent.querySelectorAll(s);
              return newContent.matches(s) ? [newContent, ...elements] : elements;
            },
            /** @ts-ignore */
            insertBefore: (n, r) => newContent.parentNode.insertBefore(n, r),
            /** @ts-ignore */
            moveBefore: (n, r) => newContent.parentNode.moveBefore(n, r),
            // for later use with populateIdMapWithTree to halt upwards iteration
            get __idiomorphRoot() {
              return newContent;
            }
          }
        );
      }
      function parseContent(newContent) {
        let parser = new DOMParser();
        let contentWithSvgsRemoved = newContent.replace(
          /<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim,
          ""
        );
        if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
          let content = parser.parseFromString(newContent, "text/html");
          if (contentWithSvgsRemoved.match(/<\/html>/)) {
            generatedByIdiomorph.add(content);
            return content;
          } else {
            let htmlElement = content.firstChild;
            if (htmlElement) {
              generatedByIdiomorph.add(htmlElement);
            }
            return htmlElement;
          }
        } else {
          let responseDoc = parser.parseFromString(
            "<body><template>" + newContent + "</template></body>",
            "text/html"
          );
          let content = (
            /** @type {HTMLTemplateElement} */
            responseDoc.body.querySelector("template").content
          );
          generatedByIdiomorph.add(content);
          return content;
        }
      }
      return { normalizeElement: normalizeElement2, normalizeParent: normalizeParent2 };
    }();
    return {
      morph,
      defaults
    };
  }();
  function morphElements(currentElement, newElement, _a2 = {}) {
    var _b = _a2, { callbacks } = _b, options = __objRest(_b, ["callbacks"]);
    Idiomorph.morph(currentElement, newElement, __spreadProps(__spreadValues({}, options), {
      callbacks: new DefaultIdiomorphCallbacks(callbacks)
    }));
  }
  function morphChildren(currentElement, newElement) {
    morphElements(currentElement, newElement.childNodes, {
      morphStyle: "innerHTML"
    });
  }
  var _beforeNodeMorphed;
  var DefaultIdiomorphCallbacks = class {
    constructor({ beforeNodeMorphed } = {}) {
      __privateAdd(this, _beforeNodeMorphed);
      __publicField(this, "beforeNodeAdded", (node) => {
        return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
      });
      __publicField(this, "beforeNodeMorphed", (currentElement, newElement) => {
        if (currentElement instanceof Element) {
          if (!currentElement.hasAttribute("data-turbo-permanent") && __privateGet(this, _beforeNodeMorphed).call(this, currentElement, newElement)) {
            const event = dispatch("turbo:before-morph-element", {
              cancelable: true,
              target: currentElement,
              detail: { currentElement, newElement }
            });
            return !event.defaultPrevented;
          } else {
            return false;
          }
        }
      });
      __publicField(this, "beforeAttributeUpdated", (attributeName, target, mutationType) => {
        const event = dispatch("turbo:before-morph-attribute", {
          cancelable: true,
          target,
          detail: { attributeName, mutationType }
        });
        return !event.defaultPrevented;
      });
      __publicField(this, "beforeNodeRemoved", (node) => {
        return this.beforeNodeMorphed(node);
      });
      __publicField(this, "afterNodeMorphed", (currentElement, newElement) => {
        if (currentElement instanceof Element) {
          dispatch("turbo:morph-element", {
            target: currentElement,
            detail: { currentElement, newElement }
          });
        }
      });
      __privateSet(this, _beforeNodeMorphed, beforeNodeMorphed || (() => true));
    }
  };
  _beforeNodeMorphed = new WeakMap();
  var MorphingFrameRenderer = class extends FrameRenderer {
    static renderElement(currentElement, newElement) {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      morphChildren(currentElement, newElement);
    }
    preservingPermanentElements(callback) {
      return __async(this, null, function* () {
        return yield callback();
      });
    }
  };
  var _ProgressBar = class _ProgressBar {
    constructor() {
      __publicField(this, "hiding", false);
      __publicField(this, "value", 0);
      __publicField(this, "visible", false);
      __publicField(this, "trickle", () => {
        this.setValue(this.value + Math.random() / 100);
      });
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      const cspNonce = getCspNonce();
      if (cspNonce) {
        element.nonce = cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  __publicField(_ProgressBar, "animationDuration", 300);
  var ProgressBar = _ProgressBar;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      __publicField(this, "detailsByOuterHTML", this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return __spreadProps(__spreadValues({}, result), {
          [outerHTML]: __spreadProps(__spreadValues({}, details), {
            elements: [...details.elements, element]
          })
        });
      }, {}));
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions) option.selected = false;
        for (const option of source.selectedOptions) clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a2;
      const root = (_a2 = this.getSetting("root")) != null ? _a2 : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var _viewTransitionStarted, _lastOperation;
  var ViewTransitioner = class {
    constructor() {
      __privateAdd(this, _viewTransitionStarted, false);
      __privateAdd(this, _lastOperation, Promise.resolve());
    }
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !__privateGet(this, _viewTransitionStarted)) {
        __privateSet(this, _viewTransitionStarted, true);
        __privateSet(this, _lastOperation, __privateGet(this, _lastOperation).then(() => __async(this, null, function* () {
          yield document.startViewTransition(render2).finished;
        })));
      } else {
        __privateSet(this, _lastOperation, __privateGet(this, _lastOperation).then(render2));
      }
      return __privateGet(this, _lastOperation);
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  _viewTransitionStarted = new WeakMap();
  _lastOperation = new WeakMap();
  var defaultOptions2 = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      __publicField(this, "identifier", uuid());
      // Required by turbo-ios
      __publicField(this, "timingMetrics", {});
      __publicField(this, "followedRedirect", false);
      __publicField(this, "historyChanged", false);
      __publicField(this, "scrolled", false);
      __publicField(this, "shouldCacheSnapshot", true);
      __publicField(this, "acceptsStreamResponse", false);
      __publicField(this, "snapshotCached", false);
      __publicField(this, "state", VisitState.initialized);
      __publicField(this, "viewTransitioner", new ViewTransitioner());
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = __spreadValues(__spreadValues({}, defaultOptions2), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      var _a2;
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === ((_a2 = this.referrer) == null ? void 0 : _a2.href) ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(() => __async(this, null, function* () {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) yield this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            yield this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            yield this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        }));
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(() => __async(this, null, function* () {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) yield this.view.renderPromise;
            yield this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        }));
      }
    }
    followRedirect() {
      var _a2;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a2 = this.response) == null ? void 0 : _a2.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(() => __async(this, null, function* () {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        }));
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    requestSucceededWithResponse(request, response) {
      return __async(this, null, function* () {
        const responseHTML = yield response.responseHTML;
        const { redirected, statusCode } = response;
        if (responseHTML == void 0) {
          this.recordResponse({
            statusCode: SystemStatusCode.contentTypeMismatch,
            redirected
          });
        } else {
          this.redirectedToLocation = response.redirected ? response.location : void 0;
          this.recordResponse({ statusCode, responseHTML, redirected });
        }
      });
    }
    requestFailedWithResponse(request, response) {
      return __async(this, null, function* () {
        const responseHTML = yield response.responseHTML;
        const { redirected, statusCode } = response;
        if (responseHTML == void 0) {
          this.recordResponse({
            statusCode: SystemStatusCode.contentTypeMismatch,
            redirected
          });
        } else {
          this.recordResponse({ statusCode, responseHTML, redirected });
        }
      });
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return __spreadValues({}, this.timingMetrics);
    }
    // Private
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    render(callback) {
      return __async(this, null, function* () {
        this.cancelRender();
        yield new Promise((resolve) => {
          this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
        });
        yield callback();
        delete this.frame;
      });
    }
    renderPageSnapshot(snapshot, isPreview) {
      return __async(this, null, function* () {
        yield this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), () => __async(this, null, function* () {
          yield this.view.renderPage(snapshot, isPreview, this.willRender, this);
          this.performScroll();
        }));
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      __publicField(this, "progressBar", new ProgressBar());
      __publicField(this, "showProgressBar", () => {
        this.progressBar.show();
      });
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, (options == null ? void 0 : options.restorationIdentifier) || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Link prefetching
    linkPrefetchingIsEnabledForLocation(location2) {
      return true;
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload(reason) {
      var _a2;
      dispatch("turbo:reload", { detail: reason });
      window.location.href = ((_a2 = this.location) == null ? void 0 : _a2.toString()) || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      __publicField(this, "selector", "[data-turbo-temporary]");
      __publicField(this, "deprecatedSelector", "[data-turbo-cache=false]");
      __publicField(this, "started", false);
      __publicField(this, "removeTemporaryElements", (_event) => {
        for (const element of this.temporaryElements) {
          element.remove();
        }
      });
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var _FrameRedirector_instances, shouldSubmit_fn, shouldRedirect_fn, findFrameElement_fn;
  var FrameRedirector = class {
    constructor(session2, element) {
      __privateAdd(this, _FrameRedirector_instances);
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == null && __privateMethod(this, _FrameRedirector_instances, shouldSubmit_fn).call(this, element, submitter2) && __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, element, submitter2);
    }
    formSubmitted(element, submitter2) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element, submitter2);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter2);
      }
    }
  };
  _FrameRedirector_instances = new WeakSet();
  shouldSubmit_fn = function(form, submitter2) {
    var _a2;
    const action = getAction$1(form, submitter2);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL((_a2 = meta == null ? void 0 : meta.content) != null ? _a2 : "/");
    return __privateMethod(this, _FrameRedirector_instances, shouldRedirect_fn).call(this, form, submitter2) && locationIsVisitable(action, rootLocation);
  };
  shouldRedirect_fn = function(element, submitter2) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = __privateMethod(this, _FrameRedirector_instances, findFrameElement_fn).call(this, element, submitter2);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  };
  findFrameElement_fn = function(element, submitter2) {
    const id = (submitter2 == null ? void 0 : submitter2.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  };
  var History2 = class {
    constructor(delegate) {
      __publicField(this, "location");
      __publicField(this, "restorationIdentifier", uuid());
      __publicField(this, "restorationData", {});
      __publicField(this, "started", false);
      __publicField(this, "pageLoaded", false);
      __publicField(this, "currentIndex", 0);
      // Event handlers
      __publicField(this, "onPopState", (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier, restorationIndex } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            const direction = restorationIndex > this.currentIndex ? "forward" : "back";
            this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
            this.currentIndex = restorationIndex;
          }
        }
      });
      __publicField(this, "onPageLoad", (_event) => __async(this, null, function* () {
        yield nextMicrotask();
        this.pageLoaded = true;
      }));
      this.delegate = delegate;
    }
    start() {
      var _a2, _b;
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = ((_b = (_a2 = history.state) == null ? void 0 : _a2.turbo) == null ? void 0 : _b.restorationIndex) || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = __spreadValues(__spreadValues({}, restorationData), additionalData);
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      var _a2;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a2 = history.scrollRestoration) != null ? _a2 : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var _prefetchedLink, _enable, _tryToPrefetchRequest, _cancelRequestIfObsolete, _cancelPrefetchRequest, _tryToUsePrefetchedRequest, _LinkPrefetchObserver_instances, cacheTtl_get, isPrefetchable_fn;
  var LinkPrefetchObserver = class {
    constructor(delegate, eventTarget) {
      __privateAdd(this, _LinkPrefetchObserver_instances);
      __publicField(this, "started", false);
      __privateAdd(this, _prefetchedLink, null);
      __privateAdd(this, _enable, () => {
        this.eventTarget.addEventListener("mouseenter", __privateGet(this, _tryToPrefetchRequest), {
          capture: true,
          passive: true
        });
        this.eventTarget.addEventListener("mouseleave", __privateGet(this, _cancelRequestIfObsolete), {
          capture: true,
          passive: true
        });
        this.eventTarget.addEventListener("turbo:before-fetch-request", __privateGet(this, _tryToUsePrefetchedRequest), true);
        this.started = true;
      });
      __privateAdd(this, _tryToPrefetchRequest, (event) => {
        if (getMetaContent("turbo-prefetch") === "false") return;
        const target = event.target;
        const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
        if (isLink && __privateMethod(this, _LinkPrefetchObserver_instances, isPrefetchable_fn).call(this, target)) {
          const link = target;
          const location2 = getLocationForLink(link);
          if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
            __privateSet(this, _prefetchedLink, link);
            const fetchRequest = new FetchRequest(
              this,
              FetchMethod.get,
              location2,
              new URLSearchParams(),
              target
            );
            prefetchCache.setLater(location2.toString(), fetchRequest, __privateGet(this, _LinkPrefetchObserver_instances, cacheTtl_get));
          }
        }
      });
      __privateAdd(this, _cancelRequestIfObsolete, (event) => {
        if (event.target === __privateGet(this, _prefetchedLink)) __privateGet(this, _cancelPrefetchRequest).call(this);
      });
      __privateAdd(this, _cancelPrefetchRequest, () => {
        prefetchCache.clear();
        __privateSet(this, _prefetchedLink, null);
      });
      __privateAdd(this, _tryToUsePrefetchedRequest, (event) => {
        if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
          const cached = prefetchCache.get(event.detail.url.toString());
          if (cached) {
            event.detail.fetchRequest = cached;
          }
          prefetchCache.clear();
        }
      });
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", __privateGet(this, _enable), { once: true });
      } else {
        __privateGet(this, _enable).call(this);
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", __privateGet(this, _tryToPrefetchRequest), {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", __privateGet(this, _cancelRequestIfObsolete), {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", __privateGet(this, _tryToUsePrefetchedRequest), true);
      this.started = false;
    }
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || (turboFrame == null ? void 0 : turboFrame.getAttribute("target")) || (turboFrame == null ? void 0 : turboFrame.id);
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
  };
  _prefetchedLink = new WeakMap();
  _enable = new WeakMap();
  _tryToPrefetchRequest = new WeakMap();
  _cancelRequestIfObsolete = new WeakMap();
  _cancelPrefetchRequest = new WeakMap();
  _tryToUsePrefetchedRequest = new WeakMap();
  _LinkPrefetchObserver_instances = new WeakSet();
  cacheTtl_get = function() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  };
  isPrefetchable_fn = function(link) {
    const href = link.getAttribute("href");
    if (!href) return false;
    if (unfetchableLink(link)) return false;
    if (linkToTheSamePage(link)) return false;
    if (linkOptsOut(link)) return false;
    if (nonSafeLink(link)) return false;
    if (eventPrevented(link)) return false;
    return true;
  };
  var unfetchableLink = (link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  };
  var linkToTheSamePage = (link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  };
  var linkOptsOut = (link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link)) return true;
    if (link.hasAttribute("data-turbo-confirm")) return true;
    if (link.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  };
  var eventPrevented = (link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  };
  var _Navigator_instances, getActionForFormSubmission_fn, getDefaultAction_fn;
  var Navigator = class {
    constructor(delegate) {
      __privateAdd(this, _Navigator_instances);
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, __spreadValues({
        referrer: this.location
      }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter2) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter2, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      return __async(this, null, function* () {
        if (formSubmission == this.formSubmission) {
          const responseHTML = yield fetchResponse.responseHTML;
          if (responseHTML) {
            const shouldCacheSnapshot = formSubmission.isSafe;
            if (!shouldCacheSnapshot) {
              this.view.clearSnapshotCache();
            }
            const { statusCode, redirected } = fetchResponse;
            const action = __privateMethod(this, _Navigator_instances, getActionForFormSubmission_fn).call(this, formSubmission, fetchResponse);
            const visitOptions = {
              action,
              shouldCacheSnapshot,
              response: { statusCode, responseHTML, redirected }
            };
            this.proposeVisit(fetchResponse.location, visitOptions);
          }
        }
      });
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      return __async(this, null, function* () {
        const responseHTML = yield fetchResponse.responseHTML;
        if (responseHTML) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          if (fetchResponse.serverError) {
            yield this.view.renderError(snapshot, this.currentVisit);
          } else {
            yield this.view.renderPage(snapshot, false, true, this.currentVisit);
          }
          if (!snapshot.shouldPreserveScrollPosition) {
            this.view.scrollToTop();
          }
          this.view.clearSnapshotCache();
        }
      });
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Link prefetching
    linkPrefetchingIsEnabledForLocation(location2) {
      if (typeof this.adapter.linkPrefetchingIsEnabledForLocation === "function") {
        return this.adapter.linkPrefetchingIsEnabledForLocation(location2);
      }
      return true;
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
      delete this.currentVisit;
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
  };
  _Navigator_instances = new WeakSet();
  getActionForFormSubmission_fn = function(formSubmission, fetchResponse) {
    const { submitter: submitter2, formElement } = formSubmission;
    return getVisitAction(submitter2, formElement) || __privateMethod(this, _Navigator_instances, getDefaultAction_fn).call(this, fetchResponse);
  };
  getDefaultAction_fn = function(fetchResponse) {
    var _a2;
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === ((_a2 = this.location) == null ? void 0 : _a2.href);
    return sameLocationRedirect ? "replace" : "advance";
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    constructor(delegate) {
      __publicField(this, "stage", PageStage.initial);
      __publicField(this, "started", false);
      __publicField(this, "interpretReadyState", () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      });
      __publicField(this, "pageWillUnload", () => {
        this.delegate.pageWillUnload();
      });
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      __publicField(this, "started", false);
      __publicField(this, "onScroll", () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      });
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  function withAutofocusFromFragment(fragment, callback) {
    return __async(this, null, function* () {
      const generatedID = `turbo-stream-autofocus-${uuid()}`;
      const turboStreams = fragment.querySelectorAll("turbo-stream");
      const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
      let willAutofocusId = null;
      if (elementWithAutofocus) {
        if (elementWithAutofocus.id) {
          willAutofocusId = elementWithAutofocus.id;
        } else {
          willAutofocusId = generatedID;
        }
        elementWithAutofocus.id = willAutofocusId;
      }
      callback();
      yield nextRepaint();
      const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
      if (hasNoActiveElement && willAutofocusId) {
        const elementToAutofocus = document.getElementById(willAutofocusId);
        if (elementIsFocusable(elementToAutofocus)) {
          elementToAutofocus.focus();
        }
        if (elementToAutofocus && elementToAutofocus.id == generatedID) {
          elementToAutofocus.removeAttribute("id");
        }
      }
    });
  }
  function withPreservedFocus(callback) {
    return __async(this, null, function* () {
      const [activeElementBeforeRender, activeElementAfterRender] = yield around(callback, () => document.activeElement);
      const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
      if (restoreFocusTo) {
        const elementToFocus = document.getElementById(restoreFocusTo);
        if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
          elementToFocus.focus();
        }
      }
    });
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var _started;
  var StreamObserver = class {
    constructor(delegate) {
      __publicField(this, "sources", /* @__PURE__ */ new Set());
      __privateAdd(this, _started, false);
      __publicField(this, "inspectFetchResponse", (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      });
      __publicField(this, "receiveMessageEvent", (event) => {
        if (__privateGet(this, _started) && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      });
      this.delegate = delegate;
    }
    start() {
      if (!__privateGet(this, _started)) {
        __privateSet(this, _started, true);
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (__privateGet(this, _started)) {
        __privateSet(this, _started, false);
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    receiveMessageResponse(response) {
      return __async(this, null, function* () {
        const html = yield response.responseHTML;
        if (html) {
          this.receiveMessageHTML(html);
        }
      });
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  _started = new WeakMap();
  function fetchResponseFromEvent(event) {
    var _a2;
    const fetchResponse = (_a2 = event.detail) == null ? void 0 : _a2.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a2;
    const contentType = (_a2 = response.contentType) != null ? _a2 : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    render() {
      return __async(this, null, function* () {
        this.replaceHeadAndBody();
        this.activateScriptElements();
      });
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode2 = replaceableElement.parentNode;
        if (parentNode2) {
          const element = activateScriptElement(replaceableElement);
          parentNode2.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var _PageRenderer_instances, setLanguage_fn;
  var PageRenderer = class extends Renderer {
    constructor() {
      super(...arguments);
      __privateAdd(this, _PageRenderer_instances);
    }
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    prepareToRender() {
      return __async(this, null, function* () {
        __privateMethod(this, _PageRenderer_instances, setLanguage_fn).call(this);
        yield this.mergeHead();
      });
    }
    render() {
      return __async(this, null, function* () {
        if (this.willRender) {
          yield this.replaceBody();
        }
      });
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    mergeHead() {
      return __async(this, null, function* () {
        const mergedHeadElements = this.mergeProvisionalElements();
        const newStylesheetElements = this.copyNewHeadStylesheetElements();
        this.copyNewHeadScriptElements();
        yield mergedHeadElements;
        yield newStylesheetElements;
        if (this.willRender) {
          this.removeUnusedDynamicStylesheetElements();
        }
      });
    }
    replaceBody() {
      return __async(this, null, function* () {
        yield this.preservingPermanentElements(() => __async(this, null, function* () {
          this.activateNewBody();
          yield this.assignNewBody();
        }));
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    copyNewHeadStylesheetElements() {
      return __async(this, null, function* () {
        const loadingElements = [];
        for (const element of this.newHeadStylesheetElements) {
          loadingElements.push(waitForLoad(element));
          document.head.appendChild(element);
        }
        yield Promise.all(loadingElements);
      });
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    mergeProvisionalElements() {
      return __async(this, null, function* () {
        const newHeadElements = [...this.newHeadProvisionalElements];
        for (const element of this.currentHeadProvisionalElements) {
          if (!this.isCurrentElementInElementList(element, newHeadElements)) {
            document.head.removeChild(element);
          }
        }
        for (const element of newHeadElements) {
          document.head.appendChild(element);
        }
      });
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    assignNewBody() {
      return __async(this, null, function* () {
        yield this.renderElement(this.currentElement, this.newElement);
      });
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  _PageRenderer_instances = new WeakSet();
  setLanguage_fn = function() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  };
  var MorphingPageRenderer = class extends PageRenderer {
    static renderElement(currentElement, newElement) {
      morphElements(currentElement, newElement, {
        callbacks: {
          beforeNodeMorphed: (element) => !canRefreshFrame(element)
        }
      });
      for (const frame of currentElement.querySelectorAll("turbo-frame")) {
        if (canRefreshFrame(frame)) frame.reload();
      }
      dispatch("turbo:morph", { detail: { currentElement, newElement } });
    }
    preservingPermanentElements(callback) {
      return __async(this, null, function* () {
        return yield callback();
      });
    }
    get renderMethod() {
      return "morph";
    }
    get shouldAutofocus() {
      return false;
    }
  };
  function canRefreshFrame(frame) {
    return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
  }
  var SnapshotCache = class {
    constructor(size) {
      __publicField(this, "keys", []);
      __publicField(this, "snapshots", {});
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1) this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      __publicField(this, "snapshotCache", new SnapshotCache(10));
      __publicField(this, "lastRenderedLocation", new URL(location.href));
      __publicField(this, "forceReloaded", false);
    }
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2 == null ? void 0 : visit2.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2 == null ? void 0 : visit2.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    cacheSnapshot() {
      return __async(this, arguments, function* (snapshot = this.snapshot) {
        if (snapshot.isCacheable) {
          this.delegate.viewWillCacheSnapshot();
          const { lastRenderedLocation: location2 } = this;
          yield nextEventLoopTick();
          const cachedSnapshot = snapshot.clone();
          this.snapshotCache.put(location2, cachedSnapshot);
          return cachedSnapshot;
        }
      });
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var _preloadAll;
  var Preloader = class {
    constructor(delegate, snapshotCache) {
      __publicField(this, "selector", "a[data-turbo-preload]");
      __privateAdd(this, _preloadAll, () => {
        this.preloadOnLoadLinksForView(document.body);
      });
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", __privateGet(this, _preloadAll));
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", __privateGet(this, _preloadAll));
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    preloadURL(link) {
      return __async(this, null, function* () {
        const location2 = new URL(link.href);
        if (this.snapshotCache.has(location2)) {
          return;
        }
        const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
        yield fetchRequest.perform();
      });
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    requestSucceededWithResponse(fetchRequest, fetchResponse) {
      return __async(this, null, function* () {
        try {
          const responseHTML = yield fetchResponse.responseHTML;
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          this.snapshotCache.put(fetchRequest.url, snapshot);
        } catch (_) {
        }
      });
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
  };
  _preloadAll = new WeakMap();
  var _Cache_instances, setCacheControl_fn;
  var Cache = class {
    constructor(session2) {
      __privateAdd(this, _Cache_instances);
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "");
    }
    exemptPageFromCache() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "no-cache");
    }
    exemptPageFromPreview() {
      __privateMethod(this, _Cache_instances, setCacheControl_fn).call(this, "no-preview");
    }
  };
  _Cache_instances = new WeakSet();
  setCacheControl_fn = function(value) {
    setMetaContent("turbo-cache-control", value);
  };
  var _pageRefreshDebouncePeriod;
  var Session = class {
    constructor(recentRequests2) {
      __publicField(this, "navigator", new Navigator(this));
      __publicField(this, "history", new History2(this));
      __publicField(this, "view", new PageView(this, document.documentElement));
      __publicField(this, "adapter", new BrowserAdapter(this));
      __publicField(this, "pageObserver", new PageObserver(this));
      __publicField(this, "cacheObserver", new CacheObserver());
      __publicField(this, "linkPrefetchObserver", new LinkPrefetchObserver(this, document));
      __publicField(this, "linkClickObserver", new LinkClickObserver(this, window));
      __publicField(this, "formSubmitObserver", new FormSubmitObserver(this, document));
      __publicField(this, "scrollObserver", new ScrollObserver(this));
      __publicField(this, "streamObserver", new StreamObserver(this));
      __publicField(this, "formLinkClickObserver", new FormLinkClickObserver(this, document.documentElement));
      __publicField(this, "frameRedirector", new FrameRedirector(this, document.documentElement));
      __publicField(this, "streamMessageRenderer", new StreamMessageRenderer());
      __publicField(this, "cache", new Cache(this));
      __publicField(this, "enabled", true);
      __publicField(this, "started", false);
      __privateAdd(this, _pageRefreshDebouncePeriod, 150);
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      const isCurrentUrl = url === document.baseURI;
      if (!isRecentRequest && !this.navigator.currentVisit && isCurrentUrl) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      console.warn(
        "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
      );
      this.progressBarDelay = delay;
    }
    set progressBarDelay(delay) {
      config.drive.progressBarDelay = delay;
    }
    get progressBarDelay() {
      return config.drive.progressBarDelay;
    }
    set drive(value) {
      config.drive.enabled = value;
    }
    get drive() {
      return config.drive.enabled;
    }
    set formMode(value) {
      config.forms.mode = value;
    }
    get formMode() {
      return config.forms.mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return __privateGet(this, _pageRefreshDebouncePeriod);
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce3(this.debouncedRefresh.bind(this), value);
      __privateSet(this, _pageRefreshDebouncePeriod, value);
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.navigator.linkPrefetchingIsEnabledForLocation(location2);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter2) {
      this.navigator.submitForm(form, submitter2);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      var _a2;
      if (!((_a2 = this.navigator.currentVisit) == null ? void 0 : _a2.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: __spreadValues({ newBody }, options),
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter2) {
      if (config.forms.mode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
        if (config.forms.mode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (config.drive.enabled || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  _pageRefreshDebouncePeriod = new WeakMap();
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start2() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    console.warn(
      "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.drive.progressBarDelay = delay;
  }
  function setConfirmMethod(confirmMethod) {
    console.warn(
      "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.confirm = confirmMethod;
  }
  function setFormMode(mode) {
    console.warn(
      "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.mode = mode;
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    config,
    start: start2,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var _currentFetchRequest, _resolveVisitPromise, _connected, _hasBeenLoaded, _ignoredAttributes, _shouldMorphFrame, _FrameController_instances, loadSourceURL_fn, loadFrameResponse_fn, visit_fn, navigateFrame_fn, handleUnvisitableFrameResponse_fn, willHandleFrameMissingFromResponse_fn, handleFrameMissingFromResponse_fn, throwFrameMissingError_fn, visitResponse_fn, findFrameElement_fn2, formActionIsVisitable_fn, shouldInterceptNavigation_fn, isIgnoringChangesTo_fn, ignoringChangesToAttribute_fn, withCurrentNavigationElement_fn;
  var FrameController = class {
    constructor(element) {
      __privateAdd(this, _FrameController_instances);
      __publicField(this, "fetchResponseLoaded", (_fetchResponse) => Promise.resolve());
      __privateAdd(this, _currentFetchRequest, null);
      __privateAdd(this, _resolveVisitPromise, () => {
      });
      __privateAdd(this, _connected, false);
      __privateAdd(this, _hasBeenLoaded, false);
      __privateAdd(this, _ignoredAttributes, /* @__PURE__ */ new Set());
      __privateAdd(this, _shouldMorphFrame, false);
      __publicField(this, "action", null);
      __publicField(this, "visitCachedSnapshot", ({ element }) => {
        const frame = element.querySelector("#" + this.element.id);
        if (frame && this.previousFrameElement) {
          frame.replaceChildren(...this.previousFrameElement.children);
        }
        delete this.previousFrameElement;
      });
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!__privateGet(this, _connected)) {
        __privateSet(this, _connected, true);
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (__privateGet(this, _connected)) {
        __privateSet(this, _connected, false);
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    sourceURLChanged() {
      if (__privateMethod(this, _FrameController_instances, isIgnoringChangesTo_fn).call(this, "src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || __privateGet(this, _hasBeenLoaded)) {
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    sourceURLReloaded() {
      const { refresh, src } = this.element;
      __privateSet(this, _shouldMorphFrame, src && refresh === "morph");
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
      }
    }
    loadResponse(fetchResponse) {
      return __async(this, null, function* () {
        if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
          this.sourceURL = fetchResponse.response.url;
        }
        try {
          const html = yield fetchResponse.responseHTML;
          if (html) {
            const document2 = parseHTMLDocument(html);
            const pageSnapshot = PageSnapshot.fromDocument(document2);
            if (pageSnapshot.isVisitable) {
              yield __privateMethod(this, _FrameController_instances, loadFrameResponse_fn).call(this, fetchResponse, document2);
            } else {
              yield __privateMethod(this, _FrameController_instances, handleUnvisitableFrameResponse_fn).call(this, fetchResponse);
            }
          }
        } finally {
          __privateSet(this, _shouldMorphFrame, false);
          this.fetchResponseLoaded = () => Promise.resolve();
        }
      });
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      __privateMethod(this, _FrameController_instances, loadSourceURL_fn).call(this);
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, link);
      if (frame) form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, element);
    }
    linkClickIntercepted(element, location2) {
      __privateMethod(this, _FrameController_instances, navigateFrame_fn).call(this, element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == this.element && __privateMethod(this, _FrameController_instances, shouldInterceptNavigation_fn).call(this, element, submitter2);
    }
    formSubmitted(element, submitter2) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter2);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      var _a2;
      request.headers["Turbo-Frame"] = this.id;
      if ((_a2 = this.currentNavigationElement) == null ? void 0 : _a2.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    requestSucceededWithResponse(request, response) {
      return __async(this, null, function* () {
        yield this.loadResponse(response);
        __privateGet(this, _resolveVisitPromise).call(this);
      });
    }
    requestFailedWithResponse(request, response) {
      return __async(this, null, function* () {
        yield this.loadResponse(response);
        __privateGet(this, _resolveVisitPromise).call(this);
      });
    }
    requestErrored(request, error2) {
      console.error(error2);
      __privateGet(this, _resolveVisitPromise).call(this);
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: __spreadValues({ newFrame }, options),
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = (fetchResponse) => __async(this, null, function* () {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = yield fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame.src, options);
          }
        });
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    extractForeignFrameElement(container) {
      return __async(this, null, function* () {
        let element;
        const id = CSS.escape(this.id);
        try {
          element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
          if (element) {
            return element;
          }
          element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
          if (element) {
            yield element.loaded;
            return yield this.extractForeignFrameElement(element);
          }
        } catch (error2) {
          console.error(error2);
          return new FrameElement();
        }
        return null;
      });
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      __privateMethod(this, _FrameController_instances, ignoringChangesToAttribute_fn).call(this, "src", () => {
        this.element.src = sourceURL != null ? sourceURL : null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || __privateGet(this, _resolveVisitPromise).call(this) !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && __privateGet(this, _connected);
    }
    get rootLocation() {
      var _a2;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a2 = meta == null ? void 0 : meta.content) != null ? _a2 : "/";
      return expandURL(root);
    }
  };
  _currentFetchRequest = new WeakMap();
  _resolveVisitPromise = new WeakMap();
  _connected = new WeakMap();
  _hasBeenLoaded = new WeakMap();
  _ignoredAttributes = new WeakMap();
  _shouldMorphFrame = new WeakMap();
  _FrameController_instances = new WeakSet();
  loadSourceURL_fn = function() {
    return __async(this, null, function* () {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = __privateMethod(this, _FrameController_instances, visit_fn).call(this, expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        yield this.element.loaded;
        __privateSet(this, _hasBeenLoaded, true);
      }
    });
  };
  loadFrameResponse_fn = function(fetchResponse, document2) {
    return __async(this, null, function* () {
      const newFrameElement = yield this.extractForeignFrameElement(document2.body);
      const rendererClass = __privateGet(this, _shouldMorphFrame) ? MorphingFrameRenderer : FrameRenderer;
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
        if (this.view.renderPromise) yield this.view.renderPromise;
        this.changeHistory();
        yield this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        yield this.fetchResponseLoaded(fetchResponse);
      } else if (__privateMethod(this, _FrameController_instances, willHandleFrameMissingFromResponse_fn).call(this, fetchResponse)) {
        __privateMethod(this, _FrameController_instances, handleFrameMissingFromResponse_fn).call(this, fetchResponse);
      }
    });
  };
  visit_fn = function(url) {
    return __async(this, null, function* () {
      var _a2;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a2 = __privateGet(this, _currentFetchRequest)) == null ? void 0 : _a2.cancel();
      __privateSet(this, _currentFetchRequest, request);
      return new Promise((resolve) => {
        __privateSet(this, _resolveVisitPromise, () => {
          __privateSet(this, _resolveVisitPromise, () => {
          });
          __privateSet(this, _currentFetchRequest, null);
          resolve();
        });
        request.perform();
      });
    });
  };
  navigateFrame_fn = function(element, url, submitter2) {
    const frame = __privateMethod(this, _FrameController_instances, findFrameElement_fn2).call(this, element, submitter2);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
    __privateMethod(this, _FrameController_instances, withCurrentNavigationElement_fn).call(this, element, () => {
      frame.src = url;
    });
  };
  handleUnvisitableFrameResponse_fn = function(fetchResponse) {
    return __async(this, null, function* () {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      yield __privateMethod(this, _FrameController_instances, visitResponse_fn).call(this, fetchResponse.response);
    });
  };
  willHandleFrameMissingFromResponse_fn = function(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit2 = (url, options) => __async(this, null, function* () {
      if (url instanceof Response) {
        __privateMethod(this, _FrameController_instances, visitResponse_fn).call(this, url);
      } else {
        session.visit(url, options);
      }
    });
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit: visit2 },
      cancelable: true
    });
    return !event.defaultPrevented;
  };
  handleFrameMissingFromResponse_fn = function(fetchResponse) {
    this.view.missing();
    __privateMethod(this, _FrameController_instances, throwFrameMissingError_fn).call(this, fetchResponse);
  };
  throwFrameMissingError_fn = function(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  };
  visitResponse_fn = function(response) {
    return __async(this, null, function* () {
      const wrapped = new FetchResponse(response);
      const responseHTML = yield wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    });
  };
  findFrameElement_fn2 = function(element, submitter2) {
    var _a2;
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    return (_a2 = getFrameElementById(id)) != null ? _a2 : this.element;
  };
  formActionIsVisitable_fn = function(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  };
  shouldInterceptNavigation_fn = function(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !__privateMethod(this, _FrameController_instances, formActionIsVisitable_fn).call(this, element, submitter2)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter2 && !session.elementIsNavigatable(submitter2)) {
      return false;
    }
    return true;
  };
  isIgnoringChangesTo_fn = function(attributeName) {
    return __privateGet(this, _ignoredAttributes).has(attributeName);
  };
  ignoringChangesToAttribute_fn = function(attributeName, callback) {
    __privateGet(this, _ignoredAttributes).add(attributeName);
    callback();
    __privateGet(this, _ignoredAttributes).delete(attributeName);
  };
  withCurrentNavigationElement_fn = function(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => {
        var _a2;
        return (_a2 = e.parentElement) == null ? void 0 : _a2.insertBefore(this.templateContent, e.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => {
        var _a2;
        return (_a2 = e.parentElement) == null ? void 0 : _a2.insertBefore(this.templateContent, e);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphElements(targetElement, this.templateContent);
        } else {
          targetElement.replaceWith(this.templateContent);
        }
      });
    },
    update() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphChildren(targetElement, this.templateContent);
        } else {
          targetElement.innerHTML = "";
          targetElement.append(this.templateContent);
        }
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var _StreamElement_instances, raise_fn;
  var _StreamElement = class _StreamElement extends HTMLElement {
    constructor() {
      super(...arguments);
      __privateAdd(this, _StreamElement_instances);
    }
    static renderElement(newElement) {
      return __async(this, null, function* () {
        yield newElement.performAction();
      });
    }
    connectedCallback() {
      return __async(this, null, function* () {
        try {
          yield this.render();
        } catch (error2) {
          console.error(error2);
        } finally {
          this.disconnect();
        }
      });
    }
    render() {
      return __async(this, null, function* () {
        var _a2;
        return (_a2 = this.renderPromise) != null ? _a2 : this.renderPromise = (() => __async(this, null, function* () {
          const event = this.beforeRenderEvent;
          if (this.dispatchEvent(event)) {
            yield nextRepaint();
            yield event.detail.render(this);
          }
        }))();
      });
    }
    disconnect() {
      try {
        this.remove();
      } catch (e) {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      var _a2;
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.getAttribute("id"));
      const newChildrenIds = [...((_a2 = this.templateContent) == null ? void 0 : _a2.children) || []].filter((c) => !!c.getAttribute("id")).map((c) => c.getAttribute("id"));
      return existingChildren.filter((c) => newChildrenIds.includes(c.getAttribute("id")));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "unknown action");
      }
      __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      __privateMethod(this, _StreamElement_instances, raise_fn).call(this, "first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    get description() {
      var _a2, _b;
      return (_b = ((_a2 = this.outerHTML.match(/<[^>]+>/)) != null ? _a2 : [])[0]) != null ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      var _a2;
      const element = (_a2 = this.ownerDocument) == null ? void 0 : _a2.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a2;
      const elements = (_a2 = this.ownerDocument) == null ? void 0 : _a2.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  _StreamElement_instances = new WeakSet();
  raise_fn = function(message) {
    throw new Error(`${this.description}: ${message}`);
  };
  var StreamElement = _StreamElement;
  var StreamSourceElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      __publicField(this, "streamSource", null);
    }
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = __spreadProps(__spreadValues({}, Turbo2), { StreamActions });
  start2();

  // node_modules/lucide/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };

  // node_modules/lucide/dist/esm/createElement.js
  var createSVGElement = ([tag, attrs, children]) => {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.keys(attrs).forEach((name) => {
      element.setAttribute(name, String(attrs[name]));
    });
    if (children == null ? void 0 : children.length) {
      children.forEach((child) => {
        const childElement = createSVGElement(child);
        element.appendChild(childElement);
      });
    }
    return element;
  };
  var createElement = (iconNode, customAttrs = {}) => {
    const tag = "svg";
    const attrs = __spreadValues(__spreadValues({}, defaultAttributes), customAttrs);
    return createSVGElement([tag, attrs, iconNode]);
  };

  // node_modules/lucide/dist/esm/replaceElement.js
  var getAttrs = (element) => Array.from(element.attributes).reduce((attrs, attr) => {
    attrs[attr.name] = attr.value;
    return attrs;
  }, {});
  var getClassNames = (attrs) => {
    if (typeof attrs === "string") return attrs;
    if (!attrs || !attrs.class) return "";
    if (attrs.class && typeof attrs.class === "string") {
      return attrs.class.split(" ");
    }
    if (attrs.class && Array.isArray(attrs.class)) {
      return attrs.class;
    }
    return "";
  };
  var combineClassNames = (arrayOfClassnames) => {
    const classNameArray = arrayOfClassnames.flatMap(getClassNames);
    return classNameArray.map((classItem) => classItem.trim()).filter(Boolean).filter((value, index, self2) => self2.indexOf(value) === index).join(" ");
  };
  var toPascalCase = (string) => string.replace(/(\w)(\w*)(_|-|\s*)/g, (g0, g1, g2) => g1.toUpperCase() + g2.toLowerCase());
  var replaceElement = (element, { nameAttr, icons, attrs }) => {
    var _a2;
    const iconName = element.getAttribute(nameAttr);
    if (iconName == null) return;
    const ComponentName = toPascalCase(iconName);
    const iconNode = icons[ComponentName];
    if (!iconNode) {
      return console.warn(
        `${element.outerHTML} icon name was not found in the provided icons object.`
      );
    }
    const elementAttrs = getAttrs(element);
    const iconAttrs = __spreadValues(__spreadValues(__spreadProps(__spreadValues({}, defaultAttributes), {
      "data-lucide": iconName
    }), attrs), elementAttrs);
    const classNames = combineClassNames(["lucide", `lucide-${iconName}`, elementAttrs, attrs]);
    if (classNames) {
      Object.assign(iconAttrs, {
        class: classNames
      });
    }
    const svgElement = createElement(iconNode, iconAttrs);
    return (_a2 = element.parentNode) == null ? void 0 : _a2.replaceChild(svgElement, element);
  };

  // node_modules/lucide/dist/esm/iconsAndAliases.js
  var iconsAndAliases_exports = {};
  __export(iconsAndAliases_exports, {
    AArrowDown: () => AArrowDown,
    AArrowUp: () => AArrowUp,
    ALargeSmall: () => ALargeSmall,
    Accessibility: () => Accessibility,
    Activity: () => Activity,
    ActivitySquare: () => SquareActivity,
    AirVent: () => AirVent,
    Airplay: () => Airplay,
    AlarmCheck: () => AlarmClockCheck,
    AlarmClock: () => AlarmClock,
    AlarmClockCheck: () => AlarmClockCheck,
    AlarmClockMinus: () => AlarmClockMinus,
    AlarmClockOff: () => AlarmClockOff,
    AlarmClockPlus: () => AlarmClockPlus,
    AlarmMinus: () => AlarmClockMinus,
    AlarmPlus: () => AlarmClockPlus,
    AlarmSmoke: () => AlarmSmoke,
    Album: () => Album,
    AlertCircle: () => CircleAlert,
    AlertOctagon: () => OctagonAlert,
    AlertTriangle: () => TriangleAlert,
    AlignCenter: () => AlignCenter,
    AlignCenterHorizontal: () => AlignCenterHorizontal,
    AlignCenterVertical: () => AlignCenterVertical,
    AlignEndHorizontal: () => AlignEndHorizontal,
    AlignEndVertical: () => AlignEndVertical,
    AlignHorizontalDistributeCenter: () => AlignHorizontalDistributeCenter,
    AlignHorizontalDistributeEnd: () => AlignHorizontalDistributeEnd,
    AlignHorizontalDistributeStart: () => AlignHorizontalDistributeStart,
    AlignHorizontalJustifyCenter: () => AlignHorizontalJustifyCenter,
    AlignHorizontalJustifyEnd: () => AlignHorizontalJustifyEnd,
    AlignHorizontalJustifyStart: () => AlignHorizontalJustifyStart,
    AlignHorizontalSpaceAround: () => AlignHorizontalSpaceAround,
    AlignHorizontalSpaceBetween: () => AlignHorizontalSpaceBetween,
    AlignJustify: () => AlignJustify,
    AlignLeft: () => AlignLeft,
    AlignRight: () => AlignRight,
    AlignStartHorizontal: () => AlignStartHorizontal,
    AlignStartVertical: () => AlignStartVertical,
    AlignVerticalDistributeCenter: () => AlignVerticalDistributeCenter,
    AlignVerticalDistributeEnd: () => AlignVerticalDistributeEnd,
    AlignVerticalDistributeStart: () => AlignVerticalDistributeStart,
    AlignVerticalJustifyCenter: () => AlignVerticalJustifyCenter,
    AlignVerticalJustifyEnd: () => AlignVerticalJustifyEnd,
    AlignVerticalJustifyStart: () => AlignVerticalJustifyStart,
    AlignVerticalSpaceAround: () => AlignVerticalSpaceAround,
    AlignVerticalSpaceBetween: () => AlignVerticalSpaceBetween,
    Ambulance: () => Ambulance,
    Ampersand: () => Ampersand,
    Ampersands: () => Ampersands,
    Amphora: () => Amphora,
    Anchor: () => Anchor,
    Angry: () => Angry,
    Annoyed: () => Annoyed,
    Antenna: () => Antenna,
    Anvil: () => Anvil,
    Aperture: () => Aperture,
    AppWindow: () => AppWindow,
    AppWindowMac: () => AppWindowMac,
    Apple: () => Apple,
    Archive: () => Archive,
    ArchiveRestore: () => ArchiveRestore,
    ArchiveX: () => ArchiveX,
    AreaChart: () => ChartArea,
    Armchair: () => Armchair,
    ArrowBigDown: () => ArrowBigDown,
    ArrowBigDownDash: () => ArrowBigDownDash,
    ArrowBigLeft: () => ArrowBigLeft,
    ArrowBigLeftDash: () => ArrowBigLeftDash,
    ArrowBigRight: () => ArrowBigRight,
    ArrowBigRightDash: () => ArrowBigRightDash,
    ArrowBigUp: () => ArrowBigUp,
    ArrowBigUpDash: () => ArrowBigUpDash,
    ArrowDown: () => ArrowDown,
    ArrowDown01: () => ArrowDown01,
    ArrowDown10: () => ArrowDown10,
    ArrowDownAZ: () => ArrowDownAZ,
    ArrowDownAz: () => ArrowDownAZ,
    ArrowDownCircle: () => CircleArrowDown,
    ArrowDownFromLine: () => ArrowDownFromLine,
    ArrowDownLeft: () => ArrowDownLeft,
    ArrowDownLeftFromCircle: () => CircleArrowOutDownLeft,
    ArrowDownLeftFromSquare: () => SquareArrowOutDownLeft,
    ArrowDownLeftSquare: () => SquareArrowDownLeft,
    ArrowDownNarrowWide: () => ArrowDownNarrowWide,
    ArrowDownRight: () => ArrowDownRight,
    ArrowDownRightFromCircle: () => CircleArrowOutDownRight,
    ArrowDownRightFromSquare: () => SquareArrowOutDownRight,
    ArrowDownRightSquare: () => SquareArrowDownRight,
    ArrowDownSquare: () => SquareArrowDown,
    ArrowDownToDot: () => ArrowDownToDot,
    ArrowDownToLine: () => ArrowDownToLine,
    ArrowDownUp: () => ArrowDownUp,
    ArrowDownWideNarrow: () => ArrowDownWideNarrow,
    ArrowDownZA: () => ArrowDownZA,
    ArrowDownZa: () => ArrowDownZA,
    ArrowLeft: () => ArrowLeft,
    ArrowLeftCircle: () => CircleArrowLeft,
    ArrowLeftFromLine: () => ArrowLeftFromLine,
    ArrowLeftRight: () => ArrowLeftRight,
    ArrowLeftSquare: () => SquareArrowLeft,
    ArrowLeftToLine: () => ArrowLeftToLine,
    ArrowRight: () => ArrowRight,
    ArrowRightCircle: () => CircleArrowRight,
    ArrowRightFromLine: () => ArrowRightFromLine,
    ArrowRightLeft: () => ArrowRightLeft,
    ArrowRightSquare: () => SquareArrowRight,
    ArrowRightToLine: () => ArrowRightToLine,
    ArrowUp: () => ArrowUp,
    ArrowUp01: () => ArrowUp01,
    ArrowUp10: () => ArrowUp10,
    ArrowUpAZ: () => ArrowUpAZ,
    ArrowUpAz: () => ArrowUpAZ,
    ArrowUpCircle: () => CircleArrowUp,
    ArrowUpDown: () => ArrowUpDown,
    ArrowUpFromDot: () => ArrowUpFromDot,
    ArrowUpFromLine: () => ArrowUpFromLine,
    ArrowUpLeft: () => ArrowUpLeft,
    ArrowUpLeftFromCircle: () => CircleArrowOutUpLeft,
    ArrowUpLeftFromSquare: () => SquareArrowOutUpLeft,
    ArrowUpLeftSquare: () => SquareArrowUpLeft,
    ArrowUpNarrowWide: () => ArrowUpNarrowWide,
    ArrowUpRight: () => ArrowUpRight,
    ArrowUpRightFromCircle: () => CircleArrowOutUpRight,
    ArrowUpRightFromSquare: () => SquareArrowOutUpRight,
    ArrowUpRightSquare: () => SquareArrowUpRight,
    ArrowUpSquare: () => SquareArrowUp,
    ArrowUpToLine: () => ArrowUpToLine,
    ArrowUpWideNarrow: () => ArrowUpWideNarrow,
    ArrowUpZA: () => ArrowUpZA,
    ArrowUpZa: () => ArrowUpZA,
    ArrowsUpFromLine: () => ArrowsUpFromLine,
    Asterisk: () => Asterisk,
    AsteriskSquare: () => SquareAsterisk,
    AtSign: () => AtSign,
    Atom: () => Atom,
    AudioLines: () => AudioLines,
    AudioWaveform: () => AudioWaveform,
    Award: () => Award,
    Axe: () => Axe,
    Axis3D: () => Axis3d,
    Axis3d: () => Axis3d,
    Baby: () => Baby,
    Backpack: () => Backpack,
    Badge: () => Badge,
    BadgeAlert: () => BadgeAlert,
    BadgeCent: () => BadgeCent,
    BadgeCheck: () => BadgeCheck,
    BadgeDollarSign: () => BadgeDollarSign,
    BadgeEuro: () => BadgeEuro,
    BadgeHelp: () => BadgeHelp,
    BadgeIndianRupee: () => BadgeIndianRupee,
    BadgeInfo: () => BadgeInfo,
    BadgeJapaneseYen: () => BadgeJapaneseYen,
    BadgeMinus: () => BadgeMinus,
    BadgePercent: () => BadgePercent,
    BadgePlus: () => BadgePlus,
    BadgePoundSterling: () => BadgePoundSterling,
    BadgeRussianRuble: () => BadgeRussianRuble,
    BadgeSwissFranc: () => BadgeSwissFranc,
    BadgeX: () => BadgeX,
    BaggageClaim: () => BaggageClaim,
    Ban: () => Ban,
    Banana: () => Banana,
    Bandage: () => Bandage,
    Banknote: () => Banknote,
    BanknoteArrowDown: () => BanknoteArrowDown,
    BanknoteArrowUp: () => BanknoteArrowUp,
    BanknoteX: () => BanknoteX,
    BarChart: () => ChartNoAxesColumnIncreasing,
    BarChart2: () => ChartNoAxesColumn,
    BarChart3: () => ChartColumn,
    BarChart4: () => ChartColumnIncreasing,
    BarChartBig: () => ChartColumnBig,
    BarChartHorizontal: () => ChartBar,
    BarChartHorizontalBig: () => ChartBarBig,
    Barcode: () => Barcode,
    Baseline: () => Baseline,
    Bath: () => Bath,
    Battery: () => Battery,
    BatteryCharging: () => BatteryCharging,
    BatteryFull: () => BatteryFull,
    BatteryLow: () => BatteryLow,
    BatteryMedium: () => BatteryMedium,
    BatteryPlus: () => BatteryPlus,
    BatteryWarning: () => BatteryWarning,
    Beaker: () => Beaker,
    Bean: () => Bean,
    BeanOff: () => BeanOff,
    Bed: () => Bed,
    BedDouble: () => BedDouble,
    BedSingle: () => BedSingle,
    Beef: () => Beef,
    Beer: () => Beer,
    BeerOff: () => BeerOff,
    Bell: () => Bell,
    BellDot: () => BellDot,
    BellElectric: () => BellElectric,
    BellMinus: () => BellMinus,
    BellOff: () => BellOff,
    BellPlus: () => BellPlus,
    BellRing: () => BellRing,
    BetweenHorizonalEnd: () => BetweenHorizontalEnd,
    BetweenHorizonalStart: () => BetweenHorizontalStart,
    BetweenHorizontalEnd: () => BetweenHorizontalEnd,
    BetweenHorizontalStart: () => BetweenHorizontalStart,
    BetweenVerticalEnd: () => BetweenVerticalEnd,
    BetweenVerticalStart: () => BetweenVerticalStart,
    BicepsFlexed: () => BicepsFlexed,
    Bike: () => Bike,
    Binary: () => Binary,
    Binoculars: () => Binoculars,
    Biohazard: () => Biohazard,
    Bird: () => Bird,
    Bitcoin: () => Bitcoin,
    Blend: () => Blend,
    Blinds: () => Blinds,
    Blocks: () => Blocks,
    Bluetooth: () => Bluetooth,
    BluetoothConnected: () => BluetoothConnected,
    BluetoothOff: () => BluetoothOff,
    BluetoothSearching: () => BluetoothSearching,
    Bold: () => Bold2,
    Bolt: () => Bolt,
    Bomb: () => Bomb,
    Bone: () => Bone,
    Book: () => Book,
    BookA: () => BookA,
    BookAudio: () => BookAudio,
    BookCheck: () => BookCheck,
    BookCopy: () => BookCopy,
    BookDashed: () => BookDashed,
    BookDown: () => BookDown,
    BookHeadphones: () => BookHeadphones,
    BookHeart: () => BookHeart,
    BookImage: () => BookImage,
    BookKey: () => BookKey,
    BookLock: () => BookLock,
    BookMarked: () => BookMarked,
    BookMinus: () => BookMinus,
    BookOpen: () => BookOpen,
    BookOpenCheck: () => BookOpenCheck,
    BookOpenText: () => BookOpenText,
    BookPlus: () => BookPlus,
    BookTemplate: () => BookDashed,
    BookText: () => BookText,
    BookType: () => BookType,
    BookUp: () => BookUp,
    BookUp2: () => BookUp2,
    BookUser: () => BookUser,
    BookX: () => BookX,
    Bookmark: () => Bookmark,
    BookmarkCheck: () => BookmarkCheck,
    BookmarkMinus: () => BookmarkMinus,
    BookmarkPlus: () => BookmarkPlus,
    BookmarkX: () => BookmarkX,
    BoomBox: () => BoomBox,
    Bot: () => Bot,
    BotMessageSquare: () => BotMessageSquare,
    BotOff: () => BotOff,
    BowArrow: () => BowArrow,
    Box: () => Box,
    BoxSelect: () => SquareDashed,
    Boxes: () => Boxes,
    Braces: () => Braces,
    Brackets: () => Brackets,
    Brain: () => Brain,
    BrainCircuit: () => BrainCircuit,
    BrainCog: () => BrainCog,
    BrickWall: () => BrickWall,
    BrickWallFire: () => BrickWallFire,
    Briefcase: () => Briefcase,
    BriefcaseBusiness: () => BriefcaseBusiness,
    BriefcaseConveyorBelt: () => BriefcaseConveyorBelt,
    BriefcaseMedical: () => BriefcaseMedical,
    BringToFront: () => BringToFront,
    Brush: () => Brush,
    BrushCleaning: () => BrushCleaning,
    Bubbles: () => Bubbles,
    Bug: () => Bug,
    BugOff: () => BugOff,
    BugPlay: () => BugPlay,
    Building: () => Building,
    Building2: () => Building2,
    Bus: () => Bus,
    BusFront: () => BusFront,
    Cable: () => Cable,
    CableCar: () => CableCar,
    Cake: () => Cake,
    CakeSlice: () => CakeSlice,
    Calculator: () => Calculator,
    Calendar: () => Calendar,
    Calendar1: () => Calendar1,
    CalendarArrowDown: () => CalendarArrowDown,
    CalendarArrowUp: () => CalendarArrowUp,
    CalendarCheck: () => CalendarCheck,
    CalendarCheck2: () => CalendarCheck2,
    CalendarClock: () => CalendarClock,
    CalendarCog: () => CalendarCog,
    CalendarDays: () => CalendarDays,
    CalendarFold: () => CalendarFold,
    CalendarHeart: () => CalendarHeart,
    CalendarMinus: () => CalendarMinus,
    CalendarMinus2: () => CalendarMinus2,
    CalendarOff: () => CalendarOff,
    CalendarPlus: () => CalendarPlus,
    CalendarPlus2: () => CalendarPlus2,
    CalendarRange: () => CalendarRange,
    CalendarSearch: () => CalendarSearch,
    CalendarSync: () => CalendarSync,
    CalendarX: () => CalendarX,
    CalendarX2: () => CalendarX2,
    Camera: () => Camera,
    CameraOff: () => CameraOff,
    CandlestickChart: () => ChartCandlestick,
    Candy: () => Candy,
    CandyCane: () => CandyCane,
    CandyOff: () => CandyOff,
    Cannabis: () => Cannabis,
    Captions: () => Captions,
    CaptionsOff: () => CaptionsOff,
    Car: () => Car,
    CarFront: () => CarFront,
    CarTaxiFront: () => CarTaxiFront,
    Caravan: () => Caravan,
    Carrot: () => Carrot,
    CaseLower: () => CaseLower,
    CaseSensitive: () => CaseSensitive,
    CaseUpper: () => CaseUpper,
    CassetteTape: () => CassetteTape,
    Cast: () => Cast,
    Castle: () => Castle,
    Cat: () => Cat,
    Cctv: () => Cctv,
    ChartArea: () => ChartArea,
    ChartBar: () => ChartBar,
    ChartBarBig: () => ChartBarBig,
    ChartBarDecreasing: () => ChartBarDecreasing,
    ChartBarIncreasing: () => ChartBarIncreasing,
    ChartBarStacked: () => ChartBarStacked,
    ChartCandlestick: () => ChartCandlestick,
    ChartColumn: () => ChartColumn,
    ChartColumnBig: () => ChartColumnBig,
    ChartColumnDecreasing: () => ChartColumnDecreasing,
    ChartColumnIncreasing: () => ChartColumnIncreasing,
    ChartColumnStacked: () => ChartColumnStacked,
    ChartGantt: () => ChartGantt,
    ChartLine: () => ChartLine,
    ChartNetwork: () => ChartNetwork,
    ChartNoAxesColumn: () => ChartNoAxesColumn,
    ChartNoAxesColumnDecreasing: () => ChartNoAxesColumnDecreasing,
    ChartNoAxesColumnIncreasing: () => ChartNoAxesColumnIncreasing,
    ChartNoAxesCombined: () => ChartNoAxesCombined,
    ChartNoAxesGantt: () => ChartNoAxesGantt,
    ChartPie: () => ChartPie,
    ChartScatter: () => ChartScatter,
    ChartSpline: () => ChartSpline,
    Check: () => Check,
    CheckCheck: () => CheckCheck,
    CheckCircle: () => CircleCheckBig,
    CheckCircle2: () => CircleCheck,
    CheckSquare: () => SquareCheckBig,
    CheckSquare2: () => SquareCheck,
    ChefHat: () => ChefHat,
    Cherry: () => Cherry,
    ChevronDown: () => ChevronDown,
    ChevronDownCircle: () => CircleChevronDown,
    ChevronDownSquare: () => SquareChevronDown,
    ChevronFirst: () => ChevronFirst,
    ChevronLast: () => ChevronLast,
    ChevronLeft: () => ChevronLeft,
    ChevronLeftCircle: () => CircleChevronLeft,
    ChevronLeftSquare: () => SquareChevronLeft,
    ChevronRight: () => ChevronRight,
    ChevronRightCircle: () => CircleChevronRight,
    ChevronRightSquare: () => SquareChevronRight,
    ChevronUp: () => ChevronUp,
    ChevronUpCircle: () => CircleChevronUp,
    ChevronUpSquare: () => SquareChevronUp,
    ChevronsDown: () => ChevronsDown,
    ChevronsDownUp: () => ChevronsDownUp,
    ChevronsLeft: () => ChevronsLeft,
    ChevronsLeftRight: () => ChevronsLeftRight,
    ChevronsLeftRightEllipsis: () => ChevronsLeftRightEllipsis,
    ChevronsRight: () => ChevronsRight,
    ChevronsRightLeft: () => ChevronsRightLeft,
    ChevronsUp: () => ChevronsUp,
    ChevronsUpDown: () => ChevronsUpDown,
    Chrome: () => Chrome,
    Church: () => Church,
    Cigarette: () => Cigarette,
    CigaretteOff: () => CigaretteOff,
    Circle: () => Circle,
    CircleAlert: () => CircleAlert,
    CircleArrowDown: () => CircleArrowDown,
    CircleArrowLeft: () => CircleArrowLeft,
    CircleArrowOutDownLeft: () => CircleArrowOutDownLeft,
    CircleArrowOutDownRight: () => CircleArrowOutDownRight,
    CircleArrowOutUpLeft: () => CircleArrowOutUpLeft,
    CircleArrowOutUpRight: () => CircleArrowOutUpRight,
    CircleArrowRight: () => CircleArrowRight,
    CircleArrowUp: () => CircleArrowUp,
    CircleCheck: () => CircleCheck,
    CircleCheckBig: () => CircleCheckBig,
    CircleChevronDown: () => CircleChevronDown,
    CircleChevronLeft: () => CircleChevronLeft,
    CircleChevronRight: () => CircleChevronRight,
    CircleChevronUp: () => CircleChevronUp,
    CircleDashed: () => CircleDashed,
    CircleDivide: () => CircleDivide,
    CircleDollarSign: () => CircleDollarSign,
    CircleDot: () => CircleDot,
    CircleDotDashed: () => CircleDotDashed,
    CircleEllipsis: () => CircleEllipsis,
    CircleEqual: () => CircleEqual,
    CircleFadingArrowUp: () => CircleFadingArrowUp,
    CircleFadingPlus: () => CircleFadingPlus,
    CircleGauge: () => CircleGauge,
    CircleHelp: () => CircleHelp,
    CircleMinus: () => CircleMinus,
    CircleOff: () => CircleOff,
    CircleParking: () => CircleParking,
    CircleParkingOff: () => CircleParkingOff,
    CirclePause: () => CirclePause,
    CirclePercent: () => CirclePercent,
    CirclePlay: () => CirclePlay,
    CirclePlus: () => CirclePlus,
    CirclePower: () => CirclePower,
    CircleSlash: () => CircleSlash,
    CircleSlash2: () => CircleSlash2,
    CircleSlashed: () => CircleSlash2,
    CircleSmall: () => CircleSmall,
    CircleStop: () => CircleStop,
    CircleUser: () => CircleUser,
    CircleUserRound: () => CircleUserRound,
    CircleX: () => CircleX,
    CircuitBoard: () => CircuitBoard,
    Citrus: () => Citrus,
    Clapperboard: () => Clapperboard,
    Clipboard: () => Clipboard,
    ClipboardCheck: () => ClipboardCheck,
    ClipboardCopy: () => ClipboardCopy,
    ClipboardEdit: () => ClipboardPen,
    ClipboardList: () => ClipboardList,
    ClipboardMinus: () => ClipboardMinus,
    ClipboardPaste: () => ClipboardPaste,
    ClipboardPen: () => ClipboardPen,
    ClipboardPenLine: () => ClipboardPenLine,
    ClipboardPlus: () => ClipboardPlus,
    ClipboardSignature: () => ClipboardPenLine,
    ClipboardType: () => ClipboardType,
    ClipboardX: () => ClipboardX,
    Clock: () => Clock,
    Clock1: () => Clock1,
    Clock10: () => Clock10,
    Clock11: () => Clock11,
    Clock12: () => Clock12,
    Clock2: () => Clock2,
    Clock3: () => Clock3,
    Clock4: () => Clock4,
    Clock5: () => Clock5,
    Clock6: () => Clock6,
    Clock7: () => Clock7,
    Clock8: () => Clock8,
    Clock9: () => Clock9,
    ClockAlert: () => ClockAlert,
    ClockArrowDown: () => ClockArrowDown,
    ClockArrowUp: () => ClockArrowUp,
    ClockFading: () => ClockFading,
    ClockPlus: () => ClockPlus,
    Cloud: () => Cloud,
    CloudAlert: () => CloudAlert,
    CloudCog: () => CloudCog,
    CloudDownload: () => CloudDownload,
    CloudDrizzle: () => CloudDrizzle,
    CloudFog: () => CloudFog,
    CloudHail: () => CloudHail,
    CloudLightning: () => CloudLightning,
    CloudMoon: () => CloudMoon,
    CloudMoonRain: () => CloudMoonRain,
    CloudOff: () => CloudOff,
    CloudRain: () => CloudRain,
    CloudRainWind: () => CloudRainWind,
    CloudSnow: () => CloudSnow,
    CloudSun: () => CloudSun,
    CloudSunRain: () => CloudSunRain,
    CloudUpload: () => CloudUpload,
    Cloudy: () => Cloudy,
    Clover: () => Clover,
    Club: () => Club,
    Code: () => Code2,
    Code2: () => CodeXml,
    CodeSquare: () => SquareCode,
    CodeXml: () => CodeXml,
    Codepen: () => Codepen,
    Codesandbox: () => Codesandbox,
    Coffee: () => Coffee,
    Cog: () => Cog,
    Coins: () => Coins,
    Columns: () => Columns2,
    Columns2: () => Columns2,
    Columns3: () => Columns3,
    Columns3Cog: () => Columns3Cog,
    Columns4: () => Columns4,
    ColumnsSettings: () => Columns3Cog,
    Combine: () => Combine,
    Command: () => Command,
    Compass: () => Compass,
    Component: () => Component,
    Computer: () => Computer,
    ConciergeBell: () => ConciergeBell,
    Cone: () => Cone,
    Construction: () => Construction,
    Contact: () => Contact,
    Contact2: () => ContactRound,
    ContactRound: () => ContactRound,
    Container: () => Container,
    Contrast: () => Contrast,
    Cookie: () => Cookie,
    CookingPot: () => CookingPot,
    Copy: () => Copy,
    CopyCheck: () => CopyCheck,
    CopyMinus: () => CopyMinus,
    CopyPlus: () => CopyPlus,
    CopySlash: () => CopySlash,
    CopyX: () => CopyX,
    Copyleft: () => Copyleft,
    Copyright: () => Copyright,
    CornerDownLeft: () => CornerDownLeft,
    CornerDownRight: () => CornerDownRight,
    CornerLeftDown: () => CornerLeftDown,
    CornerLeftUp: () => CornerLeftUp,
    CornerRightDown: () => CornerRightDown,
    CornerRightUp: () => CornerRightUp,
    CornerUpLeft: () => CornerUpLeft,
    CornerUpRight: () => CornerUpRight,
    Cpu: () => Cpu,
    CreativeCommons: () => CreativeCommons,
    CreditCard: () => CreditCard,
    Croissant: () => Croissant,
    Crop: () => Crop,
    Cross: () => Cross,
    Crosshair: () => Crosshair,
    Crown: () => Crown,
    Cuboid: () => Cuboid,
    CupSoda: () => CupSoda,
    CurlyBraces: () => Braces,
    Currency: () => Currency,
    Cylinder: () => Cylinder,
    Dam: () => Dam,
    Database: () => Database,
    DatabaseBackup: () => DatabaseBackup,
    DatabaseZap: () => DatabaseZap,
    DecimalsArrowLeft: () => DecimalsArrowLeft,
    DecimalsArrowRight: () => DecimalsArrowRight,
    Delete: () => Delete,
    Dessert: () => Dessert,
    Diameter: () => Diameter,
    Diamond: () => Diamond,
    DiamondMinus: () => DiamondMinus,
    DiamondPercent: () => DiamondPercent,
    DiamondPlus: () => DiamondPlus,
    Dice1: () => Dice1,
    Dice2: () => Dice2,
    Dice3: () => Dice3,
    Dice4: () => Dice4,
    Dice5: () => Dice5,
    Dice6: () => Dice6,
    Dices: () => Dices,
    Diff: () => Diff,
    Disc: () => Disc,
    Disc2: () => Disc2,
    Disc3: () => Disc3,
    DiscAlbum: () => DiscAlbum,
    Divide: () => Divide,
    DivideCircle: () => CircleDivide,
    DivideSquare: () => SquareDivide,
    Dna: () => Dna,
    DnaOff: () => DnaOff,
    Dock: () => Dock,
    Dog: () => Dog,
    DollarSign: () => DollarSign,
    Donut: () => Donut,
    DoorClosed: () => DoorClosed,
    DoorClosedLocked: () => DoorClosedLocked,
    DoorOpen: () => DoorOpen,
    Dot: () => Dot,
    DotSquare: () => SquareDot,
    Download: () => Download,
    DownloadCloud: () => CloudDownload,
    DraftingCompass: () => DraftingCompass,
    Drama: () => Drama,
    Dribbble: () => Dribbble,
    Drill: () => Drill,
    Droplet: () => Droplet,
    DropletOff: () => DropletOff,
    Droplets: () => Droplets,
    Drum: () => Drum,
    Drumstick: () => Drumstick,
    Dumbbell: () => Dumbbell,
    Ear: () => Ear,
    EarOff: () => EarOff,
    Earth: () => Earth,
    EarthLock: () => EarthLock,
    Eclipse: () => Eclipse,
    Edit: () => SquarePen,
    Edit2: () => Pen,
    Edit3: () => PenLine,
    Egg: () => Egg,
    EggFried: () => EggFried,
    EggOff: () => EggOff,
    Ellipsis: () => Ellipsis,
    EllipsisVertical: () => EllipsisVertical,
    Equal: () => Equal,
    EqualApproximately: () => EqualApproximately,
    EqualNot: () => EqualNot,
    EqualSquare: () => SquareEqual,
    Eraser: () => Eraser,
    EthernetPort: () => EthernetPort,
    Euro: () => Euro,
    Expand: () => Expand,
    ExternalLink: () => ExternalLink,
    Eye: () => Eye,
    EyeClosed: () => EyeClosed,
    EyeOff: () => EyeOff,
    Facebook: () => Facebook,
    Factory: () => Factory,
    Fan: () => Fan,
    FastForward: () => FastForward,
    Feather: () => Feather,
    Fence: () => Fence,
    FerrisWheel: () => FerrisWheel,
    Figma: () => Figma,
    File: () => File2,
    FileArchive: () => FileArchive,
    FileAudio: () => FileAudio,
    FileAudio2: () => FileAudio2,
    FileAxis3D: () => FileAxis3d,
    FileAxis3d: () => FileAxis3d,
    FileBadge: () => FileBadge,
    FileBadge2: () => FileBadge2,
    FileBarChart: () => FileChartColumnIncreasing,
    FileBarChart2: () => FileChartColumn,
    FileBox: () => FileBox,
    FileChartColumn: () => FileChartColumn,
    FileChartColumnIncreasing: () => FileChartColumnIncreasing,
    FileChartLine: () => FileChartLine,
    FileChartPie: () => FileChartPie,
    FileCheck: () => FileCheck,
    FileCheck2: () => FileCheck2,
    FileClock: () => FileClock,
    FileCode: () => FileCode,
    FileCode2: () => FileCode2,
    FileCog: () => FileCog,
    FileCog2: () => FileCog,
    FileDiff: () => FileDiff,
    FileDigit: () => FileDigit,
    FileDown: () => FileDown,
    FileEdit: () => FilePen,
    FileHeart: () => FileHeart,
    FileImage: () => FileImage,
    FileInput: () => FileInput,
    FileJson: () => FileJson,
    FileJson2: () => FileJson2,
    FileKey: () => FileKey,
    FileKey2: () => FileKey2,
    FileLineChart: () => FileChartLine,
    FileLock: () => FileLock,
    FileLock2: () => FileLock2,
    FileMinus: () => FileMinus,
    FileMinus2: () => FileMinus2,
    FileMusic: () => FileMusic,
    FileOutput: () => FileOutput,
    FilePen: () => FilePen,
    FilePenLine: () => FilePenLine,
    FilePieChart: () => FileChartPie,
    FilePlus: () => FilePlus,
    FilePlus2: () => FilePlus2,
    FileQuestion: () => FileQuestion,
    FileScan: () => FileScan,
    FileSearch: () => FileSearch,
    FileSearch2: () => FileSearch2,
    FileSignature: () => FilePenLine,
    FileSliders: () => FileSliders,
    FileSpreadsheet: () => FileSpreadsheet,
    FileStack: () => FileStack,
    FileSymlink: () => FileSymlink,
    FileTerminal: () => FileTerminal,
    FileText: () => FileText,
    FileType: () => FileType,
    FileType2: () => FileType2,
    FileUp: () => FileUp,
    FileUser: () => FileUser,
    FileVideo: () => FileVideo,
    FileVideo2: () => FileVideo2,
    FileVolume: () => FileVolume,
    FileVolume2: () => FileVolume2,
    FileWarning: () => FileWarning,
    FileX: () => FileX,
    FileX2: () => FileX2,
    Files: () => Files,
    Film: () => Film,
    Filter: () => Funnel,
    FilterX: () => FunnelX,
    Fingerprint: () => Fingerprint,
    FireExtinguisher: () => FireExtinguisher,
    Fish: () => Fish,
    FishOff: () => FishOff,
    FishSymbol: () => FishSymbol,
    Flag: () => Flag,
    FlagOff: () => FlagOff,
    FlagTriangleLeft: () => FlagTriangleLeft,
    FlagTriangleRight: () => FlagTriangleRight,
    Flame: () => Flame,
    FlameKindling: () => FlameKindling,
    Flashlight: () => Flashlight,
    FlashlightOff: () => FlashlightOff,
    FlaskConical: () => FlaskConical,
    FlaskConicalOff: () => FlaskConicalOff,
    FlaskRound: () => FlaskRound,
    FlipHorizontal: () => FlipHorizontal,
    FlipHorizontal2: () => FlipHorizontal2,
    FlipVertical: () => FlipVertical,
    FlipVertical2: () => FlipVertical2,
    Flower: () => Flower,
    Flower2: () => Flower2,
    Focus: () => Focus,
    FoldHorizontal: () => FoldHorizontal,
    FoldVertical: () => FoldVertical,
    Folder: () => Folder,
    FolderArchive: () => FolderArchive,
    FolderCheck: () => FolderCheck,
    FolderClock: () => FolderClock,
    FolderClosed: () => FolderClosed,
    FolderCode: () => FolderCode,
    FolderCog: () => FolderCog,
    FolderCog2: () => FolderCog,
    FolderDot: () => FolderDot,
    FolderDown: () => FolderDown,
    FolderEdit: () => FolderPen,
    FolderGit: () => FolderGit,
    FolderGit2: () => FolderGit2,
    FolderHeart: () => FolderHeart,
    FolderInput: () => FolderInput,
    FolderKanban: () => FolderKanban,
    FolderKey: () => FolderKey,
    FolderLock: () => FolderLock,
    FolderMinus: () => FolderMinus,
    FolderOpen: () => FolderOpen,
    FolderOpenDot: () => FolderOpenDot,
    FolderOutput: () => FolderOutput,
    FolderPen: () => FolderPen,
    FolderPlus: () => FolderPlus,
    FolderRoot: () => FolderRoot,
    FolderSearch: () => FolderSearch,
    FolderSearch2: () => FolderSearch2,
    FolderSymlink: () => FolderSymlink,
    FolderSync: () => FolderSync,
    FolderTree: () => FolderTree,
    FolderUp: () => FolderUp,
    FolderX: () => FolderX,
    Folders: () => Folders,
    Footprints: () => Footprints,
    ForkKnife: () => Utensils,
    ForkKnifeCrossed: () => UtensilsCrossed,
    Forklift: () => Forklift,
    FormInput: () => RectangleEllipsis,
    Forward: () => Forward,
    Frame: () => Frame,
    Framer: () => Framer,
    Frown: () => Frown,
    Fuel: () => Fuel,
    Fullscreen: () => Fullscreen,
    FunctionSquare: () => SquareFunction,
    Funnel: () => Funnel,
    FunnelPlus: () => FunnelPlus,
    FunnelX: () => FunnelX,
    GalleryHorizontal: () => GalleryHorizontal,
    GalleryHorizontalEnd: () => GalleryHorizontalEnd,
    GalleryThumbnails: () => GalleryThumbnails,
    GalleryVertical: () => GalleryVertical,
    GalleryVerticalEnd: () => GalleryVerticalEnd,
    Gamepad: () => Gamepad,
    Gamepad2: () => Gamepad2,
    GanttChart: () => ChartNoAxesGantt,
    GanttChartSquare: () => SquareChartGantt,
    Gauge: () => Gauge,
    GaugeCircle: () => CircleGauge,
    Gavel: () => Gavel,
    Gem: () => Gem,
    Ghost: () => Ghost,
    Gift: () => Gift,
    GitBranch: () => GitBranch,
    GitBranchPlus: () => GitBranchPlus,
    GitCommit: () => GitCommitHorizontal,
    GitCommitHorizontal: () => GitCommitHorizontal,
    GitCommitVertical: () => GitCommitVertical,
    GitCompare: () => GitCompare,
    GitCompareArrows: () => GitCompareArrows,
    GitFork: () => GitFork,
    GitGraph: () => GitGraph,
    GitMerge: () => GitMerge,
    GitPullRequest: () => GitPullRequest,
    GitPullRequestArrow: () => GitPullRequestArrow,
    GitPullRequestClosed: () => GitPullRequestClosed,
    GitPullRequestCreate: () => GitPullRequestCreate,
    GitPullRequestCreateArrow: () => GitPullRequestCreateArrow,
    GitPullRequestDraft: () => GitPullRequestDraft,
    Github: () => Github,
    Gitlab: () => Gitlab,
    GlassWater: () => GlassWater,
    Glasses: () => Glasses,
    Globe: () => Globe,
    Globe2: () => Earth,
    GlobeLock: () => GlobeLock,
    Goal: () => Goal,
    Grab: () => Grab,
    GraduationCap: () => GraduationCap,
    Grape: () => Grape,
    Grid: () => Grid3x3,
    Grid2X2: () => Grid2x2,
    Grid2X2Check: () => Grid2x2Check,
    Grid2X2Plus: () => Grid2x2Plus,
    Grid2X2X: () => Grid2x2X,
    Grid2x2: () => Grid2x2,
    Grid2x2Check: () => Grid2x2Check,
    Grid2x2Plus: () => Grid2x2Plus,
    Grid2x2X: () => Grid2x2X,
    Grid3X3: () => Grid3x3,
    Grid3x3: () => Grid3x3,
    Grip: () => Grip,
    GripHorizontal: () => GripHorizontal,
    GripVertical: () => GripVertical,
    Group: () => Group,
    Guitar: () => Guitar,
    Ham: () => Ham,
    Hamburger: () => Hamburger,
    Hammer: () => Hammer,
    Hand: () => Hand,
    HandCoins: () => HandCoins,
    HandHeart: () => HandHeart,
    HandHelping: () => HandHelping,
    HandMetal: () => HandMetal,
    HandPlatter: () => HandPlatter,
    Handshake: () => Handshake,
    HardDrive: () => HardDrive,
    HardDriveDownload: () => HardDriveDownload,
    HardDriveUpload: () => HardDriveUpload,
    HardHat: () => HardHat,
    Hash: () => Hash,
    Haze: () => Haze,
    HdmiPort: () => HdmiPort,
    Heading: () => Heading7,
    Heading1: () => Heading1,
    Heading2: () => Heading2,
    Heading3: () => Heading3,
    Heading4: () => Heading4,
    Heading5: () => Heading5,
    Heading6: () => Heading6,
    HeadphoneOff: () => HeadphoneOff,
    Headphones: () => Headphones,
    Headset: () => Headset,
    Heart: () => Heart,
    HeartCrack: () => HeartCrack,
    HeartHandshake: () => HeartHandshake,
    HeartMinus: () => HeartMinus,
    HeartOff: () => HeartOff,
    HeartPlus: () => HeartPlus,
    HeartPulse: () => HeartPulse,
    Heater: () => Heater,
    HelpCircle: () => CircleHelp,
    HelpingHand: () => HandHelping,
    Hexagon: () => Hexagon,
    Highlighter: () => Highlighter,
    History: () => History3,
    Home: () => House,
    Hop: () => Hop,
    HopOff: () => HopOff,
    Hospital: () => Hospital,
    Hotel: () => Hotel,
    Hourglass: () => Hourglass,
    House: () => House,
    HousePlug: () => HousePlug,
    HousePlus: () => HousePlus,
    HouseWifi: () => HouseWifi,
    IceCream: () => IceCreamCone,
    IceCream2: () => IceCreamBowl,
    IceCreamBowl: () => IceCreamBowl,
    IceCreamCone: () => IceCreamCone,
    IdCard: () => IdCard,
    Image: () => Image,
    ImageDown: () => ImageDown,
    ImageMinus: () => ImageMinus,
    ImageOff: () => ImageOff,
    ImagePlay: () => ImagePlay,
    ImagePlus: () => ImagePlus,
    ImageUp: () => ImageUp,
    ImageUpscale: () => ImageUpscale,
    Images: () => Images,
    Import: () => Import,
    Inbox: () => Inbox,
    Indent: () => IndentIncrease,
    IndentDecrease: () => IndentDecrease,
    IndentIncrease: () => IndentIncrease,
    IndianRupee: () => IndianRupee,
    Infinity: () => Infinity2,
    Info: () => Info,
    Inspect: () => SquareMousePointer,
    InspectionPanel: () => InspectionPanel,
    Instagram: () => Instagram,
    Italic: () => Italic2,
    IterationCcw: () => IterationCcw,
    IterationCw: () => IterationCw,
    JapaneseYen: () => JapaneseYen,
    Joystick: () => Joystick,
    Kanban: () => Kanban,
    KanbanSquare: () => SquareKanban,
    KanbanSquareDashed: () => SquareDashedKanban,
    Key: () => Key,
    KeyRound: () => KeyRound,
    KeySquare: () => KeySquare,
    Keyboard: () => Keyboard,
    KeyboardMusic: () => KeyboardMusic,
    KeyboardOff: () => KeyboardOff,
    Lamp: () => Lamp,
    LampCeiling: () => LampCeiling,
    LampDesk: () => LampDesk,
    LampFloor: () => LampFloor,
    LampWallDown: () => LampWallDown,
    LampWallUp: () => LampWallUp,
    LandPlot: () => LandPlot,
    Landmark: () => Landmark,
    Languages: () => Languages,
    Laptop: () => Laptop,
    Laptop2: () => LaptopMinimal,
    LaptopMinimal: () => LaptopMinimal,
    LaptopMinimalCheck: () => LaptopMinimalCheck,
    Lasso: () => Lasso,
    LassoSelect: () => LassoSelect,
    Laugh: () => Laugh,
    Layers: () => Layers,
    Layers2: () => Layers2,
    Layers3: () => Layers,
    Layout: () => PanelsTopLeft,
    LayoutDashboard: () => LayoutDashboard,
    LayoutGrid: () => LayoutGrid,
    LayoutList: () => LayoutList,
    LayoutPanelLeft: () => LayoutPanelLeft,
    LayoutPanelTop: () => LayoutPanelTop,
    LayoutTemplate: () => LayoutTemplate,
    Leaf: () => Leaf2,
    LeafyGreen: () => LeafyGreen,
    Lectern: () => Lectern,
    LetterText: () => LetterText,
    Library: () => Library,
    LibraryBig: () => LibraryBig,
    LibrarySquare: () => SquareLibrary,
    LifeBuoy: () => LifeBuoy,
    Ligature: () => Ligature,
    Lightbulb: () => Lightbulb,
    LightbulbOff: () => LightbulbOff,
    LineChart: () => ChartLine,
    Link: () => Link,
    Link2: () => Link2,
    Link2Off: () => Link2Off,
    Linkedin: () => Linkedin,
    List: () => List,
    ListCheck: () => ListCheck,
    ListChecks: () => ListChecks,
    ListCollapse: () => ListCollapse,
    ListEnd: () => ListEnd,
    ListFilter: () => ListFilter,
    ListFilterPlus: () => ListFilterPlus,
    ListMinus: () => ListMinus,
    ListMusic: () => ListMusic,
    ListOrdered: () => ListOrdered,
    ListPlus: () => ListPlus,
    ListRestart: () => ListRestart,
    ListStart: () => ListStart,
    ListTodo: () => ListTodo,
    ListTree: () => ListTree,
    ListVideo: () => ListVideo,
    ListX: () => ListX,
    Loader: () => Loader,
    Loader2: () => LoaderCircle,
    LoaderCircle: () => LoaderCircle,
    LoaderPinwheel: () => LoaderPinwheel,
    Locate: () => Locate,
    LocateFixed: () => LocateFixed,
    LocateOff: () => LocateOff,
    LocationEdit: () => LocationEdit,
    Lock: () => Lock,
    LockKeyhole: () => LockKeyhole,
    LockKeyholeOpen: () => LockKeyholeOpen,
    LockOpen: () => LockOpen,
    LogIn: () => LogIn,
    LogOut: () => LogOut,
    Logs: () => Logs,
    Lollipop: () => Lollipop,
    Luggage: () => Luggage,
    MSquare: () => SquareM,
    Magnet: () => Magnet,
    Mail: () => Mail,
    MailCheck: () => MailCheck,
    MailMinus: () => MailMinus,
    MailOpen: () => MailOpen,
    MailPlus: () => MailPlus,
    MailQuestion: () => MailQuestion,
    MailSearch: () => MailSearch,
    MailWarning: () => MailWarning,
    MailX: () => MailX,
    Mailbox: () => Mailbox,
    Mails: () => Mails,
    Map: () => Map2,
    MapPin: () => MapPin,
    MapPinCheck: () => MapPinCheck,
    MapPinCheckInside: () => MapPinCheckInside,
    MapPinHouse: () => MapPinHouse,
    MapPinMinus: () => MapPinMinus,
    MapPinMinusInside: () => MapPinMinusInside,
    MapPinOff: () => MapPinOff,
    MapPinPlus: () => MapPinPlus,
    MapPinPlusInside: () => MapPinPlusInside,
    MapPinX: () => MapPinX,
    MapPinXInside: () => MapPinXInside,
    MapPinned: () => MapPinned,
    MapPlus: () => MapPlus,
    Mars: () => Mars,
    MarsStroke: () => MarsStroke,
    Martini: () => Martini,
    Maximize: () => Maximize,
    Maximize2: () => Maximize2,
    Medal: () => Medal,
    Megaphone: () => Megaphone,
    MegaphoneOff: () => MegaphoneOff,
    Meh: () => Meh,
    MemoryStick: () => MemoryStick,
    Menu: () => Menu,
    MenuSquare: () => SquareMenu,
    Merge: () => Merge,
    MessageCircle: () => MessageCircle,
    MessageCircleCode: () => MessageCircleCode,
    MessageCircleDashed: () => MessageCircleDashed,
    MessageCircleHeart: () => MessageCircleHeart,
    MessageCircleMore: () => MessageCircleMore,
    MessageCircleOff: () => MessageCircleOff,
    MessageCirclePlus: () => MessageCirclePlus,
    MessageCircleQuestion: () => MessageCircleQuestion,
    MessageCircleReply: () => MessageCircleReply,
    MessageCircleWarning: () => MessageCircleWarning,
    MessageCircleX: () => MessageCircleX,
    MessageSquare: () => MessageSquare,
    MessageSquareCode: () => MessageSquareCode,
    MessageSquareDashed: () => MessageSquareDashed,
    MessageSquareDiff: () => MessageSquareDiff,
    MessageSquareDot: () => MessageSquareDot,
    MessageSquareHeart: () => MessageSquareHeart,
    MessageSquareLock: () => MessageSquareLock,
    MessageSquareMore: () => MessageSquareMore,
    MessageSquareOff: () => MessageSquareOff,
    MessageSquarePlus: () => MessageSquarePlus,
    MessageSquareQuote: () => MessageSquareQuote,
    MessageSquareReply: () => MessageSquareReply,
    MessageSquareShare: () => MessageSquareShare,
    MessageSquareText: () => MessageSquareText,
    MessageSquareWarning: () => MessageSquareWarning,
    MessageSquareX: () => MessageSquareX,
    MessagesSquare: () => MessagesSquare,
    Mic: () => Mic,
    Mic2: () => MicVocal,
    MicOff: () => MicOff,
    MicVocal: () => MicVocal,
    Microchip: () => Microchip,
    Microscope: () => Microscope,
    Microwave: () => Microwave,
    Milestone: () => Milestone,
    Milk: () => Milk,
    MilkOff: () => MilkOff,
    Minimize: () => Minimize,
    Minimize2: () => Minimize2,
    Minus: () => Minus,
    MinusCircle: () => CircleMinus,
    MinusSquare: () => SquareMinus,
    Monitor: () => Monitor,
    MonitorCheck: () => MonitorCheck,
    MonitorCog: () => MonitorCog,
    MonitorDot: () => MonitorDot,
    MonitorDown: () => MonitorDown,
    MonitorOff: () => MonitorOff,
    MonitorPause: () => MonitorPause,
    MonitorPlay: () => MonitorPlay,
    MonitorSmartphone: () => MonitorSmartphone,
    MonitorSpeaker: () => MonitorSpeaker,
    MonitorStop: () => MonitorStop,
    MonitorUp: () => MonitorUp,
    MonitorX: () => MonitorX,
    Moon: () => Moon,
    MoonStar: () => MoonStar,
    MoreHorizontal: () => Ellipsis,
    MoreVertical: () => EllipsisVertical,
    Mountain: () => Mountain,
    MountainSnow: () => MountainSnow,
    Mouse: () => Mouse,
    MouseOff: () => MouseOff,
    MousePointer: () => MousePointer,
    MousePointer2: () => MousePointer2,
    MousePointerBan: () => MousePointerBan,
    MousePointerClick: () => MousePointerClick,
    MousePointerSquareDashed: () => SquareDashedMousePointer,
    Move: () => Move,
    Move3D: () => Move3d,
    Move3d: () => Move3d,
    MoveDiagonal: () => MoveDiagonal,
    MoveDiagonal2: () => MoveDiagonal2,
    MoveDown: () => MoveDown,
    MoveDownLeft: () => MoveDownLeft,
    MoveDownRight: () => MoveDownRight,
    MoveHorizontal: () => MoveHorizontal,
    MoveLeft: () => MoveLeft,
    MoveRight: () => MoveRight,
    MoveUp: () => MoveUp,
    MoveUpLeft: () => MoveUpLeft,
    MoveUpRight: () => MoveUpRight,
    MoveVertical: () => MoveVertical,
    Music: () => Music,
    Music2: () => Music2,
    Music3: () => Music3,
    Music4: () => Music4,
    Navigation: () => Navigation,
    Navigation2: () => Navigation2,
    Navigation2Off: () => Navigation2Off,
    NavigationOff: () => NavigationOff,
    Network: () => Network,
    Newspaper: () => Newspaper,
    Nfc: () => Nfc,
    NonBinary: () => NonBinary,
    Notebook: () => Notebook,
    NotebookPen: () => NotebookPen,
    NotebookTabs: () => NotebookTabs,
    NotebookText: () => NotebookText,
    NotepadText: () => NotepadText,
    NotepadTextDashed: () => NotepadTextDashed,
    Nut: () => Nut,
    NutOff: () => NutOff,
    Octagon: () => Octagon,
    OctagonAlert: () => OctagonAlert,
    OctagonMinus: () => OctagonMinus,
    OctagonPause: () => OctagonPause,
    OctagonX: () => OctagonX,
    Omega: () => Omega,
    Option: () => Option,
    Orbit: () => Orbit,
    Origami: () => Origami,
    Outdent: () => IndentDecrease,
    Package: () => Package,
    Package2: () => Package2,
    PackageCheck: () => PackageCheck,
    PackageMinus: () => PackageMinus,
    PackageOpen: () => PackageOpen,
    PackagePlus: () => PackagePlus,
    PackageSearch: () => PackageSearch,
    PackageX: () => PackageX,
    PaintBucket: () => PaintBucket,
    PaintRoller: () => PaintRoller,
    Paintbrush: () => Paintbrush,
    Paintbrush2: () => PaintbrushVertical,
    PaintbrushVertical: () => PaintbrushVertical,
    Palette: () => Palette,
    Palmtree: () => TreePalm,
    PanelBottom: () => PanelBottom,
    PanelBottomClose: () => PanelBottomClose,
    PanelBottomDashed: () => PanelBottomDashed,
    PanelBottomInactive: () => PanelBottomDashed,
    PanelBottomOpen: () => PanelBottomOpen,
    PanelLeft: () => PanelLeft,
    PanelLeftClose: () => PanelLeftClose,
    PanelLeftDashed: () => PanelLeftDashed,
    PanelLeftInactive: () => PanelLeftDashed,
    PanelLeftOpen: () => PanelLeftOpen,
    PanelRight: () => PanelRight,
    PanelRightClose: () => PanelRightClose,
    PanelRightDashed: () => PanelRightDashed,
    PanelRightInactive: () => PanelRightDashed,
    PanelRightOpen: () => PanelRightOpen,
    PanelTop: () => PanelTop,
    PanelTopClose: () => PanelTopClose,
    PanelTopDashed: () => PanelTopDashed,
    PanelTopInactive: () => PanelTopDashed,
    PanelTopOpen: () => PanelTopOpen,
    PanelsLeftBottom: () => PanelsLeftBottom,
    PanelsLeftRight: () => Columns3,
    PanelsRightBottom: () => PanelsRightBottom,
    PanelsTopBottom: () => Rows3,
    PanelsTopLeft: () => PanelsTopLeft,
    Paperclip: () => Paperclip,
    Parentheses: () => Parentheses,
    ParkingCircle: () => CircleParking,
    ParkingCircleOff: () => CircleParkingOff,
    ParkingMeter: () => ParkingMeter,
    ParkingSquare: () => SquareParking,
    ParkingSquareOff: () => SquareParkingOff,
    PartyPopper: () => PartyPopper,
    Pause: () => Pause,
    PauseCircle: () => CirclePause,
    PauseOctagon: () => OctagonPause,
    PawPrint: () => PawPrint,
    PcCase: () => PcCase,
    Pen: () => Pen,
    PenBox: () => SquarePen,
    PenLine: () => PenLine,
    PenOff: () => PenOff,
    PenSquare: () => SquarePen,
    PenTool: () => PenTool,
    Pencil: () => Pencil,
    PencilLine: () => PencilLine,
    PencilOff: () => PencilOff,
    PencilRuler: () => PencilRuler,
    Pentagon: () => Pentagon,
    Percent: () => Percent,
    PercentCircle: () => CirclePercent,
    PercentDiamond: () => DiamondPercent,
    PercentSquare: () => SquarePercent,
    PersonStanding: () => PersonStanding,
    PhilippinePeso: () => PhilippinePeso,
    Phone: () => Phone,
    PhoneCall: () => PhoneCall,
    PhoneForwarded: () => PhoneForwarded,
    PhoneIncoming: () => PhoneIncoming,
    PhoneMissed: () => PhoneMissed,
    PhoneOff: () => PhoneOff,
    PhoneOutgoing: () => PhoneOutgoing,
    Pi: () => Pi,
    PiSquare: () => SquarePi,
    Piano: () => Piano,
    Pickaxe: () => Pickaxe,
    PictureInPicture: () => PictureInPicture,
    PictureInPicture2: () => PictureInPicture2,
    PieChart: () => ChartPie,
    PiggyBank: () => PiggyBank,
    Pilcrow: () => Pilcrow,
    PilcrowLeft: () => PilcrowLeft,
    PilcrowRight: () => PilcrowRight,
    PilcrowSquare: () => SquarePilcrow,
    Pill: () => Pill,
    PillBottle: () => PillBottle,
    Pin: () => Pin,
    PinOff: () => PinOff,
    Pipette: () => Pipette,
    Pizza: () => Pizza,
    Plane: () => Plane,
    PlaneLanding: () => PlaneLanding,
    PlaneTakeoff: () => PlaneTakeoff,
    Play: () => Play,
    PlayCircle: () => CirclePlay,
    PlaySquare: () => SquarePlay,
    Plug: () => Plug,
    Plug2: () => Plug2,
    PlugZap: () => PlugZap,
    PlugZap2: () => PlugZap,
    Plus: () => Plus,
    PlusCircle: () => CirclePlus,
    PlusSquare: () => SquarePlus,
    Pocket: () => Pocket,
    PocketKnife: () => PocketKnife,
    Podcast: () => Podcast,
    Pointer: () => Pointer,
    PointerOff: () => PointerOff,
    Popcorn: () => Popcorn,
    Popsicle: () => Popsicle,
    PoundSterling: () => PoundSterling,
    Power: () => Power,
    PowerCircle: () => CirclePower,
    PowerOff: () => PowerOff,
    PowerSquare: () => SquarePower,
    Presentation: () => Presentation,
    Printer: () => Printer,
    PrinterCheck: () => PrinterCheck,
    Projector: () => Projector,
    Proportions: () => Proportions,
    Puzzle: () => Puzzle,
    Pyramid: () => Pyramid,
    QrCode: () => QrCode,
    Quote: () => Quote,
    Rabbit: () => Rabbit,
    Radar: () => Radar,
    Radiation: () => Radiation,
    Radical: () => Radical,
    Radio: () => Radio,
    RadioReceiver: () => RadioReceiver,
    RadioTower: () => RadioTower,
    Radius: () => Radius,
    RailSymbol: () => RailSymbol,
    Rainbow: () => Rainbow,
    Rat: () => Rat,
    Ratio: () => Ratio,
    Receipt: () => Receipt,
    ReceiptCent: () => ReceiptCent,
    ReceiptEuro: () => ReceiptEuro,
    ReceiptIndianRupee: () => ReceiptIndianRupee,
    ReceiptJapaneseYen: () => ReceiptJapaneseYen,
    ReceiptPoundSterling: () => ReceiptPoundSterling,
    ReceiptRussianRuble: () => ReceiptRussianRuble,
    ReceiptSwissFranc: () => ReceiptSwissFranc,
    ReceiptText: () => ReceiptText,
    RectangleEllipsis: () => RectangleEllipsis,
    RectangleGoggles: () => RectangleGoggles,
    RectangleHorizontal: () => RectangleHorizontal,
    RectangleVertical: () => RectangleVertical,
    Recycle: () => Recycle,
    Redo: () => Redo,
    Redo2: () => Redo2,
    RedoDot: () => RedoDot,
    RefreshCcw: () => RefreshCcw,
    RefreshCcwDot: () => RefreshCcwDot,
    RefreshCw: () => RefreshCw,
    RefreshCwOff: () => RefreshCwOff,
    Refrigerator: () => Refrigerator,
    Regex: () => Regex,
    RemoveFormatting: () => RemoveFormatting,
    Repeat: () => Repeat,
    Repeat1: () => Repeat1,
    Repeat2: () => Repeat2,
    Replace: () => Replace,
    ReplaceAll: () => ReplaceAll,
    Reply: () => Reply,
    ReplyAll: () => ReplyAll,
    Rewind: () => Rewind,
    Ribbon: () => Ribbon,
    Rocket: () => Rocket,
    RockingChair: () => RockingChair,
    RollerCoaster: () => RollerCoaster,
    Rotate3D: () => Rotate3d,
    Rotate3d: () => Rotate3d,
    RotateCcw: () => RotateCcw,
    RotateCcwKey: () => RotateCcwKey,
    RotateCcwSquare: () => RotateCcwSquare,
    RotateCw: () => RotateCw,
    RotateCwSquare: () => RotateCwSquare,
    Route: () => Route,
    RouteOff: () => RouteOff,
    Router: () => Router2,
    Rows: () => Rows2,
    Rows2: () => Rows2,
    Rows3: () => Rows3,
    Rows4: () => Rows4,
    Rss: () => Rss,
    Ruler: () => Ruler,
    RulerDimensionLine: () => RulerDimensionLine,
    RussianRuble: () => RussianRuble,
    Sailboat: () => Sailboat,
    Salad: () => Salad,
    Sandwich: () => Sandwich,
    Satellite: () => Satellite,
    SatelliteDish: () => SatelliteDish,
    SaudiRiyal: () => SaudiRiyal,
    Save: () => Save,
    SaveAll: () => SaveAll,
    SaveOff: () => SaveOff,
    Scale: () => Scale,
    Scale3D: () => Scale3d,
    Scale3d: () => Scale3d,
    Scaling: () => Scaling,
    Scan: () => Scan,
    ScanBarcode: () => ScanBarcode,
    ScanEye: () => ScanEye,
    ScanFace: () => ScanFace,
    ScanHeart: () => ScanHeart,
    ScanLine: () => ScanLine,
    ScanQrCode: () => ScanQrCode,
    ScanSearch: () => ScanSearch,
    ScanText: () => ScanText,
    ScatterChart: () => ChartScatter,
    School: () => School,
    School2: () => University,
    Scissors: () => Scissors,
    ScissorsLineDashed: () => ScissorsLineDashed,
    ScissorsSquare: () => SquareScissors,
    ScissorsSquareDashedBottom: () => SquareBottomDashedScissors,
    ScreenShare: () => ScreenShare,
    ScreenShareOff: () => ScreenShareOff,
    Scroll: () => Scroll,
    ScrollText: () => ScrollText,
    Search: () => Search,
    SearchCheck: () => SearchCheck,
    SearchCode: () => SearchCode,
    SearchSlash: () => SearchSlash,
    SearchX: () => SearchX,
    Section: () => Section,
    Send: () => Send,
    SendHorizonal: () => SendHorizontal,
    SendHorizontal: () => SendHorizontal,
    SendToBack: () => SendToBack,
    SeparatorHorizontal: () => SeparatorHorizontal,
    SeparatorVertical: () => SeparatorVertical,
    Server: () => Server,
    ServerCog: () => ServerCog,
    ServerCrash: () => ServerCrash,
    ServerOff: () => ServerOff,
    Settings: () => Settings,
    Settings2: () => Settings2,
    Shapes: () => Shapes,
    Share: () => Share,
    Share2: () => Share2,
    Sheet: () => Sheet,
    Shell: () => Shell,
    Shield: () => Shield,
    ShieldAlert: () => ShieldAlert,
    ShieldBan: () => ShieldBan,
    ShieldCheck: () => ShieldCheck,
    ShieldClose: () => ShieldX,
    ShieldEllipsis: () => ShieldEllipsis,
    ShieldHalf: () => ShieldHalf,
    ShieldMinus: () => ShieldMinus,
    ShieldOff: () => ShieldOff,
    ShieldPlus: () => ShieldPlus,
    ShieldQuestion: () => ShieldQuestion,
    ShieldUser: () => ShieldUser,
    ShieldX: () => ShieldX,
    Ship: () => Ship,
    ShipWheel: () => ShipWheel,
    Shirt: () => Shirt,
    ShoppingBag: () => ShoppingBag,
    ShoppingBasket: () => ShoppingBasket,
    ShoppingCart: () => ShoppingCart,
    Shovel: () => Shovel,
    ShowerHead: () => ShowerHead,
    Shredder: () => Shredder,
    Shrimp: () => Shrimp,
    Shrink: () => Shrink,
    Shrub: () => Shrub,
    Shuffle: () => Shuffle,
    Sidebar: () => PanelLeft,
    SidebarClose: () => PanelLeftClose,
    SidebarOpen: () => PanelLeftOpen,
    Sigma: () => Sigma,
    SigmaSquare: () => SquareSigma,
    Signal: () => Signal,
    SignalHigh: () => SignalHigh,
    SignalLow: () => SignalLow,
    SignalMedium: () => SignalMedium,
    SignalZero: () => SignalZero,
    Signature: () => Signature,
    Signpost: () => Signpost,
    SignpostBig: () => SignpostBig,
    Siren: () => Siren,
    SkipBack: () => SkipBack,
    SkipForward: () => SkipForward,
    Skull: () => Skull,
    Slack: () => Slack,
    Slash: () => Slash,
    SlashSquare: () => SquareSlash,
    Slice: () => Slice2,
    Sliders: () => SlidersVertical,
    SlidersHorizontal: () => SlidersHorizontal,
    SlidersVertical: () => SlidersVertical,
    Smartphone: () => Smartphone,
    SmartphoneCharging: () => SmartphoneCharging,
    SmartphoneNfc: () => SmartphoneNfc,
    Smile: () => Smile,
    SmilePlus: () => SmilePlus,
    Snail: () => Snail,
    Snowflake: () => Snowflake,
    SoapDispenserDroplet: () => SoapDispenserDroplet,
    Sofa: () => Sofa,
    SortAsc: () => ArrowUpNarrowWide,
    SortDesc: () => ArrowDownWideNarrow,
    Soup: () => Soup,
    Space: () => Space,
    Spade: () => Spade,
    Sparkle: () => Sparkle,
    Sparkles: () => Sparkles,
    Speaker: () => Speaker,
    Speech: () => Speech,
    SpellCheck: () => SpellCheck,
    SpellCheck2: () => SpellCheck2,
    Spline: () => Spline,
    SplinePointer: () => SplinePointer,
    Split: () => Split,
    SplitSquareHorizontal: () => SquareSplitHorizontal,
    SplitSquareVertical: () => SquareSplitVertical,
    SprayCan: () => SprayCan,
    Sprout: () => Sprout,
    Square: () => Square,
    SquareActivity: () => SquareActivity,
    SquareArrowDown: () => SquareArrowDown,
    SquareArrowDownLeft: () => SquareArrowDownLeft,
    SquareArrowDownRight: () => SquareArrowDownRight,
    SquareArrowLeft: () => SquareArrowLeft,
    SquareArrowOutDownLeft: () => SquareArrowOutDownLeft,
    SquareArrowOutDownRight: () => SquareArrowOutDownRight,
    SquareArrowOutUpLeft: () => SquareArrowOutUpLeft,
    SquareArrowOutUpRight: () => SquareArrowOutUpRight,
    SquareArrowRight: () => SquareArrowRight,
    SquareArrowUp: () => SquareArrowUp,
    SquareArrowUpLeft: () => SquareArrowUpLeft,
    SquareArrowUpRight: () => SquareArrowUpRight,
    SquareAsterisk: () => SquareAsterisk,
    SquareBottomDashedScissors: () => SquareBottomDashedScissors,
    SquareChartGantt: () => SquareChartGantt,
    SquareCheck: () => SquareCheck,
    SquareCheckBig: () => SquareCheckBig,
    SquareChevronDown: () => SquareChevronDown,
    SquareChevronLeft: () => SquareChevronLeft,
    SquareChevronRight: () => SquareChevronRight,
    SquareChevronUp: () => SquareChevronUp,
    SquareCode: () => SquareCode,
    SquareDashed: () => SquareDashed,
    SquareDashedBottom: () => SquareDashedBottom,
    SquareDashedBottomCode: () => SquareDashedBottomCode,
    SquareDashedKanban: () => SquareDashedKanban,
    SquareDashedMousePointer: () => SquareDashedMousePointer,
    SquareDivide: () => SquareDivide,
    SquareDot: () => SquareDot,
    SquareEqual: () => SquareEqual,
    SquareFunction: () => SquareFunction,
    SquareGanttChart: () => SquareChartGantt,
    SquareKanban: () => SquareKanban,
    SquareLibrary: () => SquareLibrary,
    SquareM: () => SquareM,
    SquareMenu: () => SquareMenu,
    SquareMinus: () => SquareMinus,
    SquareMousePointer: () => SquareMousePointer,
    SquareParking: () => SquareParking,
    SquareParkingOff: () => SquareParkingOff,
    SquarePen: () => SquarePen,
    SquarePercent: () => SquarePercent,
    SquarePi: () => SquarePi,
    SquarePilcrow: () => SquarePilcrow,
    SquarePlay: () => SquarePlay,
    SquarePlus: () => SquarePlus,
    SquarePower: () => SquarePower,
    SquareRadical: () => SquareRadical,
    SquareRoundCorner: () => SquareRoundCorner,
    SquareScissors: () => SquareScissors,
    SquareSigma: () => SquareSigma,
    SquareSlash: () => SquareSlash,
    SquareSplitHorizontal: () => SquareSplitHorizontal,
    SquareSplitVertical: () => SquareSplitVertical,
    SquareSquare: () => SquareSquare,
    SquareStack: () => SquareStack,
    SquareTerminal: () => SquareTerminal,
    SquareUser: () => SquareUser,
    SquareUserRound: () => SquareUserRound,
    SquareX: () => SquareX,
    SquaresExclude: () => SquaresExclude,
    SquaresIntersect: () => SquaresIntersect,
    SquaresSubtract: () => SquaresSubtract,
    SquaresUnite: () => SquaresUnite,
    Squircle: () => Squircle,
    Squirrel: () => Squirrel,
    Stamp: () => Stamp,
    Star: () => Star,
    StarHalf: () => StarHalf,
    StarOff: () => StarOff,
    Stars: () => Sparkles,
    StepBack: () => StepBack,
    StepForward: () => StepForward,
    Stethoscope: () => Stethoscope,
    Sticker: () => Sticker,
    StickyNote: () => StickyNote,
    StopCircle: () => CircleStop,
    Store: () => Store,
    StretchHorizontal: () => StretchHorizontal,
    StretchVertical: () => StretchVertical,
    Strikethrough: () => Strikethrough,
    Subscript: () => Subscript,
    Subtitles: () => Captions,
    Sun: () => Sun,
    SunDim: () => SunDim,
    SunMedium: () => SunMedium,
    SunMoon: () => SunMoon,
    SunSnow: () => SunSnow,
    Sunrise: () => Sunrise,
    Sunset: () => Sunset,
    Superscript: () => Superscript,
    SwatchBook: () => SwatchBook,
    SwissFranc: () => SwissFranc,
    SwitchCamera: () => SwitchCamera,
    Sword: () => Sword,
    Swords: () => Swords,
    Syringe: () => Syringe,
    Table: () => Table3,
    Table2: () => Table2,
    TableCellsMerge: () => TableCellsMerge,
    TableCellsSplit: () => TableCellsSplit,
    TableColumnsSplit: () => TableColumnsSplit,
    TableConfig: () => Columns3Cog,
    TableOfContents: () => TableOfContents,
    TableProperties: () => TableProperties,
    TableRowsSplit: () => TableRowsSplit,
    Tablet: () => Tablet,
    TabletSmartphone: () => TabletSmartphone,
    Tablets: () => Tablets,
    Tag: () => Tag,
    Tags: () => Tags,
    Tally1: () => Tally1,
    Tally2: () => Tally2,
    Tally3: () => Tally3,
    Tally4: () => Tally4,
    Tally5: () => Tally5,
    Tangent: () => Tangent,
    Target: () => Target,
    Telescope: () => Telescope,
    Tent: () => Tent,
    TentTree: () => TentTree,
    Terminal: () => Terminal,
    TerminalSquare: () => SquareTerminal,
    TestTube: () => TestTube,
    TestTube2: () => TestTubeDiagonal,
    TestTubeDiagonal: () => TestTubeDiagonal,
    TestTubes: () => TestTubes,
    Text: () => Text2,
    TextCursor: () => TextCursor,
    TextCursorInput: () => TextCursorInput,
    TextQuote: () => TextQuote,
    TextSearch: () => TextSearch,
    TextSelect: () => TextSelect,
    TextSelection: () => TextSelect,
    Theater: () => Theater,
    Thermometer: () => Thermometer,
    ThermometerSnowflake: () => ThermometerSnowflake,
    ThermometerSun: () => ThermometerSun,
    ThumbsDown: () => ThumbsDown,
    ThumbsUp: () => ThumbsUp,
    Ticket: () => Ticket,
    TicketCheck: () => TicketCheck,
    TicketMinus: () => TicketMinus,
    TicketPercent: () => TicketPercent,
    TicketPlus: () => TicketPlus,
    TicketSlash: () => TicketSlash,
    TicketX: () => TicketX,
    Tickets: () => Tickets,
    TicketsPlane: () => TicketsPlane,
    Timer: () => Timer,
    TimerOff: () => TimerOff,
    TimerReset: () => TimerReset,
    ToggleLeft: () => ToggleLeft,
    ToggleRight: () => ToggleRight,
    Toilet: () => Toilet,
    Tornado: () => Tornado,
    Torus: () => Torus,
    Touchpad: () => Touchpad,
    TouchpadOff: () => TouchpadOff,
    TowerControl: () => TowerControl,
    ToyBrick: () => ToyBrick,
    Tractor: () => Tractor,
    TrafficCone: () => TrafficCone,
    Train: () => TramFront,
    TrainFront: () => TrainFront,
    TrainFrontTunnel: () => TrainFrontTunnel,
    TrainTrack: () => TrainTrack,
    TramFront: () => TramFront,
    Transgender: () => Transgender,
    Trash: () => Trash,
    Trash2: () => Trash2,
    TreeDeciduous: () => TreeDeciduous,
    TreePalm: () => TreePalm,
    TreePine: () => TreePine,
    Trees: () => Trees,
    Trello: () => Trello,
    TrendingDown: () => TrendingDown,
    TrendingUp: () => TrendingUp,
    TrendingUpDown: () => TrendingUpDown,
    Triangle: () => Triangle,
    TriangleAlert: () => TriangleAlert,
    TriangleDashed: () => TriangleDashed,
    TriangleRight: () => TriangleRight,
    Trophy: () => Trophy,
    Truck: () => Truck,
    TruckElectric: () => TruckElectric,
    Turtle: () => Turtle,
    Tv: () => Tv,
    Tv2: () => TvMinimal,
    TvMinimal: () => TvMinimal,
    TvMinimalPlay: () => TvMinimalPlay,
    Twitch: () => Twitch,
    Twitter: () => Twitter,
    Type: () => Type,
    TypeOutline: () => TypeOutline,
    Umbrella: () => Umbrella,
    UmbrellaOff: () => UmbrellaOff,
    Underline: () => Underline,
    Undo: () => Undo,
    Undo2: () => Undo2,
    UndoDot: () => UndoDot,
    UnfoldHorizontal: () => UnfoldHorizontal,
    UnfoldVertical: () => UnfoldVertical,
    Ungroup: () => Ungroup,
    University: () => University,
    Unlink: () => Unlink,
    Unlink2: () => Unlink2,
    Unlock: () => LockOpen,
    UnlockKeyhole: () => LockKeyholeOpen,
    Unplug: () => Unplug,
    Upload: () => Upload,
    UploadCloud: () => CloudUpload,
    Usb: () => Usb,
    User: () => User,
    User2: () => UserRound,
    UserCheck: () => UserCheck,
    UserCheck2: () => UserRoundCheck,
    UserCircle: () => CircleUser,
    UserCircle2: () => CircleUserRound,
    UserCog: () => UserCog,
    UserCog2: () => UserRoundCog,
    UserLock: () => UserLock,
    UserMinus: () => UserMinus,
    UserMinus2: () => UserRoundMinus,
    UserPen: () => UserPen,
    UserPlus: () => UserPlus,
    UserPlus2: () => UserRoundPlus,
    UserRound: () => UserRound,
    UserRoundCheck: () => UserRoundCheck,
    UserRoundCog: () => UserRoundCog,
    UserRoundMinus: () => UserRoundMinus,
    UserRoundPen: () => UserRoundPen,
    UserRoundPlus: () => UserRoundPlus,
    UserRoundSearch: () => UserRoundSearch,
    UserRoundX: () => UserRoundX,
    UserSearch: () => UserSearch,
    UserSquare: () => SquareUser,
    UserSquare2: () => SquareUserRound,
    UserX: () => UserX,
    UserX2: () => UserRoundX,
    Users: () => Users,
    Users2: () => UsersRound,
    UsersRound: () => UsersRound,
    Utensils: () => Utensils,
    UtensilsCrossed: () => UtensilsCrossed,
    UtilityPole: () => UtilityPole,
    Variable: () => Variable,
    Vault: () => Vault,
    Vegan: () => Vegan,
    VenetianMask: () => VenetianMask,
    Venus: () => Venus,
    VenusAndMars: () => VenusAndMars,
    Verified: () => BadgeCheck,
    Vibrate: () => Vibrate,
    VibrateOff: () => VibrateOff,
    Video: () => Video,
    VideoOff: () => VideoOff,
    Videotape: () => Videotape,
    View: () => View2,
    Voicemail: () => Voicemail,
    Volleyball: () => Volleyball,
    Volume: () => Volume,
    Volume1: () => Volume1,
    Volume2: () => Volume2,
    VolumeOff: () => VolumeOff,
    VolumeX: () => VolumeX,
    Vote: () => Vote,
    Wallet: () => Wallet,
    Wallet2: () => WalletMinimal,
    WalletCards: () => WalletCards,
    WalletMinimal: () => WalletMinimal,
    Wallpaper: () => Wallpaper,
    Wand: () => Wand,
    Wand2: () => WandSparkles,
    WandSparkles: () => WandSparkles,
    Warehouse: () => Warehouse,
    WashingMachine: () => WashingMachine,
    Watch: () => Watch,
    Waves: () => Waves,
    WavesLadder: () => WavesLadder,
    Waypoints: () => Waypoints,
    Webcam: () => Webcam,
    Webhook: () => Webhook,
    WebhookOff: () => WebhookOff,
    Weight: () => Weight,
    Wheat: () => Wheat,
    WheatOff: () => WheatOff,
    WholeWord: () => WholeWord,
    Wifi: () => Wifi,
    WifiHigh: () => WifiHigh,
    WifiLow: () => WifiLow,
    WifiOff: () => WifiOff,
    WifiPen: () => WifiPen,
    WifiZero: () => WifiZero,
    Wind: () => Wind,
    WindArrowDown: () => WindArrowDown,
    Wine: () => Wine,
    WineOff: () => WineOff,
    Workflow: () => Workflow,
    Worm: () => Worm,
    WrapText: () => WrapText,
    Wrench: () => Wrench,
    X: () => X,
    XCircle: () => CircleX,
    XOctagon: () => OctagonX,
    XSquare: () => SquareX,
    Youtube: () => Youtube,
    Zap: () => Zap,
    ZapOff: () => ZapOff,
    ZoomIn: () => ZoomIn,
    ZoomOut: () => ZoomOut
  });

  // node_modules/lucide/dist/esm/icons/a-arrow-down.js
  var AArrowDown = [
    ["path", { d: "M3.5 13h6" }],
    ["path", { d: "m2 16 4.5-9 4.5 9" }],
    ["path", { d: "M18 7v9" }],
    ["path", { d: "m14 12 4 4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/a-arrow-up.js
  var AArrowUp = [
    ["path", { d: "M3.5 13h6" }],
    ["path", { d: "m2 16 4.5-9 4.5 9" }],
    ["path", { d: "M18 16V7" }],
    ["path", { d: "m14 11 4-4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/a-large-small.js
  var ALargeSmall = [
    ["path", { d: "M21 14h-5" }],
    ["path", { d: "M16 16v-3.5a2.5 2.5 0 0 1 5 0V16" }],
    ["path", { d: "M4.5 13h6" }],
    ["path", { d: "m3 16 4.5-9 4.5 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/accessibility.js
  var Accessibility = [
    ["circle", { cx: "16", cy: "4", r: "1" }],
    ["path", { d: "m18 19 1-7-6 1" }],
    ["path", { d: "m5 8 3-3 5.5 3-2.36 3.5" }],
    ["path", { d: "M4.24 14.5a5 5 0 0 0 6.88 6" }],
    ["path", { d: "M13.76 17.5a5 5 0 0 0-6.88-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/activity.js
  var Activity = [
    [
      "path",
      {
        d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/air-vent.js
  var AirVent = [
    ["path", { d: "M18 17.5a2.5 2.5 0 1 1-4 2.03V12" }],
    ["path", { d: "M6 12H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M6 8h12" }],
    ["path", { d: "M6.6 15.572A2 2 0 1 0 10 17v-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/airplay.js
  var Airplay = [
    ["path", { d: "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1" }],
    ["path", { d: "m12 15 5 6H7Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-clock-check.js
  var AlarmClockCheck = [
    ["circle", { cx: "12", cy: "13", r: "8" }],
    ["path", { d: "M5 3 2 6" }],
    ["path", { d: "m22 6-3-3" }],
    ["path", { d: "M6.38 18.7 4 21" }],
    ["path", { d: "M17.64 18.67 20 21" }],
    ["path", { d: "m9 13 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-clock-minus.js
  var AlarmClockMinus = [
    ["circle", { cx: "12", cy: "13", r: "8" }],
    ["path", { d: "M5 3 2 6" }],
    ["path", { d: "m22 6-3-3" }],
    ["path", { d: "M6.38 18.7 4 21" }],
    ["path", { d: "M17.64 18.67 20 21" }],
    ["path", { d: "M9 13h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-clock-off.js
  var AlarmClockOff = [
    ["path", { d: "M6.87 6.87a8 8 0 1 0 11.26 11.26" }],
    ["path", { d: "M19.9 14.25a8 8 0 0 0-9.15-9.15" }],
    ["path", { d: "m22 6-3-3" }],
    ["path", { d: "M6.26 18.67 4 21" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M4 4 2 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-clock-plus.js
  var AlarmClockPlus = [
    ["circle", { cx: "12", cy: "13", r: "8" }],
    ["path", { d: "M5 3 2 6" }],
    ["path", { d: "m22 6-3-3" }],
    ["path", { d: "M6.38 18.7 4 21" }],
    ["path", { d: "M17.64 18.67 20 21" }],
    ["path", { d: "M12 10v6" }],
    ["path", { d: "M9 13h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-clock.js
  var AlarmClock = [
    ["circle", { cx: "12", cy: "13", r: "8" }],
    ["path", { d: "M12 9v4l2 2" }],
    ["path", { d: "M5 3 2 6" }],
    ["path", { d: "m22 6-3-3" }],
    ["path", { d: "M6.38 18.7 4 21" }],
    ["path", { d: "M17.64 18.67 20 21" }]
  ];

  // node_modules/lucide/dist/esm/icons/alarm-smoke.js
  var AlarmSmoke = [
    ["path", { d: "M11 21c0-2.5 2-2.5 2-5" }],
    ["path", { d: "M16 21c0-2.5 2-2.5 2-5" }],
    ["path", { d: "m19 8-.8 3a1.25 1.25 0 0 1-1.2 1H7a1.25 1.25 0 0 1-1.2-1L5 8" }],
    ["path", { d: "M21 3a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a1 1 0 0 1 1-1z" }],
    ["path", { d: "M6 21c0-2.5 2-2.5 2-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/album.js
  var Album = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["polyline", { points: "11 3 11 11 14 8 17 11 17 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-center-vertical.js
  var AlignCenterVertical = [
    ["path", { d: "M12 2v20" }],
    ["path", { d: "M8 10H4a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h4" }],
    ["path", { d: "M16 10h4a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-4" }],
    ["path", { d: "M8 20H7a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2h1" }],
    ["path", { d: "M16 14h1a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-center-horizontal.js
  var AlignCenterHorizontal = [
    ["path", { d: "M2 12h20" }],
    ["path", { d: "M10 16v4a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-4" }],
    ["path", { d: "M10 8V4a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M20 16v1a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-1" }],
    ["path", { d: "M14 8V7c0-1.1.9-2 2-2h2a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-center.js
  var AlignCenter = [
    ["path", { d: "M17 12H7" }],
    ["path", { d: "M19 18H5" }],
    ["path", { d: "M21 6H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-end-horizontal.js
  var AlignEndHorizontal = [
    ["rect", { width: "6", height: "16", x: "4", y: "2", rx: "2" }],
    ["rect", { width: "6", height: "9", x: "14", y: "9", rx: "2" }],
    ["path", { d: "M22 22H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-end-vertical.js
  var AlignEndVertical = [
    ["rect", { width: "16", height: "6", x: "2", y: "4", rx: "2" }],
    ["rect", { width: "9", height: "6", x: "9", y: "14", rx: "2" }],
    ["path", { d: "M22 22V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-distribute-center.js
  var AlignHorizontalDistributeCenter = [
    ["rect", { width: "6", height: "14", x: "4", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "14", y: "7", rx: "2" }],
    ["path", { d: "M17 22v-5" }],
    ["path", { d: "M17 7V2" }],
    ["path", { d: "M7 22v-3" }],
    ["path", { d: "M7 5V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-distribute-end.js
  var AlignHorizontalDistributeEnd = [
    ["rect", { width: "6", height: "14", x: "4", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "14", y: "7", rx: "2" }],
    ["path", { d: "M10 2v20" }],
    ["path", { d: "M20 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-distribute-start.js
  var AlignHorizontalDistributeStart = [
    ["rect", { width: "6", height: "14", x: "4", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "14", y: "7", rx: "2" }],
    ["path", { d: "M4 2v20" }],
    ["path", { d: "M14 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-justify-center.js
  var AlignHorizontalJustifyCenter = [
    ["rect", { width: "6", height: "14", x: "2", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "16", y: "7", rx: "2" }],
    ["path", { d: "M12 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-justify-end.js
  var AlignHorizontalJustifyEnd = [
    ["rect", { width: "6", height: "14", x: "2", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "12", y: "7", rx: "2" }],
    ["path", { d: "M22 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-justify-start.js
  var AlignHorizontalJustifyStart = [
    ["rect", { width: "6", height: "14", x: "6", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "16", y: "7", rx: "2" }],
    ["path", { d: "M2 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-space-around.js
  var AlignHorizontalSpaceAround = [
    ["rect", { width: "6", height: "10", x: "9", y: "7", rx: "2" }],
    ["path", { d: "M4 22V2" }],
    ["path", { d: "M20 22V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-horizontal-space-between.js
  var AlignHorizontalSpaceBetween = [
    ["rect", { width: "6", height: "14", x: "3", y: "5", rx: "2" }],
    ["rect", { width: "6", height: "10", x: "15", y: "7", rx: "2" }],
    ["path", { d: "M3 2v20" }],
    ["path", { d: "M21 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-justify.js
  var AlignJustify = [
    ["path", { d: "M3 12h18" }],
    ["path", { d: "M3 18h18" }],
    ["path", { d: "M3 6h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-left.js
  var AlignLeft = [
    ["path", { d: "M15 12H3" }],
    ["path", { d: "M17 18H3" }],
    ["path", { d: "M21 6H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-right.js
  var AlignRight = [
    ["path", { d: "M21 12H9" }],
    ["path", { d: "M21 18H7" }],
    ["path", { d: "M21 6H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-start-horizontal.js
  var AlignStartHorizontal = [
    ["rect", { width: "6", height: "16", x: "4", y: "6", rx: "2" }],
    ["rect", { width: "6", height: "9", x: "14", y: "6", rx: "2" }],
    ["path", { d: "M22 2H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-start-vertical.js
  var AlignStartVertical = [
    ["rect", { width: "9", height: "6", x: "6", y: "14", rx: "2" }],
    ["rect", { width: "16", height: "6", x: "6", y: "4", rx: "2" }],
    ["path", { d: "M2 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-distribute-center.js
  var AlignVerticalDistributeCenter = [
    ["path", { d: "M22 17h-3" }],
    ["path", { d: "M22 7h-5" }],
    ["path", { d: "M5 17H2" }],
    ["path", { d: "M7 7H2" }],
    ["rect", { x: "5", y: "14", width: "14", height: "6", rx: "2" }],
    ["rect", { x: "7", y: "4", width: "10", height: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-distribute-end.js
  var AlignVerticalDistributeEnd = [
    ["rect", { width: "14", height: "6", x: "5", y: "14", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "4", rx: "2" }],
    ["path", { d: "M2 20h20" }],
    ["path", { d: "M2 10h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-distribute-start.js
  var AlignVerticalDistributeStart = [
    ["rect", { width: "14", height: "6", x: "5", y: "14", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "4", rx: "2" }],
    ["path", { d: "M2 14h20" }],
    ["path", { d: "M2 4h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-justify-center.js
  var AlignVerticalJustifyCenter = [
    ["rect", { width: "14", height: "6", x: "5", y: "16", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "2", rx: "2" }],
    ["path", { d: "M2 12h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-justify-end.js
  var AlignVerticalJustifyEnd = [
    ["rect", { width: "14", height: "6", x: "5", y: "12", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "2", rx: "2" }],
    ["path", { d: "M2 22h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-justify-start.js
  var AlignVerticalJustifyStart = [
    ["rect", { width: "14", height: "6", x: "5", y: "16", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "6", rx: "2" }],
    ["path", { d: "M2 2h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-space-around.js
  var AlignVerticalSpaceAround = [
    ["rect", { width: "10", height: "6", x: "7", y: "9", rx: "2" }],
    ["path", { d: "M22 20H2" }],
    ["path", { d: "M22 4H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/align-vertical-space-between.js
  var AlignVerticalSpaceBetween = [
    ["rect", { width: "14", height: "6", x: "5", y: "15", rx: "2" }],
    ["rect", { width: "10", height: "6", x: "7", y: "3", rx: "2" }],
    ["path", { d: "M2 21h20" }],
    ["path", { d: "M2 3h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/ambulance.js
  var Ambulance = [
    ["path", { d: "M10 10H6" }],
    ["path", { d: "M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2" }],
    [
      "path",
      {
        d: "M19 18h2a1 1 0 0 0 1-1v-3.28a1 1 0 0 0-.684-.948l-1.923-.641a1 1 0 0 1-.578-.502l-1.539-3.076A1 1 0 0 0 16.382 8H14"
      }
    ],
    ["path", { d: "M8 8v4" }],
    ["path", { d: "M9 18h6" }],
    ["circle", { cx: "17", cy: "18", r: "2" }],
    ["circle", { cx: "7", cy: "18", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/ampersand.js
  var Ampersand = [
    [
      "path",
      {
        d: "M17.5 12c0 4.4-3.6 8-8 8A4.5 4.5 0 0 1 5 15.5c0-6 8-4 8-8.5a3 3 0 1 0-6 0c0 3 2.5 8.5 12 13"
      }
    ],
    ["path", { d: "M16 12h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/ampersands.js
  var Ampersands = [
    [
      "path",
      { d: "M10 17c-5-3-7-7-7-9a2 2 0 0 1 4 0c0 2.5-5 2.5-5 6 0 1.7 1.3 3 3 3 2.8 0 5-2.2 5-5" }
    ],
    [
      "path",
      { d: "M22 17c-5-3-7-7-7-9a2 2 0 0 1 4 0c0 2.5-5 2.5-5 6 0 1.7 1.3 3 3 3 2.8 0 5-2.2 5-5" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/amphora.js
  var Amphora = [
    ["path", { d: "M10 2v5.632c0 .424-.272.795-.653.982A6 6 0 0 0 6 14c.006 4 3 7 5 8" }],
    ["path", { d: "M10 5H8a2 2 0 0 0 0 4h.68" }],
    ["path", { d: "M14 2v5.632c0 .424.272.795.652.982A6 6 0 0 1 18 14c0 4-3 7-5 8" }],
    ["path", { d: "M14 5h2a2 2 0 0 1 0 4h-.68" }],
    ["path", { d: "M18 22H6" }],
    ["path", { d: "M9 2h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/anchor.js
  var Anchor = [
    ["path", { d: "M12 22V8" }],
    ["path", { d: "M5 12H2a10 10 0 0 0 20 0h-3" }],
    ["circle", { cx: "12", cy: "5", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/angry.js
  var Angry = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M16 16s-1.5-2-4-2-4 2-4 2" }],
    ["path", { d: "M7.5 8 10 9" }],
    ["path", { d: "m14 9 2.5-1" }],
    ["path", { d: "M9 10h.01" }],
    ["path", { d: "M15 10h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/antenna.js
  var Antenna = [
    ["path", { d: "M2 12 7 2" }],
    ["path", { d: "m7 12 5-10" }],
    ["path", { d: "m12 12 5-10" }],
    ["path", { d: "m17 12 5-10" }],
    ["path", { d: "M4.5 7h15" }],
    ["path", { d: "M12 16v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/annoyed.js
  var Annoyed = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M8 15h8" }],
    ["path", { d: "M8 9h2" }],
    ["path", { d: "M14 9h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/anvil.js
  var Anvil = [
    ["path", { d: "M7 10H6a4 4 0 0 1-4-4 1 1 0 0 1 1-1h4" }],
    ["path", { d: "M7 5a1 1 0 0 1 1-1h13a1 1 0 0 1 1 1 7 7 0 0 1-7 7H8a1 1 0 0 1-1-1z" }],
    ["path", { d: "M9 12v5" }],
    ["path", { d: "M15 12v5" }],
    ["path", { d: "M5 20a3 3 0 0 1 3-3h8a3 3 0 0 1 3 3 1 1 0 0 1-1 1H6a1 1 0 0 1-1-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/aperture.js
  var Aperture = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m14.31 8 5.74 9.94" }],
    ["path", { d: "M9.69 8h11.48" }],
    ["path", { d: "m7.38 12 5.74-9.94" }],
    ["path", { d: "M9.69 16 3.95 6.06" }],
    ["path", { d: "M14.31 16H2.83" }],
    ["path", { d: "m16.62 12-5.74 9.94" }]
  ];

  // node_modules/lucide/dist/esm/icons/app-window-mac.js
  var AppWindowMac = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M6 8h.01" }],
    ["path", { d: "M10 8h.01" }],
    ["path", { d: "M14 8h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/app-window.js
  var AppWindow = [
    ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2" }],
    ["path", { d: "M10 4v4" }],
    ["path", { d: "M2 8h20" }],
    ["path", { d: "M6 4v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/apple.js
  var Apple = [
    [
      "path",
      {
        d: "M12 20.94c1.5 0 2.75 1.06 4 1.06 3 0 6-8 6-12.22A4.91 4.91 0 0 0 17 5c-2.22 0-4 1.44-5 2-1-.56-2.78-2-5-2a4.9 4.9 0 0 0-5 4.78C2 14 5 22 8 22c1.25 0 2.5-1.06 4-1.06Z"
      }
    ],
    ["path", { d: "M10 2c1 .5 2 2 2 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/archive-restore.js
  var ArchiveRestore = [
    ["rect", { width: "20", height: "5", x: "2", y: "3", rx: "1" }],
    ["path", { d: "M4 8v11a2 2 0 0 0 2 2h2" }],
    ["path", { d: "M20 8v11a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "m9 15 3-3 3 3" }],
    ["path", { d: "M12 12v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/archive-x.js
  var ArchiveX = [
    ["rect", { width: "20", height: "5", x: "2", y: "3", rx: "1" }],
    ["path", { d: "M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8" }],
    ["path", { d: "m9.5 17 5-5" }],
    ["path", { d: "m9.5 12 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/archive.js
  var Archive = [
    ["rect", { width: "20", height: "5", x: "2", y: "3", rx: "1" }],
    ["path", { d: "M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8" }],
    ["path", { d: "M10 12h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/armchair.js
  var Armchair = [
    ["path", { d: "M19 9V6a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v3" }],
    [
      "path",
      {
        d: "M3 16a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-4 0v1.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V11a2 2 0 0 0-4 0z"
      }
    ],
    ["path", { d: "M5 18v2" }],
    ["path", { d: "M19 18v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-big-down-dash.js
  var ArrowBigDownDash = [
    ["path", { d: "M15 5H9" }],
    ["path", { d: "M15 9v3h4l-7 7-7-7h4V9z" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-big-down.js
  var ArrowBigDown = [["path", { d: "M15 6v6h4l-7 7-7-7h4V6h6z" }]];

  // node_modules/lucide/dist/esm/icons/arrow-big-left-dash.js
  var ArrowBigLeftDash = [
    ["path", { d: "M19 15V9" }],
    ["path", { d: "M15 15h-3v4l-7-7 7-7v4h3v6z" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-big-left.js
  var ArrowBigLeft = [["path", { d: "M18 15h-6v4l-7-7 7-7v4h6v6z" }]];

  // node_modules/lucide/dist/esm/icons/arrow-big-right-dash.js
  var ArrowBigRightDash = [
    ["path", { d: "M5 9v6" }],
    ["path", { d: "M9 9h3V5l7 7-7 7v-4H9V9z" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-big-up-dash.js
  var ArrowBigUpDash = [
    ["path", { d: "M9 19h6" }],
    ["path", { d: "M9 15v-3H5l7-7 7 7h-4v3H9z" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-big-right.js
  var ArrowBigRight = [["path", { d: "M6 9h6V5l7 7-7 7v-4H6V9z" }]];

  // node_modules/lucide/dist/esm/icons/arrow-big-up.js
  var ArrowBigUp = [["path", { d: "M9 18v-6H5l7-7 7 7h-4v6H9z" }]];

  // node_modules/lucide/dist/esm/icons/arrow-down-0-1.js
  var ArrowDown01 = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["rect", { x: "15", y: "4", width: "4", height: "6", ry: "2" }],
    ["path", { d: "M17 20v-6h-2" }],
    ["path", { d: "M15 20h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-1-0.js
  var ArrowDown10 = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["path", { d: "M17 10V4h-2" }],
    ["path", { d: "M15 10h4" }],
    ["rect", { x: "15", y: "14", width: "4", height: "6", ry: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-a-z.js
  var ArrowDownAZ = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["path", { d: "M20 8h-5" }],
    ["path", { d: "M15 10V6.5a2.5 2.5 0 0 1 5 0V10" }],
    ["path", { d: "M15 14h5l-5 6h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-from-line.js
  var ArrowDownFromLine = [
    ["path", { d: "M19 3H5" }],
    ["path", { d: "M12 21V7" }],
    ["path", { d: "m6 15 6 6 6-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-left.js
  var ArrowDownLeft = [
    ["path", { d: "M17 7 7 17" }],
    ["path", { d: "M17 17H7V7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-right.js
  var ArrowDownRight = [
    ["path", { d: "m7 7 10 10" }],
    ["path", { d: "M17 7v10H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-narrow-wide.js
  var ArrowDownNarrowWide = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["path", { d: "M11 4h4" }],
    ["path", { d: "M11 8h7" }],
    ["path", { d: "M11 12h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-to-dot.js
  var ArrowDownToDot = [
    ["path", { d: "M12 2v14" }],
    ["path", { d: "m19 9-7 7-7-7" }],
    ["circle", { cx: "12", cy: "21", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-to-line.js
  var ArrowDownToLine = [
    ["path", { d: "M12 17V3" }],
    ["path", { d: "m6 11 6 6 6-6" }],
    ["path", { d: "M19 21H5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-up.js
  var ArrowDownUp = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["path", { d: "m21 8-4-4-4 4" }],
    ["path", { d: "M17 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-wide-narrow.js
  var ArrowDownWideNarrow = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 20V4" }],
    ["path", { d: "M11 4h10" }],
    ["path", { d: "M11 8h7" }],
    ["path", { d: "M11 12h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down-z-a.js
  var ArrowDownZA = [
    ["path", { d: "m3 16 4 4 4-4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M15 4h5l-5 6h5" }],
    ["path", { d: "M15 20v-3.5a2.5 2.5 0 0 1 5 0V20" }],
    ["path", { d: "M20 18h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-down.js
  var ArrowDown = [
    ["path", { d: "M12 5v14" }],
    ["path", { d: "m19 12-7 7-7-7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-left-from-line.js
  var ArrowLeftFromLine = [
    ["path", { d: "m9 6-6 6 6 6" }],
    ["path", { d: "M3 12h14" }],
    ["path", { d: "M21 19V5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-left-right.js
  var ArrowLeftRight = [
    ["path", { d: "M8 3 4 7l4 4" }],
    ["path", { d: "M4 7h16" }],
    ["path", { d: "m16 21 4-4-4-4" }],
    ["path", { d: "M20 17H4" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-left-to-line.js
  var ArrowLeftToLine = [
    ["path", { d: "M3 19V5" }],
    ["path", { d: "m13 6-6 6 6 6" }],
    ["path", { d: "M7 12h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-left.js
  var ArrowLeft = [
    ["path", { d: "m12 19-7-7 7-7" }],
    ["path", { d: "M19 12H5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-right-from-line.js
  var ArrowRightFromLine = [
    ["path", { d: "M3 5v14" }],
    ["path", { d: "M21 12H7" }],
    ["path", { d: "m15 18 6-6-6-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-right-left.js
  var ArrowRightLeft = [
    ["path", { d: "m16 3 4 4-4 4" }],
    ["path", { d: "M20 7H4" }],
    ["path", { d: "m8 21-4-4 4-4" }],
    ["path", { d: "M4 17h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-right-to-line.js
  var ArrowRightToLine = [
    ["path", { d: "M17 12H3" }],
    ["path", { d: "m11 18 6-6-6-6" }],
    ["path", { d: "M21 5v14" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-right.js
  var ArrowRight = [
    ["path", { d: "M5 12h14" }],
    ["path", { d: "m12 5 7 7-7 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-0-1.js
  var ArrowUp01 = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["rect", { x: "15", y: "4", width: "4", height: "6", ry: "2" }],
    ["path", { d: "M17 20v-6h-2" }],
    ["path", { d: "M15 20h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-1-0.js
  var ArrowUp10 = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M17 10V4h-2" }],
    ["path", { d: "M15 10h4" }],
    ["rect", { x: "15", y: "14", width: "4", height: "6", ry: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-a-z.js
  var ArrowUpAZ = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M20 8h-5" }],
    ["path", { d: "M15 10V6.5a2.5 2.5 0 0 1 5 0V10" }],
    ["path", { d: "M15 14h5l-5 6h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-down.js
  var ArrowUpDown = [
    ["path", { d: "m21 16-4 4-4-4" }],
    ["path", { d: "M17 20V4" }],
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-from-dot.js
  var ArrowUpFromDot = [
    ["path", { d: "m5 9 7-7 7 7" }],
    ["path", { d: "M12 16V2" }],
    ["circle", { cx: "12", cy: "21", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-from-line.js
  var ArrowUpFromLine = [
    ["path", { d: "m18 9-6-6-6 6" }],
    ["path", { d: "M12 3v14" }],
    ["path", { d: "M5 21h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-left.js
  var ArrowUpLeft = [
    ["path", { d: "M7 17V7h10" }],
    ["path", { d: "M17 17 7 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-narrow-wide.js
  var ArrowUpNarrowWide = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M11 12h4" }],
    ["path", { d: "M11 16h7" }],
    ["path", { d: "M11 20h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-right.js
  var ArrowUpRight = [
    ["path", { d: "M7 7h10v10" }],
    ["path", { d: "M7 17 17 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-to-line.js
  var ArrowUpToLine = [
    ["path", { d: "M5 3h14" }],
    ["path", { d: "m18 13-6-6-6 6" }],
    ["path", { d: "M12 7v14" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-wide-narrow.js
  var ArrowUpWideNarrow = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M11 12h10" }],
    ["path", { d: "M11 16h7" }],
    ["path", { d: "M11 20h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up-z-a.js
  var ArrowUpZA = [
    ["path", { d: "m3 8 4-4 4 4" }],
    ["path", { d: "M7 4v16" }],
    ["path", { d: "M15 4h5l-5 6h5" }],
    ["path", { d: "M15 20v-3.5a2.5 2.5 0 0 1 5 0V20" }],
    ["path", { d: "M20 18h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrows-up-from-line.js
  var ArrowsUpFromLine = [
    ["path", { d: "m4 6 3-3 3 3" }],
    ["path", { d: "M7 17V3" }],
    ["path", { d: "m14 6 3-3 3 3" }],
    ["path", { d: "M17 17V3" }],
    ["path", { d: "M4 21h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/arrow-up.js
  var ArrowUp = [
    ["path", { d: "m5 12 7-7 7 7" }],
    ["path", { d: "M12 19V5" }]
  ];

  // node_modules/lucide/dist/esm/icons/asterisk.js
  var Asterisk = [
    ["path", { d: "M12 6v12" }],
    ["path", { d: "M17.196 9 6.804 15" }],
    ["path", { d: "m6.804 9 10.392 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/at-sign.js
  var AtSign = [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/atom.js
  var Atom = [
    ["circle", { cx: "12", cy: "12", r: "1" }],
    [
      "path",
      {
        d: "M20.2 20.2c2.04-2.03.02-7.36-4.5-11.9-4.54-4.52-9.87-6.54-11.9-4.5-2.04 2.03-.02 7.36 4.5 11.9 4.54 4.52 9.87 6.54 11.9 4.5Z"
      }
    ],
    [
      "path",
      {
        d: "M15.7 15.7c4.52-4.54 6.54-9.87 4.5-11.9-2.03-2.04-7.36-.02-11.9 4.5-4.52 4.54-6.54 9.87-4.5 11.9 2.03 2.04 7.36.02 11.9-4.5Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/audio-lines.js
  var AudioLines = [
    ["path", { d: "M2 10v3" }],
    ["path", { d: "M6 6v11" }],
    ["path", { d: "M10 3v18" }],
    ["path", { d: "M14 8v7" }],
    ["path", { d: "M18 5v13" }],
    ["path", { d: "M22 10v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/audio-waveform.js
  var AudioWaveform = [
    [
      "path",
      {
        d: "M2 13a2 2 0 0 0 2-2V7a2 2 0 0 1 4 0v13a2 2 0 0 0 4 0V4a2 2 0 0 1 4 0v13a2 2 0 0 0 4 0v-4a2 2 0 0 1 2-2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/award.js
  var Award = [
    [
      "path",
      {
        d: "m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "6" }]
  ];

  // node_modules/lucide/dist/esm/icons/axe.js
  var Axe = [
    ["path", { d: "m14 12-8.5 8.5a2.12 2.12 0 1 1-3-3L11 9" }],
    ["path", { d: "M15 13 9 7l4-4 6 6h3a8 8 0 0 1-7 7z" }]
  ];

  // node_modules/lucide/dist/esm/icons/axis-3d.js
  var Axis3d = [
    ["path", { d: "M4 4v16h16" }],
    ["path", { d: "m4 20 7-7" }]
  ];

  // node_modules/lucide/dist/esm/icons/baby.js
  var Baby = [
    ["path", { d: "M10 16c.5.3 1.2.5 2 .5s1.5-.2 2-.5" }],
    ["path", { d: "M15 12h.01" }],
    [
      "path",
      {
        d: "M19.38 6.813A9 9 0 0 1 20.8 10.2a2 2 0 0 1 0 3.6 9 9 0 0 1-17.6 0 2 2 0 0 1 0-3.6A9 9 0 0 1 12 3c2 0 3.5 1.1 3.5 2.5s-.9 2.5-2 2.5c-.8 0-1.5-.4-1.5-1"
      }
    ],
    ["path", { d: "M9 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/backpack.js
  var Backpack = [
    ["path", { d: "M4 10a4 4 0 0 1 4-4h8a4 4 0 0 1 4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2z" }],
    ["path", { d: "M8 10h8" }],
    ["path", { d: "M8 18h8" }],
    ["path", { d: "M8 22v-6a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v6" }],
    ["path", { d: "M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-alert.js
  var BadgeAlert = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-cent.js
  var BadgeCent = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M12 7v10" }],
    ["path", { d: "M15.4 10a4 4 0 1 0 0 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-check.js
  var BadgeCheck = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "m9 12 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-dollar-sign.js
  var BadgeDollarSign = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M16 8h-6a2 2 0 1 0 0 4h4a2 2 0 1 1 0 4H8" }],
    ["path", { d: "M12 18V6" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-euro.js
  var BadgeEuro = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M7 12h5" }],
    ["path", { d: "M15 9.4a4 4 0 1 0 0 5.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-help.js
  var BadgeHelp = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" }],
    ["line", { x1: "12", x2: "12.01", y1: "17", y2: "17" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-indian-rupee.js
  var BadgeIndianRupee = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M8 8h8" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "m13 17-5-1h1a4 4 0 0 0 0-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-info.js
  var BadgeInfo = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["line", { x1: "12", x2: "12", y1: "16", y2: "12" }],
    ["line", { x1: "12", x2: "12.01", y1: "8", y2: "8" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-japanese-yen.js
  var BadgeJapaneseYen = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "m9 8 3 3v7" }],
    ["path", { d: "m12 11 3-3" }],
    ["path", { d: "M9 12h6" }],
    ["path", { d: "M9 16h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-minus.js
  var BadgeMinus = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-percent.js
  var BadgePercent = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "M9 9h.01" }],
    ["path", { d: "M15 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-plus.js
  var BadgePlus = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "16" }],
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-pound-sterling.js
  var BadgePoundSterling = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M8 12h4" }],
    ["path", { d: "M10 16V9.5a2.5 2.5 0 0 1 5 0" }],
    ["path", { d: "M8 16h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-russian-ruble.js
  var BadgeRussianRuble = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M9 16h5" }],
    ["path", { d: "M9 12h5a2 2 0 1 0 0-4h-3v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-x.js
  var BadgeX = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["line", { x1: "15", x2: "9", y1: "9", y2: "15" }],
    ["line", { x1: "9", x2: "15", y1: "9", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge-swiss-franc.js
  var BadgeSwissFranc = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ],
    ["path", { d: "M11 17V8h4" }],
    ["path", { d: "M11 12h3" }],
    ["path", { d: "M9 16h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/badge.js
  var Badge = [
    [
      "path",
      {
        d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/baggage-claim.js
  var BaggageClaim = [
    ["path", { d: "M22 18H6a2 2 0 0 1-2-2V7a2 2 0 0 0-2-2" }],
    ["path", { d: "M17 14V4a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v10" }],
    ["rect", { width: "13", height: "8", x: "8", y: "6", rx: "1" }],
    ["circle", { cx: "18", cy: "20", r: "2" }],
    ["circle", { cx: "9", cy: "20", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/ban.js
  var Ban = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m4.9 4.9 14.2 14.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/banana.js
  var Banana = [
    ["path", { d: "M4 13c3.5-2 8-2 10 2a5.5 5.5 0 0 1 8 5" }],
    [
      "path",
      {
        d: "M5.15 17.89c5.52-1.52 8.65-6.89 7-12C11.55 4 11.5 2 13 2c3.22 0 5 5.5 5 8 0 6.5-4.2 12-10.49 12C5.11 22 2 22 2 20c0-1.5 1.14-1.55 3.15-2.11Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bandage.js
  var Bandage = [
    ["path", { d: "M10 10.01h.01" }],
    ["path", { d: "M10 14.01h.01" }],
    ["path", { d: "M14 10.01h.01" }],
    ["path", { d: "M14 14.01h.01" }],
    ["path", { d: "M18 6v11.5" }],
    ["path", { d: "M6 6v12" }],
    ["rect", { x: "2", y: "6", width: "20", height: "12", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/banknote-arrow-down.js
  var BanknoteArrowDown = [
    ["path", { d: "M12 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5" }],
    ["path", { d: "m16 19 3 3 3-3" }],
    ["path", { d: "M18 12h.01" }],
    ["path", { d: "M19 16v6" }],
    ["path", { d: "M6 12h.01" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/banknote-arrow-up.js
  var BanknoteArrowUp = [
    ["path", { d: "M12 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5" }],
    ["path", { d: "M18 12h.01" }],
    ["path", { d: "M19 22v-6" }],
    ["path", { d: "m22 19-3-3-3 3" }],
    ["path", { d: "M6 12h.01" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/banknote-x.js
  var BanknoteX = [
    ["path", { d: "M13 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5" }],
    ["path", { d: "m17 17 5 5" }],
    ["path", { d: "M18 12h.01" }],
    ["path", { d: "m22 17-5 5" }],
    ["path", { d: "M6 12h.01" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/banknote.js
  var Banknote = [
    ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2" }],
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "M6 12h.01M18 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/barcode.js
  var Barcode = [
    ["path", { d: "M3 5v14" }],
    ["path", { d: "M8 5v14" }],
    ["path", { d: "M12 5v14" }],
    ["path", { d: "M17 5v14" }],
    ["path", { d: "M21 5v14" }]
  ];

  // node_modules/lucide/dist/esm/icons/baseline.js
  var Baseline = [
    ["path", { d: "M4 20h16" }],
    ["path", { d: "m6 16 6-12 6 12" }],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/bath.js
  var Bath = [
    ["path", { d: "M10 4 8 6" }],
    ["path", { d: "M17 19v2" }],
    ["path", { d: "M2 12h20" }],
    ["path", { d: "M7 19v2" }],
    ["path", { d: "M9 5 7.621 3.621A2.121 2.121 0 0 0 4 5v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-charging.js
  var BatteryCharging = [
    ["path", { d: "M15 7h1a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M6 7H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h1" }],
    ["path", { d: "m11 7-3 5h4l-3 5" }],
    ["line", { x1: "22", x2: "22", y1: "11", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-low.js
  var BatteryLow = [
    ["rect", { width: "16", height: "10", x: "2", y: "7", rx: "2", ry: "2" }],
    ["line", { x1: "22", x2: "22", y1: "11", y2: "13" }],
    ["line", { x1: "6", x2: "6", y1: "11", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-full.js
  var BatteryFull = [
    ["rect", { width: "16", height: "10", x: "2", y: "7", rx: "2", ry: "2" }],
    ["line", { x1: "22", x2: "22", y1: "11", y2: "13" }],
    ["line", { x1: "6", x2: "6", y1: "11", y2: "13" }],
    ["line", { x1: "10", x2: "10", y1: "11", y2: "13" }],
    ["line", { x1: "14", x2: "14", y1: "11", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-medium.js
  var BatteryMedium = [
    ["rect", { width: "16", height: "10", x: "2", y: "7", rx: "2", ry: "2" }],
    ["line", { x1: "22", x2: "22", y1: "11", y2: "13" }],
    ["line", { x1: "6", x2: "6", y1: "11", y2: "13" }],
    ["line", { x1: "10", x2: "10", y1: "11", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-plus.js
  var BatteryPlus = [
    ["path", { d: "M10 9v6" }],
    ["path", { d: "M13.5 7H16a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-2.5" }],
    ["path", { d: "M22 11v2" }],
    ["path", { d: "M6.5 17H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h2.5" }],
    ["path", { d: "M7 12h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery-warning.js
  var BatteryWarning = [
    ["path", { d: "M10 17h.01" }],
    ["path", { d: "M10 7v6" }],
    ["path", { d: "M14 7h2a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M22 11v2" }],
    ["path", { d: "M6 7H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/battery.js
  var Battery = [
    ["rect", { width: "16", height: "10", x: "2", y: "7", rx: "2", ry: "2" }],
    ["line", { x1: "22", x2: "22", y1: "11", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/beaker.js
  var Beaker = [
    ["path", { d: "M4.5 3h15" }],
    ["path", { d: "M6 3v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V3" }],
    ["path", { d: "M6 14h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/bean-off.js
  var BeanOff = [
    ["path", { d: "M9 9c-.64.64-1.521.954-2.402 1.165A6 6 0 0 0 8 22a13.96 13.96 0 0 0 9.9-4.1" }],
    ["path", { d: "M10.75 5.093A6 6 0 0 1 22 8c0 2.411-.61 4.68-1.683 6.66" }],
    ["path", { d: "M5.341 10.62a4 4 0 0 0 6.487 1.208M10.62 5.341a4.015 4.015 0 0 1 2.039 2.04" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/bean.js
  var Bean = [
    [
      "path",
      {
        d: "M10.165 6.598C9.954 7.478 9.64 8.36 9 9c-.64.64-1.521.954-2.402 1.165A6 6 0 0 0 8 22c7.732 0 14-6.268 14-14a6 6 0 0 0-11.835-1.402Z"
      }
    ],
    ["path", { d: "M5.341 10.62a4 4 0 1 0 5.279-5.28" }]
  ];

  // node_modules/lucide/dist/esm/icons/bed-double.js
  var BedDouble = [
    ["path", { d: "M2 20v-8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v8" }],
    ["path", { d: "M4 10V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M12 4v6" }],
    ["path", { d: "M2 18h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/bed-single.js
  var BedSingle = [
    ["path", { d: "M3 20v-8a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v8" }],
    ["path", { d: "M5 10V6a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M3 18h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/bed.js
  var Bed = [
    ["path", { d: "M2 4v16" }],
    ["path", { d: "M2 8h18a2 2 0 0 1 2 2v10" }],
    ["path", { d: "M2 17h20" }],
    ["path", { d: "M6 8v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/beef.js
  var Beef = [
    [
      "path",
      {
        d: "M16.4 13.7A6.5 6.5 0 1 0 6.28 6.6c-1.1 3.13-.78 3.9-3.18 6.08A3 3 0 0 0 5 18c4 0 8.4-1.8 11.4-4.3"
      }
    ],
    [
      "path",
      {
        d: "m18.5 6 2.19 4.5a6.48 6.48 0 0 1-2.29 7.2C15.4 20.2 11 22 7 22a3 3 0 0 1-2.68-1.66L2.4 16.5"
      }
    ],
    ["circle", { cx: "12.5", cy: "8.5", r: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/beer-off.js
  var BeerOff = [
    ["path", { d: "M13 13v5" }],
    ["path", { d: "M17 11.47V8" }],
    ["path", { d: "M17 11h1a3 3 0 0 1 2.745 4.211" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M5 8v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-3" }],
    ["path", { d: "M7.536 7.535C6.766 7.649 6.154 8 5.5 8a2.5 2.5 0 0 1-1.768-4.268" }],
    [
      "path",
      {
        d: "M8.727 3.204C9.306 2.767 9.885 2 11 2c1.56 0 2 1.5 3 1.5s1.72-.5 2.5-.5a1 1 0 1 1 0 5c-.78 0-1.5-.5-2.5-.5a3.149 3.149 0 0 0-.842.12"
      }
    ],
    ["path", { d: "M9 14.6V18" }]
  ];

  // node_modules/lucide/dist/esm/icons/beer.js
  var Beer = [
    ["path", { d: "M17 11h1a3 3 0 0 1 0 6h-1" }],
    ["path", { d: "M9 12v6" }],
    ["path", { d: "M13 12v6" }],
    [
      "path",
      {
        d: "M14 7.5c-1 0-1.44.5-3 .5s-2-.5-3-.5-1.72.5-2.5.5a2.5 2.5 0 0 1 0-5c.78 0 1.57.5 2.5.5S9.44 2 11 2s2 1.5 3 1.5 1.72-.5 2.5-.5a2.5 2.5 0 0 1 0 5c-.78 0-1.5-.5-2.5-.5Z"
      }
    ],
    ["path", { d: "M5 8v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/bell-dot.js
  var BellDot = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    [
      "path",
      {
        d: "M13.916 2.314A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.74 7.327A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673 9 9 0 0 1-.585-.665"
      }
    ],
    ["circle", { cx: "18", cy: "8", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/bell-electric.js
  var BellElectric = [
    ["path", { d: "M18.518 17.347A7 7 0 0 1 14 19" }],
    ["path", { d: "M18.8 4A11 11 0 0 1 20 9" }],
    ["path", { d: "M9 9h.01" }],
    ["circle", { cx: "20", cy: "16", r: "2" }],
    ["circle", { cx: "9", cy: "9", r: "7" }],
    ["rect", { x: "4", y: "16", width: "10", height: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/bell-minus.js
  var BellMinus = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    ["path", { d: "M15 8h6" }],
    [
      "path",
      {
        d: "M16.243 3.757A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673A9.4 9.4 0 0 1 18.667 12"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bell-plus.js
  var BellPlus = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    ["path", { d: "M15 8h6" }],
    ["path", { d: "M18 5v6" }],
    [
      "path",
      {
        d: "M20.002 14.464a9 9 0 0 0 .738.863A1 1 0 0 1 20 17H4a1 1 0 0 1-.74-1.673C4.59 13.956 6 12.499 6 8a6 6 0 0 1 8.75-5.332"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bell-off.js
  var BellOff = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    ["path", { d: "M17 17H4a1 1 0 0 1-.74-1.673C4.59 13.956 6 12.499 6 8a6 6 0 0 1 .258-1.742" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M8.668 3.01A6 6 0 0 1 18 8c0 2.687.77 4.653 1.707 6.05" }]
  ];

  // node_modules/lucide/dist/esm/icons/bell.js
  var Bell = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    [
      "path",
      {
        d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bell-ring.js
  var BellRing = [
    ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0" }],
    ["path", { d: "M22 8c0-2.3-.8-4.3-2-6" }],
    [
      "path",
      {
        d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326"
      }
    ],
    ["path", { d: "M4 2C2.8 3.7 2 5.7 2 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/between-horizontal-end.js
  var BetweenHorizontalEnd = [
    ["rect", { width: "13", height: "7", x: "3", y: "3", rx: "1" }],
    ["path", { d: "m22 15-3-3 3-3" }],
    ["rect", { width: "13", height: "7", x: "3", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/between-horizontal-start.js
  var BetweenHorizontalStart = [
    ["rect", { width: "13", height: "7", x: "8", y: "3", rx: "1" }],
    ["path", { d: "m2 9 3 3-3 3" }],
    ["rect", { width: "13", height: "7", x: "8", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/between-vertical-end.js
  var BetweenVerticalEnd = [
    ["rect", { width: "7", height: "13", x: "3", y: "3", rx: "1" }],
    ["path", { d: "m9 22 3-3 3 3" }],
    ["rect", { width: "7", height: "13", x: "14", y: "3", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/between-vertical-start.js
  var BetweenVerticalStart = [
    ["rect", { width: "7", height: "13", x: "3", y: "8", rx: "1" }],
    ["path", { d: "m15 2-3 3-3-3" }],
    ["rect", { width: "7", height: "13", x: "14", y: "8", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/biceps-flexed.js
  var BicepsFlexed = [
    [
      "path",
      {
        d: "M12.409 13.017A5 5 0 0 1 22 15c0 3.866-4 7-9 7-4.077 0-8.153-.82-10.371-2.462-.426-.316-.631-.832-.62-1.362C2.118 12.723 2.627 2 10 2a3 3 0 0 1 3 3 2 2 0 0 1-2 2c-1.105 0-1.64-.444-2-1"
      }
    ],
    ["path", { d: "M15 14a5 5 0 0 0-7.584 2" }],
    ["path", { d: "M9.964 6.825C8.019 7.977 9.5 13 8 15" }]
  ];

  // node_modules/lucide/dist/esm/icons/bike.js
  var Bike = [
    ["circle", { cx: "18.5", cy: "17.5", r: "3.5" }],
    ["circle", { cx: "5.5", cy: "17.5", r: "3.5" }],
    ["circle", { cx: "15", cy: "5", r: "1" }],
    ["path", { d: "M12 17.5V14l-3-3 4-3 2 3h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/binoculars.js
  var Binoculars = [
    ["path", { d: "M10 10h4" }],
    ["path", { d: "M19 7V4a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3" }],
    [
      "path",
      {
        d: "M20 21a2 2 0 0 0 2-2v-3.851c0-1.39-2-2.962-2-4.829V8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v11a2 2 0 0 0 2 2z"
      }
    ],
    ["path", { d: "M 22 16 L 2 16" }],
    [
      "path",
      {
        d: "M4 21a2 2 0 0 1-2-2v-3.851c0-1.39 2-2.962 2-4.829V8a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2z"
      }
    ],
    ["path", { d: "M9 7V4a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/binary.js
  var Binary = [
    ["rect", { x: "14", y: "14", width: "4", height: "6", rx: "2" }],
    ["rect", { x: "6", y: "4", width: "4", height: "6", rx: "2" }],
    ["path", { d: "M6 20h4" }],
    ["path", { d: "M14 10h4" }],
    ["path", { d: "M6 14h2v6" }],
    ["path", { d: "M14 4h2v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/biohazard.js
  var Biohazard = [
    ["circle", { cx: "12", cy: "11.9", r: "2" }],
    ["path", { d: "M6.7 3.4c-.9 2.5 0 5.2 2.2 6.7C6.5 9 3.7 9.6 2 11.6" }],
    ["path", { d: "m8.9 10.1 1.4.8" }],
    ["path", { d: "M17.3 3.4c.9 2.5 0 5.2-2.2 6.7 2.4-1.2 5.2-.6 6.9 1.5" }],
    ["path", { d: "m15.1 10.1-1.4.8" }],
    ["path", { d: "M16.7 20.8c-2.6-.4-4.6-2.6-4.7-5.3-.2 2.6-2.1 4.8-4.7 5.2" }],
    ["path", { d: "M12 13.9v1.6" }],
    ["path", { d: "M13.5 5.4c-1-.2-2-.2-3 0" }],
    ["path", { d: "M17 16.4c.7-.7 1.2-1.6 1.5-2.5" }],
    ["path", { d: "M5.5 13.9c.3.9.8 1.8 1.5 2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/bird.js
  var Bird = [
    ["path", { d: "M16 7h.01" }],
    ["path", { d: "M3.4 18H12a8 8 0 0 0 8-8V7a4 4 0 0 0-7.28-2.3L2 20" }],
    ["path", { d: "m20 7 2 .5-2 .5" }],
    ["path", { d: "M10 18v3" }],
    ["path", { d: "M14 17.75V21" }],
    ["path", { d: "M7 18a6 6 0 0 0 3.84-10.61" }]
  ];

  // node_modules/lucide/dist/esm/icons/bitcoin.js
  var Bitcoin = [
    [
      "path",
      {
        d: "M11.767 19.089c4.924.868 6.14-6.025 1.216-6.894m-1.216 6.894L5.86 18.047m5.908 1.042-.347 1.97m1.563-8.864c4.924.869 6.14-6.025 1.215-6.893m-1.215 6.893-3.94-.694m5.155-6.2L8.29 4.26m5.908 1.042.348-1.97M7.48 20.364l3.126-17.727"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/blend.js
  var Blend = [
    ["circle", { cx: "9", cy: "9", r: "7" }],
    ["circle", { cx: "15", cy: "15", r: "7" }]
  ];

  // node_modules/lucide/dist/esm/icons/blinds.js
  var Blinds = [
    ["path", { d: "M3 3h18" }],
    ["path", { d: "M20 7H8" }],
    ["path", { d: "M20 11H8" }],
    ["path", { d: "M10 19h10" }],
    ["path", { d: "M8 15h12" }],
    ["path", { d: "M4 3v14" }],
    ["circle", { cx: "4", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/blocks.js
  var Blocks = [
    ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1" }],
    [
      "path",
      {
        d: "M10 21V8a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1H3"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bluetooth-connected.js
  var BluetoothConnected = [
    ["path", { d: "m7 7 10 10-5 5V2l5 5L7 17" }],
    ["line", { x1: "18", x2: "21", y1: "12", y2: "12" }],
    ["line", { x1: "3", x2: "6", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/bluetooth-off.js
  var BluetoothOff = [
    ["path", { d: "m17 17-5 5V12l-5 5" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M14.5 9.5 17 7l-5-5v4.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/bluetooth-searching.js
  var BluetoothSearching = [
    ["path", { d: "m7 7 10 10-5 5V2l5 5L7 17" }],
    ["path", { d: "M20.83 14.83a4 4 0 0 0 0-5.66" }],
    ["path", { d: "M18 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/bold.js
  var Bold2 = [
    ["path", { d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/bolt.js
  var Bolt = [
    [
      "path",
      {
        d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/bluetooth.js
  var Bluetooth = [["path", { d: "m7 7 10 10-5 5V2l5 5L7 17" }]];

  // node_modules/lucide/dist/esm/icons/bone.js
  var Bone = [
    [
      "path",
      {
        d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bomb.js
  var Bomb = [
    ["circle", { cx: "11", cy: "13", r: "9" }],
    [
      "path",
      { d: "M14.35 4.65 16.3 2.7a2.41 2.41 0 0 1 3.4 0l1.6 1.6a2.4 2.4 0 0 1 0 3.4l-1.95 1.95" }
    ],
    ["path", { d: "m22 2-1.5 1.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-audio.js
  var BookAudio = [
    ["path", { d: "M12 6v7" }],
    ["path", { d: "M16 8v3" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "M8 8v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-check.js
  var BookCheck = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "m9 9.5 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-a.js
  var BookA = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "m8 13 4-7 4 7" }],
    ["path", { d: "M9.1 11h5.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-copy.js
  var BookCopy = [
    ["path", { d: "M2 16V4a2 2 0 0 1 2-2h11" }],
    [
      "path",
      { d: "M22 18H11a2 2 0 1 0 0 4h10.5a.5.5 0 0 0 .5-.5v-15a.5.5 0 0 0-.5-.5H11a2 2 0 0 0-2 2v12" }
    ],
    ["path", { d: "M5 14H4a2 2 0 1 0 0 4h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-down.js
  var BookDown = [
    ["path", { d: "M12 13V7" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "m9 10 3 3 3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-dashed.js
  var BookDashed = [
    ["path", { d: "M12 17h1.5" }],
    ["path", { d: "M12 22h1.5" }],
    ["path", { d: "M12 2h1.5" }],
    ["path", { d: "M17.5 22H19a1 1 0 0 0 1-1" }],
    ["path", { d: "M17.5 2H19a1 1 0 0 1 1 1v1.5" }],
    ["path", { d: "M20 14v3h-2.5" }],
    ["path", { d: "M20 8.5V10" }],
    ["path", { d: "M4 10V8.5" }],
    ["path", { d: "M4 19.5V14" }],
    ["path", { d: "M4 4.5A2.5 2.5 0 0 1 6.5 2H8" }],
    ["path", { d: "M8 22H6.5a1 1 0 0 1 0-5H8" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-headphones.js
  var BookHeadphones = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "M8 12v-2a4 4 0 0 1 8 0v2" }],
    ["circle", { cx: "15", cy: "12", r: "1" }],
    ["circle", { cx: "9", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-heart.js
  var BookHeart = [
    [
      "path",
      {
        d: "M16 8.2A2.22 2.22 0 0 0 13.8 6c-.8 0-1.4.3-1.8.9-.4-.6-1-.9-1.8-.9A2.22 2.22 0 0 0 8 8.2c0 .6.3 1.2.7 1.6A226.652 226.652 0 0 0 12 13a404 404 0 0 0 3.3-3.1 2.413 2.413 0 0 0 .7-1.7"
      }
    ],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/book-image.js
  var BookImage = [
    ["path", { d: "m20 13.7-2.1-2.1a2 2 0 0 0-2.8 0L9.7 17" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["circle", { cx: "10", cy: "8", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-key.js
  var BookKey = [
    ["path", { d: "m19 3 1 1" }],
    ["path", { d: "m20 2-4.5 4.5" }],
    ["path", { d: "M20 7.898V21a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }],
    ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2h7.844" }],
    ["circle", { cx: "14", cy: "8", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-marked.js
  var BookMarked = [
    ["path", { d: "M10 2v8l3-3 3 3V2" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/book-lock.js
  var BookLock = [
    ["path", { d: "M18 6V4a2 2 0 1 0-4 0v2" }],
    ["path", { d: "M20 15v6a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }],
    ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H10" }],
    ["rect", { x: "12", y: "6", width: "8", height: "5", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-minus.js
  var BookMinus = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-open-check.js
  var BookOpenCheck = [
    ["path", { d: "M12 21V7" }],
    ["path", { d: "m16 12 2 2 4-4" }],
    [
      "path",
      {
        d: "M22 6V4a1 1 0 0 0-1-1h-5a4 4 0 0 0-4 4 4 4 0 0 0-4-4H3a1 1 0 0 0-1 1v13a1 1 0 0 0 1 1h6a3 3 0 0 1 3 3 3 3 0 0 1 3-3h6a1 1 0 0 0 1-1v-1.3"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/book-open-text.js
  var BookOpenText = [
    ["path", { d: "M12 7v14" }],
    ["path", { d: "M16 12h2" }],
    ["path", { d: "M16 8h2" }],
    [
      "path",
      {
        d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"
      }
    ],
    ["path", { d: "M6 12h2" }],
    ["path", { d: "M6 8h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-open.js
  var BookOpen = [
    ["path", { d: "M12 7v14" }],
    [
      "path",
      {
        d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/book-plus.js
  var BookPlus = [
    ["path", { d: "M12 7v6" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-text.js
  var BookText = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "M8 11h8" }],
    ["path", { d: "M8 7h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-type.js
  var BookType = [
    ["path", { d: "M10 13h4" }],
    ["path", { d: "M12 6v7" }],
    ["path", { d: "M16 8V6H8v2" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/book-up-2.js
  var BookUp2 = [
    ["path", { d: "M12 13V7" }],
    ["path", { d: "M18 2h1a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }],
    ["path", { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2" }],
    ["path", { d: "m9 10 3-3 3 3" }],
    ["path", { d: "m9 5 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-up.js
  var BookUp = [
    ["path", { d: "M12 13V7" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "m9 10 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-user.js
  var BookUser = [
    ["path", { d: "M15 13a3 3 0 1 0-6 0" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["circle", { cx: "12", cy: "8", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/book-x.js
  var BookX = [
    ["path", { d: "m14.5 7-5 5" }],
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ],
    ["path", { d: "m9.5 7 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/book.js
  var Book = [
    [
      "path",
      { d: "M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H19a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6.5a1 1 0 0 1 0-5H20" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/bookmark-check.js
  var BookmarkCheck = [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2Z" }],
    ["path", { d: "m9 10 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/bookmark-minus.js
  var BookmarkMinus = [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z" }],
    ["line", { x1: "15", x2: "9", y1: "10", y2: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/bookmark-plus.js
  var BookmarkPlus = [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z" }],
    ["line", { x1: "12", x2: "12", y1: "7", y2: "13" }],
    ["line", { x1: "15", x2: "9", y1: "10", y2: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/bookmark-x.js
  var BookmarkX = [
    ["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2Z" }],
    ["path", { d: "m14.5 7.5-5 5" }],
    ["path", { d: "m9.5 7.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/bookmark.js
  var Bookmark = [["path", { d: "m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z" }]];

  // node_modules/lucide/dist/esm/icons/boom-box.js
  var BoomBox = [
    ["path", { d: "M4 9V5a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M8 8v1" }],
    ["path", { d: "M12 8v1" }],
    ["path", { d: "M16 8v1" }],
    ["rect", { width: "20", height: "12", x: "2", y: "9", rx: "2" }],
    ["circle", { cx: "8", cy: "15", r: "2" }],
    ["circle", { cx: "16", cy: "15", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/bot-message-square.js
  var BotMessageSquare = [
    ["path", { d: "M12 6V2H8" }],
    ["path", { d: "m8 18-4 4V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2Z" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "M9 11v2" }],
    ["path", { d: "M15 11v2" }],
    ["path", { d: "M20 12h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/bot-off.js
  var BotOff = [
    ["path", { d: "M13.67 8H18a2 2 0 0 1 2 2v4.33" }],
    ["path", { d: "M2 14h2" }],
    ["path", { d: "M20 14h2" }],
    ["path", { d: "M22 22 2 2" }],
    ["path", { d: "M8 8H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h12a2 2 0 0 0 1.414-.586" }],
    ["path", { d: "M9 13v2" }],
    ["path", { d: "M9.67 4H12v2.33" }]
  ];

  // node_modules/lucide/dist/esm/icons/bot.js
  var Bot = [
    ["path", { d: "M12 8V4H8" }],
    ["rect", { width: "16", height: "12", x: "4", y: "8", rx: "2" }],
    ["path", { d: "M2 14h2" }],
    ["path", { d: "M20 14h2" }],
    ["path", { d: "M15 13v2" }],
    ["path", { d: "M9 13v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/bow-arrow.js
  var BowArrow = [
    ["path", { d: "M17 3h4v4" }],
    ["path", { d: "M18.575 11.082a13 13 0 0 1 1.048 9.027 1.17 1.17 0 0 1-1.914.597L14 17" }],
    ["path", { d: "M7 10 3.29 6.29a1.17 1.17 0 0 1 .6-1.91 13 13 0 0 1 9.03 1.05" }],
    [
      "path",
      {
        d: "M7 14a1.7 1.7 0 0 0-1.207.5l-2.646 2.646A.5.5 0 0 0 3.5 18H5a1 1 0 0 1 1 1v1.5a.5.5 0 0 0 .854.354L9.5 18.207A1.7 1.7 0 0 0 10 17v-2a1 1 0 0 0-1-1z"
      }
    ],
    ["path", { d: "M9.707 14.293 21 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/box.js
  var Box = [
    [
      "path",
      {
        d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z"
      }
    ],
    ["path", { d: "m3.3 7 8.7 5 8.7-5" }],
    ["path", { d: "M12 22V12" }]
  ];

  // node_modules/lucide/dist/esm/icons/boxes.js
  var Boxes = [
    [
      "path",
      {
        d: "M2.97 12.92A2 2 0 0 0 2 14.63v3.24a2 2 0 0 0 .97 1.71l3 1.8a2 2 0 0 0 2.06 0L12 19v-5.5l-5-3-4.03 2.42Z"
      }
    ],
    ["path", { d: "m7 16.5-4.74-2.85" }],
    ["path", { d: "m7 16.5 5-3" }],
    ["path", { d: "M7 16.5v5.17" }],
    [
      "path",
      {
        d: "M12 13.5V19l3.97 2.38a2 2 0 0 0 2.06 0l3-1.8a2 2 0 0 0 .97-1.71v-3.24a2 2 0 0 0-.97-1.71L17 10.5l-5 3Z"
      }
    ],
    ["path", { d: "m17 16.5-5-3" }],
    ["path", { d: "m17 16.5 4.74-2.85" }],
    ["path", { d: "M17 16.5v5.17" }],
    [
      "path",
      {
        d: "M7.97 4.42A2 2 0 0 0 7 6.13v4.37l5 3 5-3V6.13a2 2 0 0 0-.97-1.71l-3-1.8a2 2 0 0 0-2.06 0l-3 1.8Z"
      }
    ],
    ["path", { d: "M12 8 7.26 5.15" }],
    ["path", { d: "m12 8 4.74-2.85" }],
    ["path", { d: "M12 13.5V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/braces.js
  var Braces = [
    ["path", { d: "M8 3H7a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5c0 1.1.9 2 2 2h1" }],
    ["path", { d: "M16 21h1a2 2 0 0 0 2-2v-5c0-1.1.9-2 2-2a2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/brackets.js
  var Brackets = [
    ["path", { d: "M16 3h2a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1h-2" }],
    ["path", { d: "M8 21H6a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/brain-cog.js
  var BrainCog = [
    ["path", { d: "m10.852 14.772-.383.923" }],
    ["path", { d: "m10.852 9.228-.383-.923" }],
    ["path", { d: "m13.148 14.772.382.924" }],
    ["path", { d: "m13.531 8.305-.383.923" }],
    ["path", { d: "m14.772 10.852.923-.383" }],
    ["path", { d: "m14.772 13.148.923.383" }],
    [
      "path",
      {
        d: "M17.598 6.5A3 3 0 1 0 12 5a3 3 0 0 0-5.63-1.446 3 3 0 0 0-.368 1.571 4 4 0 0 0-2.525 5.771"
      }
    ],
    ["path", { d: "M17.998 5.125a4 4 0 0 1 2.525 5.771" }],
    ["path", { d: "M19.505 10.294a4 4 0 0 1-1.5 7.706" }],
    [
      "path",
      { d: "M4.032 17.483A4 4 0 0 0 11.464 20c.18-.311.892-.311 1.072 0a4 4 0 0 0 7.432-2.516" }
    ],
    ["path", { d: "M4.5 10.291A4 4 0 0 0 6 18" }],
    ["path", { d: "M6.002 5.125a3 3 0 0 0 .4 1.375" }],
    ["path", { d: "m9.228 10.852-.923-.383" }],
    ["path", { d: "m9.228 13.148-.923.383" }],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/brain-circuit.js
  var BrainCircuit = [
    [
      "path",
      { d: "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z" }
    ],
    ["path", { d: "M9 13a4.5 4.5 0 0 0 3-4" }],
    ["path", { d: "M6.003 5.125A3 3 0 0 0 6.401 6.5" }],
    ["path", { d: "M3.477 10.896a4 4 0 0 1 .585-.396" }],
    ["path", { d: "M6 18a4 4 0 0 1-1.967-.516" }],
    ["path", { d: "M12 13h4" }],
    ["path", { d: "M12 18h6a2 2 0 0 1 2 2v1" }],
    ["path", { d: "M12 8h8" }],
    ["path", { d: "M16 8V5a2 2 0 0 1 2-2" }],
    ["circle", { cx: "16", cy: "13", r: ".5" }],
    ["circle", { cx: "18", cy: "3", r: ".5" }],
    ["circle", { cx: "20", cy: "21", r: ".5" }],
    ["circle", { cx: "20", cy: "8", r: ".5" }]
  ];

  // node_modules/lucide/dist/esm/icons/brain.js
  var Brain = [
    [
      "path",
      { d: "M12 5a3 3 0 1 0-5.997.125 4 4 0 0 0-2.526 5.77 4 4 0 0 0 .556 6.588A4 4 0 1 0 12 18Z" }
    ],
    [
      "path",
      { d: "M12 5a3 3 0 1 1 5.997.125 4 4 0 0 1 2.526 5.77 4 4 0 0 1-.556 6.588A4 4 0 1 1 12 18Z" }
    ],
    ["path", { d: "M15 13a4.5 4.5 0 0 1-3-4 4.5 4.5 0 0 1-3 4" }],
    ["path", { d: "M17.599 6.5a3 3 0 0 0 .399-1.375" }],
    ["path", { d: "M6.003 5.125A3 3 0 0 0 6.401 6.5" }],
    ["path", { d: "M3.477 10.896a4 4 0 0 1 .585-.396" }],
    ["path", { d: "M19.938 10.5a4 4 0 0 1 .585.396" }],
    ["path", { d: "M6 18a4 4 0 0 1-1.967-.516" }],
    ["path", { d: "M19.967 17.484A4 4 0 0 1 18 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/brick-wall-fire.js
  var BrickWallFire = [
    ["path", { d: "M16 3v2.107" }],
    [
      "path",
      {
        d: "M17 9c1 3 2.5 3.5 3.5 4.5A5 5 0 0 1 22 17a5 5 0 0 1-10 0c0-.3 0-.6.1-.9a2 2 0 1 0 3.3-2C13 11.5 16 9 17 9"
      }
    ],
    ["path", { d: "M21 8.274V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.938" }],
    ["path", { d: "M3 15h5.253" }],
    ["path", { d: "M3 9h8.228" }],
    ["path", { d: "M8 15v6" }],
    ["path", { d: "M8 3v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/brick-wall.js
  var BrickWall = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M12 9v6" }],
    ["path", { d: "M16 15v6" }],
    ["path", { d: "M16 3v6" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M8 15v6" }],
    ["path", { d: "M8 3v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/briefcase-business.js
  var BriefcaseBusiness = [
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M16 6V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M22 13a18.15 18.15 0 0 1-20 0" }],
    ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/briefcase-conveyor-belt.js
  var BriefcaseConveyorBelt = [
    ["path", { d: "M10 20v2" }],
    ["path", { d: "M14 20v2" }],
    ["path", { d: "M18 20v2" }],
    ["path", { d: "M21 20H3" }],
    ["path", { d: "M6 20v2" }],
    ["path", { d: "M8 16V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v12" }],
    ["rect", { x: "4", y: "6", width: "16", height: "10", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/briefcase-medical.js
  var BriefcaseMedical = [
    ["path", { d: "M12 11v4" }],
    ["path", { d: "M14 13h-4" }],
    ["path", { d: "M16 6V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M18 6v14" }],
    ["path", { d: "M6 6v14" }],
    ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/bring-to-front.js
  var BringToFront = [
    ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "2" }],
    ["path", { d: "M4 10a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2" }],
    ["path", { d: "M14 20a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/brush-cleaning.js
  var BrushCleaning = [
    ["path", { d: "m16 22-1-4" }],
    [
      "path",
      {
        d: "M19 13.99a1 1 0 0 0 1-1V12a2 2 0 0 0-2-2h-3a1 1 0 0 1-1-1V4a2 2 0 0 0-4 0v5a1 1 0 0 1-1 1H6a2 2 0 0 0-2 2v.99a1 1 0 0 0 1 1"
      }
    ],
    ["path", { d: "M5 14h14l1.973 6.767A1 1 0 0 1 20 22H4a1 1 0 0 1-.973-1.233z" }],
    ["path", { d: "m8 22 1-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/briefcase.js
  var Briefcase = [
    ["path", { d: "M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" }],
    ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/brush.js
  var Brush = [
    ["path", { d: "m11 10 3 3" }],
    ["path", { d: "M6.5 21A3.5 3.5 0 1 0 3 17.5a2.62 2.62 0 0 1-.708 1.792A1 1 0 0 0 3 21z" }],
    ["path", { d: "M9.969 17.031 21.378 5.624a1 1 0 0 0-3.002-3.002L6.967 14.031" }]
  ];

  // node_modules/lucide/dist/esm/icons/bug-off.js
  var BugOff = [
    ["path", { d: "M15 7.13V6a3 3 0 0 0-5.14-2.1L8 2" }],
    ["path", { d: "M14.12 3.88 16 2" }],
    ["path", { d: "M22 13h-4v-2a4 4 0 0 0-4-4h-1.3" }],
    ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M7.7 7.7A4 4 0 0 0 6 11v3a6 6 0 0 0 11.13 3.13" }],
    ["path", { d: "M12 20v-8" }],
    ["path", { d: "M6 13H2" }],
    ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/bug-play.js
  var BugPlay = [
    [
      "path",
      {
        d: "M12.765 21.522a.5.5 0 0 1-.765-.424v-8.196a.5.5 0 0 1 .765-.424l5.878 3.674a1 1 0 0 1 0 1.696z"
      }
    ],
    ["path", { d: "M14.12 3.88 16 2" }],
    ["path", { d: "M18 11a4 4 0 0 0-4-4h-4a4 4 0 0 0-4 4v3a6.1 6.1 0 0 0 2 4.5" }],
    ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4" }],
    ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4" }],
    ["path", { d: "M6 13H2" }],
    ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5" }],
    ["path", { d: "m8 2 1.88 1.88" }],
    ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/bubbles.js
  var Bubbles = [
    ["path", { d: "M7.2 14.8a2 2 0 0 1 2 2" }],
    ["circle", { cx: "18.5", cy: "8.5", r: "3.5" }],
    ["circle", { cx: "7.5", cy: "16.5", r: "5.5" }],
    ["circle", { cx: "7.5", cy: "4.5", r: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/bug.js
  var Bug = [
    ["path", { d: "m8 2 1.88 1.88" }],
    ["path", { d: "M14.12 3.88 16 2" }],
    ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1" }],
    ["path", { d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6" }],
    ["path", { d: "M12 20v-9" }],
    ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5" }],
    ["path", { d: "M6 13H2" }],
    ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4" }],
    ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4" }],
    ["path", { d: "M22 13h-4" }],
    ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/building-2.js
  var Building2 = [
    ["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z" }],
    ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2" }],
    ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M10 6h4" }],
    ["path", { d: "M10 10h4" }],
    ["path", { d: "M10 14h4" }],
    ["path", { d: "M10 18h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/building.js
  var Building = [
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2" }],
    ["path", { d: "M9 22v-4h6v4" }],
    ["path", { d: "M8 6h.01" }],
    ["path", { d: "M16 6h.01" }],
    ["path", { d: "M12 6h.01" }],
    ["path", { d: "M12 10h.01" }],
    ["path", { d: "M12 14h.01" }],
    ["path", { d: "M16 10h.01" }],
    ["path", { d: "M16 14h.01" }],
    ["path", { d: "M8 10h.01" }],
    ["path", { d: "M8 14h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/bus.js
  var Bus = [
    ["path", { d: "M8 6v6" }],
    ["path", { d: "M15 6v6" }],
    ["path", { d: "M2 12h19.6" }],
    [
      "path",
      {
        d: "M18 18h3s.5-1.7.8-2.8c.1-.4.2-.8.2-1.2 0-.4-.1-.8-.2-1.2l-1.4-5C20.1 6.8 19.1 6 18 6H4a2 2 0 0 0-2 2v10h3"
      }
    ],
    ["circle", { cx: "7", cy: "18", r: "2" }],
    ["path", { d: "M9 18h5" }],
    ["circle", { cx: "16", cy: "18", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cable-car.js
  var CableCar = [
    ["path", { d: "M10 3h.01" }],
    ["path", { d: "M14 2h.01" }],
    ["path", { d: "m2 9 20-5" }],
    ["path", { d: "M12 12V6.5" }],
    ["rect", { width: "16", height: "10", x: "4", y: "12", rx: "3" }],
    ["path", { d: "M9 12v5" }],
    ["path", { d: "M15 12v5" }],
    ["path", { d: "M4 17h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/bus-front.js
  var BusFront = [
    ["path", { d: "M4 6 2 7" }],
    ["path", { d: "M10 6h4" }],
    ["path", { d: "m22 7-2-1" }],
    ["rect", { width: "16", height: "16", x: "4", y: "3", rx: "2" }],
    ["path", { d: "M4 11h16" }],
    ["path", { d: "M8 15h.01" }],
    ["path", { d: "M16 15h.01" }],
    ["path", { d: "M6 19v2" }],
    ["path", { d: "M18 21v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cable.js
  var Cable = [
    ["path", { d: "M17 21v-2a1 1 0 0 1-1-1v-1a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v1a1 1 0 0 1-1 1" }],
    ["path", { d: "M19 15V6.5a1 1 0 0 0-7 0v11a1 1 0 0 1-7 0V9" }],
    ["path", { d: "M21 21v-2h-4" }],
    ["path", { d: "M3 5h4V3" }],
    ["path", { d: "M7 5a1 1 0 0 1 1 1v1a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1V3" }]
  ];

  // node_modules/lucide/dist/esm/icons/cake-slice.js
  var CakeSlice = [
    ["circle", { cx: "9", cy: "7", r: "2" }],
    ["path", { d: "M7.2 7.9 3 11v9c0 .6.4 1 1 1h16c.6 0 1-.4 1-1v-9c0-2-3-6-7-8l-3.6 2.6" }],
    ["path", { d: "M16 13H3" }],
    ["path", { d: "M16 17H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/cake.js
  var Cake = [
    ["path", { d: "M20 21v-8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8" }],
    ["path", { d: "M4 16s.5-1 2-1 2.5 2 4 2 2.5-2 4-2 2.5 2 4 2 2-1 2-1" }],
    ["path", { d: "M2 21h20" }],
    ["path", { d: "M7 8v3" }],
    ["path", { d: "M12 8v3" }],
    ["path", { d: "M17 8v3" }],
    ["path", { d: "M7 4h.01" }],
    ["path", { d: "M12 4h.01" }],
    ["path", { d: "M17 4h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-1.js
  var Calendar1 = [
    ["path", { d: "M11 14h1v4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }],
    ["rect", { x: "3", y: "4", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-arrow-down.js
  var CalendarArrowDown = [
    ["path", { d: "m14 18 4 4 4-4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M18 14v8" }],
    ["path", { d: "M21 11.354V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7.343" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calculator.js
  var Calculator = [
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2" }],
    ["line", { x1: "8", x2: "16", y1: "6", y2: "6" }],
    ["line", { x1: "16", x2: "16", y1: "14", y2: "18" }],
    ["path", { d: "M16 10h.01" }],
    ["path", { d: "M12 10h.01" }],
    ["path", { d: "M8 10h.01" }],
    ["path", { d: "M12 14h.01" }],
    ["path", { d: "M8 14h.01" }],
    ["path", { d: "M12 18h.01" }],
    ["path", { d: "M8 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-arrow-up.js
  var CalendarArrowUp = [
    ["path", { d: "m14 18 4-4 4 4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M18 22v-8" }],
    ["path", { d: "M21 11.343V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h9" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-check-2.js
  var CalendarCheck2 = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M21 14V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "m16 20 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-check.js
  var CalendarCheck = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "m9 16 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-clock.js
  var CalendarClock = [
    ["path", { d: "M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M3 10h5" }],
    ["path", { d: "M17.5 17.5 16 16.3V14" }],
    ["circle", { cx: "16", cy: "16", r: "6" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-cog.js
  var CalendarCog = [
    ["path", { d: "m15.228 16.852-.923-.383" }],
    ["path", { d: "m15.228 19.148-.923.383" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "m16.47 14.305.382.923" }],
    ["path", { d: "m16.852 20.772-.383.924" }],
    ["path", { d: "m19.148 15.228.383-.923" }],
    ["path", { d: "m19.53 21.696-.382-.924" }],
    ["path", { d: "m20.772 16.852.924-.383" }],
    ["path", { d: "m20.772 19.148.924.383" }],
    ["path", { d: "M21 11V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-days.js
  var CalendarDays = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 14h.01" }],
    ["path", { d: "M12 14h.01" }],
    ["path", { d: "M16 14h.01" }],
    ["path", { d: "M8 18h.01" }],
    ["path", { d: "M12 18h.01" }],
    ["path", { d: "M16 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-fold.js
  var CalendarFold = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M21 17V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11Z" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M15 22v-4a2 2 0 0 1 2-2h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-heart.js
  var CalendarHeart = [
    ["path", { d: "M3 10h18V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7" }],
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    [
      "path",
      {
        d: "M21.29 14.7a2.43 2.43 0 0 0-2.65-.52c-.3.12-.57.3-.8.53l-.34.34-.35-.34a2.43 2.43 0 0 0-2.65-.53c-.3.12-.56.3-.79.53-.95.94-1 2.53.2 3.74L17.5 22l3.6-3.55c1.2-1.21 1.14-2.8.19-3.74Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-minus-2.js
  var CalendarMinus2 = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M10 16h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-minus.js
  var CalendarMinus = [
    ["path", { d: "M16 19h6" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M21 15V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-off.js
  var CalendarOff = [
    ["path", { d: "M4.2 4.2A2 2 0 0 0 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 1.82-1.18" }],
    ["path", { d: "M21 15.5V6a2 2 0 0 0-2-2H9.5" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M3 10h7" }],
    ["path", { d: "M21 10h-5.5" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-plus-2.js
  var CalendarPlus2 = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M10 16h4" }],
    ["path", { d: "M12 14v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-plus.js
  var CalendarPlus = [
    ["path", { d: "M16 19h6" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M19 16v6" }],
    ["path", { d: "M21 12.598V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-range.js
  var CalendarRange = [
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M17 14h-6" }],
    ["path", { d: "M13 18H7" }],
    ["path", { d: "M7 14h.01" }],
    ["path", { d: "M17 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-search.js
  var CalendarSearch = [
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M21 11.75V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7.25" }],
    ["path", { d: "m22 22-1.875-1.875" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "M8 2v4" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-sync.js
  var CalendarSync = [
    ["path", { d: "M11 10v4h4" }],
    ["path", { d: "m11 14 1.535-1.605a5 5 0 0 1 8 1.5" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "m21 18-1.535 1.605a5 5 0 0 1-8-1.5" }],
    ["path", { d: "M21 22v-4h-4" }],
    ["path", { d: "M21 8.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h4.3" }],
    ["path", { d: "M3 10h4" }],
    ["path", { d: "M8 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-x-2.js
  var CalendarX2 = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M21 13V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "m17 22 5-5" }],
    ["path", { d: "m17 17 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar-x.js
  var CalendarX = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }],
    ["path", { d: "m14 14-4 4" }],
    ["path", { d: "m10 14 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/calendar.js
  var Calendar = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2" }],
    ["path", { d: "M3 10h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/camera-off.js
  var CameraOff = [
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }],
    ["path", { d: "M7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M9.5 4h5L17 7h3a2 2 0 0 1 2 2v7.5" }],
    ["path", { d: "M14.121 15.121A3 3 0 1 1 9.88 10.88" }]
  ];

  // node_modules/lucide/dist/esm/icons/camera.js
  var Camera = [
    [
      "path",
      {
        d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"
      }
    ],
    ["circle", { cx: "12", cy: "13", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/candy-cane.js
  var CandyCane = [
    [
      "path",
      { d: "M5.7 21a2 2 0 0 1-3.5-2l8.6-14a6 6 0 0 1 10.4 6 2 2 0 1 1-3.464-2 2 2 0 1 0-3.464-2Z" }
    ],
    ["path", { d: "M17.75 7 15 2.1" }],
    ["path", { d: "M10.9 4.8 13 9" }],
    ["path", { d: "m7.9 9.7 2 4.4" }],
    ["path", { d: "M4.9 14.7 7 18.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/candy-off.js
  var CandyOff = [
    ["path", { d: "M10 10v7.9" }],
    ["path", { d: "M11.802 6.145a5 5 0 0 1 6.053 6.053" }],
    ["path", { d: "M14 6.1v2.243" }],
    ["path", { d: "m15.5 15.571-.964.964a5 5 0 0 1-7.071 0 5 5 0 0 1 0-7.07l.964-.965" }],
    [
      "path",
      {
        d: "M16 7V3a1 1 0 0 1 1.707-.707 2.5 2.5 0 0 0 2.152.717 1 1 0 0 1 1.131 1.131 2.5 2.5 0 0 0 .717 2.152A1 1 0 0 1 21 8h-4"
      }
    ],
    ["path", { d: "m2 2 20 20" }],
    [
      "path",
      {
        d: "M8 17v4a1 1 0 0 1-1.707.707 2.5 2.5 0 0 0-2.152-.717 1 1 0 0 1-1.131-1.131 2.5 2.5 0 0 0-.717-2.152A1 1 0 0 1 3 16h4"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/candy.js
  var Candy = [
    ["path", { d: "M10 7v10.9" }],
    ["path", { d: "M14 6.1V17" }],
    [
      "path",
      {
        d: "M16 7V3a1 1 0 0 1 1.707-.707 2.5 2.5 0 0 0 2.152.717 1 1 0 0 1 1.131 1.131 2.5 2.5 0 0 0 .717 2.152A1 1 0 0 1 21 8h-4"
      }
    ],
    [
      "path",
      {
        d: "M16.536 7.465a5 5 0 0 0-7.072 0l-2 2a5 5 0 0 0 0 7.07 5 5 0 0 0 7.072 0l2-2a5 5 0 0 0 0-7.07"
      }
    ],
    [
      "path",
      {
        d: "M8 17v4a1 1 0 0 1-1.707.707 2.5 2.5 0 0 0-2.152-.717 1 1 0 0 1-1.131-1.131 2.5 2.5 0 0 0-.717-2.152A1 1 0 0 1 3 16h4"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/cannabis.js
  var Cannabis = [
    ["path", { d: "M12 22v-4" }],
    [
      "path",
      {
        d: "M7 12c-1.5 0-4.5 1.5-5 3 3.5 1.5 6 1 6 1-1.5 1.5-2 3.5-2 5 2.5 0 4.5-1.5 6-3 1.5 1.5 3.5 3 6 3 0-1.5-.5-3.5-2-5 0 0 2.5.5 6-1-.5-1.5-3.5-3-5-3 1.5-1 4-4 4-6-2.5 0-5.5 1.5-7 3 0-2.5-.5-5-2-7-1.5 2-2 4.5-2 7-1.5-1.5-4.5-3-7-3 0 2 2.5 5 4 6"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/captions-off.js
  var CaptionsOff = [
    ["path", { d: "M10.5 5H19a2 2 0 0 1 2 2v8.5" }],
    ["path", { d: "M17 11h-.5" }],
    ["path", { d: "M19 19H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M7 11h4" }],
    ["path", { d: "M7 15h2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/car-front.js
  var CarFront = [
    ["path", { d: "m21 8-2 2-1.5-3.7A2 2 0 0 0 15.646 5H8.4a2 2 0 0 0-1.903 1.257L5 10 3 8" }],
    ["path", { d: "M7 14h.01" }],
    ["path", { d: "M17 14h.01" }],
    ["rect", { width: "18", height: "8", x: "3", y: "10", rx: "2" }],
    ["path", { d: "M5 18v2" }],
    ["path", { d: "M19 18v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/captions.js
  var Captions = [
    ["rect", { width: "18", height: "14", x: "3", y: "5", rx: "2", ry: "2" }],
    ["path", { d: "M7 15h4M15 15h2M7 11h2M13 11h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/car-taxi-front.js
  var CarTaxiFront = [
    ["path", { d: "M10 2h4" }],
    ["path", { d: "m21 8-2 2-1.5-3.7A2 2 0 0 0 15.646 5H8.4a2 2 0 0 0-1.903 1.257L5 10 3 8" }],
    ["path", { d: "M7 14h.01" }],
    ["path", { d: "M17 14h.01" }],
    ["rect", { width: "18", height: "8", x: "3", y: "10", rx: "2" }],
    ["path", { d: "M5 18v2" }],
    ["path", { d: "M19 18v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/car.js
  var Car = [
    [
      "path",
      {
        d: "M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2"
      }
    ],
    ["circle", { cx: "7", cy: "17", r: "2" }],
    ["path", { d: "M9 17h6" }],
    ["circle", { cx: "17", cy: "17", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/caravan.js
  var Caravan = [
    ["path", { d: "M18 19V9a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v8a2 2 0 0 0 2 2h2" }],
    ["path", { d: "M2 9h3a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H2" }],
    ["path", { d: "M22 17v1a1 1 0 0 1-1 1H10v-9a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v9" }],
    ["circle", { cx: "8", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/carrot.js
  var Carrot = [
    [
      "path",
      {
        d: "M2.27 21.7s9.87-3.5 12.73-6.36a4.5 4.5 0 0 0-6.36-6.37C5.77 11.84 2.27 21.7 2.27 21.7zM8.64 14l-2.05-2.04M15.34 15l-2.46-2.46"
      }
    ],
    ["path", { d: "M22 9s-1.33-2-3.5-2C16.86 7 15 9 15 9s1.33 2 3.5 2S22 9 22 9z" }],
    ["path", { d: "M15 2s-2 1.33-2 3.5S15 9 15 9s2-1.84 2-3.5C17 3.33 15 2 15 2z" }]
  ];

  // node_modules/lucide/dist/esm/icons/case-lower.js
  var CaseLower = [
    ["circle", { cx: "7", cy: "12", r: "3" }],
    ["path", { d: "M10 9v6" }],
    ["circle", { cx: "17", cy: "12", r: "3" }],
    ["path", { d: "M14 7v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/case-sensitive.js
  var CaseSensitive = [
    ["path", { d: "m3 15 4-8 4 8" }],
    ["path", { d: "M4 13h6" }],
    ["circle", { cx: "18", cy: "12", r: "3" }],
    ["path", { d: "M21 9v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/case-upper.js
  var CaseUpper = [
    ["path", { d: "m3 15 4-8 4 8" }],
    ["path", { d: "M4 13h6" }],
    ["path", { d: "M15 11h4.5a2 2 0 0 1 0 4H15V7h4a2 2 0 0 1 0 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/cassette-tape.js
  var CassetteTape = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["circle", { cx: "8", cy: "10", r: "2" }],
    ["path", { d: "M8 12h8" }],
    ["circle", { cx: "16", cy: "10", r: "2" }],
    ["path", { d: "m6 20 .7-2.9A1.4 1.4 0 0 1 8.1 16h7.8a1.4 1.4 0 0 1 1.4 1l.7 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/cast.js
  var Cast = [
    ["path", { d: "M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6" }],
    ["path", { d: "M2 12a9 9 0 0 1 8 8" }],
    ["path", { d: "M2 16a5 5 0 0 1 4 4" }],
    ["line", { x1: "2", x2: "2.01", y1: "20", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/castle.js
  var Castle = [
    ["path", { d: "M22 20v-9H2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2Z" }],
    ["path", { d: "M18 11V4H6v7" }],
    ["path", { d: "M15 22v-4a3 3 0 0 0-3-3a3 3 0 0 0-3 3v4" }],
    ["path", { d: "M22 11V9" }],
    ["path", { d: "M2 11V9" }],
    ["path", { d: "M6 4V2" }],
    ["path", { d: "M18 4V2" }],
    ["path", { d: "M10 4V2" }],
    ["path", { d: "M14 4V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cat.js
  var Cat = [
    [
      "path",
      {
        d: "M12 5c.67 0 1.35.09 2 .26 1.78-2 5.03-2.84 6.42-2.26 1.4.58-.42 7-.42 7 .57 1.07 1 2.24 1 3.44C21 17.9 16.97 21 12 21s-9-3-9-7.56c0-1.25.5-2.4 1-3.44 0 0-1.89-6.42-.5-7 1.39-.58 4.72.23 6.5 2.23A9.04 9.04 0 0 1 12 5Z"
      }
    ],
    ["path", { d: "M8 14v.5" }],
    ["path", { d: "M16 14v.5" }],
    ["path", { d: "M11.25 16.25h1.5L12 17l-.75-.75Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-area.js
  var ChartArea = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    [
      "path",
      {
        d: "M7 11.207a.5.5 0 0 1 .146-.353l2-2a.5.5 0 0 1 .708 0l3.292 3.292a.5.5 0 0 0 .708 0l4.292-4.292a.5.5 0 0 1 .854.353V16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/cctv.js
  var Cctv = [
    [
      "path",
      { d: "M16.75 12h3.632a1 1 0 0 1 .894 1.447l-2.034 4.069a1 1 0 0 1-1.708.134l-2.124-2.97" }
    ],
    [
      "path",
      {
        d: "M17.106 9.053a1 1 0 0 1 .447 1.341l-3.106 6.211a1 1 0 0 1-1.342.447L3.61 12.3a2.92 2.92 0 0 1-1.3-3.91L3.69 5.6a2.92 2.92 0 0 1 3.92-1.3z"
      }
    ],
    ["path", { d: "M2 19h3.76a2 2 0 0 0 1.8-1.1L9 15" }],
    ["path", { d: "M2 21v-4" }],
    ["path", { d: "M7 9h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-bar-big.js
  var ChartBarBig = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["rect", { x: "7", y: "13", width: "9", height: "4", rx: "1" }],
    ["rect", { x: "7", y: "5", width: "12", height: "4", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-bar-decreasing.js
  var ChartBarDecreasing = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M7 11h8" }],
    ["path", { d: "M7 16h3" }],
    ["path", { d: "M7 6h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-bar-stacked.js
  var ChartBarStacked = [
    ["path", { d: "M11 13v4" }],
    ["path", { d: "M15 5v4" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["rect", { x: "7", y: "13", width: "9", height: "4", rx: "1" }],
    ["rect", { x: "7", y: "5", width: "12", height: "4", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-bar-increasing.js
  var ChartBarIncreasing = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M7 11h8" }],
    ["path", { d: "M7 16h12" }],
    ["path", { d: "M7 6h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-bar.js
  var ChartBar = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M7 16h8" }],
    ["path", { d: "M7 11h12" }],
    ["path", { d: "M7 6h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-candlestick.js
  var ChartCandlestick = [
    ["path", { d: "M9 5v4" }],
    ["rect", { width: "4", height: "6", x: "7", y: "9", rx: "1" }],
    ["path", { d: "M9 15v2" }],
    ["path", { d: "M17 3v2" }],
    ["rect", { width: "4", height: "8", x: "15", y: "5", rx: "1" }],
    ["path", { d: "M17 13v3" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-column-big.js
  var ChartColumnBig = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["rect", { x: "15", y: "5", width: "4", height: "12", rx: "1" }],
    ["rect", { x: "7", y: "8", width: "4", height: "9", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-column-decreasing.js
  var ChartColumnDecreasing = [
    ["path", { d: "M13 17V9" }],
    ["path", { d: "M18 17v-3" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M8 17V5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-column-increasing.js
  var ChartColumnIncreasing = [
    ["path", { d: "M13 17V9" }],
    ["path", { d: "M18 17V5" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M8 17v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-column-stacked.js
  var ChartColumnStacked = [
    ["path", { d: "M11 13H7" }],
    ["path", { d: "M19 9h-4" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["rect", { x: "15", y: "5", width: "4", height: "12", rx: "1" }],
    ["rect", { x: "7", y: "8", width: "4", height: "9", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-column.js
  var ChartColumn = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M18 17V9" }],
    ["path", { d: "M13 17V5" }],
    ["path", { d: "M8 17v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-gantt.js
  var ChartGantt = [
    ["path", { d: "M10 6h8" }],
    ["path", { d: "M12 16h6" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M8 11h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-line.js
  var ChartLine = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "m19 9-5 5-4-4-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-network.js
  var ChartNetwork = [
    ["path", { d: "m13.11 7.664 1.78 2.672" }],
    ["path", { d: "m14.162 12.788-3.324 1.424" }],
    ["path", { d: "m20 4-6.06 1.515" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["circle", { cx: "12", cy: "6", r: "2" }],
    ["circle", { cx: "16", cy: "12", r: "2" }],
    ["circle", { cx: "9", cy: "15", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-no-axes-column-decreasing.js
  var ChartNoAxesColumnDecreasing = [
    ["path", { d: "M12 20V10" }],
    ["path", { d: "M18 20v-4" }],
    ["path", { d: "M6 20V4" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-no-axes-column-increasing.js
  var ChartNoAxesColumnIncreasing = [
    ["line", { x1: "12", x2: "12", y1: "20", y2: "10" }],
    ["line", { x1: "18", x2: "18", y1: "20", y2: "4" }],
    ["line", { x1: "6", x2: "6", y1: "20", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-no-axes-column.js
  var ChartNoAxesColumn = [
    ["line", { x1: "18", x2: "18", y1: "20", y2: "10" }],
    ["line", { x1: "12", x2: "12", y1: "20", y2: "4" }],
    ["line", { x1: "6", x2: "6", y1: "20", y2: "14" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-no-axes-combined.js
  var ChartNoAxesCombined = [
    ["path", { d: "M12 16v5" }],
    ["path", { d: "M16 14v7" }],
    ["path", { d: "M20 10v11" }],
    ["path", { d: "m22 3-8.646 8.646a.5.5 0 0 1-.708 0L9.354 8.354a.5.5 0 0 0-.707 0L2 15" }],
    ["path", { d: "M4 18v3" }],
    ["path", { d: "M8 14v7" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-no-axes-gantt.js
  var ChartNoAxesGantt = [
    ["path", { d: "M8 6h10" }],
    ["path", { d: "M6 12h9" }],
    ["path", { d: "M11 18h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-pie.js
  var ChartPie = [
    [
      "path",
      {
        d: "M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"
      }
    ],
    ["path", { d: "M21.21 15.89A10 10 0 1 1 8 2.83" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-scatter.js
  var ChartScatter = [
    ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "18.5", cy: "5.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "11.5", cy: "11.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "7.5", cy: "16.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "17.5", cy: "14.5", r: ".5", fill: "currentColor" }],
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/chart-spline.js
  var ChartSpline = [
    ["path", { d: "M3 3v16a2 2 0 0 0 2 2h16" }],
    ["path", { d: "M7 16c.5-2 1.5-7 4-7 2 0 2 3 4 3 2.5 0 4.5-5 5-7" }]
  ];

  // node_modules/lucide/dist/esm/icons/check-check.js
  var CheckCheck = [
    ["path", { d: "M18 6 7 17l-5-5" }],
    ["path", { d: "m22 10-7.5 7.5L13 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/check.js
  var Check = [["path", { d: "M20 6 9 17l-5-5" }]];

  // node_modules/lucide/dist/esm/icons/chef-hat.js
  var ChefHat = [
    [
      "path",
      {
        d: "M17 21a1 1 0 0 0 1-1v-5.35c0-.457.316-.844.727-1.041a4 4 0 0 0-2.134-7.589 5 5 0 0 0-9.186 0 4 4 0 0 0-2.134 7.588c.411.198.727.585.727 1.041V20a1 1 0 0 0 1 1Z"
      }
    ],
    ["path", { d: "M6 17h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/cherry.js
  var Cherry = [
    ["path", { d: "M2 17a5 5 0 0 0 10 0c0-2.76-2.5-5-5-3-2.5-2-5 .24-5 3Z" }],
    ["path", { d: "M12 17a5 5 0 0 0 10 0c0-2.76-2.5-5-5-3-2.5-2-5 .24-5 3Z" }],
    ["path", { d: "M7 14c3.22-2.91 4.29-8.75 5-12 1.66 2.38 4.94 9 5 12" }],
    ["path", { d: "M22 9c-4.29 0-7.14-2.33-10-7 5.71 0 10 4.67 10 7Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevron-down.js
  var ChevronDown = [["path", { d: "m6 9 6 6 6-6" }]];

  // node_modules/lucide/dist/esm/icons/chevron-first.js
  var ChevronFirst = [
    ["path", { d: "m17 18-6-6 6-6" }],
    ["path", { d: "M7 6v12" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevron-left.js
  var ChevronLeft = [["path", { d: "m15 18-6-6 6-6" }]];

  // node_modules/lucide/dist/esm/icons/chevron-last.js
  var ChevronLast = [
    ["path", { d: "m7 18 6-6-6-6" }],
    ["path", { d: "M17 6v12" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevron-right.js
  var ChevronRight = [["path", { d: "m9 18 6-6-6-6" }]];

  // node_modules/lucide/dist/esm/icons/chevrons-down-up.js
  var ChevronsDownUp = [
    ["path", { d: "m7 20 5-5 5 5" }],
    ["path", { d: "m7 4 5 5 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevron-up.js
  var ChevronUp = [["path", { d: "m18 15-6-6-6 6" }]];

  // node_modules/lucide/dist/esm/icons/chevrons-down.js
  var ChevronsDown = [
    ["path", { d: "m7 6 5 5 5-5" }],
    ["path", { d: "m7 13 5 5 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-left-right-ellipsis.js
  var ChevronsLeftRightEllipsis = [
    ["path", { d: "m18 8 4 4-4 4" }],
    ["path", { d: "m6 8-4 4 4 4" }],
    ["path", { d: "M8 12h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M16 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-left-right.js
  var ChevronsLeftRight = [
    ["path", { d: "m9 7-5 5 5 5" }],
    ["path", { d: "m15 7 5 5-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-left.js
  var ChevronsLeft = [
    ["path", { d: "m11 17-5-5 5-5" }],
    ["path", { d: "m18 17-5-5 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-right-left.js
  var ChevronsRightLeft = [
    ["path", { d: "m20 17-5-5 5-5" }],
    ["path", { d: "m4 17 5-5-5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-up-down.js
  var ChevronsUpDown = [
    ["path", { d: "m7 15 5 5 5-5" }],
    ["path", { d: "m7 9 5-5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-right.js
  var ChevronsRight = [
    ["path", { d: "m6 17 5-5-5-5" }],
    ["path", { d: "m13 17 5-5-5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chevrons-up.js
  var ChevronsUp = [
    ["path", { d: "m17 11-5-5-5 5" }],
    ["path", { d: "m17 18-5-5-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/chrome.js
  var Chrome = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["line", { x1: "21.17", x2: "12", y1: "8", y2: "8" }],
    ["line", { x1: "3.95", x2: "8.54", y1: "6.06", y2: "14" }],
    ["line", { x1: "10.88", x2: "15.46", y1: "21.94", y2: "14" }]
  ];

  // node_modules/lucide/dist/esm/icons/cigarette-off.js
  var CigaretteOff = [
    ["path", { d: "M12 12H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h13" }],
    ["path", { d: "M18 8c0-2.5-2-2.5-2-5" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M21 12a1 1 0 0 1 1 1v2a1 1 0 0 1-.5.866" }],
    ["path", { d: "M22 8c0-2.5-2-2.5-2-5" }],
    ["path", { d: "M7 12v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/church.js
  var Church = [
    ["path", { d: "M10 9h4" }],
    ["path", { d: "M12 7v5" }],
    ["path", { d: "M14 22v-4a2 2 0 0 0-4 0v4" }],
    [
      "path",
      {
        d: "M18 22V5.618a1 1 0 0 0-.553-.894l-4.553-2.277a2 2 0 0 0-1.788 0L6.553 4.724A1 1 0 0 0 6 5.618V22"
      }
    ],
    [
      "path",
      {
        d: "m18 7 3.447 1.724a1 1 0 0 1 .553.894V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9.618a1 1 0 0 1 .553-.894L6 7"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/cigarette.js
  var Cigarette = [
    ["path", { d: "M17 12H3a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h14" }],
    ["path", { d: "M18 8c0-2.5-2-2.5-2-5" }],
    ["path", { d: "M21 16a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1" }],
    ["path", { d: "M22 8c0-2.5-2-2.5-2-5" }],
    ["path", { d: "M7 12v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-alert.js
  var CircleAlert = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "12" }],
    ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-down.js
  var CircleArrowDown = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M12 8v8" }],
    ["path", { d: "m8 12 4 4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-left.js
  var CircleArrowLeft = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M16 12H8" }],
    ["path", { d: "m12 8-4 4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-out-down-left.js
  var CircleArrowOutDownLeft = [
    ["path", { d: "M2 12a10 10 0 1 1 10 10" }],
    ["path", { d: "m2 22 10-10" }],
    ["path", { d: "M8 22H2v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-out-down-right.js
  var CircleArrowOutDownRight = [
    ["path", { d: "M12 22a10 10 0 1 1 10-10" }],
    ["path", { d: "M22 22 12 12" }],
    ["path", { d: "M22 16v6h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-out-up-left.js
  var CircleArrowOutUpLeft = [
    ["path", { d: "M2 8V2h6" }],
    ["path", { d: "m2 2 10 10" }],
    ["path", { d: "M12 2A10 10 0 1 1 2 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-out-up-right.js
  var CircleArrowOutUpRight = [
    ["path", { d: "M22 12A10 10 0 1 1 12 2" }],
    ["path", { d: "M22 2 12 12" }],
    ["path", { d: "M16 2h6v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-up.js
  var CircleArrowUp = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m16 12-4-4-4 4" }],
    ["path", { d: "M12 16V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-arrow-right.js
  var CircleArrowRight = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "m12 16 4-4-4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-check-big.js
  var CircleCheckBig = [
    ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335" }],
    ["path", { d: "m9 11 3 3L22 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-check.js
  var CircleCheck = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m9 12 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-chevron-down.js
  var CircleChevronDown = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m16 10-4 4-4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-chevron-left.js
  var CircleChevronLeft = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m14 16-4-4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-chevron-right.js
  var CircleChevronRight = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m10 8 4 4-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-chevron-up.js
  var CircleChevronUp = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m8 14 4-4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-dashed.js
  var CircleDashed = [
    ["path", { d: "M10.1 2.182a10 10 0 0 1 3.8 0" }],
    ["path", { d: "M13.9 21.818a10 10 0 0 1-3.8 0" }],
    ["path", { d: "M17.609 3.721a10 10 0 0 1 2.69 2.7" }],
    ["path", { d: "M2.182 13.9a10 10 0 0 1 0-3.8" }],
    ["path", { d: "M20.279 17.609a10 10 0 0 1-2.7 2.69" }],
    ["path", { d: "M21.818 10.1a10 10 0 0 1 0 3.8" }],
    ["path", { d: "M3.721 6.391a10 10 0 0 1 2.7-2.69" }],
    ["path", { d: "M6.391 20.279a10 10 0 0 1-2.69-2.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-divide.js
  var CircleDivide = [
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "16", y2: "16" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "8" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-dollar-sign.js
  var CircleDollarSign = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M16 8h-6a2 2 0 1 0 0 4h4a2 2 0 1 1 0 4H8" }],
    ["path", { d: "M12 18V6" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-dot-dashed.js
  var CircleDotDashed = [
    ["path", { d: "M10.1 2.18a9.93 9.93 0 0 1 3.8 0" }],
    ["path", { d: "M17.6 3.71a9.95 9.95 0 0 1 2.69 2.7" }],
    ["path", { d: "M21.82 10.1a9.93 9.93 0 0 1 0 3.8" }],
    ["path", { d: "M20.29 17.6a9.95 9.95 0 0 1-2.7 2.69" }],
    ["path", { d: "M13.9 21.82a9.94 9.94 0 0 1-3.8 0" }],
    ["path", { d: "M6.4 20.29a9.95 9.95 0 0 1-2.69-2.7" }],
    ["path", { d: "M2.18 13.9a9.93 9.93 0 0 1 0-3.8" }],
    ["path", { d: "M3.71 6.4a9.95 9.95 0 0 1 2.7-2.69" }],
    ["circle", { cx: "12", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-dot.js
  var CircleDot = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-ellipsis.js
  var CircleEllipsis = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M17 12h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M7 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-equal.js
  var CircleEqual = [
    ["path", { d: "M7 10h10" }],
    ["path", { d: "M7 14h10" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-fading-arrow-up.js
  var CircleFadingArrowUp = [
    ["path", { d: "M12 2a10 10 0 0 1 7.38 16.75" }],
    ["path", { d: "m16 12-4-4-4 4" }],
    ["path", { d: "M12 16V8" }],
    ["path", { d: "M2.5 8.875a10 10 0 0 0-.5 3" }],
    ["path", { d: "M2.83 16a10 10 0 0 0 2.43 3.4" }],
    ["path", { d: "M4.636 5.235a10 10 0 0 1 .891-.857" }],
    ["path", { d: "M8.644 21.42a10 10 0 0 0 7.631-.38" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-fading-plus.js
  var CircleFadingPlus = [
    ["path", { d: "M12 2a10 10 0 0 1 7.38 16.75" }],
    ["path", { d: "M12 8v8" }],
    ["path", { d: "M16 12H8" }],
    ["path", { d: "M2.5 8.875a10 10 0 0 0-.5 3" }],
    ["path", { d: "M2.83 16a10 10 0 0 0 2.43 3.4" }],
    ["path", { d: "M4.636 5.235a10 10 0 0 1 .891-.857" }],
    ["path", { d: "M8.644 21.42a10 10 0 0 0 7.631-.38" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-gauge.js
  var CircleGauge = [
    ["path", { d: "M15.6 2.7a10 10 0 1 0 5.7 5.7" }],
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "M13.4 10.6 19 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-help.js
  var CircleHelp = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" }],
    ["path", { d: "M12 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-minus.js
  var CircleMinus = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-off.js
  var CircleOff = [
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M8.35 2.69A10 10 0 0 1 21.3 15.65" }],
    ["path", { d: "M19.08 19.08A10 10 0 1 1 4.92 4.92" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-parking-off.js
  var CircleParkingOff = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m5 5 14 14" }],
    ["path", { d: "M13 13a3 3 0 1 0 0-6H9v2" }],
    ["path", { d: "M9 17v-2.34" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-parking.js
  var CircleParking = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M9 17V7h4a3 3 0 0 1 0 6H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-pause.js
  var CirclePause = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["line", { x1: "10", x2: "10", y1: "15", y2: "9" }],
    ["line", { x1: "14", x2: "14", y1: "15", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-percent.js
  var CirclePercent = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "M9 9h.01" }],
    ["path", { d: "M15 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-play.js
  var CirclePlay = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polygon", { points: "10 8 16 12 10 16 10 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-plus.js
  var CirclePlus = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "M12 8v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-power.js
  var CirclePower = [
    ["path", { d: "M12 7v4" }],
    ["path", { d: "M7.998 9.003a5 5 0 1 0 8-.005" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-slash-2.js
  var CircleSlash2 = [
    ["path", { d: "M22 2 2 22" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-slash.js
  var CircleSlash = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["line", { x1: "9", x2: "15", y1: "15", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-small.js
  var CircleSmall = [["circle", { cx: "12", cy: "12", r: "6" }]];

  // node_modules/lucide/dist/esm/icons/circle-stop.js
  var CircleStop = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["rect", { x: "9", y: "9", width: "6", height: "6", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-user-round.js
  var CircleUserRound = [
    ["path", { d: "M18 20a6 6 0 0 0-12 0" }],
    ["circle", { cx: "12", cy: "10", r: "4" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-user.js
  var CircleUser = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle.js
  var Circle = [["circle", { cx: "12", cy: "12", r: "10" }]];

  // node_modules/lucide/dist/esm/icons/circuit-board.js
  var CircuitBoard = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M11 9h4a2 2 0 0 0 2-2V3" }],
    ["circle", { cx: "9", cy: "9", r: "2" }],
    ["path", { d: "M7 21v-4a2 2 0 0 1 2-2h4" }],
    ["circle", { cx: "15", cy: "15", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/circle-x.js
  var CircleX = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/citrus.js
  var Citrus = [
    [
      "path",
      { d: "M21.66 17.67a1.08 1.08 0 0 1-.04 1.6A12 12 0 0 1 4.73 2.38a1.1 1.1 0 0 1 1.61-.04z" }
    ],
    ["path", { d: "M19.65 15.66A8 8 0 0 1 8.35 4.34" }],
    ["path", { d: "m14 10-5.5 5.5" }],
    ["path", { d: "M14 17.85V10H6.15" }]
  ];

  // node_modules/lucide/dist/esm/icons/clapperboard.js
  var Clapperboard = [
    ["path", { d: "M20.2 6 3 11l-.9-2.4c-.3-1.1.3-2.2 1.3-2.5l13.5-4c1.1-.3 2.2.3 2.5 1.3Z" }],
    ["path", { d: "m6.2 5.3 3.1 3.9" }],
    ["path", { d: "m12.4 3.4 3.1 4" }],
    ["path", { d: "M3 11h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-check.js
  var ClipboardCheck = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "m9 14 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-copy.js
  var ClipboardCopy = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v4" }],
    ["path", { d: "M21 14H11" }],
    ["path", { d: "m15 10-4 4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-list.js
  var ClipboardList = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M12 11h4" }],
    ["path", { d: "M12 16h4" }],
    ["path", { d: "M8 11h.01" }],
    ["path", { d: "M8 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-minus.js
  var ClipboardMinus = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M9 14h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-paste.js
  var ClipboardPaste = [
    ["path", { d: "M11 14h10" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v1.344" }],
    ["path", { d: "m17 18 4-4-4-4" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 1.793-1.113" }],
    ["rect", { x: "8", y: "2", width: "8", height: "4", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-pen-line.js
  var ClipboardPenLine = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1" }],
    ["path", { d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-.5" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 1.73 1" }],
    ["path", { d: "M8 18h1" }],
    [
      "path",
      {
        d: "M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-pen.js
  var ClipboardPen = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-5.5" }],
    ["path", { d: "M4 13.5V6a2 2 0 0 1 2-2h2" }],
    [
      "path",
      {
        d: "M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-plus.js
  var ClipboardPlus = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M9 14h6" }],
    ["path", { d: "M12 17v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-type.js
  var ClipboardType = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M9 12v-1h6v1" }],
    ["path", { d: "M11 17h2" }],
    ["path", { d: "M12 11v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard-x.js
  var ClipboardX = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "m15 11-6 6" }],
    ["path", { d: "m9 11 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/clipboard.js
  var Clipboard = [
    ["rect", { width: "8", height: "4", x: "8", y: "2", rx: "1", ry: "1" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-1.js
  var Clock1 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 14.5 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-10.js
  var Clock10 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 8 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-11.js
  var Clock11 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 9.5 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-12.js
  var Clock12 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-2.js
  var Clock2 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 16 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-3.js
  var Clock3 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 16.5 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-4.js
  var Clock4 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 16 14" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-5.js
  var Clock5 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 14.5 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-6.js
  var Clock6 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 12 16.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-7.js
  var Clock7 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 9.5 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-9.js
  var Clock9 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 7.5 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-8.js
  var Clock8 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 8 14" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-alert.js
  var ClockAlert = [
    ["path", { d: "M12 6v6l4 2" }],
    ["path", { d: "M16 21.16a10 10 0 1 1 5-13.516" }],
    ["path", { d: "M20 11.5v6" }],
    ["path", { d: "M20 21.5h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-arrow-down.js
  var ClockArrowDown = [
    ["path", { d: "M12.338 21.994A10 10 0 1 1 21.925 13.227" }],
    ["path", { d: "M12 6v6l2 1" }],
    ["path", { d: "m14 18 4 4 4-4" }],
    ["path", { d: "M18 14v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-arrow-up.js
  var ClockArrowUp = [
    ["path", { d: "M13.228 21.925A10 10 0 1 1 21.994 12.338" }],
    ["path", { d: "M12 6v6l1.562.781" }],
    ["path", { d: "m14 18 4-4 4 4" }],
    ["path", { d: "M18 22v-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-fading.js
  var ClockFading = [
    ["path", { d: "M12 2a10 10 0 0 1 7.38 16.75" }],
    ["path", { d: "M12 6v6l4 2" }],
    ["path", { d: "M2.5 8.875a10 10 0 0 0-.5 3" }],
    ["path", { d: "M2.83 16a10 10 0 0 0 2.43 3.4" }],
    ["path", { d: "M4.636 5.235a10 10 0 0 1 .891-.857" }],
    ["path", { d: "M8.644 21.42a10 10 0 0 0 7.631-.38" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock-plus.js
  var ClockPlus = [
    ["path", { d: "M12 6v6l3.644 1.822" }],
    ["path", { d: "M16 19h6" }],
    ["path", { d: "M19 16v6" }],
    ["path", { d: "M21.92 13.267a10 10 0 1 0-8.653 8.653" }]
  ];

  // node_modules/lucide/dist/esm/icons/clock.js
  var Clock = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["polyline", { points: "12 6 12 12 16 14" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-alert.js
  var CloudAlert = [
    ["path", { d: "M12 12v4" }],
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M17 18h.5a1 1 0 0 0 0-9h-1.79A7 7 0 1 0 7 17.708" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-cog.js
  var CloudCog = [
    ["path", { d: "m10.852 19.772-.383.924" }],
    ["path", { d: "m13.148 14.228.383-.923" }],
    ["path", { d: "M13.148 19.772a3 3 0 1 0-2.296-5.544l-.383-.923" }],
    ["path", { d: "m13.53 20.696-.382-.924a3 3 0 1 1-2.296-5.544" }],
    ["path", { d: "m14.772 15.852.923-.383" }],
    ["path", { d: "m14.772 18.148.923.383" }],
    ["path", { d: "M4.2 15.1a7 7 0 1 1 9.93-9.858A7 7 0 0 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.2" }],
    ["path", { d: "m9.228 15.852-.923-.383" }],
    ["path", { d: "m9.228 18.148-.923.383" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-download.js
  var CloudDownload = [
    ["path", { d: "M12 13v8l-4-4" }],
    ["path", { d: "m12 21 4-4" }],
    ["path", { d: "M4.393 15.269A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.436 8.284" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-fog.js
  var CloudFog = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "M16 17H7" }],
    ["path", { d: "M17 21H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-drizzle.js
  var CloudDrizzle = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "M8 19v1" }],
    ["path", { d: "M8 14v1" }],
    ["path", { d: "M16 19v1" }],
    ["path", { d: "M16 14v1" }],
    ["path", { d: "M12 21v1" }],
    ["path", { d: "M12 16v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-hail.js
  var CloudHail = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "M16 14v2" }],
    ["path", { d: "M8 14v2" }],
    ["path", { d: "M16 20h.01" }],
    ["path", { d: "M8 20h.01" }],
    ["path", { d: "M12 16v2" }],
    ["path", { d: "M12 22h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-lightning.js
  var CloudLightning = [
    ["path", { d: "M6 16.326A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 .5 8.973" }],
    ["path", { d: "m13 12-3 5h4l-3 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-moon-rain.js
  var CloudMoonRain = [
    ["path", { d: "M10.188 8.5A6 6 0 0 1 16 4a1 1 0 0 0 6 6 6 6 0 0 1-3 5.197" }],
    ["path", { d: "M11 20v2" }],
    ["path", { d: "M3 20a5 5 0 1 1 8.9-4H13a3 3 0 0 1 2 5.24" }],
    ["path", { d: "M7 19v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-moon.js
  var CloudMoon = [
    ["path", { d: "M10.188 8.5A6 6 0 0 1 16 4a1 1 0 0 0 6 6 6 6 0 0 1-3 5.197" }],
    ["path", { d: "M13 16a3 3 0 1 1 0 6H7a5 5 0 1 1 4.9-6Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-off.js
  var CloudOff = [
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M5.782 5.782A7 7 0 0 0 9 19h8.5a4.5 4.5 0 0 0 1.307-.193" }],
    ["path", { d: "M21.532 16.5A4.5 4.5 0 0 0 17.5 10h-1.79A7.008 7.008 0 0 0 10 5.07" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-rain-wind.js
  var CloudRainWind = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "m9.2 22 3-7" }],
    ["path", { d: "m9 13-3 7" }],
    ["path", { d: "m17 13-3 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-rain.js
  var CloudRain = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "M16 14v6" }],
    ["path", { d: "M8 14v6" }],
    ["path", { d: "M12 16v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-snow.js
  var CloudSnow = [
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "M8 15h.01" }],
    ["path", { d: "M8 19h.01" }],
    ["path", { d: "M12 17h.01" }],
    ["path", { d: "M12 21h.01" }],
    ["path", { d: "M16 15h.01" }],
    ["path", { d: "M16 19h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-sun-rain.js
  var CloudSunRain = [
    ["path", { d: "M12 2v2" }],
    ["path", { d: "m4.93 4.93 1.41 1.41" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "m19.07 4.93-1.41 1.41" }],
    ["path", { d: "M15.947 12.65a4 4 0 0 0-5.925-4.128" }],
    ["path", { d: "M3 20a5 5 0 1 1 8.9-4H13a3 3 0 0 1 2 5.24" }],
    ["path", { d: "M11 20v2" }],
    ["path", { d: "M7 19v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-sun.js
  var CloudSun = [
    ["path", { d: "M12 2v2" }],
    ["path", { d: "m4.93 4.93 1.41 1.41" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "m19.07 4.93-1.41 1.41" }],
    ["path", { d: "M15.947 12.65a4 4 0 0 0-5.925-4.128" }],
    ["path", { d: "M13 22H7a5 5 0 1 1 4.9-6H13a3 3 0 0 1 0 6Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud-upload.js
  var CloudUpload = [
    ["path", { d: "M12 13v8" }],
    ["path", { d: "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" }],
    ["path", { d: "m8 17 4-4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloud.js
  var Cloud = [["path", { d: "M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z" }]];

  // node_modules/lucide/dist/esm/icons/clover.js
  var Clover = [
    ["path", { d: "M16.17 7.83 2 22" }],
    [
      "path",
      {
        d: "M4.02 12a2.827 2.827 0 1 1 3.81-4.17A2.827 2.827 0 1 1 12 4.02a2.827 2.827 0 1 1 4.17 3.81A2.827 2.827 0 1 1 19.98 12a2.827 2.827 0 1 1-3.81 4.17A2.827 2.827 0 1 1 12 19.98a2.827 2.827 0 1 1-4.17-3.81A1 1 0 1 1 4 12"
      }
    ],
    ["path", { d: "m7.83 7.83 8.34 8.34" }]
  ];

  // node_modules/lucide/dist/esm/icons/cloudy.js
  var Cloudy = [
    ["path", { d: "M17.5 21H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z" }],
    ["path", { d: "M22 10a3 3 0 0 0-3-3h-2.207a5.502 5.502 0 0 0-10.702.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/club.js
  var Club = [
    [
      "path",
      { d: "M17.28 9.05a5.5 5.5 0 1 0-10.56 0A5.5 5.5 0 1 0 12 17.66a5.5 5.5 0 1 0 5.28-8.6Z" }
    ],
    ["path", { d: "M12 17.66L12 22" }]
  ];

  // node_modules/lucide/dist/esm/icons/code-xml.js
  var CodeXml = [
    ["path", { d: "m18 16 4-4-4-4" }],
    ["path", { d: "m6 8-4 4 4 4" }],
    ["path", { d: "m14.5 4-5 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/code.js
  var Code2 = [
    ["polyline", { points: "16 18 22 12 16 6" }],
    ["polyline", { points: "8 6 2 12 8 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/codepen.js
  var Codepen = [
    ["polygon", { points: "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "15.5" }],
    ["polyline", { points: "22 8.5 12 15.5 2 8.5" }],
    ["polyline", { points: "2 15.5 12 8.5 22 15.5" }],
    ["line", { x1: "12", x2: "12", y1: "2", y2: "8.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/codesandbox.js
  var Codesandbox = [
    [
      "path",
      {
        d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"
      }
    ],
    ["polyline", { points: "7.5 4.21 12 6.81 16.5 4.21" }],
    ["polyline", { points: "7.5 19.79 7.5 14.6 3 12" }],
    ["polyline", { points: "21 12 16.5 14.6 16.5 19.79" }],
    ["polyline", { points: "3.27 6.96 12 12.01 20.73 6.96" }],
    ["line", { x1: "12", x2: "12", y1: "22.08", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/coffee.js
  var Coffee = [
    ["path", { d: "M10 2v2" }],
    ["path", { d: "M14 2v2" }],
    [
      "path",
      {
        d: "M16 8a1 1 0 0 1 1 1v8a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V9a1 1 0 0 1 1-1h14a4 4 0 1 1 0 8h-1"
      }
    ],
    ["path", { d: "M6 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cog.js
  var Cog = [
    ["path", { d: "M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z" }],
    ["path", { d: "M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 22v-2" }],
    ["path", { d: "m17 20.66-1-1.73" }],
    ["path", { d: "M11 10.27 7 3.34" }],
    ["path", { d: "m20.66 17-1.73-1" }],
    ["path", { d: "m3.34 7 1.73 1" }],
    ["path", { d: "M14 12h8" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "m20.66 7-1.73 1" }],
    ["path", { d: "m3.34 17 1.73-1" }],
    ["path", { d: "m17 3.34-1 1.73" }],
    ["path", { d: "m11 13.73-4 6.93" }]
  ];

  // node_modules/lucide/dist/esm/icons/coins.js
  var Coins = [
    ["circle", { cx: "8", cy: "8", r: "6" }],
    ["path", { d: "M18.09 10.37A6 6 0 1 1 10.34 18" }],
    ["path", { d: "M7 6h1v4" }],
    ["path", { d: "m16.71 13.88.7.71-2.82 2.82" }]
  ];

  // node_modules/lucide/dist/esm/icons/columns-2.js
  var Columns2 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M12 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/columns-3-cog.js
  var Columns3Cog = [
    ["path", { d: "M10.5 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v5.5" }],
    ["path", { d: "m14.3 19.6 1-.4" }],
    ["path", { d: "M15 3v7.5" }],
    ["path", { d: "m15.2 16.9-.9-.3" }],
    ["path", { d: "m16.6 21.7.3-.9" }],
    ["path", { d: "m16.8 15.3-.4-1" }],
    ["path", { d: "m19.1 15.2.3-.9" }],
    ["path", { d: "m19.6 21.7-.4-1" }],
    ["path", { d: "m20.7 16.8 1-.4" }],
    ["path", { d: "m21.7 19.4-.9-.3" }],
    ["path", { d: "M9 3v18" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/columns-3.js
  var Columns3 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "M15 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/columns-4.js
  var Columns4 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7.5 3v18" }],
    ["path", { d: "M12 3v18" }],
    ["path", { d: "M16.5 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/combine.js
  var Combine = [
    ["path", { d: "M10 18H5a3 3 0 0 1-3-3v-1" }],
    ["path", { d: "M14 2a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2" }],
    ["path", { d: "M20 2a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2" }],
    ["path", { d: "m7 21 3-3-3-3" }],
    ["rect", { x: "14", y: "14", width: "8", height: "8", rx: "2" }],
    ["rect", { x: "2", y: "2", width: "8", height: "8", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/command.js
  var Command = [
    ["path", { d: "M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/component.js
  var Component = [
    [
      "path",
      {
        d: "M15.536 11.293a1 1 0 0 0 0 1.414l2.376 2.377a1 1 0 0 0 1.414 0l2.377-2.377a1 1 0 0 0 0-1.414l-2.377-2.377a1 1 0 0 0-1.414 0z"
      }
    ],
    [
      "path",
      {
        d: "M2.297 11.293a1 1 0 0 0 0 1.414l2.377 2.377a1 1 0 0 0 1.414 0l2.377-2.377a1 1 0 0 0 0-1.414L6.088 8.916a1 1 0 0 0-1.414 0z"
      }
    ],
    [
      "path",
      {
        d: "M8.916 17.912a1 1 0 0 0 0 1.415l2.377 2.376a1 1 0 0 0 1.414 0l2.377-2.376a1 1 0 0 0 0-1.415l-2.377-2.376a1 1 0 0 0-1.414 0z"
      }
    ],
    [
      "path",
      {
        d: "M8.916 4.674a1 1 0 0 0 0 1.414l2.377 2.376a1 1 0 0 0 1.414 0l2.377-2.376a1 1 0 0 0 0-1.414l-2.377-2.377a1 1 0 0 0-1.414 0z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/compass.js
  var Compass = [
    [
      "path",
      {
        d: "m16.24 7.76-1.804 5.411a2 2 0 0 1-1.265 1.265L7.76 16.24l1.804-5.411a2 2 0 0 1 1.265-1.265z"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/computer.js
  var Computer = [
    ["rect", { width: "14", height: "8", x: "5", y: "2", rx: "2" }],
    ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2" }],
    ["path", { d: "M6 18h2" }],
    ["path", { d: "M12 18h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/concierge-bell.js
  var ConciergeBell = [
    ["path", { d: "M3 20a1 1 0 0 1-1-1v-1a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v1a1 1 0 0 1-1 1Z" }],
    ["path", { d: "M20 16a8 8 0 1 0-16 0" }],
    ["path", { d: "M12 4v4" }],
    ["path", { d: "M10 4h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/cone.js
  var Cone = [
    ["path", { d: "m20.9 18.55-8-15.98a1 1 0 0 0-1.8 0l-8 15.98" }],
    ["ellipse", { cx: "12", cy: "19", rx: "9", ry: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/construction.js
  var Construction = [
    ["rect", { x: "2", y: "6", width: "20", height: "8", rx: "1" }],
    ["path", { d: "M17 14v7" }],
    ["path", { d: "M7 14v7" }],
    ["path", { d: "M17 3v3" }],
    ["path", { d: "M7 3v3" }],
    ["path", { d: "M10 14 2.3 6.3" }],
    ["path", { d: "m14 6 7.7 7.7" }],
    ["path", { d: "m8 6 8 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/contact-round.js
  var ContactRound = [
    ["path", { d: "M16 2v2" }],
    ["path", { d: "M17.915 22a6 6 0 0 0-12 0" }],
    ["path", { d: "M8 2v2" }],
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["rect", { x: "3", y: "4", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/contact.js
  var Contact = [
    ["path", { d: "M16 2v2" }],
    ["path", { d: "M7 22v-2a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M8 2v2" }],
    ["circle", { cx: "12", cy: "11", r: "3" }],
    ["rect", { x: "3", y: "4", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/container.js
  var Container = [
    [
      "path",
      {
        d: "M22 7.7c0-.6-.4-1.2-.8-1.5l-6.3-3.9a1.72 1.72 0 0 0-1.7 0l-10.3 6c-.5.2-.9.8-.9 1.4v6.6c0 .5.4 1.2.8 1.5l6.3 3.9a1.72 1.72 0 0 0 1.7 0l10.3-6c.5-.3.9-1 .9-1.5Z"
      }
    ],
    ["path", { d: "M10 21.9V14L2.1 9.1" }],
    ["path", { d: "m10 14 11.9-6.9" }],
    ["path", { d: "M14 19.8v-8.1" }],
    ["path", { d: "M18 17.5V9.4" }]
  ];

  // node_modules/lucide/dist/esm/icons/contrast.js
  var Contrast = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M12 18a6 6 0 0 0 0-12v12z" }]
  ];

  // node_modules/lucide/dist/esm/icons/cookie.js
  var Cookie = [
    ["path", { d: "M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5" }],
    ["path", { d: "M8.5 8.5v.01" }],
    ["path", { d: "M16 15.5v.01" }],
    ["path", { d: "M12 12v.01" }],
    ["path", { d: "M11 17v.01" }],
    ["path", { d: "M7 14v.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/cooking-pot.js
  var CookingPot = [
    ["path", { d: "M2 12h20" }],
    ["path", { d: "M20 12v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8" }],
    ["path", { d: "m4 8 16-4" }],
    ["path", { d: "m8.86 6.78-.45-1.81a2 2 0 0 1 1.45-2.43l1.94-.48a2 2 0 0 1 2.43 1.46l.45 1.8" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy-check.js
  var CopyCheck = [
    ["path", { d: "m12 15 2 2 4-4" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy-minus.js
  var CopyMinus = [
    ["line", { x1: "12", x2: "18", y1: "15", y2: "15" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy-plus.js
  var CopyPlus = [
    ["line", { x1: "15", x2: "15", y1: "12", y2: "18" }],
    ["line", { x1: "12", x2: "18", y1: "15", y2: "15" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy-slash.js
  var CopySlash = [
    ["line", { x1: "12", x2: "18", y1: "18", y2: "12" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy-x.js
  var CopyX = [
    ["line", { x1: "12", x2: "18", y1: "12", y2: "18" }],
    ["line", { x1: "12", x2: "18", y1: "18", y2: "12" }],
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copy.js
  var Copy = [
    ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2" }],
    ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/copyleft.js
  var Copyleft = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M9.17 14.83a4 4 0 1 0 0-5.66" }]
  ];

  // node_modules/lucide/dist/esm/icons/copyright.js
  var Copyright = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M14.83 14.83a4 4 0 1 1 0-5.66" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-down-left.js
  var CornerDownLeft = [
    ["polyline", { points: "9 10 4 15 9 20" }],
    ["path", { d: "M20 4v7a4 4 0 0 1-4 4H4" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-down-right.js
  var CornerDownRight = [
    ["polyline", { points: "15 10 20 15 15 20" }],
    ["path", { d: "M4 4v7a4 4 0 0 0 4 4h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-left-down.js
  var CornerLeftDown = [
    ["polyline", { points: "14 15 9 20 4 15" }],
    ["path", { d: "M20 4h-7a4 4 0 0 0-4 4v12" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-left-up.js
  var CornerLeftUp = [
    ["polyline", { points: "14 9 9 4 4 9" }],
    ["path", { d: "M20 20h-7a4 4 0 0 1-4-4V4" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-right-down.js
  var CornerRightDown = [
    ["polyline", { points: "10 15 15 20 20 15" }],
    ["path", { d: "M4 4h7a4 4 0 0 1 4 4v12" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-right-up.js
  var CornerRightUp = [
    ["polyline", { points: "10 9 15 4 20 9" }],
    ["path", { d: "M4 20h7a4 4 0 0 0 4-4V4" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-up-left.js
  var CornerUpLeft = [
    ["polyline", { points: "9 14 4 9 9 4" }],
    ["path", { d: "M20 20v-7a4 4 0 0 0-4-4H4" }]
  ];

  // node_modules/lucide/dist/esm/icons/corner-up-right.js
  var CornerUpRight = [
    ["polyline", { points: "15 14 20 9 15 4" }],
    ["path", { d: "M4 20v-7a4 4 0 0 1 4-4h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/cpu.js
  var Cpu = [
    ["path", { d: "M12 20v2" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M17 20v2" }],
    ["path", { d: "M17 2v2" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "M2 17h2" }],
    ["path", { d: "M2 7h2" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "M20 17h2" }],
    ["path", { d: "M20 7h2" }],
    ["path", { d: "M7 20v2" }],
    ["path", { d: "M7 2v2" }],
    ["rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" }],
    ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/creative-commons.js
  var CreativeCommons = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M10 9.3a2.8 2.8 0 0 0-3.5 1 3.1 3.1 0 0 0 0 3.4 2.7 2.7 0 0 0 3.5 1" }],
    ["path", { d: "M17 9.3a2.8 2.8 0 0 0-3.5 1 3.1 3.1 0 0 0 0 3.4 2.7 2.7 0 0 0 3.5 1" }]
  ];

  // node_modules/lucide/dist/esm/icons/credit-card.js
  var CreditCard = [
    ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "2" }],
    ["line", { x1: "2", x2: "22", y1: "10", y2: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/croissant.js
  var Croissant = [
    [
      "path",
      {
        d: "m4.6 13.11 5.79-3.21c1.89-1.05 4.79 1.78 3.71 3.71l-3.22 5.81C8.8 23.16.79 15.23 4.6 13.11Z"
      }
    ],
    [
      "path",
      { d: "m10.5 9.5-1-2.29C9.2 6.48 8.8 6 8 6H4.5C2.79 6 2 6.5 2 8.5a7.71 7.71 0 0 0 2 4.83" }
    ],
    ["path", { d: "M8 6c0-1.55.24-4-2-4-2 0-2.5 2.17-2.5 4" }],
    [
      "path",
      {
        d: "m14.5 13.5 2.29 1c.73.3 1.21.7 1.21 1.5v3.5c0 1.71-.5 2.5-2.5 2.5a7.71 7.71 0 0 1-4.83-2"
      }
    ],
    ["path", { d: "M18 16c1.55 0 4-.24 4 2 0 2-2.17 2.5-4 2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/crop.js
  var Crop = [
    ["path", { d: "M6 2v14a2 2 0 0 0 2 2h14" }],
    ["path", { d: "M18 22V8a2 2 0 0 0-2-2H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/cross.js
  var Cross = [
    [
      "path",
      {
        d: "M4 9a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4a1 1 0 0 1 1 1v4a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-4a1 1 0 0 1 1-1h4a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-4a1 1 0 0 1-1-1V4a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v4a1 1 0 0 1-1 1z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/crosshair.js
  var Crosshair = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["line", { x1: "22", x2: "18", y1: "12", y2: "12" }],
    ["line", { x1: "6", x2: "2", y1: "12", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "6", y2: "2" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "18" }]
  ];

  // node_modules/lucide/dist/esm/icons/crown.js
  var Crown = [
    [
      "path",
      {
        d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z"
      }
    ],
    ["path", { d: "M5 21h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/cuboid.js
  var Cuboid = [
    [
      "path",
      {
        d: "m21.12 6.4-6.05-4.06a2 2 0 0 0-2.17-.05L2.95 8.41a2 2 0 0 0-.95 1.7v5.82a2 2 0 0 0 .88 1.66l6.05 4.07a2 2 0 0 0 2.17.05l9.95-6.12a2 2 0 0 0 .95-1.7V8.06a2 2 0 0 0-.88-1.66Z"
      }
    ],
    ["path", { d: "M10 22v-8L2.25 9.15" }],
    ["path", { d: "m10 14 11.77-6.87" }]
  ];

  // node_modules/lucide/dist/esm/icons/cup-soda.js
  var CupSoda = [
    ["path", { d: "m6 8 1.75 12.28a2 2 0 0 0 2 1.72h4.54a2 2 0 0 0 2-1.72L18 8" }],
    ["path", { d: "M5 8h14" }],
    ["path", { d: "M7 15a6.47 6.47 0 0 1 5 0 6.47 6.47 0 0 0 5 0" }],
    ["path", { d: "m12 8 1-6h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/currency.js
  var Currency = [
    ["circle", { cx: "12", cy: "12", r: "8" }],
    ["line", { x1: "3", x2: "6", y1: "3", y2: "6" }],
    ["line", { x1: "21", x2: "18", y1: "3", y2: "6" }],
    ["line", { x1: "3", x2: "6", y1: "21", y2: "18" }],
    ["line", { x1: "21", x2: "18", y1: "21", y2: "18" }]
  ];

  // node_modules/lucide/dist/esm/icons/cylinder.js
  var Cylinder = [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3" }],
    ["path", { d: "M3 5v14a9 3 0 0 0 18 0V5" }]
  ];

  // node_modules/lucide/dist/esm/icons/database-backup.js
  var DatabaseBackup = [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3" }],
    ["path", { d: "M3 12a9 3 0 0 0 5 2.69" }],
    ["path", { d: "M21 9.3V5" }],
    ["path", { d: "M3 5v14a9 3 0 0 0 6.47 2.88" }],
    ["path", { d: "M12 12v4h4" }],
    ["path", { d: "M13 20a5 5 0 0 0 9-3 4.5 4.5 0 0 0-4.5-4.5c-1.33 0-2.54.54-3.41 1.41L12 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/database-zap.js
  var DatabaseZap = [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3" }],
    ["path", { d: "M3 5V19A9 3 0 0 0 15 21.84" }],
    ["path", { d: "M21 5V8" }],
    ["path", { d: "M21 12L18 17H22L19 22" }],
    ["path", { d: "M3 12A9 3 0 0 0 14.59 14.87" }]
  ];

  // node_modules/lucide/dist/esm/icons/database.js
  var Database = [
    ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3" }],
    ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5" }],
    ["path", { d: "M3 12A9 3 0 0 0 21 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/dam.js
  var Dam = [
    ["path", { d: "M11 11.31c1.17.56 1.54 1.69 3.5 1.69 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }],
    ["path", { d: "M11.75 18c.35.5 1.45 1 2.75 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }],
    ["path", { d: "M2 10h4" }],
    ["path", { d: "M2 14h4" }],
    ["path", { d: "M2 18h4" }],
    ["path", { d: "M2 6h4" }],
    ["path", { d: "M7 3a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1L10 4a1 1 0 0 0-1-1z" }]
  ];

  // node_modules/lucide/dist/esm/icons/decimals-arrow-left.js
  var DecimalsArrowLeft = [
    ["path", { d: "m13 21-3-3 3-3" }],
    ["path", { d: "M20 18H10" }],
    ["path", { d: "M3 11h.01" }],
    ["rect", { x: "6", y: "3", width: "5", height: "8", rx: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/decimals-arrow-right.js
  var DecimalsArrowRight = [
    ["path", { d: "M10 18h10" }],
    ["path", { d: "m17 21 3-3-3-3" }],
    ["path", { d: "M3 11h.01" }],
    ["rect", { x: "15", y: "3", width: "5", height: "8", rx: "2.5" }],
    ["rect", { x: "6", y: "3", width: "5", height: "8", rx: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/delete.js
  var Delete = [
    [
      "path",
      {
        d: "M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"
      }
    ],
    ["path", { d: "m12 9 6 6" }],
    ["path", { d: "m18 9-6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/dessert.js
  var Dessert = [
    ["circle", { cx: "12", cy: "4", r: "2" }],
    [
      "path",
      {
        d: "M10.2 3.2C5.5 4 2 8.1 2 13a2 2 0 0 0 4 0v-1a2 2 0 0 1 4 0v4a2 2 0 0 0 4 0v-4a2 2 0 0 1 4 0v1a2 2 0 0 0 4 0c0-4.9-3.5-9-8.2-9.8"
      }
    ],
    ["path", { d: "M3.2 14.8a9 9 0 0 0 17.6 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/diameter.js
  var Diameter = [
    ["circle", { cx: "19", cy: "19", r: "2" }],
    ["circle", { cx: "5", cy: "5", r: "2" }],
    ["path", { d: "M6.48 3.66a10 10 0 0 1 13.86 13.86" }],
    ["path", { d: "m6.41 6.41 11.18 11.18" }],
    ["path", { d: "M3.66 6.48a10 10 0 0 0 13.86 13.86" }]
  ];

  // node_modules/lucide/dist/esm/icons/diamond-minus.js
  var DiamondMinus = [
    [
      "path",
      {
        d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41L13.7 2.71a2.41 2.41 0 0 0-3.41 0z"
      }
    ],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/diamond-percent.js
  var DiamondPercent = [
    [
      "path",
      {
        d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41L13.7 2.71a2.41 2.41 0 0 0-3.41 0Z"
      }
    ],
    ["path", { d: "M9.2 9.2h.01" }],
    ["path", { d: "m14.5 9.5-5 5" }],
    ["path", { d: "M14.7 14.8h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/diamond-plus.js
  var DiamondPlus = [
    ["path", { d: "M12 8v8" }],
    [
      "path",
      {
        d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41L13.7 2.71a2.41 2.41 0 0 0-3.41 0z"
      }
    ],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/diamond.js
  var Diamond = [
    [
      "path",
      {
        d: "M2.7 10.3a2.41 2.41 0 0 0 0 3.41l7.59 7.59a2.41 2.41 0 0 0 3.41 0l7.59-7.59a2.41 2.41 0 0 0 0-3.41l-7.59-7.59a2.41 2.41 0 0 0-3.41 0Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/dice-1.js
  var Dice1 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M12 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dice-2.js
  var Dice2 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M15 9h.01" }],
    ["path", { d: "M9 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dice-3.js
  var Dice3 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M16 8h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M8 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dice-4.js
  var Dice4 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M16 8h.01" }],
    ["path", { d: "M8 8h.01" }],
    ["path", { d: "M8 16h.01" }],
    ["path", { d: "M16 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dice-5.js
  var Dice5 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M16 8h.01" }],
    ["path", { d: "M8 8h.01" }],
    ["path", { d: "M8 16h.01" }],
    ["path", { d: "M16 16h.01" }],
    ["path", { d: "M12 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dice-6.js
  var Dice6 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M16 8h.01" }],
    ["path", { d: "M16 12h.01" }],
    ["path", { d: "M16 16h.01" }],
    ["path", { d: "M8 8h.01" }],
    ["path", { d: "M8 12h.01" }],
    ["path", { d: "M8 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/dices.js
  var Dices = [
    ["rect", { width: "12", height: "12", x: "2", y: "10", rx: "2", ry: "2" }],
    ["path", { d: "m17.92 14 3.5-3.5a2.24 2.24 0 0 0 0-3l-5-4.92a2.24 2.24 0 0 0-3 0L10 6" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "M10 14h.01" }],
    ["path", { d: "M15 6h.01" }],
    ["path", { d: "M18 9h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/diff.js
  var Diff = [
    ["path", { d: "M12 3v14" }],
    ["path", { d: "M5 10h14" }],
    ["path", { d: "M5 21h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/disc-2.js
  var Disc2 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M12 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/disc-3.js
  var Disc3 = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M6 12c0-1.7.7-3.2 1.8-4.2" }],
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "M18 12c0 1.7-.7 3.2-1.8 4.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/disc.js
  var Disc = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/disc-album.js
  var DiscAlbum = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["circle", { cx: "12", cy: "12", r: "5" }],
    ["path", { d: "M12 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/divide.js
  var Divide = [
    ["circle", { cx: "12", cy: "6", r: "1" }],
    ["line", { x1: "5", x2: "19", y1: "12", y2: "12" }],
    ["circle", { cx: "12", cy: "18", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/dna-off.js
  var DnaOff = [
    ["path", { d: "M15 2c-1.35 1.5-2.092 3-2.5 4.5L14 8" }],
    ["path", { d: "m17 6-2.891-2.891" }],
    ["path", { d: "M2 15c3.333-3 6.667-3 10-3" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "m20 9 .891.891" }],
    ["path", { d: "M22 9c-1.5 1.35-3 2.092-4.5 2.5l-1-1" }],
    ["path", { d: "M3.109 14.109 4 15" }],
    ["path", { d: "m6.5 12.5 1 1" }],
    ["path", { d: "m7 18 2.891 2.891" }],
    ["path", { d: "M9 22c1.35-1.5 2.092-3 2.5-4.5L10 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/dock.js
  var Dock = [
    ["path", { d: "M2 8h20" }],
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M6 16h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/dna.js
  var Dna = [
    ["path", { d: "m10 16 1.5 1.5" }],
    ["path", { d: "m14 8-1.5-1.5" }],
    ["path", { d: "M15 2c-1.798 1.998-2.518 3.995-2.807 5.993" }],
    ["path", { d: "m16.5 10.5 1 1" }],
    ["path", { d: "m17 6-2.891-2.891" }],
    ["path", { d: "M2 15c6.667-6 13.333 0 20-6" }],
    ["path", { d: "m20 9 .891.891" }],
    ["path", { d: "M3.109 14.109 4 15" }],
    ["path", { d: "m6.5 12.5 1 1" }],
    ["path", { d: "m7 18 2.891 2.891" }],
    ["path", { d: "M9 22c1.798-1.998 2.518-3.995 2.807-5.993" }]
  ];

  // node_modules/lucide/dist/esm/icons/dog.js
  var Dog = [
    ["path", { d: "M11.25 16.25h1.5L12 17z" }],
    ["path", { d: "M16 14v.5" }],
    [
      "path",
      {
        d: "M4.42 11.247A13.152 13.152 0 0 0 4 14.556C4 18.728 7.582 21 12 21s8-2.272 8-6.444a11.702 11.702 0 0 0-.493-3.309"
      }
    ],
    ["path", { d: "M8 14v.5" }],
    [
      "path",
      {
        d: "M8.5 8.5c-.384 1.05-1.083 2.028-2.344 2.5-1.931.722-3.576-.297-3.656-1-.113-.994 1.177-6.53 4-7 1.923-.321 3.651.845 3.651 2.235A7.497 7.497 0 0 1 14 5.277c0-1.39 1.844-2.598 3.767-2.277 2.823.47 4.113 6.006 4 7-.08.703-1.725 1.722-3.656 1-1.261-.472-1.855-1.45-2.239-2.5"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/dollar-sign.js
  var DollarSign = [
    ["line", { x1: "12", x2: "12", y1: "2", y2: "22" }],
    ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" }]
  ];

  // node_modules/lucide/dist/esm/icons/donut.js
  var Donut = [
    [
      "path",
      {
        d: "M20.5 10a2.5 2.5 0 0 1-2.4-3H18a2.95 2.95 0 0 1-2.6-4.4 10 10 0 1 0 6.3 7.1c-.3.2-.8.3-1.2.3"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/door-closed.js
  var DoorClosed = [
    ["path", { d: "M10 12h.01" }],
    ["path", { d: "M18 20V6a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v14" }],
    ["path", { d: "M2 20h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/door-closed-locked.js
  var DoorClosedLocked = [
    ["path", { d: "M10 12h.01" }],
    ["path", { d: "M18 9V6a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v14" }],
    ["path", { d: "M2 20h8" }],
    ["path", { d: "M20 17v-2a2 2 0 1 0-4 0v2" }],
    ["rect", { x: "14", y: "17", width: "8", height: "5", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/door-open.js
  var DoorOpen = [
    ["path", { d: "M11 20H2" }],
    [
      "path",
      {
        d: "M11 4.562v16.157a1 1 0 0 0 1.242.97L19 20V5.562a2 2 0 0 0-1.515-1.94l-4-1A2 2 0 0 0 11 4.561z"
      }
    ],
    ["path", { d: "M11 4H8a2 2 0 0 0-2 2v14" }],
    ["path", { d: "M14 12h.01" }],
    ["path", { d: "M22 20h-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/dot.js
  var Dot = [["circle", { cx: "12.1", cy: "12.1", r: "1" }]];

  // node_modules/lucide/dist/esm/icons/download.js
  var Download = [
    ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }],
    ["polyline", { points: "7 10 12 15 17 10" }],
    ["line", { x1: "12", x2: "12", y1: "15", y2: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/drafting-compass.js
  var DraftingCompass = [
    ["path", { d: "m12.99 6.74 1.93 3.44" }],
    ["path", { d: "M19.136 12a10 10 0 0 1-14.271 0" }],
    ["path", { d: "m21 21-2.16-3.84" }],
    ["path", { d: "m3 21 8.02-14.26" }],
    ["circle", { cx: "12", cy: "5", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/dribbble.js
  var Dribbble = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M19.13 5.09C15.22 9.14 10 10.44 2.25 10.94" }],
    ["path", { d: "M21.75 12.84c-6.62-1.41-12.14 1-16.38 6.32" }],
    ["path", { d: "M8.56 2.75c4.37 6 6 9.42 8 17.72" }]
  ];

  // node_modules/lucide/dist/esm/icons/drama.js
  var Drama = [
    ["path", { d: "M10 11h.01" }],
    ["path", { d: "M14 6h.01" }],
    ["path", { d: "M18 6h.01" }],
    ["path", { d: "M6.5 13.1h.01" }],
    ["path", { d: "M22 5c0 9-4 12-6 12s-6-3-6-12c0-2 2-3 6-3s6 1 6 3" }],
    ["path", { d: "M17.4 9.9c-.8.8-2 .8-2.8 0" }],
    [
      "path",
      {
        d: "M10.1 7.1C9 7.2 7.7 7.7 6 8.6c-3.5 2-4.7 3.9-3.7 5.6 4.5 7.8 9.5 8.4 11.2 7.4.9-.5 1.9-2.1 1.9-4.7"
      }
    ],
    ["path", { d: "M9.1 16.5c.3-1.1 1.4-1.7 2.4-1.4" }]
  ];

  // node_modules/lucide/dist/esm/icons/drill.js
  var Drill = [
    ["path", { d: "M10 18a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H5a3 3 0 0 1-3-3 1 1 0 0 1 1-1z" }],
    [
      "path",
      {
        d: "M13 10H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1l-.81 3.242a1 1 0 0 1-.97.758H8"
      }
    ],
    ["path", { d: "M14 4h3a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-3" }],
    ["path", { d: "M18 6h4" }],
    ["path", { d: "m5 10-2 8" }],
    ["path", { d: "m7 18 2-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/droplet-off.js
  var DropletOff = [
    [
      "path",
      {
        d: "M18.715 13.186C18.29 11.858 17.384 10.607 16 9.5c-2-1.6-3.5-4-4-6.5a10.7 10.7 0 0 1-.884 2.586"
      }
    ],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M8.795 8.797A11 11 0 0 1 8 9.5C6 11.1 5 13 5 15a7 7 0 0 0 13.222 3.208" }]
  ];

  // node_modules/lucide/dist/esm/icons/droplet.js
  var Droplet = [
    [
      "path",
      {
        d: "M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/droplets.js
  var Droplets = [
    [
      "path",
      {
        d: "M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z"
      }
    ],
    [
      "path",
      {
        d: "M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/drum.js
  var Drum = [
    ["path", { d: "m2 2 8 8" }],
    ["path", { d: "m22 2-8 8" }],
    ["ellipse", { cx: "12", cy: "9", rx: "10", ry: "5" }],
    ["path", { d: "M7 13.4v7.9" }],
    ["path", { d: "M12 14v8" }],
    ["path", { d: "M17 13.4v7.9" }],
    ["path", { d: "M2 9v8a10 5 0 0 0 20 0V9" }]
  ];

  // node_modules/lucide/dist/esm/icons/drumstick.js
  var Drumstick = [
    ["path", { d: "M15.4 15.63a7.875 6 135 1 1 6.23-6.23 4.5 3.43 135 0 0-6.23 6.23" }],
    ["path", { d: "m8.29 12.71-2.6 2.6a2.5 2.5 0 1 0-1.65 4.65A2.5 2.5 0 1 0 8.7 18.3l2.59-2.59" }]
  ];

  // node_modules/lucide/dist/esm/icons/dumbbell.js
  var Dumbbell = [
    [
      "path",
      {
        d: "M17.596 12.768a2 2 0 1 0 2.829-2.829l-1.768-1.767a2 2 0 0 0 2.828-2.829l-2.828-2.828a2 2 0 0 0-2.829 2.828l-1.767-1.768a2 2 0 1 0-2.829 2.829z"
      }
    ],
    ["path", { d: "m2.5 21.5 1.4-1.4" }],
    ["path", { d: "m20.1 3.9 1.4-1.4" }],
    [
      "path",
      {
        d: "M5.343 21.485a2 2 0 1 0 2.829-2.828l1.767 1.768a2 2 0 1 0 2.829-2.829l-6.364-6.364a2 2 0 1 0-2.829 2.829l1.768 1.767a2 2 0 0 0-2.828 2.829z"
      }
    ],
    ["path", { d: "m9.6 14.4 4.8-4.8" }]
  ];

  // node_modules/lucide/dist/esm/icons/ear.js
  var Ear = [
    ["path", { d: "M6 8.5a6.5 6.5 0 1 1 13 0c0 6-6 6-6 10a3.5 3.5 0 1 1-7 0" }],
    ["path", { d: "M15 8.5a2.5 2.5 0 0 0-5 0v1a2 2 0 1 1 0 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/ear-off.js
  var EarOff = [
    ["path", { d: "M6 18.5a3.5 3.5 0 1 0 7 0c0-1.57.92-2.52 2.04-3.46" }],
    ["path", { d: "M6 8.5c0-.75.13-1.47.36-2.14" }],
    ["path", { d: "M8.8 3.15A6.5 6.5 0 0 1 19 8.5c0 1.63-.44 2.81-1.09 3.76" }],
    ["path", { d: "M12.5 6A2.5 2.5 0 0 1 15 8.5M10 13a2 2 0 0 0 1.82-1.18" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/earth-lock.js
  var EarthLock = [
    ["path", { d: "M7 3.34V5a3 3 0 0 0 3 3" }],
    ["path", { d: "M11 21.95V18a2 2 0 0 0-2-2 2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05" }],
    ["path", { d: "M21.54 15H17a2 2 0 0 0-2 2v4.54" }],
    ["path", { d: "M12 2a10 10 0 1 0 9.54 13" }],
    ["path", { d: "M20 6V4a2 2 0 1 0-4 0v2" }],
    ["rect", { width: "8", height: "5", x: "14", y: "6", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/earth.js
  var Earth = [
    ["path", { d: "M21.54 15H17a2 2 0 0 0-2 2v4.54" }],
    [
      "path",
      { d: "M7 3.34V5a3 3 0 0 0 3 3a2 2 0 0 1 2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.1.9-2 2-2h3.17" }
    ],
    ["path", { d: "M11 21.95V18a2 2 0 0 0-2-2a2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/eclipse.js
  var Eclipse = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M12 2a7 7 0 1 0 10 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/egg-fried.js
  var EggFried = [
    ["circle", { cx: "11.5", cy: "12.5", r: "3.5" }],
    [
      "path",
      {
        d: "M3 8c0-3.5 2.5-6 6.5-6 5 0 4.83 3 7.5 5s5 2 5 6c0 4.5-2.5 6.5-7 6.5-2.5 0-2.5 2.5-6 2.5s-7-2-7-5.5c0-3 1.5-3 1.5-5C3.5 10 3 9 3 8Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/egg-off.js
  var EggOff = [
    [
      "path",
      {
        d: "M6.399 6.399C5.362 8.157 4.65 10.189 4.5 12c-.37 4.43 1.27 9.95 7.5 10 3.256-.026 5.259-1.547 6.375-3.625"
      }
    ],
    [
      "path",
      {
        d: "M19.532 13.875A14.07 14.07 0 0 0 19.5 12c-.36-4.34-3.95-9.96-7.5-10-1.04.012-2.082.502-3.046 1.297"
      }
    ],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/egg.js
  var Egg = [
    [
      "path",
      {
        d: "M12 22c6.23-.05 7.87-5.57 7.5-10-.36-4.34-3.95-9.96-7.5-10-3.55.04-7.14 5.66-7.5 10-.37 4.43 1.27 9.95 7.5 10z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/ellipsis-vertical.js
  var EllipsisVertical = [
    ["circle", { cx: "12", cy: "12", r: "1" }],
    ["circle", { cx: "12", cy: "5", r: "1" }],
    ["circle", { cx: "12", cy: "19", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/ellipsis.js
  var Ellipsis = [
    ["circle", { cx: "12", cy: "12", r: "1" }],
    ["circle", { cx: "19", cy: "12", r: "1" }],
    ["circle", { cx: "5", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/equal-approximately.js
  var EqualApproximately = [
    ["path", { d: "M5 15a6.5 6.5 0 0 1 7 0 6.5 6.5 0 0 0 7 0" }],
    ["path", { d: "M5 9a6.5 6.5 0 0 1 7 0 6.5 6.5 0 0 0 7 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/equal-not.js
  var EqualNot = [
    ["line", { x1: "5", x2: "19", y1: "9", y2: "9" }],
    ["line", { x1: "5", x2: "19", y1: "15", y2: "15" }],
    ["line", { x1: "19", x2: "5", y1: "5", y2: "19" }]
  ];

  // node_modules/lucide/dist/esm/icons/equal.js
  var Equal = [
    ["line", { x1: "5", x2: "19", y1: "9", y2: "9" }],
    ["line", { x1: "5", x2: "19", y1: "15", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/eraser.js
  var Eraser = [
    [
      "path",
      { d: "m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21" }
    ],
    ["path", { d: "M22 21H7" }],
    ["path", { d: "m5 11 9 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/ethernet-port.js
  var EthernetPort = [
    [
      "path",
      { d: "m15 20 3-3h2a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h2l3 3z" }
    ],
    ["path", { d: "M6 8v1" }],
    ["path", { d: "M10 8v1" }],
    ["path", { d: "M14 8v1" }],
    ["path", { d: "M18 8v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/euro.js
  var Euro = [
    ["path", { d: "M4 10h12" }],
    ["path", { d: "M4 14h9" }],
    [
      "path",
      { d: "M19 6a7.7 7.7 0 0 0-5.2-2A7.9 7.9 0 0 0 6 12c0 4.4 3.5 8 7.8 8 2 0 3.8-.8 5.2-2" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/external-link.js
  var ExternalLink = [
    ["path", { d: "M15 3h6v6" }],
    ["path", { d: "M10 14 21 3" }],
    ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/eye-closed.js
  var EyeClosed = [
    ["path", { d: "m15 18-.722-3.25" }],
    ["path", { d: "M2 8a10.645 10.645 0 0 0 20 0" }],
    ["path", { d: "m20 15-1.726-2.05" }],
    ["path", { d: "m4 15 1.726-2.05" }],
    ["path", { d: "m9 18 .722-3.25" }]
  ];

  // node_modules/lucide/dist/esm/icons/expand.js
  var Expand = [
    ["path", { d: "m15 15 6 6" }],
    ["path", { d: "m15 9 6-6" }],
    ["path", { d: "M21 16v5h-5" }],
    ["path", { d: "M21 8V3h-5" }],
    ["path", { d: "M3 16v5h5" }],
    ["path", { d: "m3 21 6-6" }],
    ["path", { d: "M3 8V3h5" }],
    ["path", { d: "M9 9 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/eye-off.js
  var EyeOff = [
    [
      "path",
      {
        d: "M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49"
      }
    ],
    ["path", { d: "M14.084 14.158a3 3 0 0 1-4.242-4.242" }],
    [
      "path",
      {
        d: "M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143"
      }
    ],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/facebook.js
  var Facebook = [
    ["path", { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z" }]
  ];

  // node_modules/lucide/dist/esm/icons/eye.js
  var Eye = [
    [
      "path",
      {
        d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/factory.js
  var Factory = [
    [
      "path",
      { d: "M2 20a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8l-7 5V8l-7 5V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z" }
    ],
    ["path", { d: "M17 18h1" }],
    ["path", { d: "M12 18h1" }],
    ["path", { d: "M7 18h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/fan.js
  var Fan = [
    [
      "path",
      {
        d: "M10.827 16.379a6.082 6.082 0 0 1-8.618-7.002l5.412 1.45a6.082 6.082 0 0 1 7.002-8.618l-1.45 5.412a6.082 6.082 0 0 1 8.618 7.002l-5.412-1.45a6.082 6.082 0 0 1-7.002 8.618l1.45-5.412Z"
      }
    ],
    ["path", { d: "M12 12v.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/fast-forward.js
  var FastForward = [
    ["polygon", { points: "13 19 22 12 13 5 13 19" }],
    ["polygon", { points: "2 19 11 12 2 5 2 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/feather.js
  var Feather = [
    [
      "path",
      {
        d: "M12.67 19a2 2 0 0 0 1.416-.588l6.154-6.172a6 6 0 0 0-8.49-8.49L5.586 9.914A2 2 0 0 0 5 11.328V18a1 1 0 0 0 1 1z"
      }
    ],
    ["path", { d: "M16 8 2 22" }],
    ["path", { d: "M17.5 15H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/fence.js
  var Fence = [
    ["path", { d: "M4 3 2 5v15c0 .6.4 1 1 1h2c.6 0 1-.4 1-1V5Z" }],
    ["path", { d: "M6 8h4" }],
    ["path", { d: "M6 18h4" }],
    ["path", { d: "m12 3-2 2v15c0 .6.4 1 1 1h2c.6 0 1-.4 1-1V5Z" }],
    ["path", { d: "M14 8h4" }],
    ["path", { d: "M14 18h4" }],
    ["path", { d: "m20 3-2 2v15c0 .6.4 1 1 1h2c.6 0 1-.4 1-1V5Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/ferris-wheel.js
  var FerrisWheel = [
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "M12 2v4" }],
    ["path", { d: "m6.8 15-3.5 2" }],
    ["path", { d: "m20.7 7-3.5 2" }],
    ["path", { d: "M6.8 9 3.3 7" }],
    ["path", { d: "m20.7 17-3.5-2" }],
    ["path", { d: "m9 22 3-8 3 8" }],
    ["path", { d: "M8 22h8" }],
    ["path", { d: "M18 18.7a9 9 0 1 0-12 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/figma.js
  var Figma = [
    ["path", { d: "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z" }],
    ["path", { d: "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z" }],
    ["path", { d: "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z" }],
    ["path", { d: "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z" }],
    ["path", { d: "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-archive.js
  var FileArchive = [
    ["path", { d: "M10 12v-1" }],
    ["path", { d: "M10 18v-2" }],
    ["path", { d: "M10 7V6" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M15.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v16a2 2 0 0 0 .274 1.01" }],
    ["circle", { cx: "10", cy: "20", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-audio-2.js
  var FileAudio2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "3", cy: "17", r: "1" }],
    ["path", { d: "M2 17v-3a4 4 0 0 1 8 0v3" }],
    ["circle", { cx: "9", cy: "17", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-audio.js
  var FileAudio = [
    ["path", { d: "M17.5 22h.5a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      { d: "M2 19a2 2 0 1 1 4 0v1a2 2 0 1 1-4 0v-4a6 6 0 0 1 12 0v4a2 2 0 1 1-4 0v-1a2 2 0 1 1 4 0" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-axis-3d.js
  var FileAxis3d = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m8 18 4-4" }],
    ["path", { d: "M8 10v8h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-badge.js
  var FileBadge = [
    ["path", { d: "M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M5 17a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" }],
    ["path", { d: "M7 16.5 8 22l-3-1-3 1 1-5.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-badge-2.js
  var FileBadge2 = [
    [
      "path",
      {
        d: "m13.69 12.479 1.29 4.88a.5.5 0 0 1-.697.591l-1.844-.849a1 1 0 0 0-.88.001l-1.846.85a.5.5 0 0 1-.693-.593l1.29-4.88"
      }
    ],
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" }],
    ["circle", { cx: "12", cy: "10", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-box.js
  var FileBox = [
    ["path", { d: "M14.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        d: "M3 13.1a2 2 0 0 0-1 1.76v3.24a2 2 0 0 0 .97 1.78L6 21.7a2 2 0 0 0 2.03.01L11 19.9a2 2 0 0 0 1-1.76V14.9a2 2 0 0 0-.97-1.78L8 11.3a2 2 0 0 0-2.03-.01Z"
      }
    ],
    ["path", { d: "M7 17v5" }],
    ["path", { d: "M11.7 14.2 7 17l-4.7-2.8" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-chart-column-increasing.js
  var FileChartColumnIncreasing = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 18v-2" }],
    ["path", { d: "M12 18v-4" }],
    ["path", { d: "M16 18v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-chart-column.js
  var FileChartColumn = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 18v-1" }],
    ["path", { d: "M12 18v-6" }],
    ["path", { d: "M16 18v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-chart-pie.js
  var FileChartPie = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M16 22h2a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3.5" }],
    ["path", { d: "M4.017 11.512a6 6 0 1 0 8.466 8.475" }],
    [
      "path",
      {
        d: "M9 16a1 1 0 0 1-1-1v-4c0-.552.45-1.008.995-.917a6 6 0 0 1 4.922 4.922c.091.544-.365.995-.917.995z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-chart-line.js
  var FileChartLine = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m16 13-3.5 3.5-2-2L8 17" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-check-2.js
  var FileCheck2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m3 15 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-check.js
  var FileCheck = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m9 15 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-clock.js
  var FileClock = [
    ["path", { d: "M16 22h2a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "8", cy: "16", r: "6" }],
    ["path", { d: "M9.5 17.5 8 16.25V14" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-code-2.js
  var FileCode2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m5 12-3 3 3 3" }],
    ["path", { d: "m9 18 3-3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-code.js
  var FileCode = [
    ["path", { d: "M10 12.5 8 15l2 2.5" }],
    ["path", { d: "m14 12.5 2 2.5-2 2.5" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-cog.js
  var FileCog = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m2.305 15.53.923-.382" }],
    ["path", { d: "m3.228 12.852-.924-.383" }],
    ["path", { d: "M4.677 21.5a2 2 0 0 0 1.313.5H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v2.5" }],
    ["path", { d: "m4.852 11.228-.383-.923" }],
    ["path", { d: "m4.852 16.772-.383.924" }],
    ["path", { d: "m7.148 11.228.383-.923" }],
    ["path", { d: "m7.53 17.696-.382-.924" }],
    ["path", { d: "m8.772 12.852.923-.383" }],
    ["path", { d: "m8.772 15.148.923.383" }],
    ["circle", { cx: "6", cy: "14", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-diff.js
  var FileDiff = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M9 10h6" }],
    ["path", { d: "M12 13V7" }],
    ["path", { d: "M9 17h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-digit.js
  var FileDigit = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["rect", { width: "4", height: "6", x: "2", y: "12", rx: "2" }],
    ["path", { d: "M10 12h2v6" }],
    ["path", { d: "M10 18h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-down.js
  var FileDown = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M12 18v-6" }],
    ["path", { d: "m9 15 3 3 3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-heart.js
  var FileHeart = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        d: "M10.29 10.7a2.43 2.43 0 0 0-2.66-.52c-.29.12-.56.3-.78.53l-.35.34-.35-.34a2.43 2.43 0 0 0-2.65-.53c-.3.12-.56.3-.79.53-.95.94-1 2.53.2 3.74L6.5 18l3.6-3.55c1.2-1.21 1.14-2.8.19-3.74Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-image.js
  var FileImage = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "10", cy: "12", r: "2" }],
    ["path", { d: "m20 17-1.296-1.296a2.41 2.41 0 0 0-3.408 0L9 22" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-input.js
  var FileInput = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M2 15h10" }],
    ["path", { d: "m9 18 3-3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-json-2.js
  var FileJson2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M4 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1" }],
    ["path", { d: "M8 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-json.js
  var FileJson = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1" }],
    ["path", { d: "M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-key-2.js
  var FileKey2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v6" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "4", cy: "16", r: "2" }],
    ["path", { d: "m10 10-4.5 4.5" }],
    ["path", { d: "m9 11 1 1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-key.js
  var FileKey = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["circle", { cx: "10", cy: "16", r: "2" }],
    ["path", { d: "m16 10-4.5 4.5" }],
    ["path", { d: "m15 11 1 1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-lock-2.js
  var FileLock2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v1" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["rect", { width: "8", height: "5", x: "2", y: "13", rx: "1" }],
    ["path", { d: "M8 13v-2a2 2 0 1 0-4 0v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-lock.js
  var FileLock = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["rect", { width: "8", height: "6", x: "8", y: "12", rx: "1" }],
    ["path", { d: "M10 12v-2a2 2 0 1 1 4 0v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-minus-2.js
  var FileMinus2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M3 15h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-minus.js
  var FileMinus = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M9 15h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-music.js
  var FileMusic = [
    ["path", { d: "M10.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v8.4" }],
    ["path", { d: "M8 18v-7.7L16 9v7" }],
    ["circle", { cx: "14", cy: "16", r: "2" }],
    ["circle", { cx: "6", cy: "18", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-output.js
  var FileOutput = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M4 7V4a2 2 0 0 1 2-2 2 2 0 0 0-2 2" }],
    ["path", { d: "M4.063 20.999a2 2 0 0 0 2 1L18 22a2 2 0 0 0 2-2V7l-5-5H6" }],
    ["path", { d: "m5 11-3 3" }],
    ["path", { d: "m5 17-3-3h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-pen-line.js
  var FilePenLine = [
    [
      "path",
      { d: "m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2" }
    ],
    [
      "path",
      {
        d: "M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ],
    ["path", { d: "M8 18h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-pen.js
  var FilePen = [
    ["path", { d: "M12.5 22H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v9.5" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        d: "M13.378 15.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-plus-2.js
  var FilePlus2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M3 15h6" }],
    ["path", { d: "M6 12v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-plus.js
  var FilePlus = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M9 15h6" }],
    ["path", { d: "M12 18v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-question.js
  var FileQuestion = [
    ["path", { d: "M12 17h.01" }],
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" }],
    ["path", { d: "M9.1 9a3 3 0 0 1 5.82 1c0 2-3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-scan.js
  var FileScan = [
    ["path", { d: "M20 10V7l-5-5H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M16 14a2 2 0 0 0-2 2" }],
    ["path", { d: "M20 14a2 2 0 0 1 2 2" }],
    ["path", { d: "M20 22a2 2 0 0 0 2-2" }],
    ["path", { d: "M16 22a2 2 0 0 1-2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-search-2.js
  var FileSearch2 = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "11.5", cy: "14.5", r: "2.5" }],
    ["path", { d: "M13.3 16.3 15 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-sliders.js
  var FileSliders = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "M10 11v2" }],
    ["path", { d: "M8 17h8" }],
    ["path", { d: "M14 16v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-search.js
  var FileSearch = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M4.268 21a2 2 0 0 0 1.727 1H18a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3" }],
    ["path", { d: "m9 18-1.5-1.5" }],
    ["circle", { cx: "5", cy: "14", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-spreadsheet.js
  var FileSpreadsheet = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 13h2" }],
    ["path", { d: "M14 13h2" }],
    ["path", { d: "M8 17h2" }],
    ["path", { d: "M14 17h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-stack.js
  var FileStack = [
    ["path", { d: "M21 7h-3a2 2 0 0 1-2-2V2" }],
    [
      "path",
      { d: "M21 6v6.5c0 .8-.7 1.5-1.5 1.5h-7c-.8 0-1.5-.7-1.5-1.5v-9c0-.8.7-1.5 1.5-1.5H17Z" }
    ],
    ["path", { d: "M7 8v8.8c0 .3.2.6.4.8.2.2.5.4.8.4H15" }],
    ["path", { d: "M3 12v8.8c0 .3.2.6.4.8.2.2.5.4.8.4H11" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-symlink.js
  var FileSymlink = [
    ["path", { d: "m10 18 3-3-3-3" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      { d: "M4 11V4a2 2 0 0 1 2-2h9l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h7" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-terminal.js
  var FileTerminal = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m8 16 2-2-2-2" }],
    ["path", { d: "M12 18h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-text.js
  var FileText = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M10 9H8" }],
    ["path", { d: "M16 13H8" }],
    ["path", { d: "M16 17H8" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-type-2.js
  var FileType2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M2 13v-1h6v1" }],
    ["path", { d: "M5 12v6" }],
    ["path", { d: "M4 18h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-type.js
  var FileType = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M9 13v-1h6v1" }],
    ["path", { d: "M12 12v6" }],
    ["path", { d: "M11 18h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-up.js
  var FileUp = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M12 12v6" }],
    ["path", { d: "m15 15-3-3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-user.js
  var FileUser = [
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M15 18a3 3 0 1 0-6 0" }],
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" }],
    ["circle", { cx: "12", cy: "13", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-video-2.js
  var FileVideo2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["rect", { width: "8", height: "6", x: "2", y: "12", rx: "1" }],
    ["path", { d: "m10 15.5 4 2.5v-6l-4 2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-volume-2.js
  var FileVolume2 = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 15h.01" }],
    ["path", { d: "M11.5 13.5a2.5 2.5 0 0 1 0 3" }],
    ["path", { d: "M15 12a5 5 0 0 1 0 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-video.js
  var FileVideo = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m10 11 5 3-5 3v-6Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-warning.js
  var FileWarning = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-volume.js
  var FileVolume = [
    ["path", { d: "M11 11a5 5 0 0 1 0 6" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M4 6.765V4a2 2 0 0 1 2-2h9l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-.93-.23" }],
    [
      "path",
      {
        d: "M7 10.51a.5.5 0 0 0-.826-.38l-1.893 1.628A1 1 0 0 1 3.63 12H2.5a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 .5.5h1.129a1 1 0 0 1 .652.242l1.893 1.63a.5.5 0 0 0 .826-.38z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/file-x-2.js
  var FileX2 = [
    ["path", { d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m8 12.5-5 5" }],
    ["path", { d: "m3 12.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/file.js
  var File2 = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/file-x.js
  var FileX = [
    ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "m14.5 12.5-5 5" }],
    ["path", { d: "m9.5 12.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/files.js
  var Files = [
    ["path", { d: "M20 7h-3a2 2 0 0 1-2-2V2" }],
    ["path", { d: "M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z" }],
    ["path", { d: "M3 7.6v12.8A1.6 1.6 0 0 0 4.6 22h9.8" }]
  ];

  // node_modules/lucide/dist/esm/icons/film.js
  var Film = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 3v18" }],
    ["path", { d: "M3 7.5h4" }],
    ["path", { d: "M3 12h18" }],
    ["path", { d: "M3 16.5h4" }],
    ["path", { d: "M17 3v18" }],
    ["path", { d: "M17 7.5h4" }],
    ["path", { d: "M17 16.5h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/fire-extinguisher.js
  var FireExtinguisher = [
    ["path", { d: "M15 6.5V3a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v3.5" }],
    ["path", { d: "M9 18h8" }],
    ["path", { d: "M18 3h-3" }],
    ["path", { d: "M11 3a6 6 0 0 0-6 6v11" }],
    ["path", { d: "M5 13h4" }],
    ["path", { d: "M17 10a4 4 0 0 0-8 0v10a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/fingerprint.js
  var Fingerprint = [
    ["path", { d: "M12 10a2 2 0 0 0-2 2c0 1.02-.1 2.51-.26 4" }],
    ["path", { d: "M14 13.12c0 2.38 0 6.38-1 8.88" }],
    ["path", { d: "M17.29 21.02c.12-.6.43-2.3.5-3.02" }],
    ["path", { d: "M2 12a10 10 0 0 1 18-6" }],
    ["path", { d: "M2 16h.01" }],
    ["path", { d: "M21.8 16c.2-2 .131-5.354 0-6" }],
    ["path", { d: "M5 19.5C5.5 18 6 15 6 12a6 6 0 0 1 .34-2" }],
    ["path", { d: "M8.65 22c.21-.66.45-1.32.57-2" }],
    ["path", { d: "M9 6.8a6 6 0 0 1 9 5.2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/fish-off.js
  var FishOff = [
    [
      "path",
      {
        d: "M18 12.47v.03m0-.5v.47m-.475 5.056A6.744 6.744 0 0 1 15 18c-3.56 0-7.56-2.53-8.5-6 .348-1.28 1.114-2.433 2.121-3.38m3.444-2.088A8.802 8.802 0 0 1 15 6c3.56 0 6.06 2.54 7 6-.309 1.14-.786 2.177-1.413 3.058"
      }
    ],
    [
      "path",
      {
        d: "M7 10.67C7 8 5.58 5.97 2.73 5.5c-1 1.5-1 5 .23 6.5-1.24 1.5-1.24 5-.23 6.5C5.58 18.03 7 16 7 13.33m7.48-4.372A9.77 9.77 0 0 1 16 6.07m0 11.86a9.77 9.77 0 0 1-1.728-3.618"
      }
    ],
    [
      "path",
      {
        d: "m16.01 17.93-.23 1.4A2 2 0 0 1 13.8 21H9.5a5.96 5.96 0 0 0 1.49-3.98M8.53 3h5.27a2 2 0 0 1 1.98 1.67l.23 1.4M2 2l20 20"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/fish-symbol.js
  var FishSymbol = [["path", { d: "M2 16s9-15 20-4C11 23 2 8 2 8" }]];

  // node_modules/lucide/dist/esm/icons/fish.js
  var Fish = [
    [
      "path",
      {
        d: "M6.5 12c.94-3.46 4.94-6 8.5-6 3.56 0 6.06 2.54 7 6-.94 3.47-3.44 6-7 6s-7.56-2.53-8.5-6Z"
      }
    ],
    ["path", { d: "M18 12v.5" }],
    ["path", { d: "M16 17.93a9.77 9.77 0 0 1 0-11.86" }],
    [
      "path",
      {
        d: "M7 10.67C7 8 5.58 5.97 2.73 5.5c-1 1.5-1 5 .23 6.5-1.24 1.5-1.24 5-.23 6.5C5.58 18.03 7 16 7 13.33"
      }
    ],
    ["path", { d: "M10.46 7.26C10.2 5.88 9.17 4.24 8 3h5.8a2 2 0 0 1 1.98 1.67l.23 1.4" }],
    ["path", { d: "m16.01 17.93-.23 1.4A2 2 0 0 1 13.8 21H9.5a5.96 5.96 0 0 0 1.49-3.98" }]
  ];

  // node_modules/lucide/dist/esm/icons/flag-off.js
  var FlagOff = [
    ["path", { d: "M8 2c3 0 5 2 8 2s4-1 4-1v11" }],
    ["path", { d: "M4 22V4" }],
    ["path", { d: "M4 15s1-1 4-1 5 2 8 2" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/flag-triangle-left.js
  var FlagTriangleLeft = [["path", { d: "M17 22V2L7 7l10 5" }]];

  // node_modules/lucide/dist/esm/icons/flag-triangle-right.js
  var FlagTriangleRight = [["path", { d: "M7 22V2l10 5-10 5" }]];

  // node_modules/lucide/dist/esm/icons/flag.js
  var Flag = [
    ["path", { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" }],
    ["line", { x1: "4", x2: "4", y1: "22", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/flame-kindling.js
  var FlameKindling = [
    [
      "path",
      {
        d: "M12 2c1 3 2.5 3.5 3.5 4.5A5 5 0 0 1 17 10a5 5 0 1 1-10 0c0-.3 0-.6.1-.9a2 2 0 1 0 3.3-2C8 4.5 11 2 12 2Z"
      }
    ],
    ["path", { d: "m5 22 14-4" }],
    ["path", { d: "m5 18 14 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/flame.js
  var Flame = [
    [
      "path",
      {
        d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/flashlight-off.js
  var FlashlightOff = [
    ["path", { d: "M16 16v4a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V10c0-2-2-2-2-4" }],
    ["path", { d: "M7 2h11v4c0 2-2 2-2 4v1" }],
    ["line", { x1: "11", x2: "18", y1: "6", y2: "6" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/flashlight.js
  var Flashlight = [
    ["path", { d: "M18 6c0 2-2 2-2 4v10a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2V10c0-2-2-2-2-4V2h12z" }],
    ["line", { x1: "6", x2: "18", y1: "6", y2: "6" }],
    ["line", { x1: "12", x2: "12", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/flask-conical-off.js
  var FlaskConicalOff = [
    ["path", { d: "M10 2v2.343" }],
    ["path", { d: "M14 2v6.343" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M20 20a2 2 0 0 1-2 2H6a2 2 0 0 1-1.755-2.96l5.227-9.563" }],
    ["path", { d: "M6.453 15H15" }],
    ["path", { d: "M8.5 2h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/flask-conical.js
  var FlaskConical = [
    [
      "path",
      {
        d: "M14 2v6a2 2 0 0 0 .245.96l5.51 10.08A2 2 0 0 1 18 22H6a2 2 0 0 1-1.755-2.96l5.51-10.08A2 2 0 0 0 10 8V2"
      }
    ],
    ["path", { d: "M6.453 15h11.094" }],
    ["path", { d: "M8.5 2h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/flask-round.js
  var FlaskRound = [
    ["path", { d: "M10 2v6.292a7 7 0 1 0 4 0V2" }],
    ["path", { d: "M5 15h14" }],
    ["path", { d: "M8.5 2h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/flip-horizontal-2.js
  var FlipHorizontal2 = [
    ["path", { d: "m3 7 5 5-5 5V7" }],
    ["path", { d: "m21 7-5 5 5 5V7" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "M12 14v2" }],
    ["path", { d: "M12 8v2" }],
    ["path", { d: "M12 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/flip-horizontal.js
  var FlipHorizontal = [
    ["path", { d: "M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3" }],
    ["path", { d: "M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "M12 14v2" }],
    ["path", { d: "M12 8v2" }],
    ["path", { d: "M12 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/flip-vertical-2.js
  var FlipVertical2 = [
    ["path", { d: "m17 3-5 5-5-5h10" }],
    ["path", { d: "m17 21-5-5-5 5h10" }],
    ["path", { d: "M4 12H2" }],
    ["path", { d: "M10 12H8" }],
    ["path", { d: "M16 12h-2" }],
    ["path", { d: "M22 12h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/flip-vertical.js
  var FlipVertical = [
    ["path", { d: "M21 8V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M21 16v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-3" }],
    ["path", { d: "M4 12H2" }],
    ["path", { d: "M10 12H8" }],
    ["path", { d: "M16 12h-2" }],
    ["path", { d: "M22 12h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/flower-2.js
  var Flower2 = [
    [
      "path",
      {
        d: "M12 5a3 3 0 1 1 3 3m-3-3a3 3 0 1 0-3 3m3-3v1M9 8a3 3 0 1 0 3 3M9 8h1m5 0a3 3 0 1 1-3 3m3-3h-1m-2 3v-1"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "2" }],
    ["path", { d: "M12 10v12" }],
    ["path", { d: "M12 22c4.2 0 7-1.667 7-5-4.2 0-7 1.667-7 5Z" }],
    ["path", { d: "M12 22c-4.2 0-7-1.667-7-5 4.2 0 7 1.667 7 5Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/focus.js
  var Focus = [
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/flower.js
  var Flower = [
    ["circle", { cx: "12", cy: "12", r: "3" }],
    [
      "path",
      {
        d: "M12 16.5A4.5 4.5 0 1 1 7.5 12 4.5 4.5 0 1 1 12 7.5a4.5 4.5 0 1 1 4.5 4.5 4.5 4.5 0 1 1-4.5 4.5"
      }
    ],
    ["path", { d: "M12 7.5V9" }],
    ["path", { d: "M7.5 12H9" }],
    ["path", { d: "M16.5 12H15" }],
    ["path", { d: "M12 16.5V15" }],
    ["path", { d: "m8 8 1.88 1.88" }],
    ["path", { d: "M14.12 9.88 16 8" }],
    ["path", { d: "m8 16 1.88-1.88" }],
    ["path", { d: "M14.12 14.12 16 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/fold-horizontal.js
  var FoldHorizontal = [
    ["path", { d: "M2 12h6" }],
    ["path", { d: "M22 12h-6" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 8v2" }],
    ["path", { d: "M12 14v2" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "m19 9-3 3 3 3" }],
    ["path", { d: "m5 15 3-3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-archive.js
  var FolderArchive = [
    ["circle", { cx: "15", cy: "19", r: "2" }],
    [
      "path",
      {
        d: "M20.9 19.8A2 2 0 0 0 22 18V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2h5.1"
      }
    ],
    ["path", { d: "M15 11v-1" }],
    ["path", { d: "M15 17v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/fold-vertical.js
  var FoldVertical = [
    ["path", { d: "M12 22v-6" }],
    ["path", { d: "M12 8V2" }],
    ["path", { d: "M4 12H2" }],
    ["path", { d: "M10 12H8" }],
    ["path", { d: "M16 12h-2" }],
    ["path", { d: "M22 12h-2" }],
    ["path", { d: "m15 19-3-3-3 3" }],
    ["path", { d: "m15 5-3 3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-check.js
  var FolderCheck = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "m9 13 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-clock.js
  var FolderClock = [
    ["circle", { cx: "16", cy: "16", r: "6" }],
    [
      "path",
      {
        d: "M7 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2"
      }
    ],
    ["path", { d: "M16 14v2l1 1" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-closed.js
  var FolderClosed = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M2 10h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-code.js
  var FolderCode = [
    ["path", { d: "M10 10.5 8 13l2 2.5" }],
    ["path", { d: "m14 10.5 2 2.5-2 2.5" }],
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-cog.js
  var FolderCog = [
    [
      "path",
      {
        d: "M10.3 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.98a2 2 0 0 1 1.69.9l.66 1.2A2 2 0 0 0 12 6h8a2 2 0 0 1 2 2v3.3"
      }
    ],
    ["path", { d: "m14.305 19.53.923-.382" }],
    ["path", { d: "m15.228 16.852-.923-.383" }],
    ["path", { d: "m16.852 15.228-.383-.923" }],
    ["path", { d: "m16.852 20.772-.383.924" }],
    ["path", { d: "m19.148 15.228.383-.923" }],
    ["path", { d: "m19.53 21.696-.382-.924" }],
    ["path", { d: "m20.772 16.852.924-.383" }],
    ["path", { d: "m20.772 19.148.924.383" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-dot.js
  var FolderDot = [
    [
      "path",
      {
        d: "M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"
      }
    ],
    ["circle", { cx: "12", cy: "13", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-down.js
  var FolderDown = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M12 10v6" }],
    ["path", { d: "m15 13-3 3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-git.js
  var FolderGit = [
    ["circle", { cx: "12", cy: "13", r: "2" }],
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M14 13h3" }],
    ["path", { d: "M7 13h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-heart.js
  var FolderHeart = [
    [
      "path",
      {
        d: "M11 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v1.5"
      }
    ],
    [
      "path",
      {
        d: "M13.9 17.45c-1.2-1.2-1.14-2.8-.2-3.73a2.43 2.43 0 0 1 3.44 0l.36.34.34-.34a2.43 2.43 0 0 1 3.45-.01c.95.95 1 2.53-.2 3.74L17.5 21Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-git-2.js
  var FolderGit2 = [
    [
      "path",
      {
        d: "M9 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v5"
      }
    ],
    ["circle", { cx: "13", cy: "12", r: "2" }],
    ["path", { d: "M18 19c-2.8 0-5-2.2-5-5v8" }],
    ["circle", { cx: "20", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-input.js
  var FolderInput = [
    [
      "path",
      {
        d: "M2 9V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-1"
      }
    ],
    ["path", { d: "M2 13h10" }],
    ["path", { d: "m9 16 3-3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-kanban.js
  var FolderKanban = [
    [
      "path",
      {
        d: "M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"
      }
    ],
    ["path", { d: "M8 10v4" }],
    ["path", { d: "M12 10v2" }],
    ["path", { d: "M16 10v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-key.js
  var FolderKey = [
    ["circle", { cx: "16", cy: "20", r: "2" }],
    [
      "path",
      {
        d: "M10 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2"
      }
    ],
    ["path", { d: "m22 14-4.5 4.5" }],
    ["path", { d: "m21 15 1 1" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-lock.js
  var FolderLock = [
    ["rect", { width: "8", height: "5", x: "14", y: "17", rx: "1" }],
    [
      "path",
      {
        d: "M10 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2.5"
      }
    ],
    ["path", { d: "M20 17v-2a2 2 0 1 0-4 0v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-minus.js
  var FolderMinus = [
    ["path", { d: "M9 13h6" }],
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-open-dot.js
  var FolderOpenDot = [
    [
      "path",
      {
        d: "m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"
      }
    ],
    ["circle", { cx: "14", cy: "15", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-open.js
  var FolderOpen = [
    [
      "path",
      {
        d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-pen.js
  var FolderPen = [
    [
      "path",
      {
        d: "M2 11.5V5a2 2 0 0 1 2-2h3.9c.7 0 1.3.3 1.7.9l.8 1.2c.4.6 1 .9 1.7.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-9.5"
      }
    ],
    [
      "path",
      {
        d: "M11.378 13.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-plus.js
  var FolderPlus = [
    ["path", { d: "M12 10v6" }],
    ["path", { d: "M9 13h6" }],
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folder-output.js
  var FolderOutput = [
    [
      "path",
      {
        d: "M2 7.5V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-1.5"
      }
    ],
    ["path", { d: "M2 13h10" }],
    ["path", { d: "m5 10-3 3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-root.js
  var FolderRoot = [
    [
      "path",
      {
        d: "M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"
      }
    ],
    ["circle", { cx: "12", cy: "13", r: "2" }],
    ["path", { d: "M12 15v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-search.js
  var FolderSearch = [
    [
      "path",
      {
        d: "M10.7 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v4.1"
      }
    ],
    ["path", { d: "m21 21-1.9-1.9" }],
    ["circle", { cx: "17", cy: "17", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-search-2.js
  var FolderSearch2 = [
    ["circle", { cx: "11.5", cy: "12.5", r: "2.5" }],
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M13.3 14.3 15 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-symlink.js
  var FolderSymlink = [
    [
      "path",
      {
        d: "M2 9V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h7"
      }
    ],
    ["path", { d: "m8 16 3-3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-tree.js
  var FolderTree = [
    [
      "path",
      {
        d: "M20 10a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-2.5a1 1 0 0 1-.8-.4l-.9-1.2A1 1 0 0 0 15 3h-2a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z"
      }
    ],
    [
      "path",
      {
        d: "M20 21a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1h-2.9a1 1 0 0 1-.88-.55l-.42-.85a1 1 0 0 0-.92-.6H13a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1Z"
      }
    ],
    ["path", { d: "M3 5a2 2 0 0 0 2 2h3" }],
    ["path", { d: "M3 3v13a2 2 0 0 0 2 2h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-sync.js
  var FolderSync = [
    [
      "path",
      {
        d: "M9 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v.5"
      }
    ],
    ["path", { d: "M12 10v4h4" }],
    ["path", { d: "m12 14 1.535-1.605a5 5 0 0 1 8 1.5" }],
    ["path", { d: "M22 22v-4h-4" }],
    ["path", { d: "m22 18-1.535 1.605a5 5 0 0 1-8-1.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-up.js
  var FolderUp = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M12 10v6" }],
    ["path", { d: "m9 13 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder-x.js
  var FolderX = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "m9.5 10.5 5 5" }],
    ["path", { d: "m14.5 10.5-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/folder.js
  var Folder = [
    [
      "path",
      {
        d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/folders.js
  var Folders = [
    [
      "path",
      {
        d: "M20 17a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3.9a2 2 0 0 1-1.69-.9l-.81-1.2a2 2 0 0 0-1.67-.9H8a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2Z"
      }
    ],
    ["path", { d: "M2 8v11a2 2 0 0 0 2 2h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/footprints.js
  var Footprints = [
    [
      "path",
      {
        d: "M4 16v-2.38C4 11.5 2.97 10.5 3 8c.03-2.72 1.49-6 4.5-6C9.37 2 10 3.8 10 5.5c0 3.11-2 5.66-2 8.68V16a2 2 0 1 1-4 0Z"
      }
    ],
    [
      "path",
      {
        d: "M20 20v-2.38c0-2.12 1.03-3.12 1-5.62-.03-2.72-1.49-6-4.5-6C14.63 6 14 7.8 14 9.5c0 3.11 2 5.66 2 8.68V20a2 2 0 1 0 4 0Z"
      }
    ],
    ["path", { d: "M16 17h4" }],
    ["path", { d: "M4 13h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/forklift.js
  var Forklift = [
    ["path", { d: "M12 12H5a2 2 0 0 0-2 2v5" }],
    ["circle", { cx: "13", cy: "19", r: "2" }],
    ["circle", { cx: "5", cy: "19", r: "2" }],
    ["path", { d: "M8 19h3m5-17v17h6M6 12V7c0-1.1.9-2 2-2h3l5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/forward.js
  var Forward = [
    ["polyline", { points: "15 17 20 12 15 7" }],
    ["path", { d: "M4 18v-2a4 4 0 0 1 4-4h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/frame.js
  var Frame = [
    ["line", { x1: "22", x2: "2", y1: "6", y2: "6" }],
    ["line", { x1: "22", x2: "2", y1: "18", y2: "18" }],
    ["line", { x1: "6", x2: "6", y1: "2", y2: "22" }],
    ["line", { x1: "18", x2: "18", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/framer.js
  var Framer = [["path", { d: "M5 16V9h14V2H5l14 14h-7m-7 0 7 7v-7m-7 0h7" }]];

  // node_modules/lucide/dist/esm/icons/frown.js
  var Frown = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M16 16s-1.5-2-4-2-4 2-4 2" }],
    ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9" }],
    ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/fuel.js
  var Fuel = [
    ["line", { x1: "3", x2: "15", y1: "22", y2: "22" }],
    ["line", { x1: "4", x2: "14", y1: "9", y2: "9" }],
    ["path", { d: "M14 22V4a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v18" }],
    [
      "path",
      { d: "M14 13h2a2 2 0 0 1 2 2v2a2 2 0 0 0 2 2a2 2 0 0 0 2-2V9.83a2 2 0 0 0-.59-1.42L18 5" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/fullscreen.js
  var Fullscreen = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["rect", { width: "10", height: "8", x: "7", y: "8", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/funnel-plus.js
  var FunnelPlus = [
    [
      "path",
      {
        d: "M13.354 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14v6a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341l1.218-1.348"
      }
    ],
    ["path", { d: "M16 6h6" }],
    ["path", { d: "M19 3v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/funnel-x.js
  var FunnelX = [
    [
      "path",
      {
        d: "M12.531 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14v6a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341l.427-.473"
      }
    ],
    ["path", { d: "m16.5 3.5 5 5" }],
    ["path", { d: "m21.5 3.5-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/funnel.js
  var Funnel = [
    [
      "path",
      {
        d: "M10 20a1 1 0 0 0 .553.895l2 1A1 1 0 0 0 14 21v-7a2 2 0 0 1 .517-1.341L21.74 4.67A1 1 0 0 0 21 3H3a1 1 0 0 0-.742 1.67l7.225 7.989A2 2 0 0 1 10 14z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/gallery-horizontal-end.js
  var GalleryHorizontalEnd = [
    ["path", { d: "M2 7v10" }],
    ["path", { d: "M6 5v14" }],
    ["rect", { width: "12", height: "18", x: "10", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/gallery-horizontal.js
  var GalleryHorizontal = [
    ["path", { d: "M2 3v18" }],
    ["rect", { width: "12", height: "18", x: "6", y: "3", rx: "2" }],
    ["path", { d: "M22 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/gallery-thumbnails.js
  var GalleryThumbnails = [
    ["rect", { width: "18", height: "14", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M4 21h1" }],
    ["path", { d: "M9 21h1" }],
    ["path", { d: "M14 21h1" }],
    ["path", { d: "M19 21h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/gallery-vertical-end.js
  var GalleryVerticalEnd = [
    ["path", { d: "M7 2h10" }],
    ["path", { d: "M5 6h14" }],
    ["rect", { width: "18", height: "12", x: "3", y: "10", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/gallery-vertical.js
  var GalleryVertical = [
    ["path", { d: "M3 2h18" }],
    ["rect", { width: "18", height: "12", x: "3", y: "6", rx: "2" }],
    ["path", { d: "M3 22h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/gamepad-2.js
  var Gamepad2 = [
    ["line", { x1: "6", x2: "10", y1: "11", y2: "11" }],
    ["line", { x1: "8", x2: "8", y1: "9", y2: "13" }],
    ["line", { x1: "15", x2: "15.01", y1: "12", y2: "12" }],
    ["line", { x1: "18", x2: "18.01", y1: "10", y2: "10" }],
    [
      "path",
      {
        d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/gauge.js
  var Gauge = [
    ["path", { d: "m12 14 4-4" }],
    ["path", { d: "M3.34 19a10 10 0 1 1 17.32 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/gamepad.js
  var Gamepad = [
    ["line", { x1: "6", x2: "10", y1: "12", y2: "12" }],
    ["line", { x1: "8", x2: "8", y1: "10", y2: "14" }],
    ["line", { x1: "15", x2: "15.01", y1: "13", y2: "13" }],
    ["line", { x1: "18", x2: "18.01", y1: "11", y2: "11" }],
    ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/gavel.js
  var Gavel = [
    ["path", { d: "m14.5 12.5-8 8a2.119 2.119 0 1 1-3-3l8-8" }],
    ["path", { d: "m16 16 6-6" }],
    ["path", { d: "m8 8 6-6" }],
    ["path", { d: "m9 7 8 8" }],
    ["path", { d: "m21 11-8-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/gem.js
  var Gem = [
    ["path", { d: "M6 3h12l4 6-10 13L2 9Z" }],
    ["path", { d: "M11 3 8 9l4 13 4-13-3-6" }],
    ["path", { d: "M2 9h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/ghost.js
  var Ghost = [
    ["path", { d: "M9 10h.01" }],
    ["path", { d: "M15 10h.01" }],
    ["path", { d: "M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z" }]
  ];

  // node_modules/lucide/dist/esm/icons/gift.js
  var Gift = [
    ["rect", { x: "3", y: "8", width: "18", height: "4", rx: "1" }],
    ["path", { d: "M12 8v13" }],
    ["path", { d: "M19 12v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-7" }],
    ["path", { d: "M7.5 8a2.5 2.5 0 0 1 0-5A4.8 8 0 0 1 12 8a4.8 8 0 0 1 4.5-5 2.5 2.5 0 0 1 0 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-branch-plus.js
  var GitBranchPlus = [
    ["path", { d: "M6 3v12" }],
    ["path", { d: "M18 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" }],
    ["path", { d: "M6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" }],
    ["path", { d: "M15 6a9 9 0 0 0-9 9" }],
    ["path", { d: "M18 15v6" }],
    ["path", { d: "M21 18h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-branch.js
  var GitBranch = [
    ["line", { x1: "6", x2: "6", y1: "3", y2: "15" }],
    ["circle", { cx: "18", cy: "6", r: "3" }],
    ["circle", { cx: "6", cy: "18", r: "3" }],
    ["path", { d: "M18 9a9 9 0 0 1-9 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-commit-horizontal.js
  var GitCommitHorizontal = [
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["line", { x1: "3", x2: "9", y1: "12", y2: "12" }],
    ["line", { x1: "15", x2: "21", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-commit-vertical.js
  var GitCommitVertical = [
    ["path", { d: "M12 3v6" }],
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["path", { d: "M12 15v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-compare.js
  var GitCompare = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M13 6h3a2 2 0 0 1 2 2v7" }],
    ["path", { d: "M11 18H8a2 2 0 0 1-2-2V9" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-compare-arrows.js
  var GitCompareArrows = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M12 6h5a2 2 0 0 1 2 2v7" }],
    ["path", { d: "m15 9-3-3 3-3" }],
    ["circle", { cx: "19", cy: "18", r: "3" }],
    ["path", { d: "M12 18H7a2 2 0 0 1-2-2V9" }],
    ["path", { d: "m9 15 3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-fork.js
  var GitFork = [
    ["circle", { cx: "12", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["circle", { cx: "18", cy: "6", r: "3" }],
    ["path", { d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9" }],
    ["path", { d: "M12 12v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-graph.js
  var GitGraph = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M5 9v6" }],
    ["circle", { cx: "5", cy: "18", r: "3" }],
    ["path", { d: "M12 3v18" }],
    ["circle", { cx: "19", cy: "6", r: "3" }],
    ["path", { d: "M16 15.7A9 9 0 0 0 19 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-merge.js
  var GitMerge = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M6 21V9a9 9 0 0 0 9 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request-arrow.js
  var GitPullRequestArrow = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M5 9v12" }],
    ["circle", { cx: "19", cy: "18", r: "3" }],
    ["path", { d: "m15 9-3-3 3-3" }],
    ["path", { d: "M12 6h5a2 2 0 0 1 2 2v7" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request-closed.js
  var GitPullRequestClosed = [
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M6 9v12" }],
    ["path", { d: "m21 3-6 6" }],
    ["path", { d: "m21 9-6-6" }],
    ["path", { d: "M18 11.5V15" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request-create-arrow.js
  var GitPullRequestCreateArrow = [
    ["circle", { cx: "5", cy: "6", r: "3" }],
    ["path", { d: "M5 9v12" }],
    ["path", { d: "m15 9-3-3 3-3" }],
    ["path", { d: "M12 6h5a2 2 0 0 1 2 2v3" }],
    ["path", { d: "M19 15v6" }],
    ["path", { d: "M22 18h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request-create.js
  var GitPullRequestCreate = [
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M6 9v12" }],
    ["path", { d: "M13 6h3a2 2 0 0 1 2 2v3" }],
    ["path", { d: "M18 15v6" }],
    ["path", { d: "M21 18h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request-draft.js
  var GitPullRequestDraft = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M18 6V5" }],
    ["path", { d: "M18 11v-1" }],
    ["line", { x1: "6", x2: "6", y1: "9", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/github.js
  var Github = [
    [
      "path",
      {
        d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"
      }
    ],
    ["path", { d: "M9 18c-4.51 2-5-2-7-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/git-pull-request.js
  var GitPullRequest = [
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M13 6h3a2 2 0 0 1 2 2v7" }],
    ["line", { x1: "6", x2: "6", y1: "9", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/gitlab.js
  var Gitlab = [
    [
      "path",
      {
        d: "m22 13.29-3.33-10a.42.42 0 0 0-.14-.18.38.38 0 0 0-.22-.11.39.39 0 0 0-.23.07.42.42 0 0 0-.14.18l-2.26 6.67H8.32L6.1 3.26a.42.42 0 0 0-.1-.18.38.38 0 0 0-.26-.08.39.39 0 0 0-.23.07.42.42 0 0 0-.14.18L2 13.29a.74.74 0 0 0 .27.83L12 21l9.69-6.88a.71.71 0 0 0 .31-.83Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/glass-water.js
  var GlassWater = [
    [
      "path",
      {
        d: "M5.116 4.104A1 1 0 0 1 6.11 3h11.78a1 1 0 0 1 .994 1.105L17.19 20.21A2 2 0 0 1 15.2 22H8.8a2 2 0 0 1-2-1.79z"
      }
    ],
    ["path", { d: "M6 12a5 5 0 0 1 6 0 5 5 0 0 0 6 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/glasses.js
  var Glasses = [
    ["circle", { cx: "6", cy: "15", r: "4" }],
    ["circle", { cx: "18", cy: "15", r: "4" }],
    ["path", { d: "M14 15a2 2 0 0 0-2-2 2 2 0 0 0-2 2" }],
    ["path", { d: "M2.5 13 5 7c.7-1.3 1.4-2 3-2" }],
    ["path", { d: "M21.5 13 19 7c-.7-1.3-1.5-2-3-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/globe-lock.js
  var GlobeLock = [
    ["path", { d: "M15.686 15A14.5 14.5 0 0 1 12 22a14.5 14.5 0 0 1 0-20 10 10 0 1 0 9.542 13" }],
    ["path", { d: "M2 12h8.5" }],
    ["path", { d: "M20 6V4a2 2 0 1 0-4 0v2" }],
    ["rect", { width: "8", height: "5", x: "14", y: "6", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/globe.js
  var Globe = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20" }],
    ["path", { d: "M2 12h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/goal.js
  var Goal = [
    ["path", { d: "M12 13V2l8 4-8 4" }],
    ["path", { d: "M20.561 10.222a9 9 0 1 1-12.55-5.29" }],
    ["path", { d: "M8.002 9.997a5 5 0 1 0 8.9 2.02" }]
  ];

  // node_modules/lucide/dist/esm/icons/grab.js
  var Grab = [
    ["path", { d: "M18 11.5V9a2 2 0 0 0-2-2a2 2 0 0 0-2 2v1.4" }],
    ["path", { d: "M14 10V8a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M10 9.9V9a2 2 0 0 0-2-2a2 2 0 0 0-2 2v5" }],
    ["path", { d: "M6 14a2 2 0 0 0-2-2a2 2 0 0 0-2 2" }],
    ["path", { d: "M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-4a8 8 0 0 1-8-8 2 2 0 1 1 4 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/graduation-cap.js
  var GraduationCap = [
    [
      "path",
      {
        d: "M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z"
      }
    ],
    ["path", { d: "M22 10v6" }],
    ["path", { d: "M6 12.5V16a6 3 0 0 0 12 0v-3.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/grape.js
  var Grape = [
    ["path", { d: "M22 5V2l-5.89 5.89" }],
    ["circle", { cx: "16.6", cy: "15.89", r: "3" }],
    ["circle", { cx: "8.11", cy: "7.4", r: "3" }],
    ["circle", { cx: "12.35", cy: "11.65", r: "3" }],
    ["circle", { cx: "13.91", cy: "5.85", r: "3" }],
    ["circle", { cx: "18.15", cy: "10.09", r: "3" }],
    ["circle", { cx: "6.56", cy: "13.2", r: "3" }],
    ["circle", { cx: "10.8", cy: "17.44", r: "3" }],
    ["circle", { cx: "5", cy: "19", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/grid-2x2-check.js
  var Grid2x2Check = [
    [
      "path",
      {
        d: "M12 3v17a1 1 0 0 1-1 1H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6a1 1 0 0 1-1 1H3"
      }
    ],
    ["path", { d: "m16 19 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/grid-2x2-plus.js
  var Grid2x2Plus = [
    [
      "path",
      {
        d: "M12 3v17a1 1 0 0 1-1 1H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6a1 1 0 0 1-1 1H3"
      }
    ],
    ["path", { d: "M16 19h6" }],
    ["path", { d: "M19 22v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/grid-2x2-x.js
  var Grid2x2X = [
    [
      "path",
      {
        d: "M12 3v17a1 1 0 0 1-1 1H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6a1 1 0 0 1-1 1H3"
      }
    ],
    ["path", { d: "m16 16 5 5" }],
    ["path", { d: "m16 21 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/grid-2x2.js
  var Grid2x2 = [
    ["path", { d: "M12 3v18" }],
    ["path", { d: "M3 12h18" }],
    ["rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/grid-3x3.js
  var Grid3x3 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "M15 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/grip-horizontal.js
  var GripHorizontal = [
    ["circle", { cx: "12", cy: "9", r: "1" }],
    ["circle", { cx: "19", cy: "9", r: "1" }],
    ["circle", { cx: "5", cy: "9", r: "1" }],
    ["circle", { cx: "12", cy: "15", r: "1" }],
    ["circle", { cx: "19", cy: "15", r: "1" }],
    ["circle", { cx: "5", cy: "15", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/grip-vertical.js
  var GripVertical = [
    ["circle", { cx: "9", cy: "12", r: "1" }],
    ["circle", { cx: "9", cy: "5", r: "1" }],
    ["circle", { cx: "9", cy: "19", r: "1" }],
    ["circle", { cx: "15", cy: "12", r: "1" }],
    ["circle", { cx: "15", cy: "5", r: "1" }],
    ["circle", { cx: "15", cy: "19", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/grip.js
  var Grip = [
    ["circle", { cx: "12", cy: "5", r: "1" }],
    ["circle", { cx: "19", cy: "5", r: "1" }],
    ["circle", { cx: "5", cy: "5", r: "1" }],
    ["circle", { cx: "12", cy: "12", r: "1" }],
    ["circle", { cx: "19", cy: "12", r: "1" }],
    ["circle", { cx: "5", cy: "12", r: "1" }],
    ["circle", { cx: "12", cy: "19", r: "1" }],
    ["circle", { cx: "19", cy: "19", r: "1" }],
    ["circle", { cx: "5", cy: "19", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/group.js
  var Group = [
    ["path", { d: "M3 7V5c0-1.1.9-2 2-2h2" }],
    ["path", { d: "M17 3h2c1.1 0 2 .9 2 2v2" }],
    ["path", { d: "M21 17v2c0 1.1-.9 2-2 2h-2" }],
    ["path", { d: "M7 21H5c-1.1 0-2-.9-2-2v-2" }],
    ["rect", { width: "7", height: "5", x: "7", y: "7", rx: "1" }],
    ["rect", { width: "7", height: "5", x: "10", y: "12", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/guitar.js
  var Guitar = [
    ["path", { d: "m11.9 12.1 4.514-4.514" }],
    [
      "path",
      {
        d: "M20.1 2.3a1 1 0 0 0-1.4 0l-1.114 1.114A2 2 0 0 0 17 4.828v1.344a2 2 0 0 1-.586 1.414A2 2 0 0 1 17.828 7h1.344a2 2 0 0 0 1.414-.586L21.7 5.3a1 1 0 0 0 0-1.4z"
      }
    ],
    ["path", { d: "m6 16 2 2" }],
    [
      "path",
      {
        d: "M8.23 9.85A3 3 0 0 1 11 8a5 5 0 0 1 5 5 3 3 0 0 1-1.85 2.77l-.92.38A2 2 0 0 0 12 18a4 4 0 0 1-4 4 6 6 0 0 1-6-6 4 4 0 0 1 4-4 2 2 0 0 0 1.85-1.23z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/ham.js
  var Ham = [
    ["path", { d: "M13.144 21.144A7.274 10.445 45 1 0 2.856 10.856" }],
    [
      "path",
      { d: "M13.144 21.144A7.274 4.365 45 0 0 2.856 10.856a7.274 4.365 45 0 0 10.288 10.288" }
    ],
    [
      "path",
      {
        d: "M16.565 10.435 18.6 8.4a2.501 2.501 0 1 0 1.65-4.65 2.5 2.5 0 1 0-4.66 1.66l-2.024 2.025"
      }
    ],
    ["path", { d: "m8.5 16.5-1-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/hamburger.js
  var Hamburger = [
    ["path", { d: "M12 16H4a2 2 0 1 1 0-4h16a2 2 0 1 1 0 4h-4.25" }],
    ["path", { d: "M5 12a2 2 0 0 1-2-2 9 7 0 0 1 18 0 2 2 0 0 1-2 2" }],
    ["path", { d: "M5 16a2 2 0 0 0-2 2 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 2 2 0 0 0-2-2q0 0 0 0" }],
    ["path", { d: "m6.67 12 6.13 4.6a2 2 0 0 0 2.8-.4l3.15-4.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/hammer.js
  var Hammer = [
    ["path", { d: "m15 12-8.373 8.373a1 1 0 1 1-3-3L12 9" }],
    ["path", { d: "m18 15 4-4" }],
    [
      "path",
      {
        d: "m21.5 11.5-1.914-1.914A2 2 0 0 1 19 8.172V7l-2.26-2.26a6 6 0 0 0-4.202-1.756L9 2.96l.92.82A6.18 6.18 0 0 1 12 8.4V10l2 2h1.172a2 2 0 0 1 1.414.586L18.5 14.5"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/hand-coins.js
  var HandCoins = [
    ["path", { d: "M11 15h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 17" }],
    [
      "path",
      {
        d: "m7 21 1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9"
      }
    ],
    ["path", { d: "m2 16 6 6" }],
    ["circle", { cx: "16", cy: "9", r: "2.9" }],
    ["circle", { cx: "6", cy: "5", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/hand-heart.js
  var HandHeart = [
    ["path", { d: "M11 14h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 16" }],
    [
      "path",
      {
        d: "m7 20 1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9"
      }
    ],
    ["path", { d: "m2 15 6 6" }],
    [
      "path",
      {
        d: "M19.5 8.5c.7-.7 1.5-1.6 1.5-2.7A2.73 2.73 0 0 0 16 4a2.78 2.78 0 0 0-5 1.8c0 1.2.8 2 1.5 2.8L16 12Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/hand-helping.js
  var HandHelping = [
    ["path", { d: "M11 12h2a2 2 0 1 0 0-4h-3c-.6 0-1.1.2-1.4.6L3 14" }],
    [
      "path",
      {
        d: "m7 18 1.6-1.4c.3-.4.8-.6 1.4-.6h4c1.1 0 2.1-.4 2.8-1.2l4.6-4.4a2 2 0 0 0-2.75-2.91l-4.2 3.9"
      }
    ],
    ["path", { d: "m2 13 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/hand-metal.js
  var HandMetal = [
    ["path", { d: "M18 12.5V10a2 2 0 0 0-2-2a2 2 0 0 0-2 2v1.4" }],
    ["path", { d: "M14 11V9a2 2 0 1 0-4 0v2" }],
    ["path", { d: "M10 10.5V5a2 2 0 1 0-4 0v9" }],
    [
      "path",
      {
        d: "m7 15-1.76-1.76a2 2 0 0 0-2.83 2.82l3.6 3.6C7.5 21.14 9.2 22 12 22h2a8 8 0 0 0 8-8V7a2 2 0 1 0-4 0v5"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/hand-platter.js
  var HandPlatter = [
    ["path", { d: "M12 3V2" }],
    [
      "path",
      {
        d: "m15.4 17.4 3.2-2.8a2 2 0 1 1 2.8 2.9l-3.6 3.3c-.7.8-1.7 1.2-2.8 1.2h-4c-1.1 0-2.1-.4-2.8-1.2l-1.302-1.464A1 1 0 0 0 6.151 19H5"
      }
    ],
    ["path", { d: "M2 14h12a2 2 0 0 1 0 4h-2" }],
    ["path", { d: "M4 10h16" }],
    ["path", { d: "M5 10a7 7 0 0 1 14 0" }],
    ["path", { d: "M5 14v6a1 1 0 0 1-1 1H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/hand.js
  var Hand = [
    ["path", { d: "M18 11V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2" }],
    ["path", { d: "M14 10V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v2" }],
    ["path", { d: "M10 10.5V6a2 2 0 0 0-2-2a2 2 0 0 0-2 2v8" }],
    [
      "path",
      {
        d: "M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/handshake.js
  var Handshake = [
    ["path", { d: "m11 17 2 2a1 1 0 1 0 3-3" }],
    [
      "path",
      {
        d: "m14 14 2.5 2.5a1 1 0 1 0 3-3l-3.88-3.88a3 3 0 0 0-4.24 0l-.88.88a1 1 0 1 1-3-3l2.81-2.81a5.79 5.79 0 0 1 7.06-.87l.47.28a2 2 0 0 0 1.42.25L21 4"
      }
    ],
    ["path", { d: "m21 3 1 11h-2" }],
    ["path", { d: "M3 3 2 14l6.5 6.5a1 1 0 1 0 3-3" }],
    ["path", { d: "M3 4h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/hard-drive-download.js
  var HardDriveDownload = [
    ["path", { d: "M12 2v8" }],
    ["path", { d: "m16 6-4 4-4-4" }],
    ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "M10 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/hard-drive-upload.js
  var HardDriveUpload = [
    ["path", { d: "m16 6-4-4-4 4" }],
    ["path", { d: "M12 2v8" }],
    ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "M10 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/hard-drive.js
  var HardDrive = [
    ["line", { x1: "22", x2: "2", y1: "12", y2: "12" }],
    [
      "path",
      {
        d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"
      }
    ],
    ["line", { x1: "6", x2: "6.01", y1: "16", y2: "16" }],
    ["line", { x1: "10", x2: "10.01", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/hard-hat.js
  var HardHat = [
    ["path", { d: "M10 10V5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v5" }],
    ["path", { d: "M14 6a6 6 0 0 1 6 6v3" }],
    ["path", { d: "M4 15v-3a6 6 0 0 1 6-6" }],
    ["rect", { x: "2", y: "15", width: "20", height: "4", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/hash.js
  var Hash = [
    ["line", { x1: "4", x2: "20", y1: "9", y2: "9" }],
    ["line", { x1: "4", x2: "20", y1: "15", y2: "15" }],
    ["line", { x1: "10", x2: "8", y1: "3", y2: "21" }],
    ["line", { x1: "16", x2: "14", y1: "3", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/haze.js
  var Haze = [
    ["path", { d: "m5.2 6.2 1.4 1.4" }],
    ["path", { d: "M2 13h2" }],
    ["path", { d: "M20 13h2" }],
    ["path", { d: "m17.4 7.6 1.4-1.4" }],
    ["path", { d: "M22 17H2" }],
    ["path", { d: "M22 21H2" }],
    ["path", { d: "M16 13a4 4 0 0 0-8 0" }],
    ["path", { d: "M12 5V2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/hdmi-port.js
  var HdmiPort = [
    [
      "path",
      { d: "M22 9a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h1l2 2h12l2-2h1a1 1 0 0 0 1-1Z" }
    ],
    ["path", { d: "M7.5 12h9" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-1.js
  var Heading1 = [
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }],
    ["path", { d: "M12 18V6" }],
    ["path", { d: "m17 12 3-2v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-2.js
  var Heading2 = [
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }],
    ["path", { d: "M12 18V6" }],
    ["path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-3.js
  var Heading3 = [
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }],
    ["path", { d: "M12 18V6" }],
    ["path", { d: "M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2" }],
    ["path", { d: "M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-5.js
  var Heading5 = [
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }],
    ["path", { d: "M12 18V6" }],
    ["path", { d: "M17 13v-3h4" }],
    ["path", { d: "M17 17.7c.4.2.8.3 1.3.3 1.5 0 2.7-1.1 2.7-2.5S19.8 13 18.3 13H17" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-6.js
  var Heading6 = [
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }],
    ["path", { d: "M12 18V6" }],
    ["circle", { cx: "19", cy: "16", r: "2" }],
    ["path", { d: "M20 10c-2 2-3 3.5-3 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading-4.js
  var Heading4 = [
    ["path", { d: "M12 18V6" }],
    ["path", { d: "M17 10v3a1 1 0 0 0 1 1h3" }],
    ["path", { d: "M21 10v8" }],
    ["path", { d: "M4 12h8" }],
    ["path", { d: "M4 18V6" }]
  ];

  // node_modules/lucide/dist/esm/icons/heading.js
  var Heading7 = [
    ["path", { d: "M6 12h12" }],
    ["path", { d: "M6 20V4" }],
    ["path", { d: "M18 20V4" }]
  ];

  // node_modules/lucide/dist/esm/icons/headphone-off.js
  var HeadphoneOff = [
    ["path", { d: "M21 14h-1.343" }],
    ["path", { d: "M9.128 3.47A9 9 0 0 1 21 12v3.343" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M20.414 20.414A2 2 0 0 1 19 21h-1a2 2 0 0 1-2-2v-3" }],
    ["path", { d: "M3 14h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-7a9 9 0 0 1 2.636-6.364" }]
  ];

  // node_modules/lucide/dist/esm/icons/headphones.js
  var Headphones = [
    [
      "path",
      {
        d: "M3 14h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-7a9 9 0 0 1 18 0v7a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/headset.js
  var Headset = [
    [
      "path",
      {
        d: "M3 11h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-5Zm0 0a9 9 0 1 1 18 0m0 0v5a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3Z"
      }
    ],
    ["path", { d: "M21 16v2a4 4 0 0 1-4 4h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart-crack.js
  var HeartCrack = [
    [
      "path",
      {
        d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"
      }
    ],
    ["path", { d: "m12 13-1-1 2-2-3-3 2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart-handshake.js
  var HeartHandshake = [
    [
      "path",
      {
        d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"
      }
    ],
    [
      "path",
      {
        d: "M12 5 9.04 7.96a2.17 2.17 0 0 0 0 3.08c.82.82 2.13.85 3 .07l2.07-1.9a2.82 2.82 0 0 1 3.79 0l2.96 2.66"
      }
    ],
    ["path", { d: "m18 15-2-2" }],
    ["path", { d: "m15 18-2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart-off.js
  var HeartOff = [
    ["line", { x1: "2", y1: "2", x2: "22", y2: "22" }],
    ["path", { d: "M16.5 16.5 12 21l-7-7c-1.5-1.45-3-3.2-3-5.5a5.5 5.5 0 0 1 2.14-4.35" }],
    [
      "path",
      {
        d: "M8.76 3.1c1.15.22 2.13.78 3.24 1.9 1.5-1.5 2.74-2 4.5-2A5.5 5.5 0 0 1 22 8.5c0 2.12-1.3 3.78-2.67 5.17"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/heart-minus.js
  var HeartMinus = [
    [
      "path",
      {
        d: "M13.5 19.5 12 21l-7-7c-1.5-1.45-3-3.2-3-5.5A5.5 5.5 0 0 1 7.5 3c1.76 0 3 .5 4.5 2 1.5-1.5 2.74-2 4.5-2a5.5 5.5 0 0 1 5.402 6.5"
      }
    ],
    ["path", { d: "M15 15h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart-plus.js
  var HeartPlus = [
    [
      "path",
      {
        d: "M13.5 19.5 12 21l-7-7c-1.5-1.45-3-3.2-3-5.5A5.5 5.5 0 0 1 7.5 3c1.76 0 3 .5 4.5 2 1.5-1.5 2.74-2 4.5-2a5.5 5.5 0 0 1 5.402 6.5"
      }
    ],
    ["path", { d: "M15 15h6" }],
    ["path", { d: "M18 12v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart-pulse.js
  var HeartPulse = [
    [
      "path",
      {
        d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"
      }
    ],
    ["path", { d: "M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27" }]
  ];

  // node_modules/lucide/dist/esm/icons/heart.js
  var Heart = [
    [
      "path",
      {
        d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/heater.js
  var Heater = [
    ["path", { d: "M11 8c2-3-2-3 0-6" }],
    ["path", { d: "M15.5 8c2-3-2-3 0-6" }],
    ["path", { d: "M6 10h.01" }],
    ["path", { d: "M6 14h.01" }],
    ["path", { d: "M10 16v-4" }],
    ["path", { d: "M14 16v-4" }],
    ["path", { d: "M18 16v-4" }],
    ["path", { d: "M20 6a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3" }],
    ["path", { d: "M5 20v2" }],
    ["path", { d: "M19 20v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/hexagon.js
  var Hexagon = [
    [
      "path",
      {
        d: "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/highlighter.js
  var Highlighter = [
    ["path", { d: "m9 11-6 6v3h9l3-3" }],
    ["path", { d: "m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/hop-off.js
  var HopOff = [
    ["path", { d: "M10.82 16.12c1.69.6 3.91.79 5.18.85.28.01.53-.09.7-.27" }],
    [
      "path",
      { d: "M11.14 20.57c.52.24 2.44 1.12 4.08 1.37.46.06.86-.25.9-.71.12-1.52-.3-3.43-.5-4.28" }
    ],
    ["path", { d: "M16.13 21.05c1.65.63 3.68.84 4.87.91a.9.9 0 0 0 .7-.26" }],
    [
      "path",
      { d: "M17.99 5.52a20.83 20.83 0 0 1 3.15 4.5.8.8 0 0 1-.68 1.13c-1.17.1-2.5.02-3.9-.25" }
    ],
    ["path", { d: "M20.57 11.14c.24.52 1.12 2.44 1.37 4.08.04.3-.08.59-.31.75" }],
    [
      "path",
      {
        d: "M4.93 4.93a10 10 0 0 0-.67 13.4c.35.43.96.4 1.17-.12.69-1.71 1.07-5.07 1.07-6.71 1.34.45 3.1.9 4.88.62a.85.85 0 0 0 .48-.24"
      }
    ],
    [
      "path",
      { d: "M5.52 17.99c1.05.95 2.91 2.42 4.5 3.15a.8.8 0 0 0 1.13-.68c.2-2.34-.33-5.3-1.57-8.28" }
    ],
    ["path", { d: "M8.35 2.68a10 10 0 0 1 9.98 1.58c.43.35.4.96-.12 1.17-1.5.6-4.3.98-6.07 1.05" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/history.js
  var History3 = [
    ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }],
    ["path", { d: "M3 3v5h5" }],
    ["path", { d: "M12 7v5l4 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/hop.js
  var Hop = [
    [
      "path",
      { d: "M10.82 16.12c1.69.6 3.91.79 5.18.85.55.03 1-.42.97-.97-.06-1.27-.26-3.5-.85-5.18" }
    ],
    [
      "path",
      {
        d: "M11.5 6.5c1.64 0 5-.38 6.71-1.07.52-.2.55-.82.12-1.17A10 10 0 0 0 4.26 18.33c.35.43.96.4 1.17-.12.69-1.71 1.07-5.07 1.07-6.71 1.34.45 3.1.9 4.88.62a.88.88 0 0 0 .73-.74c.3-2.14-.15-3.5-.61-4.88"
      }
    ],
    [
      "path",
      { d: "M15.62 16.95c.2.85.62 2.76.5 4.28a.77.77 0 0 1-.9.7 16.64 16.64 0 0 1-4.08-1.36" }
    ],
    [
      "path",
      { d: "M16.13 21.05c1.65.63 3.68.84 4.87.91a.9.9 0 0 0 .96-.96 17.68 17.68 0 0 0-.9-4.87" }
    ],
    [
      "path",
      { d: "M16.94 15.62c.86.2 2.77.62 4.29.5a.77.77 0 0 0 .7-.9 16.64 16.64 0 0 0-1.36-4.08" }
    ],
    [
      "path",
      { d: "M17.99 5.52a20.82 20.82 0 0 1 3.15 4.5.8.8 0 0 1-.68 1.13c-2.33.2-5.3-.32-8.27-1.57" }
    ],
    ["path", { d: "M4.93 4.93 3 3a.7.7 0 0 1 0-1" }],
    [
      "path",
      {
        d: "M9.58 12.18c1.24 2.98 1.77 5.95 1.57 8.28a.8.8 0 0 1-1.13.68 20.82 20.82 0 0 1-4.5-3.15"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/hospital.js
  var Hospital = [
    ["path", { d: "M12 6v4" }],
    ["path", { d: "M14 14h-4" }],
    ["path", { d: "M14 18h-4" }],
    ["path", { d: "M14 8h-4" }],
    ["path", { d: "M18 12h2a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-9a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M18 22V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/hotel.js
  var Hotel = [
    ["path", { d: "M10 22v-6.57" }],
    ["path", { d: "M12 11h.01" }],
    ["path", { d: "M12 7h.01" }],
    ["path", { d: "M14 15.43V22" }],
    ["path", { d: "M15 16a5 5 0 0 0-6 0" }],
    ["path", { d: "M16 11h.01" }],
    ["path", { d: "M16 7h.01" }],
    ["path", { d: "M8 11h.01" }],
    ["path", { d: "M8 7h.01" }],
    ["rect", { x: "4", y: "2", width: "16", height: "20", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/hourglass.js
  var Hourglass = [
    ["path", { d: "M5 22h14" }],
    ["path", { d: "M5 2h14" }],
    ["path", { d: "M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22" }],
    ["path", { d: "M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/house-plug.js
  var HousePlug = [
    ["path", { d: "M10 12V8.964" }],
    ["path", { d: "M14 12V8.964" }],
    ["path", { d: "M15 12a1 1 0 0 1 1 1v2a2 2 0 0 1-2 2h-4a2 2 0 0 1-2-2v-2a1 1 0 0 1 1-1z" }],
    [
      "path",
      {
        d: "M8.5 21H5a2 2 0 0 1-2-2v-9a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2v-2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/house-wifi.js
  var HouseWifi = [
    ["path", { d: "M9.5 13.866a4 4 0 0 1 5 .01" }],
    ["path", { d: "M12 17h.01" }],
    [
      "path",
      {
        d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"
      }
    ],
    ["path", { d: "M7 10.754a8 8 0 0 1 10 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/house-plus.js
  var HousePlus = [
    [
      "path",
      {
        d: "M13.22 2.416a2 2 0 0 0-2.511.057l-7 5.999A2 2 0 0 0 3 10v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7.354"
      }
    ],
    ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" }],
    ["path", { d: "M15 6h6" }],
    ["path", { d: "M18 3v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/house.js
  var House = [
    ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" }],
    [
      "path",
      {
        d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/ice-cream-bowl.js
  var IceCreamBowl = [
    [
      "path",
      { d: "M12 17c5 0 8-2.69 8-6H4c0 3.31 3 6 8 6m-4 4h8m-4-3v3M5.14 11a3.5 3.5 0 1 1 6.71 0" }
    ],
    ["path", { d: "M12.14 11a3.5 3.5 0 1 1 6.71 0" }],
    ["path", { d: "M15.5 6.5a3.5 3.5 0 1 0-7 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/ice-cream-cone.js
  var IceCreamCone = [
    ["path", { d: "m7 11 4.08 10.35a1 1 0 0 0 1.84 0L17 11" }],
    ["path", { d: "M17 7A5 5 0 0 0 7 7" }],
    ["path", { d: "M17 7a2 2 0 0 1 0 4H7a2 2 0 0 1 0-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/id-card.js
  var IdCard = [
    ["path", { d: "M16 10h2" }],
    ["path", { d: "M16 14h2" }],
    ["path", { d: "M6.17 15a3 3 0 0 1 5.66 0" }],
    ["circle", { cx: "9", cy: "11", r: "2" }],
    ["rect", { x: "2", y: "5", width: "20", height: "14", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-down.js
  var ImageDown = [
    [
      "path",
      {
        d: "M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L6 21"
      }
    ],
    ["path", { d: "m14 19 3 3v-5.5" }],
    ["path", { d: "m17 22 3-3" }],
    ["circle", { cx: "9", cy: "9", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-minus.js
  var ImageMinus = [
    ["path", { d: "M21 9v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7" }],
    ["line", { x1: "16", x2: "22", y1: "5", y2: "5" }],
    ["circle", { cx: "9", cy: "9", r: "2" }],
    ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-off.js
  var ImageOff = [
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }],
    ["path", { d: "M10.41 10.41a2 2 0 1 1-2.83-2.83" }],
    ["line", { x1: "13.5", x2: "6", y1: "13.5", y2: "21" }],
    ["line", { x1: "18", x2: "21", y1: "12", y2: "15" }],
    ["path", { d: "M3.59 3.59A1.99 1.99 0 0 0 3 5v14a2 2 0 0 0 2 2h14c.55 0 1.052-.22 1.41-.59" }],
    ["path", { d: "M21 15V5a2 2 0 0 0-2-2H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-play.js
  var ImagePlay = [
    ["path", { d: "m11 16-5 5" }],
    ["path", { d: "M11 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6.5" }],
    [
      "path",
      {
        d: "M15.765 22a.5.5 0 0 1-.765-.424V13.38a.5.5 0 0 1 .765-.424l5.878 3.674a1 1 0 0 1 0 1.696z"
      }
    ],
    ["circle", { cx: "9", cy: "9", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-plus.js
  var ImagePlus = [
    ["path", { d: "M16 5h6" }],
    ["path", { d: "M19 2v6" }],
    ["path", { d: "M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5" }],
    ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }],
    ["circle", { cx: "9", cy: "9", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-up.js
  var ImageUp = [
    [
      "path",
      {
        d: "M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L6 21"
      }
    ],
    ["path", { d: "m14 19.5 3-3 3 3" }],
    ["path", { d: "M17 22v-5.5" }],
    ["circle", { cx: "9", cy: "9", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/image-upscale.js
  var ImageUpscale = [
    ["path", { d: "M16 3h5v5" }],
    ["path", { d: "M17 21h2a2 2 0 0 0 2-2" }],
    ["path", { d: "M21 12v3" }],
    ["path", { d: "m21 3-5 5" }],
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2" }],
    ["path", { d: "m5 21 4.144-4.144a1.21 1.21 0 0 1 1.712 0L13 19" }],
    ["path", { d: "M9 3h3" }],
    ["rect", { x: "3", y: "11", width: "10", height: "10", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/image.js
  var Image = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["circle", { cx: "9", cy: "9", r: "2" }],
    ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }]
  ];

  // node_modules/lucide/dist/esm/icons/images.js
  var Images = [
    ["path", { d: "M18 22H4a2 2 0 0 1-2-2V6" }],
    ["path", { d: "m22 13-1.296-1.296a2.41 2.41 0 0 0-3.408 0L11 18" }],
    ["circle", { cx: "12", cy: "8", r: "2" }],
    ["rect", { width: "16", height: "16", x: "6", y: "2", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/import.js
  var Import = [
    ["path", { d: "M12 3v12" }],
    ["path", { d: "m8 11 4 4 4-4" }],
    ["path", { d: "M8 5H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/inbox.js
  var Inbox = [
    ["polyline", { points: "22 12 16 12 14 15 10 15 8 12 2 12" }],
    [
      "path",
      {
        d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/indent-decrease.js
  var IndentDecrease = [
    ["path", { d: "M21 12H11" }],
    ["path", { d: "M21 18H11" }],
    ["path", { d: "M21 6H11" }],
    ["path", { d: "m7 8-4 4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/indent-increase.js
  var IndentIncrease = [
    ["path", { d: "M21 12H11" }],
    ["path", { d: "M21 18H11" }],
    ["path", { d: "M21 6H11" }],
    ["path", { d: "m3 8 4 4-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/indian-rupee.js
  var IndianRupee = [
    ["path", { d: "M6 3h12" }],
    ["path", { d: "M6 8h12" }],
    ["path", { d: "m6 13 8.5 8" }],
    ["path", { d: "M6 13h3" }],
    ["path", { d: "M9 13c6.667 0 6.667-10 0-10" }]
  ];

  // node_modules/lucide/dist/esm/icons/infinity.js
  var Infinity2 = [
    ["path", { d: "M6 16c5 0 7-8 12-8a4 4 0 0 1 0 8c-5 0-7-8-12-8a4 4 0 1 0 0 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/info.js
  var Info = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M12 16v-4" }],
    ["path", { d: "M12 8h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/inspection-panel.js
  var InspectionPanel = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 7h.01" }],
    ["path", { d: "M17 7h.01" }],
    ["path", { d: "M7 17h.01" }],
    ["path", { d: "M17 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/instagram.js
  var Instagram = [
    ["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5" }],
    ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" }],
    ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/italic.js
  var Italic2 = [
    ["line", { x1: "19", x2: "10", y1: "4", y2: "4" }],
    ["line", { x1: "14", x2: "5", y1: "20", y2: "20" }],
    ["line", { x1: "15", x2: "9", y1: "4", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/iteration-ccw.js
  var IterationCcw = [
    ["path", { d: "M20 10c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8h8" }],
    ["polyline", { points: "16 14 20 18 16 22" }]
  ];

  // node_modules/lucide/dist/esm/icons/iteration-cw.js
  var IterationCw = [
    ["path", { d: "M4 10c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8H4" }],
    ["polyline", { points: "8 22 4 18 8 14" }]
  ];

  // node_modules/lucide/dist/esm/icons/japanese-yen.js
  var JapaneseYen = [
    ["path", { d: "M12 9.5V21m0-11.5L6 3m6 6.5L18 3" }],
    ["path", { d: "M6 15h12" }],
    ["path", { d: "M6 11h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/joystick.js
  var Joystick = [
    ["path", { d: "M21 17a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-2Z" }],
    ["path", { d: "M6 15v-2" }],
    ["path", { d: "M12 15V9" }],
    ["circle", { cx: "12", cy: "6", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/kanban.js
  var Kanban = [
    ["path", { d: "M6 5v11" }],
    ["path", { d: "M12 5v6" }],
    ["path", { d: "M18 5v14" }]
  ];

  // node_modules/lucide/dist/esm/icons/key-round.js
  var KeyRound = [
    [
      "path",
      {
        d: "M2.586 17.414A2 2 0 0 0 2 18.828V21a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h1a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h.172a2 2 0 0 0 1.414-.586l.814-.814a6.5 6.5 0 1 0-4-4z"
      }
    ],
    ["circle", { cx: "16.5", cy: "7.5", r: ".5", fill: "currentColor" }]
  ];

  // node_modules/lucide/dist/esm/icons/key-square.js
  var KeySquare = [
    [
      "path",
      {
        d: "M12.4 2.7a2.5 2.5 0 0 1 3.4 0l5.5 5.5a2.5 2.5 0 0 1 0 3.4l-3.7 3.7a2.5 2.5 0 0 1-3.4 0L8.7 9.8a2.5 2.5 0 0 1 0-3.4z"
      }
    ],
    ["path", { d: "m14 7 3 3" }],
    [
      "path",
      {
        d: "m9.4 10.6-6.814 6.814A2 2 0 0 0 2 18.828V21a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h1a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h.172a2 2 0 0 0 1.414-.586l.814-.814"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/key.js
  var Key = [
    ["path", { d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4" }],
    ["path", { d: "m21 2-9.6 9.6" }],
    ["circle", { cx: "7.5", cy: "15.5", r: "5.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/keyboard-music.js
  var KeyboardMusic = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M6 8h4" }],
    ["path", { d: "M14 8h.01" }],
    ["path", { d: "M18 8h.01" }],
    ["path", { d: "M2 12h20" }],
    ["path", { d: "M6 12v4" }],
    ["path", { d: "M10 12v4" }],
    ["path", { d: "M14 12v4" }],
    ["path", { d: "M18 12v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/keyboard.js
  var Keyboard = [
    ["path", { d: "M10 8h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M14 8h.01" }],
    ["path", { d: "M16 12h.01" }],
    ["path", { d: "M18 8h.01" }],
    ["path", { d: "M6 8h.01" }],
    ["path", { d: "M7 16h10" }],
    ["path", { d: "M8 12h.01" }],
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/keyboard-off.js
  var KeyboardOff = [
    ["path", { d: "M 20 4 A2 2 0 0 1 22 6" }],
    ["path", { d: "M 22 6 L 22 16.41" }],
    ["path", { d: "M 7 16 L 16 16" }],
    ["path", { d: "M 9.69 4 L 20 4" }],
    ["path", { d: "M14 8h.01" }],
    ["path", { d: "M18 8h.01" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M20 20H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }],
    ["path", { d: "M6 8h.01" }],
    ["path", { d: "M8 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/lamp-ceiling.js
  var LampCeiling = [
    ["path", { d: "M12 2v5" }],
    ["path", { d: "M14.829 15.998a3 3 0 1 1-5.658 0" }],
    [
      "path",
      {
        d: "M20.92 14.606A1 1 0 0 1 20 16H4a1 1 0 0 1-.92-1.394l3-7A1 1 0 0 1 7 7h10a1 1 0 0 1 .92.606z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/lamp-floor.js
  var LampFloor = [
    ["path", { d: "M12 10v12" }],
    [
      "path",
      {
        d: "M17.929 7.629A1 1 0 0 1 17 9H7a1 1 0 0 1-.928-1.371l2-5A1 1 0 0 1 9 2h6a1 1 0 0 1 .928.629z"
      }
    ],
    ["path", { d: "M9 22h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/lamp-desk.js
  var LampDesk = [
    [
      "path",
      {
        d: "M10.293 2.293a1 1 0 0 1 1.414 0l2.5 2.5 5.994 1.227a1 1 0 0 1 .506 1.687l-7 7a1 1 0 0 1-1.687-.506l-1.227-5.994-2.5-2.5a1 1 0 0 1 0-1.414z"
      }
    ],
    ["path", { d: "m14.207 4.793-3.414 3.414" }],
    ["path", { d: "M3 20a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z" }],
    ["path", { d: "m9.086 6.5-4.793 4.793a1 1 0 0 0-.18 1.17L7 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/lamp-wall-down.js
  var LampWallDown = [
    [
      "path",
      {
        d: "M19.929 18.629A1 1 0 0 1 19 20H9a1 1 0 0 1-.928-1.371l2-5A1 1 0 0 1 11 13h6a1 1 0 0 1 .928.629z"
      }
    ],
    ["path", { d: "M6 3a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z" }],
    ["path", { d: "M8 6h4a2 2 0 0 1 2 2v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/lamp-wall-up.js
  var LampWallUp = [
    [
      "path",
      {
        d: "M19.929 9.629A1 1 0 0 1 19 11H9a1 1 0 0 1-.928-1.371l2-5A1 1 0 0 1 11 4h6a1 1 0 0 1 .928.629z"
      }
    ],
    ["path", { d: "M6 15a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1z" }],
    ["path", { d: "M8 18h4a2 2 0 0 0 2-2v-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/land-plot.js
  var LandPlot = [
    ["path", { d: "m12 8 6-3-6-3v10" }],
    [
      "path",
      {
        d: "m8 11.99-5.5 3.14a1 1 0 0 0 0 1.74l8.5 4.86a2 2 0 0 0 2 0l8.5-4.86a1 1 0 0 0 0-1.74L16 12"
      }
    ],
    ["path", { d: "m6.49 12.85 11.02 6.3" }],
    ["path", { d: "M17.51 12.85 6.5 19.15" }]
  ];

  // node_modules/lucide/dist/esm/icons/lamp.js
  var Lamp = [
    ["path", { d: "M12 12v6" }],
    [
      "path",
      {
        d: "M4.077 10.615A1 1 0 0 0 5 12h14a1 1 0 0 0 .923-1.385l-3.077-7.384A2 2 0 0 0 15 2H9a2 2 0 0 0-1.846 1.23Z"
      }
    ],
    ["path", { d: "M8 20a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1z" }]
  ];

  // node_modules/lucide/dist/esm/icons/landmark.js
  var Landmark = [
    ["line", { x1: "3", x2: "21", y1: "22", y2: "22" }],
    ["line", { x1: "6", x2: "6", y1: "18", y2: "11" }],
    ["line", { x1: "10", x2: "10", y1: "18", y2: "11" }],
    ["line", { x1: "14", x2: "14", y1: "18", y2: "11" }],
    ["line", { x1: "18", x2: "18", y1: "18", y2: "11" }],
    ["polygon", { points: "12 2 20 7 4 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/languages.js
  var Languages = [
    ["path", { d: "m5 8 6 6" }],
    ["path", { d: "m4 14 6-6 2-3" }],
    ["path", { d: "M2 5h12" }],
    ["path", { d: "M7 2h1" }],
    ["path", { d: "m22 22-5-10-5 10" }],
    ["path", { d: "M14 18h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/laptop-minimal-check.js
  var LaptopMinimalCheck = [
    ["path", { d: "M2 20h20" }],
    ["path", { d: "m9 10 2 2 4-4" }],
    ["rect", { x: "3", y: "4", width: "18", height: "12", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/laptop-minimal.js
  var LaptopMinimal = [
    ["rect", { width: "18", height: "12", x: "3", y: "4", rx: "2", ry: "2" }],
    ["line", { x1: "2", x2: "22", y1: "20", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/laptop.js
  var Laptop = [
    [
      "path",
      {
        d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/lasso-select.js
  var LassoSelect = [
    ["path", { d: "M7 22a5 5 0 0 1-2-4" }],
    ["path", { d: "M7 16.93c.96.43 1.96.74 2.99.91" }],
    [
      "path",
      { d: "M3.34 14A6.8 6.8 0 0 1 2 10c0-4.42 4.48-8 10-8s10 3.58 10 8a7.19 7.19 0 0 1-.33 2" }
    ],
    ["path", { d: "M5 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" }],
    [
      "path",
      {
        d: "M14.33 22h-.09a.35.35 0 0 1-.24-.32v-10a.34.34 0 0 1 .33-.34c.08 0 .15.03.21.08l7.34 6a.33.33 0 0 1-.21.59h-4.49l-2.57 3.85a.35.35 0 0 1-.28.14z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/lasso.js
  var Lasso = [
    ["path", { d: "M7 22a5 5 0 0 1-2-4" }],
    [
      "path",
      { d: "M3.3 14A6.8 6.8 0 0 1 2 10c0-4.4 4.5-8 10-8s10 3.6 10 8-4.5 8-10 8a12 12 0 0 1-5-1" }
    ],
    ["path", { d: "M5 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" }]
  ];

  // node_modules/lucide/dist/esm/icons/laugh.js
  var Laugh = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M18 13a6 6 0 0 1-6 5 6 6 0 0 1-6-5h12Z" }],
    ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9" }],
    ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/layers-2.js
  var Layers2 = [
    [
      "path",
      {
        d: "M13 13.74a2 2 0 0 1-2 0L2.5 8.87a1 1 0 0 1 0-1.74L11 2.26a2 2 0 0 1 2 0l8.5 4.87a1 1 0 0 1 0 1.74z"
      }
    ],
    [
      "path",
      {
        d: "m20 14.285 1.5.845a1 1 0 0 1 0 1.74L13 21.74a2 2 0 0 1-2 0l-8.5-4.87a1 1 0 0 1 0-1.74l1.5-.845"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/layers.js
  var Layers = [
    [
      "path",
      {
        d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z"
      }
    ],
    ["path", { d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12" }],
    ["path", { d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-dashboard.js
  var LayoutDashboard = [
    ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1" }],
    ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-grid.js
  var LayoutGrid = [
    ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-list.js
  var LayoutList = [
    ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1" }],
    ["path", { d: "M14 4h7" }],
    ["path", { d: "M14 9h7" }],
    ["path", { d: "M14 15h7" }],
    ["path", { d: "M14 20h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-panel-left.js
  var LayoutPanelLeft = [
    ["rect", { width: "7", height: "18", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-panel-top.js
  var LayoutPanelTop = [
    ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1" }],
    ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/layout-template.js
  var LayoutTemplate = [
    ["rect", { width: "18", height: "7", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "9", height: "7", x: "3", y: "14", rx: "1" }],
    ["rect", { width: "5", height: "7", x: "16", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/leaf.js
  var Leaf2 = [
    [
      "path",
      { d: "M11 20A7 7 0 0 1 9.8 6.1C15.5 5 17 4.48 19 2c1 2 2 4.18 2 8 0 5.5-4.78 10-10 10Z" }
    ],
    ["path", { d: "M2 21c0-3 1.85-5.36 5.08-6C9.5 14.52 12 13 13 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/leafy-green.js
  var LeafyGreen = [
    [
      "path",
      {
        d: "M2 22c1.25-.987 2.27-1.975 3.9-2.2a5.56 5.56 0 0 1 3.8 1.5 4 4 0 0 0 6.187-2.353 3.5 3.5 0 0 0 3.69-5.116A3.5 3.5 0 0 0 20.95 8 3.5 3.5 0 1 0 16 3.05a3.5 3.5 0 0 0-5.831 1.373 3.5 3.5 0 0 0-5.116 3.69 4 4 0 0 0-2.348 6.155C3.499 15.42 4.409 16.712 4.2 18.1 3.926 19.743 3.014 20.732 2 22"
      }
    ],
    ["path", { d: "M2 22 17 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/lectern.js
  var Lectern = [
    [
      "path",
      {
        d: "M16 12h3a2 2 0 0 0 1.902-1.38l1.056-3.333A1 1 0 0 0 21 6H3a1 1 0 0 0-.958 1.287l1.056 3.334A2 2 0 0 0 5 12h3"
      }
    ],
    ["path", { d: "M18 6V3a1 1 0 0 0-1-1h-3" }],
    ["rect", { width: "8", height: "12", x: "8", y: "10", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/letter-text.js
  var LetterText = [
    ["path", { d: "M15 12h6" }],
    ["path", { d: "M15 6h6" }],
    ["path", { d: "m3 13 3.553-7.724a.5.5 0 0 1 .894 0L11 13" }],
    ["path", { d: "M3 18h18" }],
    ["path", { d: "M3.92 11h6.16" }]
  ];

  // node_modules/lucide/dist/esm/icons/library-big.js
  var LibraryBig = [
    ["rect", { width: "8", height: "18", x: "3", y: "3", rx: "1" }],
    ["path", { d: "M7 3v18" }],
    [
      "path",
      {
        d: "M20.4 18.9c.2.5-.1 1.1-.6 1.3l-1.9.7c-.5.2-1.1-.1-1.3-.6L11.1 5.1c-.2-.5.1-1.1.6-1.3l1.9-.7c.5-.2 1.1.1 1.3.6Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/library.js
  var Library = [
    ["path", { d: "m16 6 4 14" }],
    ["path", { d: "M12 6v14" }],
    ["path", { d: "M8 8v12" }],
    ["path", { d: "M4 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/life-buoy.js
  var LifeBuoy = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "m4.93 4.93 4.24 4.24" }],
    ["path", { d: "m14.83 9.17 4.24-4.24" }],
    ["path", { d: "m14.83 14.83 4.24 4.24" }],
    ["path", { d: "m9.17 14.83-4.24 4.24" }],
    ["circle", { cx: "12", cy: "12", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/ligature.js
  var Ligature = [
    ["path", { d: "M8 20V8c0-2.2 1.8-4 4-4 1.5 0 2.8.8 3.5 2" }],
    ["path", { d: "M6 12h4" }],
    ["path", { d: "M14 12h2v8" }],
    ["path", { d: "M6 20h4" }],
    ["path", { d: "M14 20h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/lightbulb-off.js
  var LightbulbOff = [
    ["path", { d: "M16.8 11.2c.8-.9 1.2-2 1.2-3.2a6 6 0 0 0-9.3-5" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M6.3 6.3a4.67 4.67 0 0 0 1.2 5.2c.7.7 1.3 1.5 1.5 2.5" }],
    ["path", { d: "M9 18h6" }],
    ["path", { d: "M10 22h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/lightbulb.js
  var Lightbulb = [
    [
      "path",
      {
        d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"
      }
    ],
    ["path", { d: "M9 18h6" }],
    ["path", { d: "M10 22h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/link-2-off.js
  var Link2Off = [
    ["path", { d: "M9 17H7A5 5 0 0 1 7 7" }],
    ["path", { d: "M15 7h2a5 5 0 0 1 4 8" }],
    ["line", { x1: "8", x2: "12", y1: "12", y2: "12" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/link-2.js
  var Link2 = [
    ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2" }],
    ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2" }],
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/link.js
  var Link = [
    ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }],
    ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }]
  ];

  // node_modules/lucide/dist/esm/icons/linkedin.js
  var Linkedin = [
    ["path", { d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z" }],
    ["rect", { width: "4", height: "12", x: "2", y: "9" }],
    ["circle", { cx: "4", cy: "4", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-check.js
  var ListCheck = [
    ["path", { d: "M11 18H3" }],
    ["path", { d: "m15 18 2 2 4-4" }],
    ["path", { d: "M16 12H3" }],
    ["path", { d: "M16 6H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-checks.js
  var ListChecks = [
    ["path", { d: "m3 17 2 2 4-4" }],
    ["path", { d: "m3 7 2 2 4-4" }],
    ["path", { d: "M13 6h8" }],
    ["path", { d: "M13 12h8" }],
    ["path", { d: "M13 18h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-collapse.js
  var ListCollapse = [
    ["path", { d: "m3 10 2.5-2.5L3 5" }],
    ["path", { d: "m3 19 2.5-2.5L3 14" }],
    ["path", { d: "M10 6h11" }],
    ["path", { d: "M10 12h11" }],
    ["path", { d: "M10 18h11" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-end.js
  var ListEnd = [
    ["path", { d: "M16 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M10 18H3" }],
    ["path", { d: "M21 6v10a2 2 0 0 1-2 2h-5" }],
    ["path", { d: "m16 16-2 2 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-filter-plus.js
  var ListFilterPlus = [
    ["path", { d: "M10 18h4" }],
    ["path", { d: "M11 6H3" }],
    ["path", { d: "M15 6h6" }],
    ["path", { d: "M18 9V3" }],
    ["path", { d: "M7 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-filter.js
  var ListFilter = [
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M7 12h10" }],
    ["path", { d: "M10 18h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-minus.js
  var ListMinus = [
    ["path", { d: "M11 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M16 18H3" }],
    ["path", { d: "M21 12h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-music.js
  var ListMusic = [
    ["path", { d: "M21 15V6" }],
    ["path", { d: "M18.5 18a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" }],
    ["path", { d: "M12 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M12 18H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-plus.js
  var ListPlus = [
    ["path", { d: "M11 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M16 18H3" }],
    ["path", { d: "M18 9v6" }],
    ["path", { d: "M21 12h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-ordered.js
  var ListOrdered = [
    ["path", { d: "M10 12h11" }],
    ["path", { d: "M10 18h11" }],
    ["path", { d: "M10 6h11" }],
    ["path", { d: "M4 10h2" }],
    ["path", { d: "M4 6h1v4" }],
    ["path", { d: "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-restart.js
  var ListRestart = [
    ["path", { d: "M21 6H3" }],
    ["path", { d: "M7 12H3" }],
    ["path", { d: "M7 18H3" }],
    ["path", { d: "M12 18a5 5 0 0 0 9-3 4.5 4.5 0 0 0-4.5-4.5c-1.33 0-2.54.54-3.41 1.41L11 14" }],
    ["path", { d: "M11 10v4h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-start.js
  var ListStart = [
    ["path", { d: "M16 12H3" }],
    ["path", { d: "M16 18H3" }],
    ["path", { d: "M10 6H3" }],
    ["path", { d: "M21 18V8a2 2 0 0 0-2-2h-5" }],
    ["path", { d: "m16 8-2-2 2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-todo.js
  var ListTodo = [
    ["rect", { x: "3", y: "5", width: "6", height: "6", rx: "1" }],
    ["path", { d: "m3 17 2 2 4-4" }],
    ["path", { d: "M13 6h8" }],
    ["path", { d: "M13 12h8" }],
    ["path", { d: "M13 18h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-tree.js
  var ListTree = [
    ["path", { d: "M21 12h-8" }],
    ["path", { d: "M21 6H8" }],
    ["path", { d: "M21 18h-8" }],
    ["path", { d: "M3 6v4c0 1.1.9 2 2 2h3" }],
    ["path", { d: "M3 10v6c0 1.1.9 2 2 2h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-video.js
  var ListVideo = [
    ["path", { d: "M12 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M12 18H3" }],
    ["path", { d: "m16 12 5 3-5 3v-6Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/list-x.js
  var ListX = [
    ["path", { d: "M11 12H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M16 18H3" }],
    ["path", { d: "m19 10-4 4" }],
    ["path", { d: "m15 10 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/list.js
  var List = [
    ["path", { d: "M3 12h.01" }],
    ["path", { d: "M3 18h.01" }],
    ["path", { d: "M3 6h.01" }],
    ["path", { d: "M8 12h13" }],
    ["path", { d: "M8 18h13" }],
    ["path", { d: "M8 6h13" }]
  ];

  // node_modules/lucide/dist/esm/icons/loader-circle.js
  var LoaderCircle = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56" }]];

  // node_modules/lucide/dist/esm/icons/loader.js
  var Loader = [
    ["path", { d: "M12 2v4" }],
    ["path", { d: "m16.2 7.8 2.9-2.9" }],
    ["path", { d: "M18 12h4" }],
    ["path", { d: "m16.2 16.2 2.9 2.9" }],
    ["path", { d: "M12 18v4" }],
    ["path", { d: "m4.9 19.1 2.9-2.9" }],
    ["path", { d: "M2 12h4" }],
    ["path", { d: "m4.9 4.9 2.9 2.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/locate-fixed.js
  var LocateFixed = [
    ["line", { x1: "2", x2: "5", y1: "12", y2: "12" }],
    ["line", { x1: "19", x2: "22", y1: "12", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "2", y2: "5" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22" }],
    ["circle", { cx: "12", cy: "12", r: "7" }],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/loader-pinwheel.js
  var LoaderPinwheel = [
    ["path", { d: "M22 12a1 1 0 0 1-10 0 1 1 0 0 0-10 0" }],
    ["path", { d: "M7 20.7a1 1 0 1 1 5-8.7 1 1 0 1 0 5-8.6" }],
    ["path", { d: "M7 3.3a1 1 0 1 1 5 8.6 1 1 0 1 0 5 8.6" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/locate-off.js
  var LocateOff = [
    ["path", { d: "M12 19v3" }],
    ["path", { d: "M12 2v3" }],
    ["path", { d: "M18.89 13.24a7 7 0 0 0-8.13-8.13" }],
    ["path", { d: "M19 12h3" }],
    ["path", { d: "M2 12h3" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M7.05 7.05a7 7 0 0 0 9.9 9.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/locate.js
  var Locate = [
    ["line", { x1: "2", x2: "5", y1: "12", y2: "12" }],
    ["line", { x1: "19", x2: "22", y1: "12", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "2", y2: "5" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22" }],
    ["circle", { cx: "12", cy: "12", r: "7" }]
  ];

  // node_modules/lucide/dist/esm/icons/location-edit.js
  var LocationEdit = [
    ["path", { d: "M17.97 9.304A8 8 0 0 0 2 10c0 4.69 4.887 9.562 7.022 11.468" }],
    [
      "path",
      {
        d: "M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ],
    ["circle", { cx: "10", cy: "10", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/lock-keyhole-open.js
  var LockKeyholeOpen = [
    ["circle", { cx: "12", cy: "16", r: "1" }],
    ["rect", { width: "18", height: "12", x: "3", y: "10", rx: "2" }],
    ["path", { d: "M7 10V7a5 5 0 0 1 9.33-2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/lock-keyhole.js
  var LockKeyhole = [
    ["circle", { cx: "12", cy: "16", r: "1" }],
    ["rect", { x: "3", y: "10", width: "18", height: "12", rx: "2" }],
    ["path", { d: "M7 10V7a5 5 0 0 1 10 0v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/lock-open.js
  var LockOpen = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/lock.js
  var Lock = [
    ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2" }],
    ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/log-in.js
  var LogIn = [
    ["path", { d: "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4" }],
    ["polyline", { points: "10 17 15 12 10 7" }],
    ["line", { x1: "15", x2: "3", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/log-out.js
  var LogOut = [
    ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }],
    ["polyline", { points: "16 17 21 12 16 7" }],
    ["line", { x1: "21", x2: "9", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/logs.js
  var Logs = [
    ["path", { d: "M13 12h8" }],
    ["path", { d: "M13 18h8" }],
    ["path", { d: "M13 6h8" }],
    ["path", { d: "M3 12h1" }],
    ["path", { d: "M3 18h1" }],
    ["path", { d: "M3 6h1" }],
    ["path", { d: "M8 12h1" }],
    ["path", { d: "M8 18h1" }],
    ["path", { d: "M8 6h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/lollipop.js
  var Lollipop = [
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["path", { d: "m21 21-4.3-4.3" }],
    ["path", { d: "M11 11a2 2 0 0 0 4 0 4 4 0 0 0-8 0 6 6 0 0 0 12 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/luggage.js
  var Luggage = [
    ["path", { d: "M6 20a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2" }],
    ["path", { d: "M8 18V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v14" }],
    ["path", { d: "M10 20h4" }],
    ["circle", { cx: "16", cy: "20", r: "2" }],
    ["circle", { cx: "8", cy: "20", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/magnet.js
  var Magnet = [
    [
      "path",
      {
        d: "m6 15-4-4 6.75-6.77a7.79 7.79 0 0 1 11 11L13 22l-4-4 6.39-6.36a2.14 2.14 0 0 0-3-3L6 15"
      }
    ],
    ["path", { d: "m5 8 4 4" }],
    ["path", { d: "m12 15 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-check.js
  var MailCheck = [
    ["path", { d: "M22 13V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h8" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "m16 19 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-minus.js
  var MailMinus = [
    ["path", { d: "M22 15V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h8" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "M16 19h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-open.js
  var MailOpen = [
    [
      "path",
      {
        d: "M21.2 8.4c.5.38.8.97.8 1.6v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V10a2 2 0 0 1 .8-1.6l8-6a2 2 0 0 1 2.4 0l8 6Z"
      }
    ],
    ["path", { d: "m22 10-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-plus.js
  var MailPlus = [
    ["path", { d: "M22 13V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h8" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "M19 16v6" }],
    ["path", { d: "M16 19h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-question.js
  var MailQuestion = [
    ["path", { d: "M22 10.5V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12.5" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "M18 15.28c.2-.4.5-.8.9-1a2.1 2.1 0 0 1 2.6.4c.3.4.5.8.5 1.3 0 1.3-2 2-2 2" }],
    ["path", { d: "M20 22v.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-warning.js
  var MailWarning = [
    ["path", { d: "M22 10.5V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12.5" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "M20 14v4" }],
    ["path", { d: "M20 22v.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-search.js
  var MailSearch = [
    ["path", { d: "M22 12.5V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h7.5" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "M18 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" }],
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["path", { d: "m22 22-1.5-1.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail-x.js
  var MailX = [
    ["path", { d: "M22 13V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h9" }],
    ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" }],
    ["path", { d: "m17 17 4 4" }],
    ["path", { d: "m21 17-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/mail.js
  var Mail = [
    ["path", { d: "m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7" }],
    ["rect", { x: "2", y: "4", width: "20", height: "16", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/mailbox.js
  var Mailbox = [
    ["path", { d: "M22 17a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9.5C2 7 4 5 6.5 5H18c2.2 0 4 1.8 4 4v8Z" }],
    ["polyline", { points: "15,9 18,9 18,11" }],
    ["path", { d: "M6.5 5C9 5 11 7 11 9.5V17a2 2 0 0 1-2 2" }],
    ["line", { x1: "6", x2: "7", y1: "10", y2: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/mails.js
  var Mails = [
    ["rect", { width: "16", height: "13", x: "6", y: "4", rx: "2" }],
    ["path", { d: "m22 7-7.1 3.78c-.57.3-1.23.3-1.8 0L6 7" }],
    ["path", { d: "M2 8v11c0 1.1.9 2 2 2h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-check-inside.js
  var MapPinCheckInside = [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"
      }
    ],
    ["path", { d: "m9 10 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-check.js
  var MapPinCheck = [
    [
      "path",
      {
        d: "M19.43 12.935c.357-.967.57-1.955.57-2.935a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 1.202 0 32.197 32.197 0 0 0 .813-.728"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "m16 18 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-house.js
  var MapPinHouse = [
    [
      "path",
      {
        d: "M15 22a1 1 0 0 1-1-1v-4a1 1 0 0 1 .445-.832l3-2a1 1 0 0 1 1.11 0l3 2A1 1 0 0 1 22 17v4a1 1 0 0 1-1 1z"
      }
    ],
    ["path", { d: "M18 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 .601.2" }],
    ["path", { d: "M18 22v-3" }],
    ["circle", { cx: "10", cy: "10", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-minus-inside.js
  var MapPinMinusInside = [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"
      }
    ],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-minus.js
  var MapPinMinus = [
    [
      "path",
      {
        d: "M18.977 14C19.6 12.701 20 11.343 20 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 1.202 0 32 32 0 0 0 .824-.738"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "M16 18h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-off.js
  var MapPinOff = [
    ["path", { d: "M12.75 7.09a3 3 0 0 1 2.16 2.16" }],
    [
      "path",
      {
        d: "M17.072 17.072c-1.634 2.17-3.527 3.912-4.471 4.727a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 1.432-4.568"
      }
    ],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M8.475 2.818A8 8 0 0 1 20 10c0 1.183-.31 2.377-.81 3.533" }],
    ["path", { d: "M9.13 9.13a3 3 0 0 0 3.74 3.74" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-plus-inside.js
  var MapPinPlusInside = [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"
      }
    ],
    ["path", { d: "M12 7v6" }],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-x-inside.js
  var MapPinXInside = [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"
      }
    ],
    ["path", { d: "m14.5 7.5-5 5" }],
    ["path", { d: "m9.5 7.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-plus.js
  var MapPinPlus = [
    [
      "path",
      {
        d: "M19.914 11.105A7.298 7.298 0 0 0 20 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 1.202 0 32 32 0 0 0 .824-.738"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "M16 18h6" }],
    ["path", { d: "M19 15v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin.js
  var MapPin = [
    [
      "path",
      {
        d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pin-x.js
  var MapPinX = [
    [
      "path",
      {
        d: "M19.752 11.901A7.78 7.78 0 0 0 20 10a8 8 0 0 0-16 0c0 4.993 5.539 10.193 7.399 11.799a1 1 0 0 0 1.202 0 19 19 0 0 0 .09-.077"
      }
    ],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "m21.5 15.5-5 5" }],
    ["path", { d: "m21.5 20.5-5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/map-pinned.js
  var MapPinned = [
    [
      "path",
      {
        d: "M18 8c0 3.613-3.869 7.429-5.393 8.795a1 1 0 0 1-1.214 0C9.87 15.429 6 11.613 6 8a6 6 0 0 1 12 0"
      }
    ],
    ["circle", { cx: "12", cy: "8", r: "2" }],
    [
      "path",
      {
        d: "M8.714 14h-3.71a1 1 0 0 0-.948.683l-2.004 6A1 1 0 0 0 3 22h18a1 1 0 0 0 .948-1.316l-2-6a1 1 0 0 0-.949-.684h-3.712"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/map-plus.js
  var MapPlus = [
    [
      "path",
      {
        d: "m11 19-1.106-.552a2 2 0 0 0-1.788 0l-3.659 1.83A1 1 0 0 1 3 19.381V6.618a1 1 0 0 1 .553-.894l4.553-2.277a2 2 0 0 1 1.788 0l4.212 2.106a2 2 0 0 0 1.788 0l3.659-1.83A1 1 0 0 1 21 4.619V12"
      }
    ],
    ["path", { d: "M15 5.764V12" }],
    ["path", { d: "M18 15v6" }],
    ["path", { d: "M21 18h-6" }],
    ["path", { d: "M9 3.236v15" }]
  ];

  // node_modules/lucide/dist/esm/icons/map.js
  var Map2 = [
    [
      "path",
      {
        d: "M14.106 5.553a2 2 0 0 0 1.788 0l3.659-1.83A1 1 0 0 1 21 4.619v12.764a1 1 0 0 1-.553.894l-4.553 2.277a2 2 0 0 1-1.788 0l-4.212-2.106a2 2 0 0 0-1.788 0l-3.659 1.83A1 1 0 0 1 3 19.381V6.618a1 1 0 0 1 .553-.894l4.553-2.277a2 2 0 0 1 1.788 0z"
      }
    ],
    ["path", { d: "M15 5.764v15" }],
    ["path", { d: "M9 3.236v15" }]
  ];

  // node_modules/lucide/dist/esm/icons/mars-stroke.js
  var MarsStroke = [
    ["path", { d: "m14 6 4 4" }],
    ["path", { d: "M17 3h4v4" }],
    ["path", { d: "m21 3-7.75 7.75" }],
    ["circle", { cx: "9", cy: "15", r: "6" }]
  ];

  // node_modules/lucide/dist/esm/icons/mars.js
  var Mars = [
    ["path", { d: "M16 3h5v5" }],
    ["path", { d: "m21 3-6.75 6.75" }],
    ["circle", { cx: "10", cy: "14", r: "6" }]
  ];

  // node_modules/lucide/dist/esm/icons/martini.js
  var Martini = [
    ["path", { d: "M8 22h8" }],
    ["path", { d: "M12 11v11" }],
    ["path", { d: "m19 3-7 8-7-8Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/maximize-2.js
  var Maximize2 = [
    ["polyline", { points: "15 3 21 3 21 9" }],
    ["polyline", { points: "9 21 3 21 3 15" }],
    ["line", { x1: "21", x2: "14", y1: "3", y2: "10" }],
    ["line", { x1: "3", x2: "10", y1: "21", y2: "14" }]
  ];

  // node_modules/lucide/dist/esm/icons/maximize.js
  var Maximize = [
    ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3" }],
    ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3" }],
    ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/medal.js
  var Medal = [
    [
      "path",
      {
        d: "M7.21 15 2.66 7.14a2 2 0 0 1 .13-2.2L4.4 2.8A2 2 0 0 1 6 2h12a2 2 0 0 1 1.6.8l1.6 2.14a2 2 0 0 1 .14 2.2L16.79 15"
      }
    ],
    ["path", { d: "M11 12 5.12 2.2" }],
    ["path", { d: "m13 12 5.88-9.8" }],
    ["path", { d: "M8 7h8" }],
    ["circle", { cx: "12", cy: "17", r: "5" }],
    ["path", { d: "M12 18v-2h-.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/megaphone-off.js
  var MegaphoneOff = [
    ["path", { d: "M9.26 9.26 3 11v3l14.14 3.14" }],
    ["path", { d: "M21 15.34V6l-7.31 2.03" }],
    ["path", { d: "M11.6 16.8a3 3 0 1 1-5.8-1.6" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/meh.js
  var Meh = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["line", { x1: "8", x2: "16", y1: "15", y2: "15" }],
    ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9" }],
    ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/megaphone.js
  var Megaphone = [
    ["path", { d: "m3 11 18-5v12L3 14v-3z" }],
    ["path", { d: "M11.6 16.8a3 3 0 1 1-5.8-1.6" }]
  ];

  // node_modules/lucide/dist/esm/icons/memory-stick.js
  var MemoryStick = [
    ["path", { d: "M6 19v-3" }],
    ["path", { d: "M10 19v-3" }],
    ["path", { d: "M14 19v-3" }],
    ["path", { d: "M18 19v-3" }],
    ["path", { d: "M8 11V9" }],
    ["path", { d: "M16 11V9" }],
    ["path", { d: "M12 11V9" }],
    ["path", { d: "M2 15h20" }],
    [
      "path",
      {
        d: "M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v1.1a2 2 0 0 0 0 3.837V17a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-5.1a2 2 0 0 0 0-3.837Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/menu.js
  var Menu = [
    ["path", { d: "M4 12h16" }],
    ["path", { d: "M4 18h16" }],
    ["path", { d: "M4 6h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/merge.js
  var Merge = [
    ["path", { d: "m8 6 4-4 4 4" }],
    ["path", { d: "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22" }],
    ["path", { d: "m20 22-5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-code.js
  var MessageCircleCode = [
    ["path", { d: "M10 9.5 8 12l2 2.5" }],
    ["path", { d: "m14 9.5 2 2.5-2 2.5" }],
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22z" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-dashed.js
  var MessageCircleDashed = [
    ["path", { d: "M13.5 3.1c-.5 0-1-.1-1.5-.1s-1 .1-1.5.1" }],
    ["path", { d: "M19.3 6.8a10.45 10.45 0 0 0-2.1-2.1" }],
    ["path", { d: "M20.9 13.5c.1-.5.1-1 .1-1.5s-.1-1-.1-1.5" }],
    ["path", { d: "M17.2 19.3a10.45 10.45 0 0 0 2.1-2.1" }],
    ["path", { d: "M10.5 20.9c.5.1 1 .1 1.5.1s1-.1 1.5-.1" }],
    ["path", { d: "M3.5 17.5 2 22l4.5-1.5" }],
    ["path", { d: "M3.1 10.5c0 .5-.1 1-.1 1.5s.1 1 .1 1.5" }],
    ["path", { d: "M6.8 4.7a10.45 10.45 0 0 0-2.1 2.1" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-heart.js
  var MessageCircleHeart = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    [
      "path",
      {
        d: "M15.8 9.2a2.5 2.5 0 0 0-3.5 0l-.3.4-.35-.3a2.42 2.42 0 1 0-3.2 3.6l3.6 3.5 3.6-3.5c1.2-1.2 1.1-2.7.2-3.7"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-more.js
  var MessageCircleMore = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "M8 12h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M16 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-plus.js
  var MessageCirclePlus = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "M12 8v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-question.js
  var MessageCircleQuestion = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" }],
    ["path", { d: "M12 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-off.js
  var MessageCircleOff = [
    ["path", { d: "M20.5 14.9A9 9 0 0 0 9.1 3.5" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M5.6 5.6C3 8.3 2.2 12.5 4 16l-2 6 6-2c3.4 1.8 7.6 1.1 10.3-1.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-reply.js
  var MessageCircleReply = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "m10 15-3-3 3-3" }],
    ["path", { d: "M7 12h7a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-warning.js
  var MessageCircleWarning = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "M12 8v4" }],
    ["path", { d: "M12 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle-x.js
  var MessageCircleX = [
    ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-circle.js
  var MessageCircle = [["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z" }]];

  // node_modules/lucide/dist/esm/icons/message-square-code.js
  var MessageSquareCode = [
    ["path", { d: "M10 7.5 8 10l2 2.5" }],
    ["path", { d: "m14 7.5 2 2.5-2 2.5" }],
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-dashed.js
  var MessageSquareDashed = [
    ["path", { d: "M10 17H7l-4 4v-7" }],
    ["path", { d: "M14 17h1" }],
    ["path", { d: "M14 3h1" }],
    ["path", { d: "M19 3a2 2 0 0 1 2 2" }],
    ["path", { d: "M21 14v1a2 2 0 0 1-2 2" }],
    ["path", { d: "M21 9v1" }],
    ["path", { d: "M3 9v1" }],
    ["path", { d: "M5 3a2 2 0 0 0-2 2" }],
    ["path", { d: "M9 3h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-dot.js
  var MessageSquareDot = [
    ["path", { d: "M11.7 3H5a2 2 0 0 0-2 2v16l4-4h12a2 2 0 0 0 2-2v-2.7" }],
    ["circle", { cx: "18", cy: "6", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-heart.js
  var MessageSquareHeart = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    [
      "path",
      {
        d: "M14.8 7.5a1.84 1.84 0 0 0-2.6 0l-.2.3-.3-.3a1.84 1.84 0 1 0-2.4 2.8L12 13l2.7-2.7c.9-.9.8-2.1.1-2.8"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-diff.js
  var MessageSquareDiff = [
    ["path", { d: "m5 19-2 2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2" }],
    ["path", { d: "M9 10h6" }],
    ["path", { d: "M12 7v6" }],
    ["path", { d: "M9 17h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-lock.js
  var MessageSquareLock = [
    ["path", { d: "M19 15v-2a2 2 0 1 0-4 0v2" }],
    ["path", { d: "M9 17H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v3.5" }],
    ["rect", { x: "13", y: "15", width: "8", height: "5", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-more.js
  var MessageSquareMore = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "M8 10h.01" }],
    ["path", { d: "M12 10h.01" }],
    ["path", { d: "M16 10h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-off.js
  var MessageSquareOff = [
    ["path", { d: "M21 15V5a2 2 0 0 0-2-2H9" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M3.6 3.6c-.4.3-.6.8-.6 1.4v16l4-4h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-plus.js
  var MessageSquarePlus = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "M12 7v6" }],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-quote.js
  var MessageSquareQuote = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "M8 12a2 2 0 0 0 2-2V8H8" }],
    ["path", { d: "M14 12a2 2 0 0 0 2-2V8h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-share.js
  var MessageSquareShare = [
    ["path", { d: "M21 12v3a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h7" }],
    ["path", { d: "M16 3h5v5" }],
    ["path", { d: "m16 8 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-reply.js
  var MessageSquareReply = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "m10 7-3 3 3 3" }],
    ["path", { d: "M17 13v-1a2 2 0 0 0-2-2H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-text.js
  var MessageSquareText = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "M13 8H7" }],
    ["path", { d: "M17 12H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-warning.js
  var MessageSquareWarning = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "M12 7v2" }],
    ["path", { d: "M12 13h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square-x.js
  var MessageSquareX = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }],
    ["path", { d: "m14.5 7.5-5 5" }],
    ["path", { d: "m9.5 7.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/message-square.js
  var MessageSquare = [
    ["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" }]
  ];

  // node_modules/lucide/dist/esm/icons/messages-square.js
  var MessagesSquare = [
    ["path", { d: "M14 9a2 2 0 0 1-2 2H6l-4 4V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2z" }],
    ["path", { d: "M18 9h2a2 2 0 0 1 2 2v11l-4-4h-6a2 2 0 0 1-2-2v-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/mic-off.js
  var MicOff = [
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }],
    ["path", { d: "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2" }],
    ["path", { d: "M5 10v2a7 7 0 0 0 12 5" }],
    ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33" }],
    ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/mic-vocal.js
  var MicVocal = [
    ["path", { d: "m11 7.601-5.994 8.19a1 1 0 0 0 .1 1.298l.817.818a1 1 0 0 0 1.314.087L15.09 12" }],
    [
      "path",
      {
        d: "M16.5 21.174C15.5 20.5 14.372 20 13 20c-2.058 0-3.928 2.356-6 2-2.072-.356-2.775-3.369-1.5-4.5"
      }
    ],
    ["circle", { cx: "16", cy: "7", r: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/mic.js
  var Mic = [
    ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z" }],
    ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2" }],
    ["line", { x1: "12", x2: "12", y1: "19", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/microchip.js
  var Microchip = [
    ["path", { d: "M18 12h2" }],
    ["path", { d: "M18 16h2" }],
    ["path", { d: "M18 20h2" }],
    ["path", { d: "M18 4h2" }],
    ["path", { d: "M18 8h2" }],
    ["path", { d: "M4 12h2" }],
    ["path", { d: "M4 16h2" }],
    ["path", { d: "M4 20h2" }],
    ["path", { d: "M4 4h2" }],
    ["path", { d: "M4 8h2" }],
    [
      "path",
      {
        d: "M8 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-1.5c-.276 0-.494.227-.562.495a2 2 0 0 1-3.876 0C9.994 2.227 9.776 2 9.5 2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/microwave.js
  var Microwave = [
    ["rect", { width: "20", height: "15", x: "2", y: "4", rx: "2" }],
    ["rect", { width: "8", height: "7", x: "6", y: "8", rx: "1" }],
    ["path", { d: "M18 8v7" }],
    ["path", { d: "M6 19v2" }],
    ["path", { d: "M18 19v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/milestone.js
  var Milestone = [
    ["path", { d: "M12 13v8" }],
    ["path", { d: "M12 3v3" }],
    [
      "path",
      {
        d: "M4 6a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h13a2 2 0 0 0 1.152-.365l3.424-2.317a1 1 0 0 0 0-1.635l-3.424-2.318A2 2 0 0 0 17 6z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/microscope.js
  var Microscope = [
    ["path", { d: "M6 18h8" }],
    ["path", { d: "M3 22h18" }],
    ["path", { d: "M14 22a7 7 0 1 0 0-14h-1" }],
    ["path", { d: "M9 14h2" }],
    ["path", { d: "M9 12a2 2 0 0 1-2-2V6h6v4a2 2 0 0 1-2 2Z" }],
    ["path", { d: "M12 6V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/milk-off.js
  var MilkOff = [
    ["path", { d: "M8 2h8" }],
    [
      "path",
      {
        d: "M9 2v1.343M15 2v2.789a4 4 0 0 0 .672 2.219l.656.984a4 4 0 0 1 .672 2.22v1.131M7.8 7.8l-.128.192A4 4 0 0 0 7 10.212V20a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-3"
      }
    ],
    ["path", { d: "M7 15a6.47 6.47 0 0 1 5 0 6.472 6.472 0 0 0 3.435.435" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/milk.js
  var Milk = [
    ["path", { d: "M8 2h8" }],
    [
      "path",
      {
        d: "M9 2v2.789a4 4 0 0 1-.672 2.219l-.656.984A4 4 0 0 0 7 10.212V20a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-9.789a4 4 0 0 0-.672-2.219l-.656-.984A4 4 0 0 1 15 4.788V2"
      }
    ],
    ["path", { d: "M7 15a6.472 6.472 0 0 1 5 0 6.47 6.47 0 0 0 5 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/minimize-2.js
  var Minimize2 = [
    ["polyline", { points: "4 14 10 14 10 20" }],
    ["polyline", { points: "20 10 14 10 14 4" }],
    ["line", { x1: "14", x2: "21", y1: "10", y2: "3" }],
    ["line", { x1: "3", x2: "10", y1: "21", y2: "14" }]
  ];

  // node_modules/lucide/dist/esm/icons/minimize.js
  var Minimize = [
    ["path", { d: "M8 3v3a2 2 0 0 1-2 2H3" }],
    ["path", { d: "M21 8h-3a2 2 0 0 1-2-2V3" }],
    ["path", { d: "M3 16h3a2 2 0 0 1 2 2v3" }],
    ["path", { d: "M16 21v-3a2 2 0 0 1 2-2h3" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-check.js
  var MonitorCheck = [
    ["path", { d: "m9 10 2 2 4-4" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/minus.js
  var Minus = [["path", { d: "M5 12h14" }]];

  // node_modules/lucide/dist/esm/icons/monitor-cog.js
  var MonitorCog = [
    ["path", { d: "M12 17v4" }],
    ["path", { d: "m14.305 7.53.923-.382" }],
    ["path", { d: "m15.228 4.852-.923-.383" }],
    ["path", { d: "m16.852 3.228-.383-.924" }],
    ["path", { d: "m16.852 8.772-.383.923" }],
    ["path", { d: "m19.148 3.228.383-.924" }],
    ["path", { d: "m19.53 9.696-.382-.924" }],
    ["path", { d: "m20.772 4.852.924-.383" }],
    ["path", { d: "m20.772 7.148.924.383" }],
    ["path", { d: "M22 13v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7" }],
    ["path", { d: "M8 21h8" }],
    ["circle", { cx: "18", cy: "6", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-dot.js
  var MonitorDot = [
    ["circle", { cx: "19", cy: "6", r: "3" }],
    ["path", { d: "M22 12v3a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h9" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-down.js
  var MonitorDown = [
    ["path", { d: "M12 13V7" }],
    ["path", { d: "m15 10-3 3-3-3" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-off.js
  var MonitorOff = [
    ["path", { d: "M17 17H4a2 2 0 0 1-2-2V5c0-1.5 1-2 1-2" }],
    ["path", { d: "M22 15V5a2 2 0 0 0-2-2H9" }],
    ["path", { d: "M8 21h8" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-pause.js
  var MonitorPause = [
    ["path", { d: "M10 13V7" }],
    ["path", { d: "M14 13V7" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-play.js
  var MonitorPlay = [
    [
      "path",
      {
        d: "M10 7.75a.75.75 0 0 1 1.142-.638l3.664 2.249a.75.75 0 0 1 0 1.278l-3.664 2.25a.75.75 0 0 1-1.142-.64z"
      }
    ],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }],
    ["rect", { x: "2", y: "3", width: "20", height: "14", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-speaker.js
  var MonitorSpeaker = [
    ["path", { d: "M5.5 20H8" }],
    ["path", { d: "M17 9h.01" }],
    ["rect", { width: "10", height: "16", x: "12", y: "4", rx: "2" }],
    ["path", { d: "M8 6H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h4" }],
    ["circle", { cx: "17", cy: "15", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-smartphone.js
  var MonitorSmartphone = [
    ["path", { d: "M18 8V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h8" }],
    ["path", { d: "M10 19v-3.96 3.15" }],
    ["path", { d: "M7 19h5" }],
    ["rect", { width: "6", height: "10", x: "16", y: "12", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-stop.js
  var MonitorStop = [
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }],
    ["rect", { x: "2", y: "3", width: "20", height: "14", rx: "2" }],
    ["rect", { x: "9", y: "7", width: "6", height: "6", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-up.js
  var MonitorUp = [
    ["path", { d: "m9 10 3-3 3 3" }],
    ["path", { d: "M12 13V7" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor-x.js
  var MonitorX = [
    ["path", { d: "m14.5 12.5-5-5" }],
    ["path", { d: "m9.5 12.5 5-5" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "M8 21h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/monitor.js
  var Monitor = [
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }],
    ["line", { x1: "8", x2: "16", y1: "21", y2: "21" }],
    ["line", { x1: "12", x2: "12", y1: "17", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/moon-star.js
  var MoonStar = [
    ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9" }],
    ["path", { d: "M20 3v4" }],
    ["path", { d: "M22 5h-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/mountain-snow.js
  var MountainSnow = [
    ["path", { d: "m8 3 4 8 5-5 5 15H2L8 3z" }],
    ["path", { d: "M4.14 15.08c2.62-1.57 5.24-1.43 7.86.42 2.74 1.94 5.49 2 8.23.19" }]
  ];

  // node_modules/lucide/dist/esm/icons/moon.js
  var Moon = [["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" }]];

  // node_modules/lucide/dist/esm/icons/mountain.js
  var Mountain = [["path", { d: "m8 3 4 8 5-5 5 15H2L8 3z" }]];

  // node_modules/lucide/dist/esm/icons/mouse-off.js
  var MouseOff = [
    ["path", { d: "M12 6v.343" }],
    ["path", { d: "M18.218 18.218A7 7 0 0 1 5 15V9a7 7 0 0 1 .782-3.218" }],
    ["path", { d: "M19 13.343V9A7 7 0 0 0 8.56 2.902" }],
    ["path", { d: "M22 22 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/mouse-pointer-2.js
  var MousePointer2 = [
    [
      "path",
      {
        d: "M4.037 4.688a.495.495 0 0 1 .651-.651l16 6.5a.5.5 0 0 1-.063.947l-6.124 1.58a2 2 0 0 0-1.438 1.435l-1.579 6.126a.5.5 0 0 1-.947.063z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/mouse-pointer-ban.js
  var MousePointerBan = [
    [
      "path",
      {
        d: "M2.034 2.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.944L8.204 7.545a1 1 0 0 0-.66.66l-1.066 3.443a.5.5 0 0 1-.944.033z"
      }
    ],
    ["circle", { cx: "16", cy: "16", r: "6" }],
    ["path", { d: "m11.8 11.8 8.4 8.4" }]
  ];

  // node_modules/lucide/dist/esm/icons/mouse-pointer-click.js
  var MousePointerClick = [
    ["path", { d: "M14 4.1 12 6" }],
    ["path", { d: "m5.1 8-2.9-.8" }],
    ["path", { d: "m6 12-1.9 2" }],
    ["path", { d: "M7.2 2.2 8 5.1" }],
    [
      "path",
      {
        d: "M9.037 9.69a.498.498 0 0 1 .653-.653l11 4.5a.5.5 0 0 1-.074.949l-4.349 1.041a1 1 0 0 0-.74.739l-1.04 4.35a.5.5 0 0 1-.95.074z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/mouse-pointer.js
  var MousePointer = [
    ["path", { d: "M12.586 12.586 19 19" }],
    [
      "path",
      {
        d: "M3.688 3.037a.497.497 0 0 0-.651.651l6.5 15.999a.501.501 0 0 0 .947-.062l1.569-6.083a2 2 0 0 1 1.448-1.479l6.124-1.579a.5.5 0 0 0 .063-.947z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/mouse.js
  var Mouse = [
    ["rect", { x: "5", y: "2", width: "14", height: "20", rx: "7" }],
    ["path", { d: "M12 6v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-3d.js
  var Move3d = [
    ["path", { d: "M5 3v16h16" }],
    ["path", { d: "m5 19 6-6" }],
    ["path", { d: "m2 6 3-3 3 3" }],
    ["path", { d: "m18 16 3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-diagonal-2.js
  var MoveDiagonal2 = [
    ["path", { d: "M19 13v6h-6" }],
    ["path", { d: "M5 11V5h6" }],
    ["path", { d: "m5 5 14 14" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-diagonal.js
  var MoveDiagonal = [
    ["path", { d: "M11 19H5v-6" }],
    ["path", { d: "M13 5h6v6" }],
    ["path", { d: "M19 5 5 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-down-left.js
  var MoveDownLeft = [
    ["path", { d: "M11 19H5V13" }],
    ["path", { d: "M19 5L5 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-down-right.js
  var MoveDownRight = [
    ["path", { d: "M19 13V19H13" }],
    ["path", { d: "M5 5L19 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-down.js
  var MoveDown = [
    ["path", { d: "M8 18L12 22L16 18" }],
    ["path", { d: "M12 2V22" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-horizontal.js
  var MoveHorizontal = [
    ["path", { d: "m18 8 4 4-4 4" }],
    ["path", { d: "M2 12h20" }],
    ["path", { d: "m6 8-4 4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-left.js
  var MoveLeft = [
    ["path", { d: "M6 8L2 12L6 16" }],
    ["path", { d: "M2 12H22" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-right.js
  var MoveRight = [
    ["path", { d: "M18 8L22 12L18 16" }],
    ["path", { d: "M2 12H22" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-up-left.js
  var MoveUpLeft = [
    ["path", { d: "M5 11V5H11" }],
    ["path", { d: "M5 5L19 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-up.js
  var MoveUp = [
    ["path", { d: "M8 6L12 2L16 6" }],
    ["path", { d: "M12 2V22" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-up-right.js
  var MoveUpRight = [
    ["path", { d: "M13 5H19V11" }],
    ["path", { d: "M19 5L5 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/move-vertical.js
  var MoveVertical = [
    ["path", { d: "M12 2v20" }],
    ["path", { d: "m8 18 4 4 4-4" }],
    ["path", { d: "m8 6 4-4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/move.js
  var Move = [
    ["path", { d: "M12 2v20" }],
    ["path", { d: "m15 19-3 3-3-3" }],
    ["path", { d: "m19 9 3 3-3 3" }],
    ["path", { d: "M2 12h20" }],
    ["path", { d: "m5 9-3 3 3 3" }],
    ["path", { d: "m9 5 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/music-2.js
  var Music2 = [
    ["circle", { cx: "8", cy: "18", r: "4" }],
    ["path", { d: "M12 18V2l7 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/music-3.js
  var Music3 = [
    ["circle", { cx: "12", cy: "18", r: "4" }],
    ["path", { d: "M16 18V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/music-4.js
  var Music4 = [
    ["path", { d: "M9 18V5l12-2v13" }],
    ["path", { d: "m9 9 12-2" }],
    ["circle", { cx: "6", cy: "18", r: "3" }],
    ["circle", { cx: "18", cy: "16", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/music.js
  var Music = [
    ["path", { d: "M9 18V5l12-2v13" }],
    ["circle", { cx: "6", cy: "18", r: "3" }],
    ["circle", { cx: "18", cy: "16", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/navigation-2-off.js
  var Navigation2Off = [
    ["path", { d: "M9.31 9.31 5 21l7-4 7 4-1.17-3.17" }],
    ["path", { d: "M14.53 8.88 12 2l-1.17 3.17" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/navigation-2.js
  var Navigation2 = [["polygon", { points: "12 2 19 21 12 17 5 21 12 2" }]];

  // node_modules/lucide/dist/esm/icons/navigation-off.js
  var NavigationOff = [
    ["path", { d: "M8.43 8.43 3 11l8 2 2 8 2.57-5.43" }],
    ["path", { d: "M17.39 11.73 22 2l-9.73 4.61" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/navigation.js
  var Navigation = [["polygon", { points: "3 11 22 2 13 21 11 13 3 11" }]];

  // node_modules/lucide/dist/esm/icons/network.js
  var Network = [
    ["rect", { x: "16", y: "16", width: "6", height: "6", rx: "1" }],
    ["rect", { x: "2", y: "16", width: "6", height: "6", rx: "1" }],
    ["rect", { x: "9", y: "2", width: "6", height: "6", rx: "1" }],
    ["path", { d: "M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3" }],
    ["path", { d: "M12 12V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/newspaper.js
  var Newspaper = [
    ["path", { d: "M15 18h-5" }],
    ["path", { d: "M18 14h-8" }],
    [
      "path",
      {
        d: "M4 22h16a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v16a2 2 0 0 1-4 0v-9a2 2 0 0 1 2-2h2"
      }
    ],
    ["rect", { width: "8", height: "4", x: "10", y: "6", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/nfc.js
  var Nfc = [
    ["path", { d: "M6 8.32a7.43 7.43 0 0 1 0 7.36" }],
    ["path", { d: "M9.46 6.21a11.76 11.76 0 0 1 0 11.58" }],
    ["path", { d: "M12.91 4.1a15.91 15.91 0 0 1 .01 15.8" }],
    ["path", { d: "M16.37 2a20.16 20.16 0 0 1 0 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/non-binary.js
  var NonBinary = [
    ["path", { d: "M12 2v10" }],
    ["path", { d: "m8.5 4 7 4" }],
    ["path", { d: "m8.5 8 7-4" }],
    ["circle", { cx: "12", cy: "17", r: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/notebook-pen.js
  var NotebookPen = [
    ["path", { d: "M13.4 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7.4" }],
    ["path", { d: "M2 6h4" }],
    ["path", { d: "M2 10h4" }],
    ["path", { d: "M2 14h4" }],
    ["path", { d: "M2 18h4" }],
    [
      "path",
      {
        d: "M21.378 5.626a1 1 0 1 0-3.004-3.004l-5.01 5.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/notebook-tabs.js
  var NotebookTabs = [
    ["path", { d: "M2 6h4" }],
    ["path", { d: "M2 10h4" }],
    ["path", { d: "M2 14h4" }],
    ["path", { d: "M2 18h4" }],
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2" }],
    ["path", { d: "M15 2v20" }],
    ["path", { d: "M15 7h5" }],
    ["path", { d: "M15 12h5" }],
    ["path", { d: "M15 17h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/notebook.js
  var Notebook = [
    ["path", { d: "M2 6h4" }],
    ["path", { d: "M2 10h4" }],
    ["path", { d: "M2 14h4" }],
    ["path", { d: "M2 18h4" }],
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2" }],
    ["path", { d: "M16 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/notebook-text.js
  var NotebookText = [
    ["path", { d: "M2 6h4" }],
    ["path", { d: "M2 10h4" }],
    ["path", { d: "M2 14h4" }],
    ["path", { d: "M2 18h4" }],
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2" }],
    ["path", { d: "M9.5 8h5" }],
    ["path", { d: "M9.5 12H16" }],
    ["path", { d: "M9.5 16H14" }]
  ];

  // node_modules/lucide/dist/esm/icons/notepad-text-dashed.js
  var NotepadTextDashed = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M12 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M20 12v2" }],
    ["path", { d: "M20 18v2a2 2 0 0 1-2 2h-1" }],
    ["path", { d: "M13 22h-2" }],
    ["path", { d: "M7 22H6a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M4 14v-2" }],
    ["path", { d: "M4 8V6a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M8 10h6" }],
    ["path", { d: "M8 14h8" }],
    ["path", { d: "M8 18h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/notepad-text.js
  var NotepadText = [
    ["path", { d: "M8 2v4" }],
    ["path", { d: "M12 2v4" }],
    ["path", { d: "M16 2v4" }],
    ["rect", { width: "16", height: "18", x: "4", y: "4", rx: "2" }],
    ["path", { d: "M8 10h6" }],
    ["path", { d: "M8 14h8" }],
    ["path", { d: "M8 18h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/nut-off.js
  var NutOff = [
    ["path", { d: "M12 4V2" }],
    [
      "path",
      {
        d: "M5 10v4a7.004 7.004 0 0 0 5.277 6.787c.412.104.802.292 1.102.592L12 22l.621-.621c.3-.3.69-.488 1.102-.592a7.01 7.01 0 0 0 4.125-2.939"
      }
    ],
    ["path", { d: "M19 10v3.343" }],
    [
      "path",
      {
        d: "M12 12c-1.349-.573-1.905-1.005-2.5-2-.546.902-1.048 1.353-2.5 2-1.018-.644-1.46-1.08-2-2-1.028.71-1.69.918-3 1 1.081-1.048 1.757-2.03 2-3 .194-.776.84-1.551 1.79-2.21m11.654 5.997c.887-.457 1.28-.891 1.556-1.787 1.032.916 1.683 1.157 3 1-1.297-1.036-1.758-2.03-2-3-.5-2-4-4-8-4-.74 0-1.461.068-2.15.192"
      }
    ],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/nut.js
  var Nut = [
    ["path", { d: "M12 4V2" }],
    [
      "path",
      {
        d: "M5 10v4a7.004 7.004 0 0 0 5.277 6.787c.412.104.802.292 1.102.592L12 22l.621-.621c.3-.3.69-.488 1.102-.592A7.003 7.003 0 0 0 19 14v-4"
      }
    ],
    [
      "path",
      {
        d: "M12 4C8 4 4.5 6 4 8c-.243.97-.919 1.952-2 3 1.31-.082 1.972-.29 3-1 .54.92.982 1.356 2 2 1.452-.647 1.954-1.098 2.5-2 .595.995 1.151 1.427 2.5 2 1.31-.621 1.862-1.058 2.5-2 .629.977 1.162 1.423 2.5 2 1.209-.548 1.68-.967 2-2 1.032.916 1.683 1.157 3 1-1.297-1.036-1.758-2.03-2-3-.5-2-4-4-8-4Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/octagon-alert.js
  var OctagonAlert = [
    ["path", { d: "M12 16h.01" }],
    ["path", { d: "M12 8v4" }],
    [
      "path",
      {
        d: "M15.312 2a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586l-4.688-4.688A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/octagon-minus.js
  var OctagonMinus = [
    [
      "path",
      {
        d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z"
      }
    ],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/octagon-pause.js
  var OctagonPause = [
    ["path", { d: "M10 15V9" }],
    ["path", { d: "M14 15V9" }],
    [
      "path",
      {
        d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/octagon.js
  var Octagon = [
    [
      "path",
      {
        d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/octagon-x.js
  var OctagonX = [
    ["path", { d: "m15 9-6 6" }],
    [
      "path",
      {
        d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z"
      }
    ],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/omega.js
  var Omega = [
    [
      "path",
      {
        d: "M3 20h4.5a.5.5 0 0 0 .5-.5v-.282a.52.52 0 0 0-.247-.437 8 8 0 1 1 8.494-.001.52.52 0 0 0-.247.438v.282a.5.5 0 0 0 .5.5H21"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/option.js
  var Option = [
    ["path", { d: "M3 3h6l6 18h6" }],
    ["path", { d: "M14 3h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/orbit.js
  var Orbit = [
    ["path", { d: "M20.341 6.484A10 10 0 0 1 10.266 21.85" }],
    ["path", { d: "M3.659 17.516A10 10 0 0 1 13.74 2.152" }],
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["circle", { cx: "19", cy: "5", r: "2" }],
    ["circle", { cx: "5", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/origami.js
  var Origami = [
    ["path", { d: "M12 12V4a1 1 0 0 1 1-1h6.297a1 1 0 0 1 .651 1.759l-4.696 4.025" }],
    [
      "path",
      { d: "m12 21-7.414-7.414A2 2 0 0 1 4 12.172V6.415a1.002 1.002 0 0 1 1.707-.707L20 20.009" }
    ],
    [
      "path",
      {
        d: "m12.214 3.381 8.414 14.966a1 1 0 0 1-.167 1.199l-1.168 1.163a1 1 0 0 1-.706.291H6.351a1 1 0 0 1-.625-.219L3.25 18.8a1 1 0 0 1 .631-1.781l4.165.027"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/package-2.js
  var Package2 = [
    ["path", { d: "M12 3v6" }],
    [
      "path",
      {
        d: "M16.76 3a2 2 0 0 1 1.8 1.1l2.23 4.479a2 2 0 0 1 .21.891V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9.472a2 2 0 0 1 .211-.894L5.45 4.1A2 2 0 0 1 7.24 3z"
      }
    ],
    ["path", { d: "M3.054 9.013h17.893" }]
  ];

  // node_modules/lucide/dist/esm/icons/package-check.js
  var PackageCheck = [
    ["path", { d: "m16 16 2 2 4-4" }],
    [
      "path",
      {
        d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14"
      }
    ],
    ["path", { d: "m7.5 4.27 9 5.15" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/package-minus.js
  var PackageMinus = [
    ["path", { d: "M16 16h6" }],
    [
      "path",
      {
        d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14"
      }
    ],
    ["path", { d: "m7.5 4.27 9 5.15" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/package-open.js
  var PackageOpen = [
    ["path", { d: "M12 22v-9" }],
    [
      "path",
      {
        d: "M15.17 2.21a1.67 1.67 0 0 1 1.63 0L21 4.57a1.93 1.93 0 0 1 0 3.36L8.82 14.79a1.655 1.655 0 0 1-1.64 0L3 12.43a1.93 1.93 0 0 1 0-3.36z"
      }
    ],
    [
      "path",
      {
        d: "M20 13v3.87a2.06 2.06 0 0 1-1.11 1.83l-6 3.08a1.93 1.93 0 0 1-1.78 0l-6-3.08A2.06 2.06 0 0 1 4 16.87V13"
      }
    ],
    [
      "path",
      {
        d: "M21 12.43a1.93 1.93 0 0 0 0-3.36L8.83 2.2a1.64 1.64 0 0 0-1.63 0L3 4.57a1.93 1.93 0 0 0 0 3.36l12.18 6.86a1.636 1.636 0 0 0 1.63 0z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/package-plus.js
  var PackagePlus = [
    ["path", { d: "M16 16h6" }],
    ["path", { d: "M19 13v6" }],
    [
      "path",
      {
        d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14"
      }
    ],
    ["path", { d: "m7.5 4.27 9 5.15" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/package-search.js
  var PackageSearch = [
    [
      "path",
      {
        d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14"
      }
    ],
    ["path", { d: "m7.5 4.27 9 5.15" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "12" }],
    ["circle", { cx: "18.5", cy: "15.5", r: "2.5" }],
    ["path", { d: "M20.27 17.27 22 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/package-x.js
  var PackageX = [
    [
      "path",
      {
        d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14"
      }
    ],
    ["path", { d: "m7.5 4.27 9 5.15" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["line", { x1: "12", x2: "12", y1: "22", y2: "12" }],
    ["path", { d: "m17 13 5 5m-5 0 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/package.js
  var Package = [
    [
      "path",
      {
        d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z"
      }
    ],
    ["path", { d: "M12 22V12" }],
    ["polyline", { points: "3.29 7 12 12 20.71 7" }],
    ["path", { d: "m7.5 4.27 9 5.15" }]
  ];

  // node_modules/lucide/dist/esm/icons/paint-bucket.js
  var PaintBucket = [
    ["path", { d: "m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z" }],
    ["path", { d: "m5 2 5 5" }],
    ["path", { d: "M2 13h15" }],
    ["path", { d: "M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/paint-roller.js
  var PaintRoller = [
    ["rect", { width: "16", height: "6", x: "2", y: "2", rx: "2" }],
    ["path", { d: "M10 16v-2a2 2 0 0 1 2-2h8a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2" }],
    ["rect", { width: "4", height: "6", x: "8", y: "16", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/paintbrush-vertical.js
  var PaintbrushVertical = [
    ["path", { d: "M10 2v2" }],
    ["path", { d: "M14 2v4" }],
    ["path", { d: "M17 2a1 1 0 0 1 1 1v9H6V3a1 1 0 0 1 1-1z" }],
    [
      "path",
      {
        d: "M6 12a1 1 0 0 0-1 1v1a2 2 0 0 0 2 2h2a1 1 0 0 1 1 1v2.9a2 2 0 1 0 4 0V17a1 1 0 0 1 1-1h2a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/paintbrush.js
  var Paintbrush = [
    ["path", { d: "m14.622 17.897-10.68-2.913" }],
    [
      "path",
      {
        d: "M18.376 2.622a1 1 0 1 1 3.002 3.002L17.36 9.643a.5.5 0 0 0 0 .707l.944.944a2.41 2.41 0 0 1 0 3.408l-.944.944a.5.5 0 0 1-.707 0L8.354 7.348a.5.5 0 0 1 0-.707l.944-.944a2.41 2.41 0 0 1 3.408 0l.944.944a.5.5 0 0 0 .707 0z"
      }
    ],
    [
      "path",
      {
        d: "M9 8c-1.804 2.71-3.97 3.46-6.583 3.948a.507.507 0 0 0-.302.819l7.32 8.883a1 1 0 0 0 1.185.204C12.735 20.405 16 16.792 16 15"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/palette.js
  var Palette = [
    [
      "path",
      {
        d: "M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z"
      }
    ],
    ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor" }],
    ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-bottom-close.js
  var PanelBottomClose = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "m15 8-3 3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-bottom-dashed.js
  var PanelBottomDashed = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M14 15h1" }],
    ["path", { d: "M19 15h2" }],
    ["path", { d: "M3 15h2" }],
    ["path", { d: "M9 15h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-bottom-open.js
  var PanelBottomOpen = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "m9 10 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-bottom.js
  var PanelBottom = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 15h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-left-close.js
  var PanelLeftClose = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "m16 15-3-3 3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-left-dashed.js
  var PanelLeftDashed = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 14v1" }],
    ["path", { d: "M9 19v2" }],
    ["path", { d: "M9 3v2" }],
    ["path", { d: "M9 9v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-left-open.js
  var PanelLeftOpen = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "m14 9 3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-left.js
  var PanelLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-right-close.js
  var PanelRightClose = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M15 3v18" }],
    ["path", { d: "m8 9 3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-right-dashed.js
  var PanelRightDashed = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M15 14v1" }],
    ["path", { d: "M15 19v2" }],
    ["path", { d: "M15 3v2" }],
    ["path", { d: "M15 9v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-right.js
  var PanelRight = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M15 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-right-open.js
  var PanelRightOpen = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M15 3v18" }],
    ["path", { d: "m10 15-3-3 3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-top-close.js
  var PanelTopClose = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "m9 16 3-3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-top-dashed.js
  var PanelTopDashed = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M14 9h1" }],
    ["path", { d: "M19 9h2" }],
    ["path", { d: "M3 9h2" }],
    ["path", { d: "M9 9h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-top-open.js
  var PanelTopOpen = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "m15 14-3 3-3-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/panel-top.js
  var PanelTop = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/panels-left-bottom.js
  var PanelsLeftBottom = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 3v18" }],
    ["path", { d: "M9 15h12" }]
  ];

  // node_modules/lucide/dist/esm/icons/panels-right-bottom.js
  var PanelsRightBottom = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 15h12" }],
    ["path", { d: "M15 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/panels-top-left.js
  var PanelsTopLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M9 21V9" }]
  ];

  // node_modules/lucide/dist/esm/icons/paperclip.js
  var Paperclip = [
    ["path", { d: "M13.234 20.252 21 12.3" }],
    [
      "path",
      {
        d: "m16 6-8.414 8.586a2 2 0 0 0 0 2.828 2 2 0 0 0 2.828 0l8.414-8.586a4 4 0 0 0 0-5.656 4 4 0 0 0-5.656 0l-8.415 8.585a6 6 0 1 0 8.486 8.486"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/parentheses.js
  var Parentheses = [
    ["path", { d: "M8 21s-4-3-4-9 4-9 4-9" }],
    ["path", { d: "M16 3s4 3 4 9-4 9-4 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/parking-meter.js
  var ParkingMeter = [
    ["path", { d: "M11 15h2" }],
    ["path", { d: "M12 12v3" }],
    ["path", { d: "M12 19v3" }],
    [
      "path",
      {
        d: "M15.282 19a1 1 0 0 0 .948-.68l2.37-6.988a7 7 0 1 0-13.2 0l2.37 6.988a1 1 0 0 0 .948.68z"
      }
    ],
    ["path", { d: "M9 9a3 3 0 1 1 6 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/party-popper.js
  var PartyPopper = [
    ["path", { d: "M5.8 11.3 2 22l10.7-3.79" }],
    ["path", { d: "M4 3h.01" }],
    ["path", { d: "M22 8h.01" }],
    ["path", { d: "M15 2h.01" }],
    ["path", { d: "M22 20h.01" }],
    [
      "path",
      {
        d: "m22 2-2.24.75a2.9 2.9 0 0 0-1.96 3.12c.1.86-.57 1.63-1.45 1.63h-.38c-.86 0-1.6.6-1.76 1.44L14 10"
      }
    ],
    ["path", { d: "m22 13-.82-.33c-.86-.34-1.82.2-1.98 1.11c-.11.7-.72 1.22-1.43 1.22H17" }],
    ["path", { d: "m11 2 .33.82c.34.86-.2 1.82-1.11 1.98C9.52 4.9 9 5.52 9 6.23V7" }],
    [
      "path",
      {
        d: "M11 13c1.93 1.93 2.83 4.17 2 5-.83.83-3.07-.07-5-2-1.93-1.93-2.83-4.17-2-5 .83-.83 3.07.07 5 2Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pause.js
  var Pause = [
    ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1" }],
    ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/paw-print.js
  var PawPrint = [
    ["circle", { cx: "11", cy: "4", r: "2" }],
    ["circle", { cx: "18", cy: "8", r: "2" }],
    ["circle", { cx: "20", cy: "16", r: "2" }],
    [
      "path",
      {
        d: "M9 10a5 5 0 0 1 5 5v3.5a3.5 3.5 0 0 1-6.84 1.045Q6.52 17.48 4.46 16.84A3.5 3.5 0 0 1 5.5 10Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pc-case.js
  var PcCase = [
    ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2" }],
    ["path", { d: "M15 14h.01" }],
    ["path", { d: "M9 6h6" }],
    ["path", { d: "M9 10h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/pen-line.js
  var PenLine = [
    ["path", { d: "M12 20h9" }],
    [
      "path",
      {
        d: "M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pen-off.js
  var PenOff = [
    [
      "path",
      {
        d: "m10 10-6.157 6.162a2 2 0 0 0-.5.833l-1.322 4.36a.5.5 0 0 0 .622.624l4.358-1.323a2 2 0 0 0 .83-.5L14 13.982"
      }
    ],
    ["path", { d: "m12.829 7.172 4.359-4.346a1 1 0 1 1 3.986 3.986l-4.353 4.353" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/pen-tool.js
  var PenTool = [
    [
      "path",
      {
        d: "M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z"
      }
    ],
    [
      "path",
      {
        d: "m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18"
      }
    ],
    ["path", { d: "m2.3 2.3 7.286 7.286" }],
    ["circle", { cx: "11", cy: "11", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/pen.js
  var Pen = [
    [
      "path",
      {
        d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pencil-line.js
  var PencilLine = [
    ["path", { d: "M12 20h9" }],
    [
      "path",
      {
        d: "M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z"
      }
    ],
    ["path", { d: "m15 5 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/pencil-off.js
  var PencilOff = [
    [
      "path",
      {
        d: "m10 10-6.157 6.162a2 2 0 0 0-.5.833l-1.322 4.36a.5.5 0 0 0 .622.624l4.358-1.323a2 2 0 0 0 .83-.5L14 13.982"
      }
    ],
    ["path", { d: "m12.829 7.172 4.359-4.346a1 1 0 1 1 3.986 3.986l-4.353 4.353" }],
    ["path", { d: "m15 5 4 4" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/pencil-ruler.js
  var PencilRuler = [
    ["path", { d: "M13 7 8.7 2.7a2.41 2.41 0 0 0-3.4 0L2.7 5.3a2.41 2.41 0 0 0 0 3.4L7 13" }],
    ["path", { d: "m8 6 2-2" }],
    ["path", { d: "m18 16 2-2" }],
    ["path", { d: "m17 11 4.3 4.3c.94.94.94 2.46 0 3.4l-2.6 2.6c-.94.94-2.46.94-3.4 0L11 17" }],
    [
      "path",
      {
        d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"
      }
    ],
    ["path", { d: "m15 5 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pencil.js
  var Pencil = [
    [
      "path",
      {
        d: "M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"
      }
    ],
    ["path", { d: "m15 5 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pentagon.js
  var Pentagon = [
    [
      "path",
      {
        d: "M10.83 2.38a2 2 0 0 1 2.34 0l8 5.74a2 2 0 0 1 .73 2.25l-3.04 9.26a2 2 0 0 1-1.9 1.37H7.04a2 2 0 0 1-1.9-1.37L2.1 10.37a2 2 0 0 1 .73-2.25z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/percent.js
  var Percent = [
    ["line", { x1: "19", x2: "5", y1: "5", y2: "19" }],
    ["circle", { cx: "6.5", cy: "6.5", r: "2.5" }],
    ["circle", { cx: "17.5", cy: "17.5", r: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/person-standing.js
  var PersonStanding = [
    ["circle", { cx: "12", cy: "5", r: "1" }],
    ["path", { d: "m9 20 3-6 3 6" }],
    ["path", { d: "m6 8 6 2 6-2" }],
    ["path", { d: "M12 10v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/philippine-peso.js
  var PhilippinePeso = [
    ["path", { d: "M20 11H4" }],
    ["path", { d: "M20 7H4" }],
    ["path", { d: "M7 21V4a1 1 0 0 1 1-1h4a1 1 0 0 1 0 12H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/phone-call.js
  var PhoneCall = [
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ],
    ["path", { d: "M14.05 2a9 9 0 0 1 8 7.94" }],
    ["path", { d: "M14.05 6A5 5 0 0 1 18 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/phone-forwarded.js
  var PhoneForwarded = [
    ["polyline", { points: "18 2 22 6 18 10" }],
    ["line", { x1: "14", x2: "22", y1: "6", y2: "6" }],
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/phone-incoming.js
  var PhoneIncoming = [
    ["polyline", { points: "16 2 16 8 22 8" }],
    ["line", { x1: "22", x2: "16", y1: "2", y2: "8" }],
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/phone-missed.js
  var PhoneMissed = [
    ["line", { x1: "22", x2: "16", y1: "2", y2: "8" }],
    ["line", { x1: "16", x2: "22", y1: "2", y2: "8" }],
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/phone-off.js
  var PhoneOff = [
    [
      "path",
      {
        d: "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"
      }
    ],
    ["line", { x1: "22", x2: "2", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/phone-outgoing.js
  var PhoneOutgoing = [
    ["polyline", { points: "22 8 22 2 16 2" }],
    ["line", { x1: "16", x2: "22", y1: "8", y2: "2" }],
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/phone.js
  var Phone = [
    [
      "path",
      {
        d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/piano.js
  var Piano = [
    [
      "path",
      {
        d: "M18.5 8c-1.4 0-2.6-.8-3.2-2A6.87 6.87 0 0 0 2 9v11a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-8.5C22 9.6 20.4 8 18.5 8"
      }
    ],
    ["path", { d: "M2 14h20" }],
    ["path", { d: "M6 14v4" }],
    ["path", { d: "M10 14v4" }],
    ["path", { d: "M14 14v4" }],
    ["path", { d: "M18 14v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pi.js
  var Pi = [
    ["line", { x1: "9", x2: "9", y1: "4", y2: "20" }],
    ["path", { d: "M4 7c0-1.7 1.3-3 3-3h13" }],
    ["path", { d: "M18 20c-1.7 0-3-1.3-3-3V4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pickaxe.js
  var Pickaxe = [
    ["path", { d: "M14.531 12.469 6.619 20.38a1 1 0 1 1-3-3l7.912-7.912" }],
    [
      "path",
      { d: "M15.686 4.314A12.5 12.5 0 0 0 5.461 2.958 1 1 0 0 0 5.58 4.71a22 22 0 0 1 6.318 3.393" }
    ],
    [
      "path",
      {
        d: "M17.7 3.7a1 1 0 0 0-1.4 0l-4.6 4.6a1 1 0 0 0 0 1.4l2.6 2.6a1 1 0 0 0 1.4 0l4.6-4.6a1 1 0 0 0 0-1.4z"
      }
    ],
    [
      "path",
      {
        d: "M19.686 8.314a12.501 12.501 0 0 1 1.356 10.225 1 1 0 0 1-1.751-.119 22 22 0 0 0-3.393-6.319"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/picture-in-picture-2.js
  var PictureInPicture2 = [
    ["path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4" }],
    ["rect", { width: "10", height: "7", x: "12", y: "13", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/piggy-bank.js
  var PiggyBank = [
    [
      "path",
      {
        d: "M11 17h3v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3a3.16 3.16 0 0 0 2-2h1a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-1a5 5 0 0 0-2-4V3a4 4 0 0 0-3.2 1.6l-.3.4H11a6 6 0 0 0-6 6v1a5 5 0 0 0 2 4v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1z"
      }
    ],
    ["path", { d: "M16 10h.01" }],
    ["path", { d: "M2 8v1a2 2 0 0 0 2 2h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/picture-in-picture.js
  var PictureInPicture = [
    ["path", { d: "M2 10h6V4" }],
    ["path", { d: "m2 4 6 6" }],
    ["path", { d: "M21 10V7a2 2 0 0 0-2-2h-7" }],
    ["path", { d: "M3 14v2a2 2 0 0 0 2 2h3" }],
    ["rect", { x: "12", y: "14", width: "10", height: "7", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/pilcrow-left.js
  var PilcrowLeft = [
    ["path", { d: "M14 3v11" }],
    ["path", { d: "M14 9h-3a3 3 0 0 1 0-6h9" }],
    ["path", { d: "M18 3v11" }],
    ["path", { d: "M22 18H2l4-4" }],
    ["path", { d: "m6 22-4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pilcrow-right.js
  var PilcrowRight = [
    ["path", { d: "M10 3v11" }],
    ["path", { d: "M10 9H7a1 1 0 0 1 0-6h8" }],
    ["path", { d: "M14 3v11" }],
    ["path", { d: "m18 14 4 4H2" }],
    ["path", { d: "m22 18-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/pilcrow.js
  var Pilcrow = [
    ["path", { d: "M13 4v16" }],
    ["path", { d: "M17 4v16" }],
    ["path", { d: "M19 4H9.5a4.5 4.5 0 0 0 0 9H13" }]
  ];

  // node_modules/lucide/dist/esm/icons/pill-bottle.js
  var PillBottle = [
    ["path", { d: "M18 11h-4a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h4" }],
    ["path", { d: "M6 7v13a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7" }],
    ["rect", { width: "16", height: "5", x: "4", y: "2", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/pill.js
  var Pill = [
    ["path", { d: "m10.5 20.5 10-10a4.95 4.95 0 1 0-7-7l-10 10a4.95 4.95 0 1 0 7 7Z" }],
    ["path", { d: "m8.5 8.5 7 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/pin-off.js
  var PinOff = [
    ["path", { d: "M12 17v5" }],
    ["path", { d: "M15 9.34V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H7.89" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M9 9v1.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h11" }]
  ];

  // node_modules/lucide/dist/esm/icons/pin.js
  var Pin = [
    ["path", { d: "M12 17v5" }],
    [
      "path",
      {
        d: "M9 10.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24V16a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V7a1 1 0 0 1 1-1 2 2 0 0 0 0-4H8a2 2 0 0 0 0 4 1 1 0 0 1 1 1z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/plane-landing.js
  var PlaneLanding = [
    ["path", { d: "M2 22h20" }],
    [
      "path",
      {
        d: "M3.77 10.77 2 9l2-4.5 1.1.55c.55.28.9.84.9 1.45s.35 1.17.9 1.45L8 8.5l3-6 1.05.53a2 2 0 0 1 1.09 1.52l.72 5.4a2 2 0 0 0 1.09 1.52l4.4 2.2c.42.22.78.55 1.01.96l.6 1.03c.49.88-.06 1.98-1.06 2.1l-1.18.15c-.47.06-.95-.02-1.37-.24L4.29 11.15a2 2 0 0 1-.52-.38Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pipette.js
  var Pipette = [
    [
      "path",
      {
        d: "m12 9-8.414 8.414A2 2 0 0 0 3 18.828v1.344a2 2 0 0 1-.586 1.414A2 2 0 0 1 3.828 21h1.344a2 2 0 0 0 1.414-.586L15 12"
      }
    ],
    ["path", { d: "m18 9 .4.4a1 1 0 1 1-3 3l-3.8-3.8a1 1 0 1 1 3-3l.4.4 3.4-3.4a1 1 0 1 1 3 3z" }],
    ["path", { d: "m2 22 .414-.414" }]
  ];

  // node_modules/lucide/dist/esm/icons/pizza.js
  var Pizza = [
    ["path", { d: "m12 14-1 1" }],
    ["path", { d: "m13.75 18.25-1.25 1.42" }],
    ["path", { d: "M17.775 5.654a15.68 15.68 0 0 0-12.121 12.12" }],
    ["path", { d: "M18.8 9.3a1 1 0 0 0 2.1 7.7" }],
    [
      "path",
      {
        d: "M21.964 20.732a1 1 0 0 1-1.232 1.232l-18-5a1 1 0 0 1-.695-1.232A19.68 19.68 0 0 1 15.732 2.037a1 1 0 0 1 1.232.695z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/plane-takeoff.js
  var PlaneTakeoff = [
    ["path", { d: "M2 22h20" }],
    [
      "path",
      {
        d: "M6.36 17.4 4 17l-2-4 1.1-.55a2 2 0 0 1 1.8 0l.17.1a2 2 0 0 0 1.8 0L8 12 5 6l.9-.45a2 2 0 0 1 2.09.2l4.02 3a2 2 0 0 0 2.1.2l4.19-2.06a2.41 2.41 0 0 1 1.73-.17L21 7a1.4 1.4 0 0 1 .87 1.99l-.38.76c-.23.46-.6.84-1.07 1.08L7.58 17.2a2 2 0 0 1-1.22.18Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/plane.js
  var Plane = [
    [
      "path",
      {
        d: "M17.8 19.2 16 11l3.5-3.5C21 6 21.5 4 21 3c-1-.5-3 0-4.5 1.5L13 8 4.8 6.2c-.5-.1-.9.1-1.1.5l-.3.5c-.2.5-.1 1 .3 1.3L9 12l-2 3H4l-1 1 3 2 2 3 1-1v-3l3-2 3.5 5.3c.3.4.8.5 1.3.3l.5-.2c.4-.3.6-.7.5-1.2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/play.js
  var Play = [["polygon", { points: "6 3 20 12 6 21 6 3" }]];

  // node_modules/lucide/dist/esm/icons/plug-2.js
  var Plug2 = [
    ["path", { d: "M9 2v6" }],
    ["path", { d: "M15 2v6" }],
    ["path", { d: "M12 17v5" }],
    ["path", { d: "M5 8h14" }],
    ["path", { d: "M6 11V8h12v3a6 6 0 1 1-12 0Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/plug-zap.js
  var PlugZap = [
    ["path", { d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z" }],
    ["path", { d: "m2 22 3-3" }],
    ["path", { d: "M7.5 13.5 10 11" }],
    ["path", { d: "M10.5 16.5 13 14" }],
    ["path", { d: "m18 3-4 4h6l-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/plug.js
  var Plug = [
    ["path", { d: "M12 22v-5" }],
    ["path", { d: "M9 8V2" }],
    ["path", { d: "M15 8V2" }],
    ["path", { d: "M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/plus.js
  var Plus = [
    ["path", { d: "M5 12h14" }],
    ["path", { d: "M12 5v14" }]
  ];

  // node_modules/lucide/dist/esm/icons/pocket-knife.js
  var PocketKnife = [
    ["path", { d: "M3 2v1c0 1 2 1 2 2S3 6 3 7s2 1 2 2-2 1-2 2 2 1 2 2" }],
    ["path", { d: "M18 6h.01" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "M20.83 8.83a4 4 0 0 0-5.66-5.66l-12 12a4 4 0 1 0 5.66 5.66Z" }],
    ["path", { d: "M18 11.66V22a4 4 0 0 0 4-4V6" }]
  ];

  // node_modules/lucide/dist/esm/icons/pocket.js
  var Pocket = [
    ["path", { d: "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z" }],
    ["polyline", { points: "8 10 12 14 16 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/podcast.js
  var Podcast = [
    ["path", { d: "M16.85 18.58a9 9 0 1 0-9.7 0" }],
    ["path", { d: "M8 14a5 5 0 1 1 8 0" }],
    ["circle", { cx: "12", cy: "11", r: "1" }],
    ["path", { d: "M13 17a1 1 0 1 0-2 0l.5 4.5a.5.5 0 1 0 1 0Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/pointer-off.js
  var PointerOff = [
    ["path", { d: "M10 4.5V4a2 2 0 0 0-2.41-1.957" }],
    ["path", { d: "M13.9 8.4a2 2 0 0 0-1.26-1.295" }],
    ["path", { d: "M21.7 16.2A8 8 0 0 0 22 14v-3a2 2 0 1 0-4 0v-1a2 2 0 0 0-3.63-1.158" }],
    [
      "path",
      { d: "m7 15-1.8-1.8a2 2 0 0 0-2.79 2.86L6 19.7a7.74 7.74 0 0 0 6 2.3h2a8 8 0 0 0 5.657-2.343" }
    ],
    ["path", { d: "M6 6v8" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/pointer.js
  var Pointer = [
    ["path", { d: "M22 14a8 8 0 0 1-8 8" }],
    ["path", { d: "M18 11v-1a2 2 0 0 0-2-2a2 2 0 0 0-2 2" }],
    ["path", { d: "M14 10V9a2 2 0 0 0-2-2a2 2 0 0 0-2 2v1" }],
    ["path", { d: "M10 9.5V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v10" }],
    [
      "path",
      {
        d: "M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/popcorn.js
  var Popcorn = [
    ["path", { d: "M18 8a2 2 0 0 0 0-4 2 2 0 0 0-4 0 2 2 0 0 0-4 0 2 2 0 0 0-4 0 2 2 0 0 0 0 4" }],
    ["path", { d: "M10 22 9 8" }],
    ["path", { d: "m14 22 1-14" }],
    [
      "path",
      {
        d: "M20 8c.5 0 .9.4.8 1l-2.6 12c-.1.5-.7 1-1.2 1H7c-.6 0-1.1-.4-1.2-1L3.2 9c-.1-.6.3-1 .8-1Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/popsicle.js
  var Popsicle = [
    [
      "path",
      { d: "M18.6 14.4c.8-.8.8-2 0-2.8l-8.1-8.1a4.95 4.95 0 1 0-7.1 7.1l8.1 8.1c.9.7 2.1.7 2.9-.1Z" }
    ],
    ["path", { d: "m22 22-5.5-5.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/power-off.js
  var PowerOff = [
    ["path", { d: "M18.36 6.64A9 9 0 0 1 20.77 15" }],
    ["path", { d: "M6.16 6.16a9 9 0 1 0 12.68 12.68" }],
    ["path", { d: "M12 2v4" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/pound-sterling.js
  var PoundSterling = [
    ["path", { d: "M18 7c0-5.333-8-5.333-8 0" }],
    ["path", { d: "M10 7v14" }],
    ["path", { d: "M6 21h12" }],
    ["path", { d: "M6 13h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/power.js
  var Power = [
    ["path", { d: "M12 2v10" }],
    ["path", { d: "M18.4 6.6a9 9 0 1 1-12.77.04" }]
  ];

  // node_modules/lucide/dist/esm/icons/presentation.js
  var Presentation = [
    ["path", { d: "M2 3h20" }],
    ["path", { d: "M21 3v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V3" }],
    ["path", { d: "m7 21 5-5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/printer-check.js
  var PrinterCheck = [
    ["path", { d: "M13.5 22H7a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v.5" }],
    ["path", { d: "m16 19 2 2 4-4" }],
    ["path", { d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/printer.js
  var Printer = [
    ["path", { d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6" }],
    ["rect", { x: "6", y: "14", width: "12", height: "8", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/projector.js
  var Projector = [
    ["path", { d: "M5 7 3 5" }],
    ["path", { d: "M9 6V3" }],
    ["path", { d: "m13 7 2-2" }],
    ["circle", { cx: "9", cy: "13", r: "3" }],
    [
      "path",
      { d: "M11.83 12H20a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2h2.17" }
    ],
    ["path", { d: "M16 16h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/proportions.js
  var Proportions = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M12 9v11" }],
    ["path", { d: "M2 9h13a2 2 0 0 1 2 2v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/puzzle.js
  var Puzzle = [
    [
      "path",
      {
        d: "M15.39 4.39a1 1 0 0 0 1.68-.474 2.5 2.5 0 1 1 3.014 3.015 1 1 0 0 0-.474 1.68l1.683 1.682a2.414 2.414 0 0 1 0 3.414L19.61 15.39a1 1 0 0 1-1.68-.474 2.5 2.5 0 1 0-3.014 3.015 1 1 0 0 1 .474 1.68l-1.683 1.682a2.414 2.414 0 0 1-3.414 0L8.61 19.61a1 1 0 0 0-1.68.474 2.5 2.5 0 1 1-3.014-3.015 1 1 0 0 0 .474-1.68l-1.683-1.682a2.414 2.414 0 0 1 0-3.414L4.39 8.61a1 1 0 0 1 1.68.474 2.5 2.5 0 1 0 3.014-3.015 1 1 0 0 1-.474-1.68l1.683-1.682a2.414 2.414 0 0 1 3.414 0z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/pyramid.js
  var Pyramid = [
    [
      "path",
      {
        d: "M2.5 16.88a1 1 0 0 1-.32-1.43l9-13.02a1 1 0 0 1 1.64 0l9 13.01a1 1 0 0 1-.32 1.44l-8.51 4.86a2 2 0 0 1-1.98 0Z"
      }
    ],
    ["path", { d: "M12 2v20" }]
  ];

  // node_modules/lucide/dist/esm/icons/qr-code.js
  var QrCode = [
    ["rect", { width: "5", height: "5", x: "3", y: "3", rx: "1" }],
    ["rect", { width: "5", height: "5", x: "16", y: "3", rx: "1" }],
    ["rect", { width: "5", height: "5", x: "3", y: "16", rx: "1" }],
    ["path", { d: "M21 16h-3a2 2 0 0 0-2 2v3" }],
    ["path", { d: "M21 21v.01" }],
    ["path", { d: "M12 7v3a2 2 0 0 1-2 2H7" }],
    ["path", { d: "M3 12h.01" }],
    ["path", { d: "M12 3h.01" }],
    ["path", { d: "M12 16v.01" }],
    ["path", { d: "M16 12h1" }],
    ["path", { d: "M21 12v.01" }],
    ["path", { d: "M12 21v-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/quote.js
  var Quote = [
    [
      "path",
      {
        d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z"
      }
    ],
    [
      "path",
      {
        d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/rabbit.js
  var Rabbit = [
    ["path", { d: "M13 16a3 3 0 0 1 2.24 5" }],
    ["path", { d: "M18 12h.01" }],
    [
      "path",
      {
        d: "M18 21h-8a4 4 0 0 1-4-4 7 7 0 0 1 7-7h.2L9.6 6.4a1 1 0 1 1 2.8-2.8L15.8 7h.2c3.3 0 6 2.7 6 6v1a2 2 0 0 1-2 2h-1a3 3 0 0 0-3 3"
      }
    ],
    ["path", { d: "M20 8.54V4a2 2 0 1 0-4 0v3" }],
    ["path", { d: "M7.612 12.524a3 3 0 1 0-1.6 4.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/radar.js
  var Radar = [
    ["path", { d: "M19.07 4.93A10 10 0 0 0 6.99 3.34" }],
    ["path", { d: "M4 6h.01" }],
    ["path", { d: "M2.29 9.62A10 10 0 1 0 21.31 8.35" }],
    ["path", { d: "M16.24 7.76A6 6 0 1 0 8.23 16.67" }],
    ["path", { d: "M12 18h.01" }],
    ["path", { d: "M17.99 11.66A6 6 0 0 1 15.77 16.67" }],
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "m13.41 10.59 5.66-5.66" }]
  ];

  // node_modules/lucide/dist/esm/icons/radiation.js
  var Radiation = [
    ["path", { d: "M12 12h.01" }],
    [
      "path",
      {
        d: "M7.5 4.2c-.3-.5-.9-.7-1.3-.4C3.9 5.5 2.3 8.1 2 11c-.1.5.4 1 1 1h5c0-1.5.8-2.8 2-3.4-1.1-1.9-2-3.5-2.5-4.4z"
      }
    ],
    [
      "path",
      {
        d: "M21 12c.6 0 1-.4 1-1-.3-2.9-1.8-5.5-4.1-7.1-.4-.3-1.1-.2-1.3.3-.6.9-1.5 2.5-2.6 4.3 1.2.7 2 2 2 3.5h5z"
      }
    ],
    [
      "path",
      {
        d: "M7.5 19.8c-.3.5-.1 1.1.4 1.3 2.6 1.2 5.6 1.2 8.2 0 .5-.2.7-.8.4-1.3-.5-.9-1.4-2.5-2.5-4.3-1.2.7-2.8.7-4 0-1.1 1.8-2 3.4-2.5 4.3z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/radical.js
  var Radical = [
    [
      "path",
      {
        d: "M3 12h3.28a1 1 0 0 1 .948.684l2.298 7.934a.5.5 0 0 0 .96-.044L13.82 4.771A1 1 0 0 1 14.792 4H21"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/radio-receiver.js
  var RadioReceiver = [
    ["path", { d: "M5 16v2" }],
    ["path", { d: "M19 16v2" }],
    ["rect", { width: "20", height: "8", x: "2", y: "8", rx: "2" }],
    ["path", { d: "M18 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/radio-tower.js
  var RadioTower = [
    ["path", { d: "M4.9 16.1C1 12.2 1 5.8 4.9 1.9" }],
    ["path", { d: "M7.8 4.7a6.14 6.14 0 0 0-.8 7.5" }],
    ["circle", { cx: "12", cy: "9", r: "2" }],
    ["path", { d: "M16.2 4.8c2 2 2.26 5.11.8 7.47" }],
    ["path", { d: "M19.1 1.9a9.96 9.96 0 0 1 0 14.1" }],
    ["path", { d: "M9.5 18h5" }],
    ["path", { d: "m8 22 4-11 4 11" }]
  ];

  // node_modules/lucide/dist/esm/icons/radio.js
  var Radio = [
    ["path", { d: "M4.9 19.1C1 15.2 1 8.8 4.9 4.9" }],
    ["path", { d: "M7.8 16.2c-2.3-2.3-2.3-6.1 0-8.5" }],
    ["circle", { cx: "12", cy: "12", r: "2" }],
    ["path", { d: "M16.2 7.8c2.3 2.3 2.3 6.1 0 8.5" }],
    ["path", { d: "M19.1 4.9C23 8.8 23 15.1 19.1 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/radius.js
  var Radius = [
    ["path", { d: "M20.34 17.52a10 10 0 1 0-2.82 2.82" }],
    ["circle", { cx: "19", cy: "19", r: "2" }],
    ["path", { d: "m13.41 13.41 4.18 4.18" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/rail-symbol.js
  var RailSymbol = [
    ["path", { d: "M5 15h14" }],
    ["path", { d: "M5 9h14" }],
    ["path", { d: "m14 20-5-5 6-6-5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/rainbow.js
  var Rainbow = [
    ["path", { d: "M22 17a10 10 0 0 0-20 0" }],
    ["path", { d: "M6 17a6 6 0 0 1 12 0" }],
    ["path", { d: "M10 17a2 2 0 0 1 4 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/rat.js
  var Rat = [
    ["path", { d: "M13 22H4a2 2 0 0 1 0-4h12" }],
    ["path", { d: "M13.236 18a3 3 0 0 0-2.2-5" }],
    ["path", { d: "M16 9h.01" }],
    [
      "path",
      {
        d: "M16.82 3.94a3 3 0 1 1 3.237 4.868l1.815 2.587a1.5 1.5 0 0 1-1.5 2.1l-2.872-.453a3 3 0 0 0-3.5 3"
      }
    ],
    ["path", { d: "M17 4.988a3 3 0 1 0-5.2 2.052A7 7 0 0 0 4 14.015 4 4 0 0 0 8 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/ratio.js
  var Ratio = [
    ["rect", { width: "12", height: "20", x: "6", y: "2", rx: "2" }],
    ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-cent.js
  var ReceiptCent = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M12 6.5v11" }],
    ["path", { d: "M15 9.4a4 4 0 1 0 0 5.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-indian-rupee.js
  var ReceiptIndianRupee = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M8 7h8" }],
    ["path", { d: "M12 17.5 8 15h1a4 4 0 0 0 0-8" }],
    ["path", { d: "M8 11h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-euro.js
  var ReceiptEuro = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M8 12h5" }],
    ["path", { d: "M16 9.5a4 4 0 1 0 0 5.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-japanese-yen.js
  var ReceiptJapaneseYen = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "m12 10 3-3" }],
    ["path", { d: "m9 7 3 3v7.5" }],
    ["path", { d: "M9 11h6" }],
    ["path", { d: "M9 15h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-pound-sterling.js
  var ReceiptPoundSterling = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M8 13h5" }],
    ["path", { d: "M10 17V9.5a2.5 2.5 0 0 1 5 0" }],
    ["path", { d: "M8 17h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-russian-ruble.js
  var ReceiptRussianRuble = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M8 15h5" }],
    ["path", { d: "M8 11h5a2 2 0 1 0 0-4h-3v10" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-swiss-franc.js
  var ReceiptSwissFranc = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M10 17V7h5" }],
    ["path", { d: "M10 11h4" }],
    ["path", { d: "M8 15h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt.js
  var Receipt = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M16 8h-6a2 2 0 1 0 0 4h4a2 2 0 1 1 0 4H8" }],
    ["path", { d: "M12 17.5v-11" }]
  ];

  // node_modules/lucide/dist/esm/icons/receipt-text.js
  var ReceiptText = [
    ["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z" }],
    ["path", { d: "M14 8H8" }],
    ["path", { d: "M16 12H8" }],
    ["path", { d: "M13 16H8" }]
  ];

  // node_modules/lucide/dist/esm/icons/rectangle-ellipsis.js
  var RectangleEllipsis = [
    ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M17 12h.01" }],
    ["path", { d: "M7 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/rectangle-horizontal.js
  var RectangleHorizontal = [
    ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/rectangle-goggles.js
  var RectangleGoggles = [
    [
      "path",
      {
        d: "M20 6a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-4a2 2 0 0 1-1.6-.8l-1.6-2.13a1 1 0 0 0-1.6 0L9.6 17.2A2 2 0 0 1 8 18H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/rectangle-vertical.js
  var RectangleVertical = [
    ["rect", { width: "12", height: "20", x: "6", y: "2", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/recycle.js
  var Recycle = [
    ["path", { d: "M7 19H4.815a1.83 1.83 0 0 1-1.57-.881 1.785 1.785 0 0 1-.004-1.784L7.196 9.5" }],
    ["path", { d: "M11 19h8.203a1.83 1.83 0 0 0 1.556-.89 1.784 1.784 0 0 0 0-1.775l-1.226-2.12" }],
    ["path", { d: "m14 16-3 3 3 3" }],
    ["path", { d: "M8.293 13.596 7.196 9.5 3.1 10.598" }],
    [
      "path",
      {
        d: "m9.344 5.811 1.093-1.892A1.83 1.83 0 0 1 11.985 3a1.784 1.784 0 0 1 1.546.888l3.943 6.843"
      }
    ],
    ["path", { d: "m13.378 9.633 4.096 1.098 1.097-4.096" }]
  ];

  // node_modules/lucide/dist/esm/icons/redo-2.js
  var Redo2 = [
    ["path", { d: "m15 14 5-5-5-5" }],
    ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13" }]
  ];

  // node_modules/lucide/dist/esm/icons/redo-dot.js
  var RedoDot = [
    ["circle", { cx: "12", cy: "17", r: "1" }],
    ["path", { d: "M21 7v6h-6" }],
    ["path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/redo.js
  var Redo = [
    ["path", { d: "M21 7v6h-6" }],
    ["path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/refresh-ccw-dot.js
  var RefreshCcwDot = [
    ["path", { d: "M3 2v6h6" }],
    ["path", { d: "M21 12A9 9 0 0 0 6 5.3L3 8" }],
    ["path", { d: "M21 22v-6h-6" }],
    ["path", { d: "M3 12a9 9 0 0 0 15 6.7l3-2.7" }],
    ["circle", { cx: "12", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/refresh-cw-off.js
  var RefreshCwOff = [
    ["path", { d: "M21 8L18.74 5.74A9.75 9.75 0 0 0 12 3C11 3 10.03 3.16 9.13 3.47" }],
    ["path", { d: "M8 16H3v5" }],
    ["path", { d: "M3 12C3 9.51 4 7.26 5.64 5.64" }],
    ["path", { d: "m3 16 2.26 2.26A9.75 9.75 0 0 0 12 21c2.49 0 4.74-1 6.36-2.64" }],
    ["path", { d: "M21 12c0 1-.16 1.97-.47 2.87" }],
    ["path", { d: "M21 3v5h-5" }],
    ["path", { d: "M22 22 2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/refresh-ccw.js
  var RefreshCcw = [
    ["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }],
    ["path", { d: "M3 3v5h5" }],
    ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" }],
    ["path", { d: "M16 16h5v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/refresh-cw.js
  var RefreshCw = [
    ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" }],
    ["path", { d: "M21 3v5h-5" }],
    ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" }],
    ["path", { d: "M8 16H3v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/refrigerator.js
  var Refrigerator = [
    ["path", { d: "M5 6a4 4 0 0 1 4-4h6a4 4 0 0 1 4 4v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6Z" }],
    ["path", { d: "M5 10h14" }],
    ["path", { d: "M15 7v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/regex.js
  var Regex = [
    ["path", { d: "M17 3v10" }],
    ["path", { d: "m12.67 5.5 8.66 5" }],
    ["path", { d: "m12.67 10.5 8.66-5" }],
    ["path", { d: "M9 17a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2z" }]
  ];

  // node_modules/lucide/dist/esm/icons/remove-formatting.js
  var RemoveFormatting = [
    ["path", { d: "M4 7V4h16v3" }],
    ["path", { d: "M5 20h6" }],
    ["path", { d: "M13 4 8 20" }],
    ["path", { d: "m15 15 5 5" }],
    ["path", { d: "m20 15-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/repeat-1.js
  var Repeat1 = [
    ["path", { d: "m17 2 4 4-4 4" }],
    ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14" }],
    ["path", { d: "m7 22-4-4 4-4" }],
    ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3" }],
    ["path", { d: "M11 10h1v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/repeat-2.js
  var Repeat2 = [
    ["path", { d: "m2 9 3-3 3 3" }],
    ["path", { d: "M13 18H7a2 2 0 0 1-2-2V6" }],
    ["path", { d: "m22 15-3 3-3-3" }],
    ["path", { d: "M11 6h6a2 2 0 0 1 2 2v10" }]
  ];

  // node_modules/lucide/dist/esm/icons/repeat.js
  var Repeat = [
    ["path", { d: "m17 2 4 4-4 4" }],
    ["path", { d: "M3 11v-1a4 4 0 0 1 4-4h14" }],
    ["path", { d: "m7 22-4-4 4-4" }],
    ["path", { d: "M21 13v1a4 4 0 0 1-4 4H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/replace-all.js
  var ReplaceAll = [
    ["path", { d: "M14 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2" }],
    ["path", { d: "M14 4a2 2 0 0 1 2-2" }],
    ["path", { d: "M16 10a2 2 0 0 1-2-2" }],
    ["path", { d: "M20 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2" }],
    ["path", { d: "M20 2a2 2 0 0 1 2 2" }],
    ["path", { d: "M22 8a2 2 0 0 1-2 2" }],
    ["path", { d: "m3 7 3 3 3-3" }],
    ["path", { d: "M6 10V5a 3 3 0 0 1 3-3h1" }],
    ["rect", { x: "2", y: "14", width: "8", height: "8", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/replace.js
  var Replace = [
    ["path", { d: "M14 4a2 2 0 0 1 2-2" }],
    ["path", { d: "M16 10a2 2 0 0 1-2-2" }],
    ["path", { d: "M20 2a2 2 0 0 1 2 2" }],
    ["path", { d: "M22 8a2 2 0 0 1-2 2" }],
    ["path", { d: "m3 7 3 3 3-3" }],
    ["path", { d: "M6 10V5a3 3 0 0 1 3-3h1" }],
    ["rect", { x: "2", y: "14", width: "8", height: "8", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/reply-all.js
  var ReplyAll = [
    ["polyline", { points: "7 17 2 12 7 7" }],
    ["polyline", { points: "12 17 7 12 12 7" }],
    ["path", { d: "M22 18v-2a4 4 0 0 0-4-4H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/reply.js
  var Reply = [
    ["polyline", { points: "9 17 4 12 9 7" }],
    ["path", { d: "M20 18v-2a4 4 0 0 0-4-4H4" }]
  ];

  // node_modules/lucide/dist/esm/icons/rewind.js
  var Rewind = [
    ["polygon", { points: "11 19 2 12 11 5 11 19" }],
    ["polygon", { points: "22 19 13 12 22 5 22 19" }]
  ];

  // node_modules/lucide/dist/esm/icons/ribbon.js
  var Ribbon = [
    ["path", { d: "M12 11.22C11 9.997 10 9 10 8a2 2 0 0 1 4 0c0 1-.998 2.002-2.01 3.22" }],
    ["path", { d: "m12 18 2.57-3.5" }],
    ["path", { d: "M6.243 9.016a7 7 0 0 1 11.507-.009" }],
    ["path", { d: "M9.35 14.53 12 11.22" }],
    [
      "path",
      {
        d: "M9.35 14.53C7.728 12.246 6 10.221 6 7a6 5 0 0 1 12 0c-.005 3.22-1.778 5.235-3.43 7.5l3.557 4.527a1 1 0 0 1-.203 1.43l-1.894 1.36a1 1 0 0 1-1.384-.215L12 18l-2.679 3.593a1 1 0 0 1-1.39.213l-1.865-1.353a1 1 0 0 1-.203-1.422z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/rocket.js
  var Rocket = [
    [
      "path",
      {
        d: "M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z"
      }
    ],
    [
      "path",
      {
        d: "m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z"
      }
    ],
    ["path", { d: "M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0" }],
    ["path", { d: "M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/rocking-chair.js
  var RockingChair = [
    ["polyline", { points: "3.5 2 6.5 12.5 18 12.5" }],
    ["line", { x1: "9.5", x2: "5.5", y1: "12.5", y2: "20" }],
    ["line", { x1: "15", x2: "18.5", y1: "12.5", y2: "20" }],
    ["path", { d: "M2.75 18a13 13 0 0 0 18.5 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/roller-coaster.js
  var RollerCoaster = [
    ["path", { d: "M6 19V5" }],
    ["path", { d: "M10 19V6.8" }],
    ["path", { d: "M14 19v-7.8" }],
    ["path", { d: "M18 5v4" }],
    ["path", { d: "M18 19v-6" }],
    ["path", { d: "M22 19V9" }],
    ["path", { d: "M2 19V9a4 4 0 0 1 4-4c2 0 4 1.33 6 4s4 4 6 4a4 4 0 1 0-3-6.65" }]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-3d.js
  var Rotate3d = [
    [
      "path",
      {
        d: "M16.466 7.5C15.643 4.237 13.952 2 12 2 9.239 2 7 6.477 7 12s2.239 10 5 10c.342 0 .677-.069 1-.2"
      }
    ],
    ["path", { d: "m15.194 13.707 3.814 1.86-1.86 3.814" }],
    [
      "path",
      {
        d: "M19 15.57c-1.804.885-4.274 1.43-7 1.43-5.523 0-10-2.239-10-5s4.477-5 10-5c4.838 0 8.873 1.718 9.8 4"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-ccw-key.js
  var RotateCcwKey = [
    ["path", { d: "m14.5 9.5 1 1" }],
    ["path", { d: "m15.5 8.5-4 4" }],
    ["path", { d: "M3 12a9 9 0 1 0 9-9 9.74 9.74 0 0 0-6.74 2.74L3 8" }],
    ["path", { d: "M3 3v5h5" }],
    ["circle", { cx: "10", cy: "14", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-ccw-square.js
  var RotateCcwSquare = [
    ["path", { d: "M20 9V7a2 2 0 0 0-2-2h-6" }],
    ["path", { d: "m15 2-3 3 3 3" }],
    ["path", { d: "M20 13v5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-ccw.js
  var RotateCcw = [
    ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }],
    ["path", { d: "M3 3v5h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-cw-square.js
  var RotateCwSquare = [
    ["path", { d: "M12 5H6a2 2 0 0 0-2 2v3" }],
    ["path", { d: "m9 8 3-3-3-3" }],
    ["path", { d: "M4 14v4a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/rotate-cw.js
  var RotateCw = [
    ["path", { d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" }],
    ["path", { d: "M21 3v5h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/route-off.js
  var RouteOff = [
    ["circle", { cx: "6", cy: "19", r: "3" }],
    ["path", { d: "M9 19h8.5c.4 0 .9-.1 1.3-.2" }],
    ["path", { d: "M5.2 5.2A3.5 3.53 0 0 0 6.5 12H12" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M21 15.3a3.5 3.5 0 0 0-3.3-3.3" }],
    ["path", { d: "M15 5h-4.3" }],
    ["circle", { cx: "18", cy: "5", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/route.js
  var Route = [
    ["circle", { cx: "6", cy: "19", r: "3" }],
    ["path", { d: "M9 19h8.5a3.5 3.5 0 0 0 0-7h-11a3.5 3.5 0 0 1 0-7H15" }],
    ["circle", { cx: "18", cy: "5", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/router.js
  var Router2 = [
    ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2" }],
    ["path", { d: "M6.01 18H6" }],
    ["path", { d: "M10.01 18H10" }],
    ["path", { d: "M15 10v4" }],
    ["path", { d: "M17.84 7.17a4 4 0 0 0-5.66 0" }],
    ["path", { d: "M20.66 4.34a8 8 0 0 0-11.31 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/rows-2.js
  var Rows2 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 12h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/rows-4.js
  var Rows4 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M21 7.5H3" }],
    ["path", { d: "M21 12H3" }],
    ["path", { d: "M21 16.5H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/rows-3.js
  var Rows3 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M21 9H3" }],
    ["path", { d: "M21 15H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/rss.js
  var Rss = [
    ["path", { d: "M4 11a9 9 0 0 1 9 9" }],
    ["path", { d: "M4 4a16 16 0 0 1 16 16" }],
    ["circle", { cx: "5", cy: "19", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/ruler-dimension-line.js
  var RulerDimensionLine = [
    ["path", { d: "M12 15v-3.014" }],
    ["path", { d: "M16 15v-3.014" }],
    ["path", { d: "M20 6H4" }],
    ["path", { d: "M20 8V4" }],
    ["path", { d: "M4 8V4" }],
    ["path", { d: "M8 15v-3.014" }],
    ["rect", { x: "3", y: "12", width: "18", height: "7", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/ruler.js
  var Ruler = [
    [
      "path",
      {
        d: "M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"
      }
    ],
    ["path", { d: "m14.5 12.5 2-2" }],
    ["path", { d: "m11.5 9.5 2-2" }],
    ["path", { d: "m8.5 6.5 2-2" }],
    ["path", { d: "m17.5 15.5 2-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/russian-ruble.js
  var RussianRuble = [
    ["path", { d: "M6 11h8a4 4 0 0 0 0-8H9v18" }],
    ["path", { d: "M6 15h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/sailboat.js
  var Sailboat = [
    ["path", { d: "M22 18H2a4 4 0 0 0 4 4h12a4 4 0 0 0 4-4Z" }],
    ["path", { d: "M21 14 10 2 3 14h18Z" }],
    ["path", { d: "M10 2v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/salad.js
  var Salad = [
    ["path", { d: "M7 21h10" }],
    ["path", { d: "M12 21a9 9 0 0 0 9-9H3a9 9 0 0 0 9 9Z" }],
    [
      "path",
      {
        d: "M11.38 12a2.4 2.4 0 0 1-.4-4.77 2.4 2.4 0 0 1 3.2-2.77 2.4 2.4 0 0 1 3.47-.63 2.4 2.4 0 0 1 3.37 3.37 2.4 2.4 0 0 1-1.1 3.7 2.51 2.51 0 0 1 .03 1.1"
      }
    ],
    ["path", { d: "m13 12 4-4" }],
    ["path", { d: "M10.9 7.25A3.99 3.99 0 0 0 4 10c0 .73.2 1.41.54 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/sandwich.js
  var Sandwich = [
    ["path", { d: "m2.37 11.223 8.372-6.777a2 2 0 0 1 2.516 0l8.371 6.777" }],
    ["path", { d: "M21 15a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-5.25" }],
    ["path", { d: "M3 15a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h9" }],
    ["path", { d: "m6.67 15 6.13 4.6a2 2 0 0 0 2.8-.4l3.15-4.2" }],
    ["rect", { width: "20", height: "4", x: "2", y: "11", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/satellite-dish.js
  var SatelliteDish = [
    ["path", { d: "M4 10a7.31 7.31 0 0 0 10 10Z" }],
    ["path", { d: "m9 15 3-3" }],
    ["path", { d: "M17 13a6 6 0 0 0-6-6" }],
    ["path", { d: "M21 13A10 10 0 0 0 11 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/satellite.js
  var Satellite = [
    ["path", { d: "M13 7 9 3 5 7l4 4" }],
    ["path", { d: "m17 11 4 4-4 4-4-4" }],
    ["path", { d: "m8 12 4 4 6-6-4-4Z" }],
    ["path", { d: "m16 8 3-3" }],
    ["path", { d: "M9 21a6 6 0 0 0-6-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/saudi-riyal.js
  var SaudiRiyal = [
    ["path", { d: "m20 19.5-5.5 1.2" }],
    ["path", { d: "M14.5 4v11.22a1 1 0 0 0 1.242.97L20 15.2" }],
    ["path", { d: "m2.978 19.351 5.549-1.363A2 2 0 0 0 10 16V2" }],
    ["path", { d: "M20 10 4 13.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/save-all.js
  var SaveAll = [
    ["path", { d: "M10 2v3a1 1 0 0 0 1 1h5" }],
    ["path", { d: "M18 18v-6a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v6" }],
    ["path", { d: "M18 22H4a2 2 0 0 1-2-2V6" }],
    [
      "path",
      {
        d: "M8 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9.172a2 2 0 0 1 1.414.586l2.828 2.828A2 2 0 0 1 22 6.828V16a2 2 0 0 1-2.01 2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/save-off.js
  var SaveOff = [
    ["path", { d: "M13 13H8a1 1 0 0 0-1 1v7" }],
    ["path", { d: "M14 8h1" }],
    ["path", { d: "M17 21v-4" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M20.41 20.41A2 2 0 0 1 19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 .59-1.41" }],
    ["path", { d: "M29.5 11.5s5 5 4 5" }],
    ["path", { d: "M9 3h6.2a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V15" }]
  ];

  // node_modules/lucide/dist/esm/icons/save.js
  var Save = [
    [
      "path",
      {
        d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z"
      }
    ],
    ["path", { d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7" }],
    ["path", { d: "M7 3v4a1 1 0 0 0 1 1h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/scale-3d.js
  var Scale3d = [
    ["path", { d: "M5 7v11a1 1 0 0 0 1 1h11" }],
    ["path", { d: "M5.293 18.707 11 13" }],
    ["circle", { cx: "19", cy: "19", r: "2" }],
    ["circle", { cx: "5", cy: "5", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/scale.js
  var Scale = [
    ["path", { d: "m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" }],
    ["path", { d: "m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" }],
    ["path", { d: "M7 21h10" }],
    ["path", { d: "M12 3v18" }],
    ["path", { d: "M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/scaling.js
  var Scaling = [
    ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }],
    ["path", { d: "M14 15H9v-5" }],
    ["path", { d: "M16 3h5v5" }],
    ["path", { d: "M21 3 9 15" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-barcode.js
  var ScanBarcode = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M8 7v10" }],
    ["path", { d: "M12 7v10" }],
    ["path", { d: "M17 7v10" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-eye.js
  var ScanEye = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["circle", { cx: "12", cy: "12", r: "1" }],
    [
      "path",
      {
        d: "M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/scan-face.js
  var ScanFace = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2" }],
    ["path", { d: "M9 9h.01" }],
    ["path", { d: "M15 9h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-heart.js
  var ScanHeart = [
    [
      "path",
      {
        d: "M11.246 16.657a1 1 0 0 0 1.508 0l3.57-4.101A2.75 2.75 0 1 0 12 9.168a2.75 2.75 0 1 0-4.324 3.388z"
      }
    ],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-qr-code.js
  var ScanQrCode = [
    ["path", { d: "M17 12v4a1 1 0 0 1-1 1h-4" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M17 8V7" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M7 17h.01" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["rect", { x: "7", y: "7", width: "5", height: "5", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-line.js
  var ScanLine = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M7 12h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-search.js
  var ScanSearch = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["path", { d: "m16 16-1.9-1.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan-text.js
  var ScanText = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M7 8h8" }],
    ["path", { d: "M7 12h10" }],
    ["path", { d: "M7 16h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/scan.js
  var Scan = [
    ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2" }],
    ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2" }],
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/school.js
  var School = [
    ["path", { d: "M14 22v-4a2 2 0 1 0-4 0v4" }],
    [
      "path",
      {
        d: "m18 10 3.447 1.724a1 1 0 0 1 .553.894V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-7.382a1 1 0 0 1 .553-.894L6 10"
      }
    ],
    ["path", { d: "M18 5v17" }],
    ["path", { d: "m4 6 7.106-3.553a2 2 0 0 1 1.788 0L20 6" }],
    ["path", { d: "M6 5v17" }],
    ["circle", { cx: "12", cy: "9", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/scissors-line-dashed.js
  var ScissorsLineDashed = [
    ["path", { d: "M5.42 9.42 8 12" }],
    ["circle", { cx: "4", cy: "8", r: "2" }],
    ["path", { d: "m14 6-8.58 8.58" }],
    ["circle", { cx: "4", cy: "16", r: "2" }],
    ["path", { d: "M10.8 14.8 14 18" }],
    ["path", { d: "M16 12h-2" }],
    ["path", { d: "M22 12h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/scissors.js
  var Scissors = [
    ["circle", { cx: "6", cy: "6", r: "3" }],
    ["path", { d: "M8.12 8.12 12 12" }],
    ["path", { d: "M20 4 8.12 15.88" }],
    ["circle", { cx: "6", cy: "18", r: "3" }],
    ["path", { d: "M14.8 14.8 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/screen-share-off.js
  var ScreenShareOff = [
    ["path", { d: "M13 3H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-3" }],
    ["path", { d: "M8 21h8" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "m22 3-5 5" }],
    ["path", { d: "m17 3 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/screen-share.js
  var ScreenShare = [
    ["path", { d: "M13 3H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-3" }],
    ["path", { d: "M8 21h8" }],
    ["path", { d: "M12 17v4" }],
    ["path", { d: "m17 8 5-5" }],
    ["path", { d: "M17 3h5v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/scroll-text.js
  var ScrollText = [
    ["path", { d: "M15 12h-5" }],
    ["path", { d: "M15 8h-5" }],
    ["path", { d: "M19 17V5a2 2 0 0 0-2-2H4" }],
    [
      "path",
      {
        d: "M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/scroll.js
  var Scroll = [
    ["path", { d: "M19 17V5a2 2 0 0 0-2-2H4" }],
    [
      "path",
      {
        d: "M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/search-check.js
  var SearchCheck = [
    ["path", { d: "m8 11 2 2 4-4" }],
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["path", { d: "m21 21-4.3-4.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/search-code.js
  var SearchCode = [
    ["path", { d: "m13 13.5 2-2.5-2-2.5" }],
    ["path", { d: "m21 21-4.3-4.3" }],
    ["path", { d: "M9 8.5 7 11l2 2.5" }],
    ["circle", { cx: "11", cy: "11", r: "8" }]
  ];

  // node_modules/lucide/dist/esm/icons/search-slash.js
  var SearchSlash = [
    ["path", { d: "m13.5 8.5-5 5" }],
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["path", { d: "m21 21-4.3-4.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/search-x.js
  var SearchX = [
    ["path", { d: "m13.5 8.5-5 5" }],
    ["path", { d: "m8.5 8.5 5 5" }],
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["path", { d: "m21 21-4.3-4.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/section.js
  var Section = [
    ["path", { d: "M16 5a4 3 0 0 0-8 0c0 4 8 3 8 7a4 3 0 0 1-8 0" }],
    ["path", { d: "M8 19a4 3 0 0 0 8 0c0-4-8-3-8-7a4 3 0 0 1 8 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/search.js
  var Search = [
    ["path", { d: "m21 21-4.34-4.34" }],
    ["circle", { cx: "11", cy: "11", r: "8" }]
  ];

  // node_modules/lucide/dist/esm/icons/send-horizontal.js
  var SendHorizontal = [
    [
      "path",
      {
        d: "M3.714 3.048a.498.498 0 0 0-.683.627l2.843 7.627a2 2 0 0 1 0 1.396l-2.842 7.627a.498.498 0 0 0 .682.627l18-8.5a.5.5 0 0 0 0-.904z"
      }
    ],
    ["path", { d: "M6 12h16" }]
  ];

  // node_modules/lucide/dist/esm/icons/send-to-back.js
  var SendToBack = [
    ["rect", { x: "14", y: "14", width: "8", height: "8", rx: "2" }],
    ["rect", { x: "2", y: "2", width: "8", height: "8", rx: "2" }],
    ["path", { d: "M7 14v1a2 2 0 0 0 2 2h1" }],
    ["path", { d: "M14 7h1a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/send.js
  var Send = [
    [
      "path",
      {
        d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z"
      }
    ],
    ["path", { d: "m21.854 2.147-10.94 10.939" }]
  ];

  // node_modules/lucide/dist/esm/icons/separator-horizontal.js
  var SeparatorHorizontal = [
    ["line", { x1: "3", x2: "21", y1: "12", y2: "12" }],
    ["polyline", { points: "8 8 12 4 16 8" }],
    ["polyline", { points: "16 16 12 20 8 16" }]
  ];

  // node_modules/lucide/dist/esm/icons/separator-vertical.js
  var SeparatorVertical = [
    ["line", { x1: "12", x2: "12", y1: "3", y2: "21" }],
    ["polyline", { points: "8 8 4 12 8 16" }],
    ["polyline", { points: "16 16 20 12 16 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/server-cog.js
  var ServerCog = [
    ["path", { d: "m10.852 14.772-.383.923" }],
    ["path", { d: "M13.148 14.772a3 3 0 1 0-2.296-5.544l-.383-.923" }],
    ["path", { d: "m13.148 9.228.383-.923" }],
    ["path", { d: "m13.53 15.696-.382-.924a3 3 0 1 1-2.296-5.544" }],
    ["path", { d: "m14.772 10.852.923-.383" }],
    ["path", { d: "m14.772 13.148.923.383" }],
    ["path", { d: "M4.5 10H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-.5" }],
    ["path", { d: "M4.5 14H4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-.5" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "M6 6h.01" }],
    ["path", { d: "m9.228 10.852-.923-.383" }],
    ["path", { d: "m9.228 13.148-.923.383" }]
  ];

  // node_modules/lucide/dist/esm/icons/server-crash.js
  var ServerCrash = [
    ["path", { d: "M6 10H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-2" }],
    ["path", { d: "M6 14H4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-2" }],
    ["path", { d: "M6 6h.01" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "m13 6-4 6h6l-4 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/server-off.js
  var ServerOff = [
    ["path", { d: "M7 2h13a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-5" }],
    ["path", { d: "M10 10 2.5 2.5C2 2 2 2.5 2 5v3a2 2 0 0 0 2 2h6z" }],
    ["path", { d: "M22 17v-1a2 2 0 0 0-2-2h-1" }],
    ["path", { d: "M4 14a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h16.5l1-.5.5.5-8-8H4z" }],
    ["path", { d: "M6 18h.01" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/server.js
  var Server = [
    ["rect", { width: "20", height: "8", x: "2", y: "2", rx: "2", ry: "2" }],
    ["rect", { width: "20", height: "8", x: "2", y: "14", rx: "2", ry: "2" }],
    ["line", { x1: "6", x2: "6.01", y1: "6", y2: "6" }],
    ["line", { x1: "6", x2: "6.01", y1: "18", y2: "18" }]
  ];

  // node_modules/lucide/dist/esm/icons/settings-2.js
  var Settings2 = [
    ["path", { d: "M20 7h-9" }],
    ["path", { d: "M14 17H5" }],
    ["circle", { cx: "17", cy: "17", r: "3" }],
    ["circle", { cx: "7", cy: "7", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/settings.js
  var Settings = [
    [
      "path",
      {
        d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/shapes.js
  var Shapes = [
    [
      "path",
      {
        d: "M8.3 10a.7.7 0 0 1-.626-1.079L11.4 3a.7.7 0 0 1 1.198-.043L16.3 8.9a.7.7 0 0 1-.572 1.1Z"
      }
    ],
    ["rect", { x: "3", y: "14", width: "7", height: "7", rx: "1" }],
    ["circle", { cx: "17.5", cy: "17.5", r: "3.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/share-2.js
  var Share2 = [
    ["circle", { cx: "18", cy: "5", r: "3" }],
    ["circle", { cx: "6", cy: "12", r: "3" }],
    ["circle", { cx: "18", cy: "19", r: "3" }],
    ["line", { x1: "8.59", x2: "15.42", y1: "13.51", y2: "17.49" }],
    ["line", { x1: "15.41", x2: "8.59", y1: "6.51", y2: "10.49" }]
  ];

  // node_modules/lucide/dist/esm/icons/sheet.js
  var Sheet = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["line", { x1: "3", x2: "21", y1: "9", y2: "9" }],
    ["line", { x1: "3", x2: "21", y1: "15", y2: "15" }],
    ["line", { x1: "9", x2: "9", y1: "9", y2: "21" }],
    ["line", { x1: "15", x2: "15", y1: "9", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/share.js
  var Share = [
    ["path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" }],
    ["polyline", { points: "16 6 12 2 8 6" }],
    ["line", { x1: "12", x2: "12", y1: "2", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/shell.js
  var Shell = [
    [
      "path",
      {
        d: "M14 11a2 2 0 1 1-4 0 4 4 0 0 1 8 0 6 6 0 0 1-12 0 8 8 0 0 1 16 0 10 10 0 1 1-20 0 11.93 11.93 0 0 1 2.42-7.22 2 2 0 1 1 3.16 2.44"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shield-alert.js
  var ShieldAlert = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M12 8v4" }],
    ["path", { d: "M12 16h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-ban.js
  var ShieldBan = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "m4.243 5.21 14.39 12.472" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-check.js
  var ShieldCheck = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "m9 12 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-ellipsis.js
  var ShieldEllipsis = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M8 12h.01" }],
    ["path", { d: "M12 12h.01" }],
    ["path", { d: "M16 12h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-half.js
  var ShieldHalf = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M12 22V2" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-minus.js
  var ShieldMinus = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M9 12h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-off.js
  var ShieldOff = [
    ["path", { d: "m2 2 20 20" }],
    [
      "path",
      {
        d: "M5 5a1 1 0 0 0-1 1v7c0 5 3.5 7.5 7.67 8.94a1 1 0 0 0 .67.01c2.35-.82 4.48-1.97 5.9-3.71"
      }
    ],
    [
      "path",
      {
        d: "M9.309 3.652A12.252 12.252 0 0 0 11.24 2.28a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1v7a9.784 9.784 0 0 1-.08 1.264"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shield-plus.js
  var ShieldPlus = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M9 12h6" }],
    ["path", { d: "M12 9v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-question.js
  var ShieldQuestion = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M9.1 9a3 3 0 0 1 5.82 1c0 2-3 3-3 3" }],
    ["path", { d: "M12 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-user.js
  var ShieldUser = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "M6.376 18.91a6 6 0 0 1 11.249.003" }],
    ["circle", { cx: "12", cy: "11", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/shield-x.js
  var ShieldX = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ],
    ["path", { d: "m14.5 9.5-5 5" }],
    ["path", { d: "m9.5 9.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/ship-wheel.js
  var ShipWheel = [
    ["circle", { cx: "12", cy: "12", r: "8" }],
    ["path", { d: "M12 2v7.5" }],
    ["path", { d: "m19 5-5.23 5.23" }],
    ["path", { d: "M22 12h-7.5" }],
    ["path", { d: "m19 19-5.23-5.23" }],
    ["path", { d: "M12 14.5V22" }],
    ["path", { d: "M10.23 13.77 5 19" }],
    ["path", { d: "M9.5 12H2" }],
    ["path", { d: "M10.23 10.23 5 5" }],
    ["circle", { cx: "12", cy: "12", r: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/ship.js
  var Ship = [
    ["path", { d: "M12 10.189V14" }],
    ["path", { d: "M12 2v3" }],
    ["path", { d: "M19 13V7a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2v6" }],
    [
      "path",
      {
        d: "M19.38 20A11.6 11.6 0 0 0 21 14l-8.188-3.639a2 2 0 0 0-1.624 0L3 14a11.6 11.6 0 0 0 2.81 7.76"
      }
    ],
    [
      "path",
      {
        d: "M2 21c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1s1.2 1 2.5 1c2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shield.js
  var Shield = [
    [
      "path",
      {
        d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shirt.js
  var Shirt = [
    [
      "path",
      {
        d: "M20.38 3.46 16 2a4 4 0 0 1-8 0L3.62 3.46a2 2 0 0 0-1.34 2.23l.58 3.47a1 1 0 0 0 .99.84H6v10c0 1.1.9 2 2 2h8a2 2 0 0 0 2-2V10h2.15a1 1 0 0 0 .99-.84l.58-3.47a2 2 0 0 0-1.34-2.23z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shopping-basket.js
  var ShoppingBasket = [
    ["path", { d: "m15 11-1 9" }],
    ["path", { d: "m19 11-4-7" }],
    ["path", { d: "M2 11h20" }],
    ["path", { d: "m3.5 11 1.6 7.4a2 2 0 0 0 2 1.6h9.8a2 2 0 0 0 2-1.6l1.7-7.4" }],
    ["path", { d: "M4.5 15.5h15" }],
    ["path", { d: "m5 11 4-7" }],
    ["path", { d: "m9 11 1 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/shopping-bag.js
  var ShoppingBag = [
    ["path", { d: "M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4Z" }],
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M16 10a4 4 0 0 1-8 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/shopping-cart.js
  var ShoppingCart = [
    ["circle", { cx: "8", cy: "21", r: "1" }],
    ["circle", { cx: "19", cy: "21", r: "1" }],
    [
      "path",
      { d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/shovel.js
  var Shovel = [
    ["path", { d: "M2 22v-5l5-5 5 5-5 5z" }],
    ["path", { d: "M9.5 14.5 16 8" }],
    ["path", { d: "m17 2 5 5-.5.5a3.53 3.53 0 0 1-5 0s0 0 0 0a3.53 3.53 0 0 1 0-5L17 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/shredder.js
  var Shredder = [
    ["path", { d: "M10 22v-5" }],
    ["path", { d: "M14 19v-2" }],
    ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M18 20v-3" }],
    ["path", { d: "M2 13h20" }],
    ["path", { d: "M20 13V7l-5-5H6a2 2 0 0 0-2 2v9" }],
    ["path", { d: "M6 20v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/shower-head.js
  var ShowerHead = [
    ["path", { d: "m4 4 2.5 2.5" }],
    ["path", { d: "M13.5 6.5a4.95 4.95 0 0 0-7 7" }],
    ["path", { d: "M15 5 5 15" }],
    ["path", { d: "M14 17v.01" }],
    ["path", { d: "M10 16v.01" }],
    ["path", { d: "M13 13v.01" }],
    ["path", { d: "M16 10v.01" }],
    ["path", { d: "M11 20v.01" }],
    ["path", { d: "M17 14v.01" }],
    ["path", { d: "M20 11v.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/shrimp.js
  var Shrimp = [
    ["path", { d: "M11 12h.01" }],
    ["path", { d: "M13 22c.5-.5 1.12-1 2.5-1-1.38 0-2-.5-2.5-1" }],
    [
      "path",
      {
        d: "M14 2a3.28 3.28 0 0 1-3.227 1.798l-6.17-.561A2.387 2.387 0 1 0 4.387 8H15.5a1 1 0 0 1 0 13 1 1 0 0 0 0-5H12a7 7 0 0 1-7-7V8"
      }
    ],
    ["path", { d: "M14 8a8.5 8.5 0 0 1 0 8" }],
    ["path", { d: "M16 16c2 0 4.5-4 4-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/shrink.js
  var Shrink = [
    ["path", { d: "m15 15 6 6m-6-6v4.8m0-4.8h4.8" }],
    ["path", { d: "M9 19.8V15m0 0H4.2M9 15l-6 6" }],
    ["path", { d: "M15 4.2V9m0 0h4.8M15 9l6-6" }],
    ["path", { d: "M9 4.2V9m0 0H4.2M9 9 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/shrub.js
  var Shrub = [
    ["path", { d: "M12 22v-7l-2-2" }],
    ["path", { d: "M17 8v.8A6 6 0 0 1 13.8 20H10A6.5 6.5 0 0 1 7 8a5 5 0 0 1 10 0Z" }],
    ["path", { d: "m14 14-2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/shuffle.js
  var Shuffle = [
    ["path", { d: "m18 14 4 4-4 4" }],
    ["path", { d: "m18 2 4 4-4 4" }],
    ["path", { d: "M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22" }],
    ["path", { d: "M2 6h1.972a4 4 0 0 1 3.6 2.2" }],
    ["path", { d: "M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45" }]
  ];

  // node_modules/lucide/dist/esm/icons/sigma.js
  var Sigma = [
    [
      "path",
      {
        d: "M18 7V5a1 1 0 0 0-1-1H6.5a.5.5 0 0 0-.4.8l4.5 6a2 2 0 0 1 0 2.4l-4.5 6a.5.5 0 0 0 .4.8H17a1 1 0 0 0 1-1v-2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/signal-high.js
  var SignalHigh = [
    ["path", { d: "M2 20h.01" }],
    ["path", { d: "M7 20v-4" }],
    ["path", { d: "M12 20v-8" }],
    ["path", { d: "M17 20V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/signal-medium.js
  var SignalMedium = [
    ["path", { d: "M2 20h.01" }],
    ["path", { d: "M7 20v-4" }],
    ["path", { d: "M12 20v-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/signal-low.js
  var SignalLow = [
    ["path", { d: "M2 20h.01" }],
    ["path", { d: "M7 20v-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/signal-zero.js
  var SignalZero = [["path", { d: "M2 20h.01" }]];

  // node_modules/lucide/dist/esm/icons/signature.js
  var Signature = [
    [
      "path",
      {
        d: "m21 17-2.156-1.868A.5.5 0 0 0 18 15.5v.5a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1c0-2.545-3.991-3.97-8.5-4a1 1 0 0 0 0 5c4.153 0 4.745-11.295 5.708-13.5a2.5 2.5 0 1 1 3.31 3.284"
      }
    ],
    ["path", { d: "M3 21h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/signal.js
  var Signal = [
    ["path", { d: "M2 20h.01" }],
    ["path", { d: "M7 20v-4" }],
    ["path", { d: "M12 20v-8" }],
    ["path", { d: "M17 20V8" }],
    ["path", { d: "M22 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/signpost-big.js
  var SignpostBig = [
    ["path", { d: "M10 9H4L2 7l2-2h6" }],
    ["path", { d: "M14 5h6l2 2-2 2h-6" }],
    ["path", { d: "M10 22V4a2 2 0 1 1 4 0v18" }],
    ["path", { d: "M8 22h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/signpost.js
  var Signpost = [
    ["path", { d: "M12 13v8" }],
    ["path", { d: "M12 3v3" }],
    [
      "path",
      {
        d: "M18 6a2 2 0 0 1 1.387.56l2.307 2.22a1 1 0 0 1 0 1.44l-2.307 2.22A2 2 0 0 1 18 13H6a2 2 0 0 1-1.387-.56l-2.306-2.22a1 1 0 0 1 0-1.44l2.306-2.22A2 2 0 0 1 6 6z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/siren.js
  var Siren = [
    ["path", { d: "M7 18v-6a5 5 0 1 1 10 0v6" }],
    ["path", { d: "M5 21a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2z" }],
    ["path", { d: "M21 12h1" }],
    ["path", { d: "M18.5 4.5 18 5" }],
    ["path", { d: "M2 12h1" }],
    ["path", { d: "M12 2v1" }],
    ["path", { d: "m4.929 4.929.707.707" }],
    ["path", { d: "M12 12v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/skip-forward.js
  var SkipForward = [
    ["polygon", { points: "5 4 15 12 5 20 5 4" }],
    ["line", { x1: "19", x2: "19", y1: "5", y2: "19" }]
  ];

  // node_modules/lucide/dist/esm/icons/skip-back.js
  var SkipBack = [
    ["polygon", { points: "19 20 9 12 19 4 19 20" }],
    ["line", { x1: "5", x2: "5", y1: "19", y2: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/skull.js
  var Skull = [
    ["path", { d: "m12.5 17-.5-1-.5 1h1z" }],
    [
      "path",
      {
        d: "M15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20v1a1 1 0 0 0 1 1z"
      }
    ],
    ["circle", { cx: "15", cy: "12", r: "1" }],
    ["circle", { cx: "9", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/slack.js
  var Slack = [
    ["rect", { width: "3", height: "8", x: "13", y: "2", rx: "1.5" }],
    ["path", { d: "M19 8.5V10h1.5A1.5 1.5 0 1 0 19 8.5" }],
    ["rect", { width: "3", height: "8", x: "8", y: "14", rx: "1.5" }],
    ["path", { d: "M5 15.5V14H3.5A1.5 1.5 0 1 0 5 15.5" }],
    ["rect", { width: "8", height: "3", x: "14", y: "13", rx: "1.5" }],
    ["path", { d: "M15.5 19H14v1.5a1.5 1.5 0 1 0 1.5-1.5" }],
    ["rect", { width: "8", height: "3", x: "2", y: "8", rx: "1.5" }],
    ["path", { d: "M8.5 5H10V3.5A1.5 1.5 0 1 0 8.5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/slash.js
  var Slash = [["path", { d: "M22 2 2 22" }]];

  // node_modules/lucide/dist/esm/icons/slice.js
  var Slice2 = [
    [
      "path",
      {
        d: "M11 16.586V19a1 1 0 0 1-1 1H2L18.37 3.63a1 1 0 1 1 3 3l-9.663 9.663a1 1 0 0 1-1.414 0L8 14"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/sliders-horizontal.js
  var SlidersHorizontal = [
    ["line", { x1: "21", x2: "14", y1: "4", y2: "4" }],
    ["line", { x1: "10", x2: "3", y1: "4", y2: "4" }],
    ["line", { x1: "21", x2: "12", y1: "12", y2: "12" }],
    ["line", { x1: "8", x2: "3", y1: "12", y2: "12" }],
    ["line", { x1: "21", x2: "16", y1: "20", y2: "20" }],
    ["line", { x1: "12", x2: "3", y1: "20", y2: "20" }],
    ["line", { x1: "14", x2: "14", y1: "2", y2: "6" }],
    ["line", { x1: "8", x2: "8", y1: "10", y2: "14" }],
    ["line", { x1: "16", x2: "16", y1: "18", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/sliders-vertical.js
  var SlidersVertical = [
    ["line", { x1: "4", x2: "4", y1: "21", y2: "14" }],
    ["line", { x1: "4", x2: "4", y1: "10", y2: "3" }],
    ["line", { x1: "12", x2: "12", y1: "21", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "3" }],
    ["line", { x1: "20", x2: "20", y1: "21", y2: "16" }],
    ["line", { x1: "20", x2: "20", y1: "12", y2: "3" }],
    ["line", { x1: "2", x2: "6", y1: "14", y2: "14" }],
    ["line", { x1: "10", x2: "14", y1: "8", y2: "8" }],
    ["line", { x1: "18", x2: "22", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/smartphone-charging.js
  var SmartphoneCharging = [
    ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2", ry: "2" }],
    ["path", { d: "M12.667 8 10 12h4l-2.667 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/smartphone-nfc.js
  var SmartphoneNfc = [
    ["rect", { width: "7", height: "12", x: "2", y: "6", rx: "1" }],
    ["path", { d: "M13 8.32a7.43 7.43 0 0 1 0 7.36" }],
    ["path", { d: "M16.46 6.21a11.76 11.76 0 0 1 0 11.58" }],
    ["path", { d: "M19.91 4.1a15.91 15.91 0 0 1 .01 15.8" }]
  ];

  // node_modules/lucide/dist/esm/icons/smartphone.js
  var Smartphone = [
    ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2", ry: "2" }],
    ["path", { d: "M12 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/smile-plus.js
  var SmilePlus = [
    ["path", { d: "M22 11v1a10 10 0 1 1-9-10" }],
    ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2" }],
    ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9" }],
    ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9" }],
    ["path", { d: "M16 5h6" }],
    ["path", { d: "M19 2v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/smile.js
  var Smile = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2" }],
    ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9" }],
    ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/snail.js
  var Snail = [
    ["path", { d: "M2 13a6 6 0 1 0 12 0 4 4 0 1 0-8 0 2 2 0 0 0 4 0" }],
    ["circle", { cx: "10", cy: "13", r: "8" }],
    ["path", { d: "M2 21h12c4.4 0 8-3.6 8-8V7a2 2 0 1 0-4 0v6" }],
    ["path", { d: "M18 3 19.1 5.2" }],
    ["path", { d: "M22 3 20.9 5.2" }]
  ];

  // node_modules/lucide/dist/esm/icons/snowflake.js
  var Snowflake = [
    ["path", { d: "m10 20-1.25-2.5L6 18" }],
    ["path", { d: "M10 4 8.75 6.5 6 6" }],
    ["path", { d: "m14 20 1.25-2.5L18 18" }],
    ["path", { d: "m14 4 1.25 2.5L18 6" }],
    ["path", { d: "m17 21-3-6h-4" }],
    ["path", { d: "m17 3-3 6 1.5 3" }],
    ["path", { d: "M2 12h6.5L10 9" }],
    ["path", { d: "m20 10-1.5 2 1.5 2" }],
    ["path", { d: "M22 12h-6.5L14 15" }],
    ["path", { d: "m4 10 1.5 2L4 14" }],
    ["path", { d: "m7 21 3-6-1.5-3" }],
    ["path", { d: "m7 3 3 6h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/soap-dispenser-droplet.js
  var SoapDispenserDroplet = [
    ["path", { d: "M10.5 2v4" }],
    ["path", { d: "M14 2H7a2 2 0 0 0-2 2" }],
    [
      "path",
      {
        d: "M19.29 14.76A6.67 6.67 0 0 1 17 11a6.6 6.6 0 0 1-2.29 3.76c-1.15.92-1.71 2.04-1.71 3.19 0 2.22 1.8 4.05 4 4.05s4-1.83 4-4.05c0-1.16-.57-2.26-1.71-3.19"
      }
    ],
    ["path", { d: "M9.607 21H6a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h7V7a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/sofa.js
  var Sofa = [
    ["path", { d: "M20 9V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v3" }],
    [
      "path",
      {
        d: "M2 16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-5a2 2 0 0 0-4 0v1.5a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5V11a2 2 0 0 0-4 0z"
      }
    ],
    ["path", { d: "M4 18v2" }],
    ["path", { d: "M20 18v2" }],
    ["path", { d: "M12 4v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/soup.js
  var Soup = [
    ["path", { d: "M12 21a9 9 0 0 0 9-9H3a9 9 0 0 0 9 9Z" }],
    ["path", { d: "M7 21h10" }],
    ["path", { d: "M19.5 12 22 6" }],
    ["path", { d: "M16.25 3c.27.1.8.53.75 1.36-.06.83-.93 1.2-1 2.02-.05.78.34 1.24.73 1.62" }],
    ["path", { d: "M11.25 3c.27.1.8.53.74 1.36-.05.83-.93 1.2-.98 2.02-.06.78.33 1.24.72 1.62" }],
    ["path", { d: "M6.25 3c.27.1.8.53.75 1.36-.06.83-.93 1.2-1 2.02-.05.78.34 1.24.74 1.62" }]
  ];

  // node_modules/lucide/dist/esm/icons/space.js
  var Space = [["path", { d: "M22 17v1c0 .5-.5 1-1 1H3c-.5 0-1-.5-1-1v-1" }]];

  // node_modules/lucide/dist/esm/icons/spade.js
  var Spade = [
    [
      "path",
      {
        d: "M5 9c-1.5 1.5-3 3.2-3 5.5A5.5 5.5 0 0 0 7.5 20c1.8 0 3-.5 4.5-2 1.5 1.5 2.7 2 4.5 2a5.5 5.5 0 0 0 5.5-5.5c0-2.3-1.5-4-3-5.5l-7-7-7 7Z"
      }
    ],
    ["path", { d: "M12 18v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/sparkles.js
  var Sparkles = [
    [
      "path",
      {
        d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"
      }
    ],
    ["path", { d: "M20 3v4" }],
    ["path", { d: "M22 5h-4" }],
    ["path", { d: "M4 17v2" }],
    ["path", { d: "M5 18H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/sparkle.js
  var Sparkle = [
    [
      "path",
      {
        d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/speaker.js
  var Speaker = [
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2" }],
    ["path", { d: "M12 6h.01" }],
    ["circle", { cx: "12", cy: "14", r: "4" }],
    ["path", { d: "M12 14h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/speech.js
  var Speech = [
    [
      "path",
      {
        d: "M8.8 20v-4.1l1.9.2a2.3 2.3 0 0 0 2.164-2.1V8.3A5.37 5.37 0 0 0 2 8.25c0 2.8.656 3.054 1 4.55a5.77 5.77 0 0 1 .029 2.758L2 20"
      }
    ],
    ["path", { d: "M19.8 17.8a7.5 7.5 0 0 0 .003-10.603" }],
    ["path", { d: "M17 15a3.5 3.5 0 0 0-.025-4.975" }]
  ];

  // node_modules/lucide/dist/esm/icons/spell-check-2.js
  var SpellCheck2 = [
    ["path", { d: "m6 16 6-12 6 12" }],
    ["path", { d: "M8 12h8" }],
    [
      "path",
      {
        d: "M4 21c1.1 0 1.1-1 2.3-1s1.1 1 2.3 1c1.1 0 1.1-1 2.3-1 1.1 0 1.1 1 2.3 1 1.1 0 1.1-1 2.3-1 1.1 0 1.1 1 2.3 1 1.1 0 1.1-1 2.3-1"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/spline-pointer.js
  var SplinePointer = [
    [
      "path",
      {
        d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z"
      }
    ],
    ["path", { d: "M5 17A12 12 0 0 1 17 5" }],
    ["circle", { cx: "19", cy: "5", r: "2" }],
    ["circle", { cx: "5", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/split.js
  var Split = [
    ["path", { d: "M16 3h5v5" }],
    ["path", { d: "M8 3H3v5" }],
    ["path", { d: "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3" }],
    ["path", { d: "m15 9 6-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/spell-check.js
  var SpellCheck = [
    ["path", { d: "m6 16 6-12 6 12" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "m16 20 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/spline.js
  var Spline = [
    ["circle", { cx: "19", cy: "5", r: "2" }],
    ["circle", { cx: "5", cy: "19", r: "2" }],
    ["path", { d: "M5 17A12 12 0 0 1 17 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/sprout.js
  var Sprout = [
    ["path", { d: "M7 20h10" }],
    ["path", { d: "M10 20c5.5-2.5.8-6.4 3-10" }],
    [
      "path",
      {
        d: "M9.5 9.4c1.1.8 1.8 2.2 2.3 3.7-2 .4-3.5.4-4.8-.3-1.2-.6-2.3-1.9-3-4.2 2.8-.5 4.4 0 5.5.8z"
      }
    ],
    [
      "path",
      { d: "M14.1 6a7 7 0 0 0-1.1 4c1.9-.1 3.3-.6 4.3-1.4 1-1 1.6-2.3 1.7-4.6-2.7.1-4 1-4.9 2z" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/spray-can.js
  var SprayCan = [
    ["path", { d: "M3 3h.01" }],
    ["path", { d: "M7 5h.01" }],
    ["path", { d: "M11 7h.01" }],
    ["path", { d: "M3 7h.01" }],
    ["path", { d: "M7 9h.01" }],
    ["path", { d: "M3 11h.01" }],
    ["rect", { width: "4", height: "4", x: "15", y: "5" }],
    ["path", { d: "m19 9 2 2v10c0 .6-.4 1-1 1h-6c-.6 0-1-.4-1-1V11l2-2" }],
    ["path", { d: "m13 14 8-2" }],
    ["path", { d: "m13 19 8-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-activity.js
  var SquareActivity = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M17 12h-2l-2 5-2-10-2 5H7" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-down-left.js
  var SquareArrowDownLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m16 8-8 8" }],
    ["path", { d: "M16 16H8V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-down-right.js
  var SquareArrowDownRight = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m8 8 8 8" }],
    ["path", { d: "M16 8v8H8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-down.js
  var SquareArrowDown = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M12 8v8" }],
    ["path", { d: "m8 12 4 4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-left.js
  var SquareArrowLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m12 8-4 4 4 4" }],
    ["path", { d: "M16 12H8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-out-down-left.js
  var SquareArrowOutDownLeft = [
    ["path", { d: "M13 21h6a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v6" }],
    ["path", { d: "m3 21 9-9" }],
    ["path", { d: "M9 21H3v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-out-up-left.js
  var SquareArrowOutUpLeft = [
    ["path", { d: "M13 3h6a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6" }],
    ["path", { d: "m3 3 9 9" }],
    ["path", { d: "M3 9V3h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-out-up-right.js
  var SquareArrowOutUpRight = [
    ["path", { d: "M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6" }],
    ["path", { d: "m21 3-9 9" }],
    ["path", { d: "M15 3h6v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-out-down-right.js
  var SquareArrowOutDownRight = [
    ["path", { d: "M21 11V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6" }],
    ["path", { d: "m21 21-9-9" }],
    ["path", { d: "M21 15v6h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-right.js
  var SquareArrowRight = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "m12 16 4-4-4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-up-left.js
  var SquareArrowUpLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 16V8h8" }],
    ["path", { d: "M16 16 8 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-up-right.js
  var SquareArrowUpRight = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 8h8v8" }],
    ["path", { d: "m8 16 8-8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-arrow-up.js
  var SquareArrowUp = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m16 12-4-4-4 4" }],
    ["path", { d: "M12 16V8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-asterisk.js
  var SquareAsterisk = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M12 8v8" }],
    ["path", { d: "m8.5 14 7-4" }],
    ["path", { d: "m8.5 10 7 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-bottom-dashed-scissors.js
  var SquareBottomDashedScissors = [
    ["path", { d: "M4 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2" }],
    ["path", { d: "M10 22H8" }],
    ["path", { d: "M16 22h-2" }],
    ["circle", { cx: "8", cy: "8", r: "2" }],
    ["path", { d: "M9.414 9.414 12 12" }],
    ["path", { d: "M14.8 14.8 18 18" }],
    ["circle", { cx: "8", cy: "16", r: "2" }],
    ["path", { d: "m18 6-8.586 8.586" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-chart-gantt.js
  var SquareChartGantt = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 8h7" }],
    ["path", { d: "M8 12h6" }],
    ["path", { d: "M11 16h5" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-check-big.js
  var SquareCheckBig = [
    ["path", { d: "M21 10.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.5" }],
    ["path", { d: "m9 11 3 3L22 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-check.js
  var SquareCheck = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m9 12 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-chevron-down.js
  var SquareChevronDown = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m16 10-4 4-4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-chevron-left.js
  var SquareChevronLeft = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m14 16-4-4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-chevron-right.js
  var SquareChevronRight = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m10 8 4 4-4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-chevron-up.js
  var SquareChevronUp = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m8 14 4-4 4 4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-code.js
  var SquareCode = [
    ["path", { d: "M10 9.5 8 12l2 2.5" }],
    ["path", { d: "m14 9.5 2 2.5-2 2.5" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dashed-bottom.js
  var SquareDashedBottom = [
    ["path", { d: "M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2" }],
    ["path", { d: "M9 21h1" }],
    ["path", { d: "M14 21h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dashed-bottom-code.js
  var SquareDashedBottomCode = [
    ["path", { d: "M10 9.5 8 12l2 2.5" }],
    ["path", { d: "M14 21h1" }],
    ["path", { d: "m14 9.5 2 2.5-2 2.5" }],
    ["path", { d: "M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2" }],
    ["path", { d: "M9 21h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dashed-kanban.js
  var SquareDashedKanban = [
    ["path", { d: "M8 7v7" }],
    ["path", { d: "M12 7v4" }],
    ["path", { d: "M16 7v9" }],
    ["path", { d: "M5 3a2 2 0 0 0-2 2" }],
    ["path", { d: "M9 3h1" }],
    ["path", { d: "M14 3h1" }],
    ["path", { d: "M19 3a2 2 0 0 1 2 2" }],
    ["path", { d: "M21 9v1" }],
    ["path", { d: "M21 14v1" }],
    ["path", { d: "M21 19a2 2 0 0 1-2 2" }],
    ["path", { d: "M14 21h1" }],
    ["path", { d: "M9 21h1" }],
    ["path", { d: "M5 21a2 2 0 0 1-2-2" }],
    ["path", { d: "M3 14v1" }],
    ["path", { d: "M3 9v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dashed-mouse-pointer.js
  var SquareDashedMousePointer = [
    [
      "path",
      {
        d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z"
      }
    ],
    ["path", { d: "M5 3a2 2 0 0 0-2 2" }],
    ["path", { d: "M19 3a2 2 0 0 1 2 2" }],
    ["path", { d: "M5 21a2 2 0 0 1-2-2" }],
    ["path", { d: "M9 3h1" }],
    ["path", { d: "M9 21h2" }],
    ["path", { d: "M14 3h1" }],
    ["path", { d: "M3 9v1" }],
    ["path", { d: "M21 9v2" }],
    ["path", { d: "M3 14v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dashed.js
  var SquareDashed = [
    ["path", { d: "M5 3a2 2 0 0 0-2 2" }],
    ["path", { d: "M19 3a2 2 0 0 1 2 2" }],
    ["path", { d: "M21 19a2 2 0 0 1-2 2" }],
    ["path", { d: "M5 21a2 2 0 0 1-2-2" }],
    ["path", { d: "M9 3h1" }],
    ["path", { d: "M9 21h1" }],
    ["path", { d: "M14 3h1" }],
    ["path", { d: "M14 21h1" }],
    ["path", { d: "M3 9v1" }],
    ["path", { d: "M21 9v1" }],
    ["path", { d: "M3 14v1" }],
    ["path", { d: "M21 14v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-divide.js
  var SquareDivide = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["line", { x1: "8", x2: "16", y1: "12", y2: "12" }],
    ["line", { x1: "12", x2: "12", y1: "16", y2: "16" }],
    ["line", { x1: "12", x2: "12", y1: "8", y2: "8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-dot.js
  var SquareDot = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["circle", { cx: "12", cy: "12", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-equal.js
  var SquareEqual = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 10h10" }],
    ["path", { d: "M7 14h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-function.js
  var SquareFunction = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "M9 17c2 0 2.8-1 2.8-2.8V10c0-2 1-3.3 3.2-3" }],
    ["path", { d: "M9 11.2h5.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-kanban.js
  var SquareKanban = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 7v7" }],
    ["path", { d: "M12 7v4" }],
    ["path", { d: "M16 7v9" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-library.js
  var SquareLibrary = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 7v10" }],
    ["path", { d: "M11 7v10" }],
    ["path", { d: "m15 7 2 10" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-m.js
  var SquareM = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 16V8l4 4 4-4v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-menu.js
  var SquareMenu = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 8h10" }],
    ["path", { d: "M7 12h10" }],
    ["path", { d: "M7 16h10" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-minus.js
  var SquareMinus = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 12h8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-mouse-pointer.js
  var SquareMousePointer = [
    [
      "path",
      {
        d: "M12.034 12.681a.498.498 0 0 1 .647-.647l9 3.5a.5.5 0 0 1-.033.943l-3.444 1.068a1 1 0 0 0-.66.66l-1.067 3.443a.5.5 0 0 1-.943.033z"
      }
    ],
    ["path", { d: "M21 11V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-parking-off.js
  var SquareParkingOff = [
    ["path", { d: "M3.6 3.6A2 2 0 0 1 5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1-.59 1.41" }],
    ["path", { d: "M3 8.7V19a2 2 0 0 0 2 2h10.3" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M13 13a3 3 0 1 0 0-6H9v2" }],
    ["path", { d: "M9 17v-2.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-parking.js
  var SquareParking = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M9 17V7h4a3 3 0 0 1 0 6H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-pen.js
  var SquarePen = [
    ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }],
    [
      "path",
      {
        d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/square-percent.js
  var SquarePercent = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "M9 9h.01" }],
    ["path", { d: "M15 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-pi.js
  var SquarePi = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 7h10" }],
    ["path", { d: "M10 7v10" }],
    ["path", { d: "M16 17a2 2 0 0 1-2-2V7" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-pilcrow.js
  var SquarePilcrow = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M12 12H9.5a2.5 2.5 0 0 1 0-5H17" }],
    ["path", { d: "M12 7v10" }],
    ["path", { d: "M16 7v10" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-play.js
  var SquarePlay = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "m9 8 6 4-6 4Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-plus.js
  var SquarePlus = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M8 12h8" }],
    ["path", { d: "M12 8v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-power.js
  var SquarePower = [
    ["path", { d: "M12 7v4" }],
    ["path", { d: "M7.998 9.003a5 5 0 1 0 8-.005" }],
    ["rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-radical.js
  var SquareRadical = [
    ["path", { d: "M7 12h2l2 5 2-10h4" }],
    ["rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-round-corner.js
  var SquareRoundCorner = [
    ["path", { d: "M21 11a8 8 0 0 0-8-8" }],
    ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-scissors.js
  var SquareScissors = [
    ["rect", { width: "20", height: "20", x: "2", y: "2", rx: "2" }],
    ["circle", { cx: "8", cy: "8", r: "2" }],
    ["path", { d: "M9.414 9.414 12 12" }],
    ["path", { d: "M14.8 14.8 18 18" }],
    ["circle", { cx: "8", cy: "16", r: "2" }],
    ["path", { d: "m18 6-8.586 8.586" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-sigma.js
  var SquareSigma = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M16 8.9V7H8l4 5-4 5h8v-1.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-slash.js
  var SquareSlash = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["line", { x1: "9", x2: "15", y1: "15", y2: "9" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-split-horizontal.js
  var SquareSplitHorizontal = [
    ["path", { d: "M8 19H5c-1 0-2-1-2-2V7c0-1 1-2 2-2h3" }],
    ["path", { d: "M16 5h3c1 0 2 1 2 2v10c0 1-1 2-2 2h-3" }],
    ["line", { x1: "12", x2: "12", y1: "4", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-split-vertical.js
  var SquareSplitVertical = [
    ["path", { d: "M5 8V5c0-1 1-2 2-2h10c1 0 2 1 2 2v3" }],
    ["path", { d: "M19 16v3c0 1-1 2-2 2H7c-1 0-2-1-2-2v-3" }],
    ["line", { x1: "4", x2: "20", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-square.js
  var SquareSquare = [
    ["rect", { x: "3", y: "3", width: "18", height: "18", rx: "2" }],
    ["rect", { x: "8", y: "8", width: "8", height: "8", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-stack.js
  var SquareStack = [
    ["path", { d: "M4 10c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2" }],
    ["path", { d: "M10 16c-1.1 0-2-.9-2-2v-4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2" }],
    ["rect", { width: "8", height: "8", x: "14", y: "14", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-user-round.js
  var SquareUserRound = [
    ["path", { d: "M18 21a6 6 0 0 0-12 0" }],
    ["circle", { cx: "12", cy: "11", r: "4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-terminal.js
  var SquareTerminal = [
    ["path", { d: "m7 11 2-2-2-2" }],
    ["path", { d: "M11 13h4" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-x.js
  var SquareX = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "m9 9 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/square-user.js
  var SquareUser = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "M7 21v-2a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/square.js
  var Square = [["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }]];

  // node_modules/lucide/dist/esm/icons/squares-exclude.js
  var SquaresExclude = [
    [
      "path",
      {
        d: "M16 12v2a2 2 0 0 1-2 2H9a1 1 0 0 0-1 1v3a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2h0"
      }
    ],
    [
      "path",
      {
        d: "M4 16a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v3a1 1 0 0 1-1 1h-5a2 2 0 0 0-2 2v2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/squares-intersect.js
  var SquaresIntersect = [
    ["path", { d: "M10 22a2 2 0 0 1-2-2" }],
    ["path", { d: "M14 2a2 2 0 0 1 2 2" }],
    ["path", { d: "M16 22h-2" }],
    ["path", { d: "M2 10V8" }],
    ["path", { d: "M2 4a2 2 0 0 1 2-2" }],
    ["path", { d: "M20 8a2 2 0 0 1 2 2" }],
    ["path", { d: "M22 14v2" }],
    ["path", { d: "M22 20a2 2 0 0 1-2 2" }],
    ["path", { d: "M4 16a2 2 0 0 1-2-2" }],
    ["path", { d: "M8 10a2 2 0 0 1 2-2h5a1 1 0 0 1 1 1v5a2 2 0 0 1-2 2H9a1 1 0 0 1-1-1z" }],
    ["path", { d: "M8 2h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/squares-subtract.js
  var SquaresSubtract = [
    ["path", { d: "M10 22a2 2 0 0 1-2-2" }],
    ["path", { d: "M16 22h-2" }],
    [
      "path",
      {
        d: "M16 4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h3a1 1 0 0 0 1-1v-5a2 2 0 0 1 2-2h5a1 1 0 0 0 1-1z"
      }
    ],
    ["path", { d: "M20 8a2 2 0 0 1 2 2" }],
    ["path", { d: "M22 14v2" }],
    ["path", { d: "M22 20a2 2 0 0 1-2 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/squares-unite.js
  var SquaresUnite = [
    [
      "path",
      {
        d: "M4 16a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v3a1 1 0 0 0 1 1h3a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-3a1 1 0 0 0-1-1z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/squircle.js
  var Squircle = [
    ["path", { d: "M12 3c7.2 0 9 1.8 9 9s-1.8 9-9 9-9-1.8-9-9 1.8-9 9-9" }]
  ];

  // node_modules/lucide/dist/esm/icons/squirrel.js
  var Squirrel = [
    ["path", { d: "M15.236 22a3 3 0 0 0-2.2-5" }],
    ["path", { d: "M16 20a3 3 0 0 1 3-3h1a2 2 0 0 0 2-2v-2a4 4 0 0 0-4-4V4" }],
    ["path", { d: "M18 13h.01" }],
    [
      "path",
      {
        d: "M18 6a4 4 0 0 0-4 4 7 7 0 0 0-7 7c0-5 4-5 4-10.5a4.5 4.5 0 1 0-9 0 2.5 2.5 0 0 0 5 0C7 10 3 11 3 17c0 2.8 2.2 5 5 5h10"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/stamp.js
  var Stamp = [
    ["path", { d: "M5 22h14" }],
    [
      "path",
      {
        d: "M19.27 13.73A2.5 2.5 0 0 0 17.5 13h-11A2.5 2.5 0 0 0 4 15.5V17a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-1.5c0-.66-.26-1.3-.73-1.77Z"
      }
    ],
    ["path", { d: "M14 13V8.5C14 7 15 7 15 5a3 3 0 0 0-3-3c-1.66 0-3 1-3 3s1 2 1 3.5V13" }]
  ];

  // node_modules/lucide/dist/esm/icons/star-half.js
  var StarHalf = [
    [
      "path",
      {
        d: "M12 18.338a2.1 2.1 0 0 0-.987.244L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.12 2.12 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.12 2.12 0 0 0 1.597-1.16l2.309-4.679A.53.53 0 0 1 12 2"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/star-off.js
  var StarOff = [
    ["path", { d: "M8.34 8.34 2 9.27l5 4.87L5.82 21 12 17.77 18.18 21l-.59-3.43" }],
    ["path", { d: "M18.42 12.76 22 9.27l-6.91-1L12 2l-1.44 2.91" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/star.js
  var Star = [
    [
      "path",
      {
        d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/step-back.js
  var StepBack = [
    ["line", { x1: "18", x2: "18", y1: "20", y2: "4" }],
    ["polygon", { points: "14,20 4,12 14,4" }]
  ];

  // node_modules/lucide/dist/esm/icons/step-forward.js
  var StepForward = [
    ["line", { x1: "6", x2: "6", y1: "4", y2: "20" }],
    ["polygon", { points: "10,4 20,12 10,20" }]
  ];

  // node_modules/lucide/dist/esm/icons/sticker.js
  var Sticker = [
    ["path", { d: "M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z" }],
    ["path", { d: "M14 3v4a2 2 0 0 0 2 2h4" }],
    ["path", { d: "M8 13h.01" }],
    ["path", { d: "M16 13h.01" }],
    ["path", { d: "M10 16s.8 1 2 1c1.3 0 2-1 2-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/stethoscope.js
  var Stethoscope = [
    ["path", { d: "M11 2v2" }],
    ["path", { d: "M5 2v2" }],
    ["path", { d: "M5 3H4a2 2 0 0 0-2 2v4a6 6 0 0 0 12 0V5a2 2 0 0 0-2-2h-1" }],
    ["path", { d: "M8 15a6 6 0 0 0 12 0v-3" }],
    ["circle", { cx: "20", cy: "10", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/sticky-note.js
  var StickyNote = [
    ["path", { d: "M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z" }],
    ["path", { d: "M15 3v4a2 2 0 0 0 2 2h4" }]
  ];

  // node_modules/lucide/dist/esm/icons/store.js
  var Store = [
    ["path", { d: "m2 7 4.41-4.41A2 2 0 0 1 7.83 2h8.34a2 2 0 0 1 1.42.59L22 7" }],
    ["path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8" }],
    ["path", { d: "M15 22v-4a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v4" }],
    ["path", { d: "M2 7h20" }],
    [
      "path",
      {
        d: "M22 7v3a2 2 0 0 1-2 2a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 16 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 12 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 8 12a2.7 2.7 0 0 1-1.59-.63.7.7 0 0 0-.82 0A2.7 2.7 0 0 1 4 12a2 2 0 0 1-2-2V7"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/stretch-horizontal.js
  var StretchHorizontal = [
    ["rect", { width: "20", height: "6", x: "2", y: "4", rx: "2" }],
    ["rect", { width: "20", height: "6", x: "2", y: "14", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/stretch-vertical.js
  var StretchVertical = [
    ["rect", { width: "6", height: "20", x: "4", y: "2", rx: "2" }],
    ["rect", { width: "6", height: "20", x: "14", y: "2", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/strikethrough.js
  var Strikethrough = [
    ["path", { d: "M16 4H9a3 3 0 0 0-2.83 4" }],
    ["path", { d: "M14 12a4 4 0 0 1 0 8H6" }],
    ["line", { x1: "4", x2: "20", y1: "12", y2: "12" }]
  ];

  // node_modules/lucide/dist/esm/icons/subscript.js
  var Subscript = [
    ["path", { d: "m4 5 8 8" }],
    ["path", { d: "m12 5-8 8" }],
    [
      "path",
      {
        d: "M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/sun-dim.js
  var SunDim = [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M12 4h.01" }],
    ["path", { d: "M20 12h.01" }],
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M4 12h.01" }],
    ["path", { d: "M17.657 6.343h.01" }],
    ["path", { d: "M17.657 17.657h.01" }],
    ["path", { d: "M6.343 17.657h.01" }],
    ["path", { d: "M6.343 6.343h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/sun-medium.js
  var SunMedium = [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M12 3v1" }],
    ["path", { d: "M12 20v1" }],
    ["path", { d: "M3 12h1" }],
    ["path", { d: "M20 12h1" }],
    ["path", { d: "m18.364 5.636-.707.707" }],
    ["path", { d: "m6.343 17.657-.707.707" }],
    ["path", { d: "m5.636 5.636.707.707" }],
    ["path", { d: "m17.657 17.657.707.707" }]
  ];

  // node_modules/lucide/dist/esm/icons/sun-moon.js
  var SunMoon = [
    ["path", { d: "M12 8a2.83 2.83 0 0 0 4 4 4 4 0 1 1-4-4" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "m4.9 4.9 1.4 1.4" }],
    ["path", { d: "m17.7 17.7 1.4 1.4" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "m6.3 17.7-1.4 1.4" }],
    ["path", { d: "m19.1 4.9-1.4 1.4" }]
  ];

  // node_modules/lucide/dist/esm/icons/sun.js
  var Sun = [
    ["circle", { cx: "12", cy: "12", r: "4" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "m4.93 4.93 1.41 1.41" }],
    ["path", { d: "m17.66 17.66 1.41 1.41" }],
    ["path", { d: "M2 12h2" }],
    ["path", { d: "M20 12h2" }],
    ["path", { d: "m6.34 17.66-1.41 1.41" }],
    ["path", { d: "m19.07 4.93-1.41 1.41" }]
  ];

  // node_modules/lucide/dist/esm/icons/sunrise.js
  var Sunrise = [
    ["path", { d: "M12 2v8" }],
    ["path", { d: "m4.93 10.93 1.41 1.41" }],
    ["path", { d: "M2 18h2" }],
    ["path", { d: "M20 18h2" }],
    ["path", { d: "m19.07 10.93-1.41 1.41" }],
    ["path", { d: "M22 22H2" }],
    ["path", { d: "m8 6 4-4 4 4" }],
    ["path", { d: "M16 18a4 4 0 0 0-8 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/sun-snow.js
  var SunSnow = [
    ["path", { d: "M10 21v-1" }],
    ["path", { d: "M10 4V3" }],
    ["path", { d: "M10 9a3 3 0 0 0 0 6" }],
    ["path", { d: "m14 20 1.25-2.5L18 18" }],
    ["path", { d: "m14 4 1.25 2.5L18 6" }],
    ["path", { d: "m17 21-3-6 1.5-3H22" }],
    ["path", { d: "m17 3-3 6 1.5 3" }],
    ["path", { d: "M2 12h1" }],
    ["path", { d: "m20 10-1.5 2 1.5 2" }],
    ["path", { d: "m3.64 18.36.7-.7" }],
    ["path", { d: "m4.34 6.34-.7-.7" }]
  ];

  // node_modules/lucide/dist/esm/icons/sunset.js
  var Sunset = [
    ["path", { d: "M12 10V2" }],
    ["path", { d: "m4.93 10.93 1.41 1.41" }],
    ["path", { d: "M2 18h2" }],
    ["path", { d: "M20 18h2" }],
    ["path", { d: "m19.07 10.93-1.41 1.41" }],
    ["path", { d: "M22 22H2" }],
    ["path", { d: "m16 6-4 4-4-4" }],
    ["path", { d: "M16 18a4 4 0 0 0-8 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/superscript.js
  var Superscript = [
    ["path", { d: "m4 19 8-8" }],
    ["path", { d: "m12 19-8-8" }],
    [
      "path",
      {
        d: "M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/swatch-book.js
  var SwatchBook = [
    ["path", { d: "M11 17a4 4 0 0 1-8 0V5a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2Z" }],
    ["path", { d: "M16.7 13H19a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2H7" }],
    ["path", { d: "M 7 17h.01" }],
    [
      "path",
      { d: "m11 8 2.3-2.3a2.4 2.4 0 0 1 3.404.004L18.6 7.6a2.4 2.4 0 0 1 .026 3.434L9.9 19.8" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/switch-camera.js
  var SwitchCamera = [
    ["path", { d: "M11 19H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h5" }],
    ["path", { d: "M13 5h7a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-5" }],
    ["circle", { cx: "12", cy: "12", r: "3" }],
    ["path", { d: "m18 22-3-3 3-3" }],
    ["path", { d: "m6 2 3 3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/sword.js
  var Sword = [
    ["polyline", { points: "14.5 17.5 3 6 3 3 6 3 17.5 14.5" }],
    ["line", { x1: "13", x2: "19", y1: "19", y2: "13" }],
    ["line", { x1: "16", x2: "20", y1: "16", y2: "20" }],
    ["line", { x1: "19", x2: "21", y1: "21", y2: "19" }]
  ];

  // node_modules/lucide/dist/esm/icons/swiss-franc.js
  var SwissFranc = [
    ["path", { d: "M10 21V3h8" }],
    ["path", { d: "M6 16h9" }],
    ["path", { d: "M10 9.5h7" }]
  ];

  // node_modules/lucide/dist/esm/icons/swords.js
  var Swords = [
    ["polyline", { points: "14.5 17.5 3 6 3 3 6 3 17.5 14.5" }],
    ["line", { x1: "13", x2: "19", y1: "19", y2: "13" }],
    ["line", { x1: "16", x2: "20", y1: "16", y2: "20" }],
    ["line", { x1: "19", x2: "21", y1: "21", y2: "19" }],
    ["polyline", { points: "14.5 6.5 18 3 21 3 21 6 17.5 9.5" }],
    ["line", { x1: "5", x2: "9", y1: "14", y2: "18" }],
    ["line", { x1: "7", x2: "4", y1: "17", y2: "20" }],
    ["line", { x1: "3", x2: "5", y1: "19", y2: "21" }]
  ];

  // node_modules/lucide/dist/esm/icons/syringe.js
  var Syringe = [
    ["path", { d: "m18 2 4 4" }],
    ["path", { d: "m17 7 3-3" }],
    ["path", { d: "M19 9 8.7 19.3c-1 1-2.5 1-3.4 0l-.6-.6c-1-1-1-2.5 0-3.4L15 5" }],
    ["path", { d: "m9 11 4 4" }],
    ["path", { d: "m5 19-3 3" }],
    ["path", { d: "m14 4 6 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-2.js
  var Table2 = [
    [
      "path",
      {
        d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/table-cells-merge.js
  var TableCellsMerge = [
    ["path", { d: "M12 21v-6" }],
    ["path", { d: "M12 9V3" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "M3 9h18" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-cells-split.js
  var TableCellsSplit = [
    ["path", { d: "M12 15V9" }],
    ["path", { d: "M3 15h18" }],
    ["path", { d: "M3 9h18" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-columns-split.js
  var TableColumnsSplit = [
    ["path", { d: "M14 14v2" }],
    ["path", { d: "M14 20v2" }],
    ["path", { d: "M14 2v2" }],
    ["path", { d: "M14 8v2" }],
    ["path", { d: "M2 15h8" }],
    ["path", { d: "M2 3h6a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H2" }],
    ["path", { d: "M2 9h8" }],
    ["path", { d: "M22 15h-4" }],
    ["path", { d: "M22 3h-2a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2" }],
    ["path", { d: "M22 9h-4" }],
    ["path", { d: "M5 3v18" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-of-contents.js
  var TableOfContents = [
    ["path", { d: "M16 12H3" }],
    ["path", { d: "M16 18H3" }],
    ["path", { d: "M16 6H3" }],
    ["path", { d: "M21 12h.01" }],
    ["path", { d: "M21 18h.01" }],
    ["path", { d: "M21 6h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-properties.js
  var TableProperties = [
    ["path", { d: "M15 3v18" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M21 9H3" }],
    ["path", { d: "M21 15H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/table-rows-split.js
  var TableRowsSplit = [
    ["path", { d: "M14 10h2" }],
    ["path", { d: "M15 22v-8" }],
    ["path", { d: "M15 2v4" }],
    ["path", { d: "M2 10h2" }],
    ["path", { d: "M20 10h2" }],
    ["path", { d: "M3 19h18" }],
    ["path", { d: "M3 22v-6a2 2 135 0 1 2-2h14a2 2 45 0 1 2 2v6" }],
    ["path", { d: "M3 2v2a2 2 45 0 0 2 2h14a2 2 135 0 0 2-2V2" }],
    ["path", { d: "M8 10h2" }],
    ["path", { d: "M9 22v-8" }],
    ["path", { d: "M9 2v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/table.js
  var Table3 = [
    ["path", { d: "M12 3v18" }],
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9h18" }],
    ["path", { d: "M3 15h18" }]
  ];

  // node_modules/lucide/dist/esm/icons/tablet-smartphone.js
  var TabletSmartphone = [
    ["rect", { width: "10", height: "14", x: "3", y: "8", rx: "2" }],
    ["path", { d: "M5 4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2h-2.4" }],
    ["path", { d: "M8 18h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/tablet.js
  var Tablet = [
    ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2" }],
    ["line", { x1: "12", x2: "12.01", y1: "18", y2: "18" }]
  ];

  // node_modules/lucide/dist/esm/icons/tag.js
  var Tag = [
    [
      "path",
      {
        d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"
      }
    ],
    ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor" }]
  ];

  // node_modules/lucide/dist/esm/icons/tags.js
  var Tags = [
    ["path", { d: "m15 5 6.3 6.3a2.4 2.4 0 0 1 0 3.4L17 19" }],
    [
      "path",
      {
        d: "M9.586 5.586A2 2 0 0 0 8.172 5H3a1 1 0 0 0-1 1v5.172a2 2 0 0 0 .586 1.414L8.29 18.29a2.426 2.426 0 0 0 3.42 0l3.58-3.58a2.426 2.426 0 0 0 0-3.42z"
      }
    ],
    ["circle", { cx: "6.5", cy: "9.5", r: ".5", fill: "currentColor" }]
  ];

  // node_modules/lucide/dist/esm/icons/tablets.js
  var Tablets = [
    ["circle", { cx: "7", cy: "7", r: "5" }],
    ["circle", { cx: "17", cy: "17", r: "5" }],
    ["path", { d: "M12 17h10" }],
    ["path", { d: "m3.46 10.54 7.08-7.08" }]
  ];

  // node_modules/lucide/dist/esm/icons/tally-1.js
  var Tally1 = [["path", { d: "M4 4v16" }]];

  // node_modules/lucide/dist/esm/icons/tally-2.js
  var Tally2 = [
    ["path", { d: "M4 4v16" }],
    ["path", { d: "M9 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/tally-3.js
  var Tally3 = [
    ["path", { d: "M4 4v16" }],
    ["path", { d: "M9 4v16" }],
    ["path", { d: "M14 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/tally-4.js
  var Tally4 = [
    ["path", { d: "M4 4v16" }],
    ["path", { d: "M9 4v16" }],
    ["path", { d: "M14 4v16" }],
    ["path", { d: "M19 4v16" }]
  ];

  // node_modules/lucide/dist/esm/icons/tally-5.js
  var Tally5 = [
    ["path", { d: "M4 4v16" }],
    ["path", { d: "M9 4v16" }],
    ["path", { d: "M14 4v16" }],
    ["path", { d: "M19 4v16" }],
    ["path", { d: "M22 6 2 18" }]
  ];

  // node_modules/lucide/dist/esm/icons/target.js
  var Target = [
    ["circle", { cx: "12", cy: "12", r: "10" }],
    ["circle", { cx: "12", cy: "12", r: "6" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tangent.js
  var Tangent = [
    ["circle", { cx: "17", cy: "4", r: "2" }],
    ["path", { d: "M15.59 5.41 5.41 15.59" }],
    ["circle", { cx: "4", cy: "17", r: "2" }],
    ["path", { d: "M12 22s-4-9-1.5-11.5S22 12 22 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/tent-tree.js
  var TentTree = [
    ["circle", { cx: "4", cy: "4", r: "2" }],
    ["path", { d: "m14 5 3-3 3 3" }],
    ["path", { d: "m14 10 3-3 3 3" }],
    ["path", { d: "M17 14V2" }],
    ["path", { d: "M17 14H7l-5 8h20Z" }],
    ["path", { d: "M8 14v8" }],
    ["path", { d: "m9 14 5 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/telescope.js
  var Telescope = [
    [
      "path",
      {
        d: "m10.065 12.493-6.18 1.318a.934.934 0 0 1-1.108-.702l-.537-2.15a1.07 1.07 0 0 1 .691-1.265l13.504-4.44"
      }
    ],
    ["path", { d: "m13.56 11.747 4.332-.924" }],
    ["path", { d: "m16 21-3.105-6.21" }],
    [
      "path",
      {
        d: "M16.485 5.94a2 2 0 0 1 1.455-2.425l1.09-.272a1 1 0 0 1 1.212.727l1.515 6.06a1 1 0 0 1-.727 1.213l-1.09.272a2 2 0 0 1-2.425-1.455z"
      }
    ],
    ["path", { d: "m6.158 8.633 1.114 4.456" }],
    ["path", { d: "m8 21 3.105-6.21" }],
    ["circle", { cx: "12", cy: "13", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tent.js
  var Tent = [
    ["path", { d: "M3.5 21 14 3" }],
    ["path", { d: "M20.5 21 10 3" }],
    ["path", { d: "M15.5 21 12 15l-3.5 6" }],
    ["path", { d: "M2 21h20" }]
  ];

  // node_modules/lucide/dist/esm/icons/terminal.js
  var Terminal = [
    ["polyline", { points: "4 17 10 11 4 5" }],
    ["line", { x1: "12", x2: "20", y1: "19", y2: "19" }]
  ];

  // node_modules/lucide/dist/esm/icons/test-tube-diagonal.js
  var TestTubeDiagonal = [
    ["path", { d: "M21 7 6.82 21.18a2.83 2.83 0 0 1-3.99-.01a2.83 2.83 0 0 1 0-4L17 3" }],
    ["path", { d: "m16 2 6 6" }],
    ["path", { d: "M12 16H4" }]
  ];

  // node_modules/lucide/dist/esm/icons/test-tube.js
  var TestTube = [
    ["path", { d: "M14.5 2v17.5c0 1.4-1.1 2.5-2.5 2.5c-1.4 0-2.5-1.1-2.5-2.5V2" }],
    ["path", { d: "M8.5 2h7" }],
    ["path", { d: "M14.5 16h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/test-tubes.js
  var TestTubes = [
    ["path", { d: "M9 2v17.5A2.5 2.5 0 0 1 6.5 22A2.5 2.5 0 0 1 4 19.5V2" }],
    ["path", { d: "M20 2v17.5a2.5 2.5 0 0 1-2.5 2.5a2.5 2.5 0 0 1-2.5-2.5V2" }],
    ["path", { d: "M3 2h7" }],
    ["path", { d: "M14 2h7" }],
    ["path", { d: "M9 16H4" }],
    ["path", { d: "M20 16h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/text-cursor-input.js
  var TextCursorInput = [
    ["path", { d: "M12 20h-1a2 2 0 0 1-2-2 2 2 0 0 1-2 2H6" }],
    ["path", { d: "M13 8h7a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2h-7" }],
    ["path", { d: "M5 16H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2h1" }],
    ["path", { d: "M6 4h1a2 2 0 0 1 2 2 2 2 0 0 1 2-2h1" }],
    ["path", { d: "M9 6v12" }]
  ];

  // node_modules/lucide/dist/esm/icons/text-cursor.js
  var TextCursor = [
    ["path", { d: "M17 22h-1a4 4 0 0 1-4-4V6a4 4 0 0 1 4-4h1" }],
    ["path", { d: "M7 22h1a4 4 0 0 0 4-4v-1" }],
    ["path", { d: "M7 2h1a4 4 0 0 1 4 4v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/text-quote.js
  var TextQuote = [
    ["path", { d: "M17 6H3" }],
    ["path", { d: "M21 12H8" }],
    ["path", { d: "M21 18H8" }],
    ["path", { d: "M3 12v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/text-search.js
  var TextSearch = [
    ["path", { d: "M21 6H3" }],
    ["path", { d: "M10 12H3" }],
    ["path", { d: "M10 18H3" }],
    ["circle", { cx: "17", cy: "15", r: "3" }],
    ["path", { d: "m21 19-1.9-1.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/text-select.js
  var TextSelect = [
    ["path", { d: "M14 21h1" }],
    ["path", { d: "M14 3h1" }],
    ["path", { d: "M19 3a2 2 0 0 1 2 2" }],
    ["path", { d: "M21 14v1" }],
    ["path", { d: "M21 19a2 2 0 0 1-2 2" }],
    ["path", { d: "M21 9v1" }],
    ["path", { d: "M3 14v1" }],
    ["path", { d: "M3 9v1" }],
    ["path", { d: "M5 21a2 2 0 0 1-2-2" }],
    ["path", { d: "M5 3a2 2 0 0 0-2 2" }],
    ["path", { d: "M7 12h10" }],
    ["path", { d: "M7 16h6" }],
    ["path", { d: "M7 8h8" }],
    ["path", { d: "M9 21h1" }],
    ["path", { d: "M9 3h1" }]
  ];

  // node_modules/lucide/dist/esm/icons/theater.js
  var Theater = [
    ["path", { d: "M2 10s3-3 3-8" }],
    ["path", { d: "M22 10s-3-3-3-8" }],
    ["path", { d: "M10 2c0 4.4-3.6 8-8 8" }],
    ["path", { d: "M14 2c0 4.4 3.6 8 8 8" }],
    ["path", { d: "M2 10s2 2 2 5" }],
    ["path", { d: "M22 10s-2 2-2 5" }],
    ["path", { d: "M8 15h8" }],
    ["path", { d: "M2 22v-1a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1" }],
    ["path", { d: "M14 22v-1a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/text.js
  var Text2 = [
    ["path", { d: "M15 18H3" }],
    ["path", { d: "M17 6H3" }],
    ["path", { d: "M21 12H3" }]
  ];

  // node_modules/lucide/dist/esm/icons/thermometer-sun.js
  var ThermometerSun = [
    ["path", { d: "M12 9a4 4 0 0 0-2 7.5" }],
    ["path", { d: "M12 3v2" }],
    ["path", { d: "m6.6 18.4-1.4 1.4" }],
    ["path", { d: "M20 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z" }],
    ["path", { d: "M4 13H2" }],
    ["path", { d: "M6.34 7.34 4.93 5.93" }]
  ];

  // node_modules/lucide/dist/esm/icons/thermometer-snowflake.js
  var ThermometerSnowflake = [
    ["path", { d: "m10 20-1.25-2.5L6 18" }],
    ["path", { d: "M10 4 8.75 6.5 6 6" }],
    ["path", { d: "M10.585 15H10" }],
    ["path", { d: "M2 12h6.5L10 9" }],
    ["path", { d: "M20 14.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0z" }],
    ["path", { d: "m4 10 1.5 2L4 14" }],
    ["path", { d: "m7 21 3-6-1.5-3" }],
    ["path", { d: "m7 3 3 6h2" }]
  ];

  // node_modules/lucide/dist/esm/icons/thermometer.js
  var Thermometer = [["path", { d: "M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z" }]];

  // node_modules/lucide/dist/esm/icons/thumbs-down.js
  var ThumbsDown = [
    ["path", { d: "M17 14V2" }],
    [
      "path",
      {
        d: "M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/thumbs-up.js
  var ThumbsUp = [
    ["path", { d: "M7 10v12" }],
    [
      "path",
      {
        d: "M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-check.js
  var TicketCheck = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "m9 12 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-minus.js
  var TicketMinus = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "M9 12h6" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-percent.js
  var TicketPercent = [
    [
      "path",
      {
        d: "M2 9a3 3 0 1 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 1 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "M9 9h.01" }],
    ["path", { d: "m15 9-6 6" }],
    ["path", { d: "M15 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-slash.js
  var TicketSlash = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "m9.5 14.5 5-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-plus.js
  var TicketPlus = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "M9 12h6" }],
    ["path", { d: "M12 9v6" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket-x.js
  var TicketX = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "m9.5 14.5 5-5" }],
    ["path", { d: "m9.5 9.5 5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/ticket.js
  var Ticket = [
    [
      "path",
      {
        d: "M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z"
      }
    ],
    ["path", { d: "M13 5v2" }],
    ["path", { d: "M13 17v2" }],
    ["path", { d: "M13 11v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tickets-plane.js
  var TicketsPlane = [
    ["path", { d: "M10.5 17h1.227a2 2 0 0 0 1.345-.52L18 12" }],
    ["path", { d: "m12 13.5 3.75.5" }],
    ["path", { d: "m4.5 8 10.58-5.06a1 1 0 0 1 1.342.488L18.5 8" }],
    ["path", { d: "M6 10V8" }],
    ["path", { d: "M6 14v1" }],
    ["path", { d: "M6 19v2" }],
    ["rect", { x: "2", y: "8", width: "20", height: "13", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tickets.js
  var Tickets = [
    ["path", { d: "m4.5 8 10.58-5.06a1 1 0 0 1 1.342.488L18.5 8" }],
    ["path", { d: "M6 10V8" }],
    ["path", { d: "M6 14v1" }],
    ["path", { d: "M6 19v2" }],
    ["rect", { x: "2", y: "8", width: "20", height: "13", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/timer-reset.js
  var TimerReset = [
    ["path", { d: "M10 2h4" }],
    ["path", { d: "M12 14v-4" }],
    ["path", { d: "M4 13a8 8 0 0 1 8-7 8 8 0 1 1-5.3 14L4 17.6" }],
    ["path", { d: "M9 17H4v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/timer.js
  var Timer = [
    ["line", { x1: "10", x2: "14", y1: "2", y2: "2" }],
    ["line", { x1: "12", x2: "15", y1: "14", y2: "11" }],
    ["circle", { cx: "12", cy: "14", r: "8" }]
  ];

  // node_modules/lucide/dist/esm/icons/timer-off.js
  var TimerOff = [
    ["path", { d: "M10 2h4" }],
    ["path", { d: "M4.6 11a8 8 0 0 0 1.7 8.7 8 8 0 0 0 8.7 1.7" }],
    ["path", { d: "M7.4 7.4a8 8 0 0 1 10.3 1 8 8 0 0 1 .9 10.2" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M12 12v-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/toggle-left.js
  var ToggleLeft = [
    ["circle", { cx: "9", cy: "12", r: "3" }],
    ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "7" }]
  ];

  // node_modules/lucide/dist/esm/icons/toggle-right.js
  var ToggleRight = [
    ["circle", { cx: "15", cy: "12", r: "3" }],
    ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "7" }]
  ];

  // node_modules/lucide/dist/esm/icons/toilet.js
  var Toilet = [
    [
      "path",
      {
        d: "M7 12h13a1 1 0 0 1 1 1 5 5 0 0 1-5 5h-.598a.5.5 0 0 0-.424.765l1.544 2.47a.5.5 0 0 1-.424.765H5.402a.5.5 0 0 1-.424-.765L7 18"
      }
    ],
    ["path", { d: "M8 18a5 5 0 0 1-5-5V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8" }]
  ];

  // node_modules/lucide/dist/esm/icons/tornado.js
  var Tornado = [
    ["path", { d: "M21 4H3" }],
    ["path", { d: "M18 8H6" }],
    ["path", { d: "M19 12H9" }],
    ["path", { d: "M16 16h-6" }],
    ["path", { d: "M11 20H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/torus.js
  var Torus = [
    ["ellipse", { cx: "12", cy: "11", rx: "3", ry: "2" }],
    ["ellipse", { cx: "12", cy: "12.5", rx: "10", ry: "8.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/touchpad-off.js
  var TouchpadOff = [
    ["path", { d: "M12 20v-6" }],
    ["path", { d: "M19.656 14H22" }],
    ["path", { d: "M2 14h12" }],
    ["path", { d: "m2 2 20 20" }],
    ["path", { d: "M20 20H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }],
    ["path", { d: "M9.656 4H20a2 2 0 0 1 2 2v10.344" }]
  ];

  // node_modules/lucide/dist/esm/icons/touchpad.js
  var Touchpad = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M2 14h20" }],
    ["path", { d: "M12 20v-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/tower-control.js
  var TowerControl = [
    ["path", { d: "M18.2 12.27 20 6H4l1.8 6.27a1 1 0 0 0 .95.73h10.5a1 1 0 0 0 .96-.73Z" }],
    ["path", { d: "M8 13v9" }],
    ["path", { d: "M16 22v-9" }],
    ["path", { d: "m9 6 1 7" }],
    ["path", { d: "m15 6-1 7" }],
    ["path", { d: "M12 6V2" }],
    ["path", { d: "M13 2h-2" }]
  ];

  // node_modules/lucide/dist/esm/icons/toy-brick.js
  var ToyBrick = [
    ["rect", { width: "18", height: "12", x: "3", y: "8", rx: "1" }],
    ["path", { d: "M10 8V5c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v3" }],
    ["path", { d: "M19 8V5c0-.6-.4-1-1-1h-3a1 1 0 0 0-1 1v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/tractor.js
  var Tractor = [
    ["path", { d: "m10 11 11 .9a1 1 0 0 1 .8 1.1l-.665 4.158a1 1 0 0 1-.988.842H20" }],
    ["path", { d: "M16 18h-5" }],
    ["path", { d: "M18 5a1 1 0 0 0-1 1v5.573" }],
    ["path", { d: "M3 4h8.129a1 1 0 0 1 .99.863L13 11.246" }],
    ["path", { d: "M4 11V4" }],
    ["path", { d: "M7 15h.01" }],
    ["path", { d: "M8 10.1V4" }],
    ["circle", { cx: "18", cy: "18", r: "2" }],
    ["circle", { cx: "7", cy: "15", r: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/traffic-cone.js
  var TrafficCone = [
    ["path", { d: "M16.05 10.966a5 2.5 0 0 1-8.1 0" }],
    [
      "path",
      {
        d: "m16.923 14.049 4.48 2.04a1 1 0 0 1 .001 1.831l-8.574 3.9a2 2 0 0 1-1.66 0l-8.574-3.91a1 1 0 0 1 0-1.83l4.484-2.04"
      }
    ],
    ["path", { d: "M16.949 14.14a5 2.5 0 1 1-9.9 0L10.063 3.5a2 2 0 0 1 3.874 0z" }],
    ["path", { d: "M9.194 6.57a5 2.5 0 0 0 5.61 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/train-front-tunnel.js
  var TrainFrontTunnel = [
    ["path", { d: "M2 22V12a10 10 0 1 1 20 0v10" }],
    ["path", { d: "M15 6.8v1.4a3 2.8 0 1 1-6 0V6.8" }],
    ["path", { d: "M10 15h.01" }],
    ["path", { d: "M14 15h.01" }],
    ["path", { d: "M10 19a4 4 0 0 1-4-4v-3a6 6 0 1 1 12 0v3a4 4 0 0 1-4 4Z" }],
    ["path", { d: "m9 19-2 3" }],
    ["path", { d: "m15 19 2 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/train-front.js
  var TrainFront = [
    ["path", { d: "M8 3.1V7a4 4 0 0 0 8 0V3.1" }],
    ["path", { d: "m9 15-1-1" }],
    ["path", { d: "m15 15 1-1" }],
    ["path", { d: "M9 19c-2.8 0-5-2.2-5-5v-4a8 8 0 0 1 16 0v4c0 2.8-2.2 5-5 5Z" }],
    ["path", { d: "m8 19-2 3" }],
    ["path", { d: "m16 19 2 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/train-track.js
  var TrainTrack = [
    ["path", { d: "M2 17 17 2" }],
    ["path", { d: "m2 14 8 8" }],
    ["path", { d: "m5 11 8 8" }],
    ["path", { d: "m8 8 8 8" }],
    ["path", { d: "m11 5 8 8" }],
    ["path", { d: "m14 2 8 8" }],
    ["path", { d: "M7 22 22 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/tram-front.js
  var TramFront = [
    ["rect", { width: "16", height: "16", x: "4", y: "3", rx: "2" }],
    ["path", { d: "M4 11h16" }],
    ["path", { d: "M12 3v8" }],
    ["path", { d: "m8 19-2 3" }],
    ["path", { d: "m18 22-2-3" }],
    ["path", { d: "M8 15h.01" }],
    ["path", { d: "M16 15h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/transgender.js
  var Transgender = [
    ["path", { d: "M12 16v6" }],
    ["path", { d: "M14 20h-4" }],
    ["path", { d: "M18 2h4v4" }],
    ["path", { d: "m2 2 7.17 7.17" }],
    ["path", { d: "M2 5.355V2h3.357" }],
    ["path", { d: "m22 2-7.17 7.17" }],
    ["path", { d: "M8 5 5 8" }],
    ["circle", { cx: "12", cy: "12", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/trash-2.js
  var Trash2 = [
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" }],
    ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" }],
    ["line", { x1: "10", x2: "10", y1: "11", y2: "17" }],
    ["line", { x1: "14", x2: "14", y1: "11", y2: "17" }]
  ];

  // node_modules/lucide/dist/esm/icons/trash.js
  var Trash = [
    ["path", { d: "M3 6h18" }],
    ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" }],
    ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tree-deciduous.js
  var TreeDeciduous = [
    [
      "path",
      {
        d: "M8 19a4 4 0 0 1-2.24-7.32A3.5 3.5 0 0 1 9 6.03V6a3 3 0 1 1 6 0v.04a3.5 3.5 0 0 1 3.24 5.65A4 4 0 0 1 16 19Z"
      }
    ],
    ["path", { d: "M12 19v3" }]
  ];

  // node_modules/lucide/dist/esm/icons/tree-palm.js
  var TreePalm = [
    ["path", { d: "M13 8c0-2.76-2.46-5-5.5-5S2 5.24 2 8h2l1-1 1 1h4" }],
    ["path", { d: "M13 7.14A5.82 5.82 0 0 1 16.5 6c3.04 0 5.5 2.24 5.5 5h-3l-1-1-1 1h-3" }],
    [
      "path",
      {
        d: "M5.89 9.71c-2.15 2.15-2.3 5.47-.35 7.43l4.24-4.25.7-.7.71-.71 2.12-2.12c-1.95-1.96-5.27-1.8-7.42.35"
      }
    ],
    ["path", { d: "M11 15.5c.5 2.5-.17 4.5-1 6.5h4c2-5.5-.5-12-1-14" }]
  ];

  // node_modules/lucide/dist/esm/icons/trees.js
  var Trees = [
    ["path", { d: "M10 10v.2A3 3 0 0 1 8.9 16H5a3 3 0 0 1-1-5.8V10a3 3 0 0 1 6 0Z" }],
    ["path", { d: "M7 16v6" }],
    ["path", { d: "M13 19v3" }],
    [
      "path",
      {
        d: "M12 19h8.3a1 1 0 0 0 .7-1.7L18 14h.3a1 1 0 0 0 .7-1.7L16 9h.2a1 1 0 0 0 .8-1.7L13 3l-1.4 1.5"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/tree-pine.js
  var TreePine = [
    [
      "path",
      {
        d: "m17 14 3 3.3a1 1 0 0 1-.7 1.7H4.7a1 1 0 0 1-.7-1.7L7 14h-.3a1 1 0 0 1-.7-1.7L9 9h-.2A1 1 0 0 1 8 7.3L12 3l4 4.3a1 1 0 0 1-.8 1.7H15l3 3.3a1 1 0 0 1-.7 1.7H17Z"
      }
    ],
    ["path", { d: "M12 22v-3" }]
  ];

  // node_modules/lucide/dist/esm/icons/trello.js
  var Trello = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }],
    ["rect", { width: "3", height: "9", x: "7", y: "7" }],
    ["rect", { width: "3", height: "5", x: "14", y: "7" }]
  ];

  // node_modules/lucide/dist/esm/icons/trending-down.js
  var TrendingDown = [
    ["polyline", { points: "22 17 13.5 8.5 8.5 13.5 2 7" }],
    ["polyline", { points: "16 17 22 17 22 11" }]
  ];

  // node_modules/lucide/dist/esm/icons/trending-up-down.js
  var TrendingUpDown = [
    ["path", { d: "M14.828 14.828 21 21" }],
    ["path", { d: "M21 16v5h-5" }],
    ["path", { d: "m21 3-9 9-4-4-6 6" }],
    ["path", { d: "M21 8V3h-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/trending-up.js
  var TrendingUp = [
    ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17" }],
    ["polyline", { points: "16 7 22 7 22 13" }]
  ];

  // node_modules/lucide/dist/esm/icons/triangle-alert.js
  var TriangleAlert = [
    ["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" }],
    ["path", { d: "M12 9v4" }],
    ["path", { d: "M12 17h.01" }]
  ];

  // node_modules/lucide/dist/esm/icons/triangle-dashed.js
  var TriangleDashed = [
    ["path", { d: "M10.17 4.193a2 2 0 0 1 3.666.013" }],
    ["path", { d: "M14 21h2" }],
    ["path", { d: "m15.874 7.743 1 1.732" }],
    ["path", { d: "m18.849 12.952 1 1.732" }],
    ["path", { d: "M21.824 18.18a2 2 0 0 1-1.835 2.824" }],
    ["path", { d: "M4.024 21a2 2 0 0 1-1.839-2.839" }],
    ["path", { d: "m5.136 12.952-1 1.732" }],
    ["path", { d: "M8 21h2" }],
    ["path", { d: "m8.102 7.743-1 1.732" }]
  ];

  // node_modules/lucide/dist/esm/icons/triangle-right.js
  var TriangleRight = [
    ["path", { d: "M22 18a2 2 0 0 1-2 2H3c-1.1 0-1.3-.6-.4-1.3L20.4 4.3c.9-.7 1.6-.4 1.6.7Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/triangle.js
  var Triangle = [
    ["path", { d: "M13.73 4a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/trophy.js
  var Trophy = [
    ["path", { d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6" }],
    ["path", { d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18" }],
    ["path", { d: "M4 22h16" }],
    ["path", { d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" }],
    ["path", { d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" }],
    ["path", { d: "M18 2H6v7a6 6 0 0 0 12 0V2Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/truck.js
  var Truck = [
    ["path", { d: "M14 18V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v11a1 1 0 0 0 1 1h2" }],
    ["path", { d: "M15 18H9" }],
    [
      "path",
      { d: "M19 18h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.624l-3.48-4.35A1 1 0 0 0 17.52 8H14" }
    ],
    ["circle", { cx: "17", cy: "18", r: "2" }],
    ["circle", { cx: "7", cy: "18", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/truck-electric.js
  var TruckElectric = [
    ["path", { d: "M14 19V7a2 2 0 0 0-2-2H9" }],
    ["path", { d: "M15 19H9" }],
    ["path", { d: "M19 19h2a1 1 0 0 0 1-1v-3.65a1 1 0 0 0-.22-.62L18.3 9.38a1 1 0 0 0-.78-.38H14" }],
    ["path", { d: "M2 13v5a1 1 0 0 0 1 1h2" }],
    ["path", { d: "M4 3 2.15 5.15a.495.495 0 0 0 .35.86h2.15a.47.47 0 0 1 .35.86L3 9.02" }],
    ["circle", { cx: "17", cy: "19", r: "2" }],
    ["circle", { cx: "7", cy: "19", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/turtle.js
  var Turtle = [
    [
      "path",
      {
        d: "m12 10 2 4v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3a8 8 0 1 0-16 0v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3l2-4h4Z"
      }
    ],
    ["path", { d: "M4.82 7.9 8 10" }],
    ["path", { d: "M15.18 7.9 12 10" }],
    ["path", { d: "M16.93 10H20a2 2 0 0 1 0 4H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tv-minimal-play.js
  var TvMinimalPlay = [
    [
      "path",
      {
        d: "M10 7.75a.75.75 0 0 1 1.142-.638l3.664 2.249a.75.75 0 0 1 0 1.278l-3.664 2.25a.75.75 0 0 1-1.142-.64z"
      }
    ],
    ["path", { d: "M7 21h10" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/tv.js
  var Tv = [
    ["rect", { width: "20", height: "15", x: "2", y: "7", rx: "2", ry: "2" }],
    ["polyline", { points: "17 2 12 7 7 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/twitch.js
  var Twitch = [["path", { d: "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7" }]];

  // node_modules/lucide/dist/esm/icons/tv-minimal.js
  var TvMinimal = [
    ["path", { d: "M7 21h10" }],
    ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/twitter.js
  var Twitter = [
    [
      "path",
      {
        d: "M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/type-outline.js
  var TypeOutline = [
    [
      "path",
      {
        d: "M14 16.5a.5.5 0 0 0 .5.5h.5a2 2 0 0 1 0 4H9a2 2 0 0 1 0-4h.5a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5V8a2 2 0 0 1-4 0V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v3a2 2 0 0 1-4 0v-.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/type.js
  var Type = [
    ["polyline", { points: "4 7 4 4 20 4 20 7" }],
    ["line", { x1: "9", x2: "15", y1: "20", y2: "20" }],
    ["line", { x1: "12", x2: "12", y1: "4", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/umbrella-off.js
  var UmbrellaOff = [
    ["path", { d: "M12 2v1" }],
    ["path", { d: "M15.5 21a1.85 1.85 0 0 1-3.5-1v-8H2a10 10 0 0 1 3.428-6.575" }],
    ["path", { d: "M17.5 12H22A10 10 0 0 0 9.004 3.455" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/underline.js
  var Underline = [
    ["path", { d: "M6 4v6a6 6 0 0 0 12 0V4" }],
    ["line", { x1: "4", x2: "20", y1: "20", y2: "20" }]
  ];

  // node_modules/lucide/dist/esm/icons/umbrella.js
  var Umbrella = [
    ["path", { d: "M22 12a10.06 10.06 1 0 0-20 0Z" }],
    ["path", { d: "M12 12v8a2 2 0 0 0 4 0" }],
    ["path", { d: "M12 2v1" }]
  ];

  // node_modules/lucide/dist/esm/icons/undo-2.js
  var Undo2 = [
    ["path", { d: "M9 14 4 9l5-5" }],
    ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11" }]
  ];

  // node_modules/lucide/dist/esm/icons/undo-dot.js
  var UndoDot = [
    ["path", { d: "M21 17a9 9 0 0 0-15-6.7L3 13" }],
    ["path", { d: "M3 7v6h6" }],
    ["circle", { cx: "12", cy: "17", r: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/undo.js
  var Undo = [
    ["path", { d: "M3 7v6h6" }],
    ["path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }]
  ];

  // node_modules/lucide/dist/esm/icons/unfold-horizontal.js
  var UnfoldHorizontal = [
    ["path", { d: "M16 12h6" }],
    ["path", { d: "M8 12H2" }],
    ["path", { d: "M12 2v2" }],
    ["path", { d: "M12 8v2" }],
    ["path", { d: "M12 14v2" }],
    ["path", { d: "M12 20v2" }],
    ["path", { d: "m19 15 3-3-3-3" }],
    ["path", { d: "m5 9-3 3 3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/ungroup.js
  var Ungroup = [
    ["rect", { width: "8", height: "6", x: "5", y: "4", rx: "1" }],
    ["rect", { width: "8", height: "6", x: "11", y: "14", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/unfold-vertical.js
  var UnfoldVertical = [
    ["path", { d: "M12 22v-6" }],
    ["path", { d: "M12 8V2" }],
    ["path", { d: "M4 12H2" }],
    ["path", { d: "M10 12H8" }],
    ["path", { d: "M16 12h-2" }],
    ["path", { d: "M22 12h-2" }],
    ["path", { d: "m15 19-3 3-3-3" }],
    ["path", { d: "m15 5-3-3-3 3" }]
  ];

  // node_modules/lucide/dist/esm/icons/university.js
  var University = [
    ["circle", { cx: "12", cy: "10", r: "1" }],
    ["path", { d: "M22 20V8h-4l-6-4-6 4H2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2" }],
    ["path", { d: "M6 17v.01" }],
    ["path", { d: "M6 13v.01" }],
    ["path", { d: "M18 17v.01" }],
    ["path", { d: "M18 13v.01" }],
    ["path", { d: "M14 22v-5a2 2 0 0 0-2-2a2 2 0 0 0-2 2v5" }]
  ];

  // node_modules/lucide/dist/esm/icons/unlink.js
  var Unlink = [
    [
      "path",
      {
        d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"
      }
    ],
    [
      "path",
      { d: "m5.17 11.75-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71" }
    ],
    ["line", { x1: "8", x2: "8", y1: "2", y2: "5" }],
    ["line", { x1: "2", x2: "5", y1: "8", y2: "8" }],
    ["line", { x1: "16", x2: "16", y1: "19", y2: "22" }],
    ["line", { x1: "19", x2: "22", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/unlink-2.js
  var Unlink2 = [["path", { d: "M15 7h2a5 5 0 0 1 0 10h-2m-6 0H7A5 5 0 0 1 7 7h2" }]];

  // node_modules/lucide/dist/esm/icons/unplug.js
  var Unplug = [
    ["path", { d: "m19 5 3-3" }],
    ["path", { d: "m2 22 3-3" }],
    ["path", { d: "M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z" }],
    ["path", { d: "M7.5 13.5 10 11" }],
    ["path", { d: "M10.5 16.5 13 14" }],
    ["path", { d: "m12 6 6 6 2.3-2.3a2.4 2.4 0 0 0 0-3.4l-2.6-2.6a2.4 2.4 0 0 0-3.4 0Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/upload.js
  var Upload = [
    ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }],
    ["polyline", { points: "17 8 12 3 7 8" }],
    ["line", { x1: "12", x2: "12", y1: "3", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/usb.js
  var Usb = [
    ["circle", { cx: "10", cy: "7", r: "1" }],
    ["circle", { cx: "4", cy: "20", r: "1" }],
    ["path", { d: "M4.7 19.3 19 5" }],
    ["path", { d: "m21 3-3 1 2 2Z" }],
    ["path", { d: "M9.26 7.68 5 12l2 5" }],
    ["path", { d: "m10 14 5 2 3.5-3.5" }],
    ["path", { d: "m18 12 1-1 1 1-1 1Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-check.js
  var UserCheck = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "9", cy: "7", r: "4" }],
    ["polyline", { points: "16 11 18 13 22 9" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-cog.js
  var UserCog = [
    ["path", { d: "M10 15H6a4 4 0 0 0-4 4v2" }],
    ["path", { d: "m14.305 16.53.923-.382" }],
    ["path", { d: "m15.228 13.852-.923-.383" }],
    ["path", { d: "m16.852 12.228-.383-.923" }],
    ["path", { d: "m16.852 17.772-.383.924" }],
    ["path", { d: "m19.148 12.228.383-.923" }],
    ["path", { d: "m19.53 18.696-.382-.924" }],
    ["path", { d: "m20.772 13.852.924-.383" }],
    ["path", { d: "m20.772 16.148.924.383" }],
    ["circle", { cx: "18", cy: "15", r: "3" }],
    ["circle", { cx: "9", cy: "7", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-lock.js
  var UserLock = [
    ["circle", { cx: "10", cy: "7", r: "4" }],
    ["path", { d: "M10.3 15H7a4 4 0 0 0-4 4v2" }],
    ["path", { d: "M15 15.5V14a2 2 0 0 1 4 0v1.5" }],
    ["rect", { width: "8", height: "5", x: "13", y: "16", rx: ".899" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-minus.js
  var UserMinus = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "9", cy: "7", r: "4" }],
    ["line", { x1: "22", x2: "16", y1: "11", y2: "11" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-pen.js
  var UserPen = [
    ["path", { d: "M11.5 15H7a4 4 0 0 0-4 4v2" }],
    [
      "path",
      {
        d: "M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ],
    ["circle", { cx: "10", cy: "7", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-plus.js
  var UserPlus = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "9", cy: "7", r: "4" }],
    ["line", { x1: "19", x2: "19", y1: "8", y2: "14" }],
    ["line", { x1: "22", x2: "16", y1: "11", y2: "11" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-check.js
  var UserRoundCheck = [
    ["path", { d: "M2 21a8 8 0 0 1 13.292-6" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "m16 19 2 2 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-cog.js
  var UserRoundCog = [
    ["path", { d: "m14.305 19.53.923-.382" }],
    ["path", { d: "m15.228 16.852-.923-.383" }],
    ["path", { d: "m16.852 15.228-.383-.923" }],
    ["path", { d: "m16.852 20.772-.383.924" }],
    ["path", { d: "m19.148 15.228.383-.923" }],
    ["path", { d: "m19.53 21.696-.382-.924" }],
    ["path", { d: "M2 21a8 8 0 0 1 10.434-7.62" }],
    ["path", { d: "m20.772 16.852.924-.383" }],
    ["path", { d: "m20.772 19.148.924.383" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["circle", { cx: "18", cy: "18", r: "3" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-minus.js
  var UserRoundMinus = [
    ["path", { d: "M2 21a8 8 0 0 1 13.292-6" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "M22 19h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-pen.js
  var UserRoundPen = [
    ["path", { d: "M2 21a8 8 0 0 1 10.821-7.487" }],
    [
      "path",
      {
        d: "M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ],
    ["circle", { cx: "10", cy: "8", r: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-plus.js
  var UserRoundPlus = [
    ["path", { d: "M2 21a8 8 0 0 1 13.292-6" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "M19 16v6" }],
    ["path", { d: "M22 19h-6" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-search.js
  var UserRoundSearch = [
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "M2 21a8 8 0 0 1 10.434-7.62" }],
    ["circle", { cx: "18", cy: "18", r: "3" }],
    ["path", { d: "m22 22-1.9-1.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round-x.js
  var UserRoundX = [
    ["path", { d: "M2 21a8 8 0 0 1 11.873-7" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "m17 17 5 5" }],
    ["path", { d: "m22 17-5 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-round.js
  var UserRound = [
    ["circle", { cx: "12", cy: "8", r: "5" }],
    ["path", { d: "M20 21a8 8 0 0 0-16 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-search.js
  var UserSearch = [
    ["circle", { cx: "10", cy: "7", r: "4" }],
    ["path", { d: "M10.3 15H7a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "17", cy: "17", r: "3" }],
    ["path", { d: "m21 21-1.9-1.9" }]
  ];

  // node_modules/lucide/dist/esm/icons/user-x.js
  var UserX = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "9", cy: "7", r: "4" }],
    ["line", { x1: "17", x2: "22", y1: "8", y2: "13" }],
    ["line", { x1: "22", x2: "17", y1: "8", y2: "13" }]
  ];

  // node_modules/lucide/dist/esm/icons/user.js
  var User = [
    ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }],
    ["circle", { cx: "12", cy: "7", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/users-round.js
  var UsersRound = [
    ["path", { d: "M18 21a8 8 0 0 0-16 0" }],
    ["circle", { cx: "10", cy: "8", r: "5" }],
    ["path", { d: "M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3" }]
  ];

  // node_modules/lucide/dist/esm/icons/users.js
  var Users = [
    ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }],
    ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744" }],
    ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87" }],
    ["circle", { cx: "9", cy: "7", r: "4" }]
  ];

  // node_modules/lucide/dist/esm/icons/utensils.js
  var Utensils = [
    ["path", { d: "M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2" }],
    ["path", { d: "M7 2v20" }],
    ["path", { d: "M21 15V2a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7" }]
  ];

  // node_modules/lucide/dist/esm/icons/utility-pole.js
  var UtilityPole = [
    ["path", { d: "M12 2v20" }],
    ["path", { d: "M2 5h20" }],
    ["path", { d: "M3 3v2" }],
    ["path", { d: "M7 3v2" }],
    ["path", { d: "M17 3v2" }],
    ["path", { d: "M21 3v2" }],
    ["path", { d: "m19 5-7 7-7-7" }]
  ];

  // node_modules/lucide/dist/esm/icons/utensils-crossed.js
  var UtensilsCrossed = [
    ["path", { d: "m16 2-2.3 2.3a3 3 0 0 0 0 4.2l1.8 1.8a3 3 0 0 0 4.2 0L22 8" }],
    ["path", { d: "M15 15 3.3 3.3a4.2 4.2 0 0 0 0 6l7.3 7.3c.7.7 2 .7 2.8 0L15 15Zm0 0 7 7" }],
    ["path", { d: "m2.1 21.8 6.4-6.3" }],
    ["path", { d: "m19 5-7 7" }]
  ];

  // node_modules/lucide/dist/esm/icons/variable.js
  var Variable = [
    ["path", { d: "M8 21s-4-3-4-9 4-9 4-9" }],
    ["path", { d: "M16 3s4 3 4 9-4 9-4 9" }],
    ["line", { x1: "15", x2: "9", y1: "9", y2: "15" }],
    ["line", { x1: "9", x2: "15", y1: "9", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/vault.js
  var Vault = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["circle", { cx: "7.5", cy: "7.5", r: ".5", fill: "currentColor" }],
    ["path", { d: "m7.9 7.9 2.7 2.7" }],
    ["circle", { cx: "16.5", cy: "7.5", r: ".5", fill: "currentColor" }],
    ["path", { d: "m13.4 10.6 2.7-2.7" }],
    ["circle", { cx: "7.5", cy: "16.5", r: ".5", fill: "currentColor" }],
    ["path", { d: "m7.9 16.1 2.7-2.7" }],
    ["circle", { cx: "16.5", cy: "16.5", r: ".5", fill: "currentColor" }],
    ["path", { d: "m13.4 13.4 2.7 2.7" }],
    ["circle", { cx: "12", cy: "12", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/venetian-mask.js
  var VenetianMask = [
    ["path", { d: "M18 11c-1.5 0-2.5.5-3 2" }],
    [
      "path",
      {
        d: "M4 6a2 2 0 0 0-2 2v4a5 5 0 0 0 5 5 8 8 0 0 1 5 2 8 8 0 0 1 5-2 5 5 0 0 0 5-5V8a2 2 0 0 0-2-2h-3a8 8 0 0 0-5 2 8 8 0 0 0-5-2z"
      }
    ],
    ["path", { d: "M6 11c1.5 0 2.5.5 3 2" }]
  ];

  // node_modules/lucide/dist/esm/icons/vegan.js
  var Vegan = [
    ["path", { d: "M16 8q6 0 6-6-6 0-6 6" }],
    ["path", { d: "M17.41 3.59a10 10 0 1 0 3 3" }],
    ["path", { d: "M2 2a26.6 26.6 0 0 1 10 20c.9-6.82 1.5-9.5 4-14" }]
  ];

  // node_modules/lucide/dist/esm/icons/venus-and-mars.js
  var VenusAndMars = [
    ["path", { d: "M10 20h4" }],
    ["path", { d: "M12 16v6" }],
    ["path", { d: "M17 2h4v4" }],
    ["path", { d: "m21 2-5.46 5.46" }],
    ["circle", { cx: "12", cy: "11", r: "5" }]
  ];

  // node_modules/lucide/dist/esm/icons/venus.js
  var Venus = [
    ["path", { d: "M12 15v7" }],
    ["path", { d: "M9 19h6" }],
    ["circle", { cx: "12", cy: "9", r: "6" }]
  ];

  // node_modules/lucide/dist/esm/icons/vibrate-off.js
  var VibrateOff = [
    ["path", { d: "m2 8 2 2-2 2 2 2-2 2" }],
    ["path", { d: "m22 8-2 2 2 2-2 2 2 2" }],
    ["path", { d: "M8 8v10c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2" }],
    ["path", { d: "M16 10.34V6c0-.55-.45-1-1-1h-4.34" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/vibrate.js
  var Vibrate = [
    ["path", { d: "m2 8 2 2-2 2 2 2-2 2" }],
    ["path", { d: "m22 8-2 2 2 2-2 2 2 2" }],
    ["rect", { width: "8", height: "14", x: "8", y: "5", rx: "1" }]
  ];

  // node_modules/lucide/dist/esm/icons/video.js
  var Video = [
    ["path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5" }],
    ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/video-off.js
  var VideoOff = [
    ["path", { d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196" }],
    ["path", { d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/videotape.js
  var Videotape = [
    ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2" }],
    ["path", { d: "M2 8h20" }],
    ["circle", { cx: "8", cy: "14", r: "2" }],
    ["path", { d: "M8 12h8" }],
    ["circle", { cx: "16", cy: "14", r: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/view.js
  var View2 = [
    ["path", { d: "M21 17v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2" }],
    ["path", { d: "M21 7V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2" }],
    ["circle", { cx: "12", cy: "12", r: "1" }],
    [
      "path",
      {
        d: "M18.944 12.33a1 1 0 0 0 0-.66 7.5 7.5 0 0 0-13.888 0 1 1 0 0 0 0 .66 7.5 7.5 0 0 0 13.888 0"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/voicemail.js
  var Voicemail = [
    ["circle", { cx: "6", cy: "12", r: "4" }],
    ["circle", { cx: "18", cy: "12", r: "4" }],
    ["line", { x1: "6", x2: "18", y1: "16", y2: "16" }]
  ];

  // node_modules/lucide/dist/esm/icons/volleyball.js
  var Volleyball = [
    ["path", { d: "M11.1 7.1a16.55 16.55 0 0 1 10.9 4" }],
    ["path", { d: "M12 12a12.6 12.6 0 0 1-8.7 5" }],
    ["path", { d: "M16.8 13.6a16.55 16.55 0 0 1-9 7.5" }],
    ["path", { d: "M20.7 17a12.8 12.8 0 0 0-8.7-5 13.3 13.3 0 0 1 0-10" }],
    ["path", { d: "M6.3 3.8a16.55 16.55 0 0 0 1.9 11.5" }],
    ["circle", { cx: "12", cy: "12", r: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/volume-1.js
  var Volume1 = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"
      }
    ],
    ["path", { d: "M16 9a5 5 0 0 1 0 6" }]
  ];

  // node_modules/lucide/dist/esm/icons/volume-2.js
  var Volume2 = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"
      }
    ],
    ["path", { d: "M16 9a5 5 0 0 1 0 6" }],
    ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728" }]
  ];

  // node_modules/lucide/dist/esm/icons/volume-off.js
  var VolumeOff = [
    ["path", { d: "M16 9a5 5 0 0 1 .95 2.293" }],
    ["path", { d: "M19.364 5.636a9 9 0 0 1 1.889 9.96" }],
    ["path", { d: "m2 2 20 20" }],
    [
      "path",
      {
        d: "m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11"
      }
    ],
    ["path", { d: "M9.828 4.172A.686.686 0 0 1 11 4.657v.686" }]
  ];

  // node_modules/lucide/dist/esm/icons/volume-x.js
  var VolumeX = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"
      }
    ],
    ["line", { x1: "22", x2: "16", y1: "9", y2: "15" }],
    ["line", { x1: "16", x2: "22", y1: "9", y2: "15" }]
  ];

  // node_modules/lucide/dist/esm/icons/volume.js
  var Volume = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/vote.js
  var Vote = [
    ["path", { d: "m9 12 2 2 4-4" }],
    ["path", { d: "M5 7c0-1.1.9-2 2-2h10a2 2 0 0 1 2 2v12H5V7Z" }],
    ["path", { d: "M22 19H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/wallet-cards.js
  var WalletCards = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M3 9a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2" }],
    [
      "path",
      { d: "M3 11h3c.8 0 1.6.3 2.1.9l1.1.9c1.6 1.6 4.1 1.6 5.7 0l1.1-.9c.5-.5 1.3-.9 2.1-.9H21" }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/wallet-minimal.js
  var WalletMinimal = [
    ["path", { d: "M17 14h.01" }],
    ["path", { d: "M7 7h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14" }]
  ];

  // node_modules/lucide/dist/esm/icons/wallet.js
  var Wallet = [
    [
      "path",
      {
        d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1"
      }
    ],
    ["path", { d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/wallpaper.js
  var Wallpaper = [
    ["circle", { cx: "8", cy: "9", r: "2" }],
    [
      "path",
      {
        d: "m9 17 6.1-6.1a2 2 0 0 1 2.81.01L22 15V5a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2"
      }
    ],
    ["path", { d: "M8 21h8" }],
    ["path", { d: "M12 17v4" }]
  ];

  // node_modules/lucide/dist/esm/icons/wand-sparkles.js
  var WandSparkles = [
    [
      "path",
      {
        d: "m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72"
      }
    ],
    ["path", { d: "m14 7 3 3" }],
    ["path", { d: "M5 6v4" }],
    ["path", { d: "M19 14v4" }],
    ["path", { d: "M10 2v2" }],
    ["path", { d: "M7 8H3" }],
    ["path", { d: "M21 16h-4" }],
    ["path", { d: "M11 3H9" }]
  ];

  // node_modules/lucide/dist/esm/icons/wand.js
  var Wand = [
    ["path", { d: "M15 4V2" }],
    ["path", { d: "M15 16v-2" }],
    ["path", { d: "M8 9h2" }],
    ["path", { d: "M20 9h2" }],
    ["path", { d: "M17.8 11.8 19 13" }],
    ["path", { d: "M15 9h.01" }],
    ["path", { d: "M17.8 6.2 19 5" }],
    ["path", { d: "m3 21 9-9" }],
    ["path", { d: "M12.2 6.2 11 5" }]
  ];

  // node_modules/lucide/dist/esm/icons/warehouse.js
  var Warehouse = [
    [
      "path",
      {
        d: "M22 8.35V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8.35A2 2 0 0 1 3.26 6.5l8-3.2a2 2 0 0 1 1.48 0l8 3.2A2 2 0 0 1 22 8.35Z"
      }
    ],
    ["path", { d: "M6 18h12" }],
    ["path", { d: "M6 14h12" }],
    ["rect", { width: "12", height: "12", x: "6", y: "10" }]
  ];

  // node_modules/lucide/dist/esm/icons/washing-machine.js
  var WashingMachine = [
    ["path", { d: "M3 6h3" }],
    ["path", { d: "M17 6h.01" }],
    ["rect", { width: "18", height: "20", x: "3", y: "2", rx: "2" }],
    ["circle", { cx: "12", cy: "13", r: "5" }],
    ["path", { d: "M12 18a2.5 2.5 0 0 0 0-5 2.5 2.5 0 0 1 0-5" }]
  ];

  // node_modules/lucide/dist/esm/icons/watch.js
  var Watch = [
    ["circle", { cx: "12", cy: "12", r: "6" }],
    ["polyline", { points: "12 10 12 12 13 13" }],
    ["path", { d: "m16.13 7.66-.81-4.05a2 2 0 0 0-2-1.61h-2.68a2 2 0 0 0-2 1.61l-.78 4.05" }],
    ["path", { d: "m7.88 16.36.8 4a2 2 0 0 0 2 1.61h2.72a2 2 0 0 0 2-1.61l.81-4.05" }]
  ];

  // node_modules/lucide/dist/esm/icons/waves-ladder.js
  var WavesLadder = [
    ["path", { d: "M19 5a2 2 0 0 0-2 2v11" }],
    [
      "path",
      {
        d: "M2 18c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"
      }
    ],
    ["path", { d: "M7 13h10" }],
    ["path", { d: "M7 9h10" }],
    ["path", { d: "M9 5a2 2 0 0 0-2 2v11" }]
  ];

  // node_modules/lucide/dist/esm/icons/waves.js
  var Waves = [
    [
      "path",
      { d: "M2 6c.6.5 1.2 1 2.5 1C7 7 7 5 9.5 5c2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1" }
    ],
    [
      "path",
      {
        d: "M2 12c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"
      }
    ],
    [
      "path",
      {
        d: "M2 18c.6.5 1.2 1 2.5 1 2.5 0 2.5-2 5-2 2.6 0 2.4 2 5 2 2.5 0 2.5-2 5-2 1.3 0 1.9.5 2.5 1"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/waypoints.js
  var Waypoints = [
    ["circle", { cx: "12", cy: "4.5", r: "2.5" }],
    ["path", { d: "m10.2 6.3-3.9 3.9" }],
    ["circle", { cx: "4.5", cy: "12", r: "2.5" }],
    ["path", { d: "M7 12h10" }],
    ["circle", { cx: "19.5", cy: "12", r: "2.5" }],
    ["path", { d: "m13.8 17.7 3.9-3.9" }],
    ["circle", { cx: "12", cy: "19.5", r: "2.5" }]
  ];

  // node_modules/lucide/dist/esm/icons/webcam.js
  var Webcam = [
    ["circle", { cx: "12", cy: "10", r: "8" }],
    ["circle", { cx: "12", cy: "10", r: "3" }],
    ["path", { d: "M7 22h10" }],
    ["path", { d: "M12 22v-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/webhook-off.js
  var WebhookOff = [
    ["path", { d: "M17 17h-5c-1.09-.02-1.94.92-2.5 1.9A3 3 0 1 1 2.57 15" }],
    ["path", { d: "M9 3.4a4 4 0 0 1 6.52.66" }],
    ["path", { d: "m6 17 3.1-5.8a2.5 2.5 0 0 0 .057-2.05" }],
    ["path", { d: "M20.3 20.3a4 4 0 0 1-2.3.7" }],
    ["path", { d: "M18.6 13a4 4 0 0 1 3.357 3.414" }],
    ["path", { d: "m12 6 .6 1" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/webhook.js
  var Webhook = [
    ["path", { d: "M18 16.98h-5.99c-1.1 0-1.95.94-2.48 1.9A4 4 0 0 1 2 17c.01-.7.2-1.4.57-2" }],
    ["path", { d: "m6 17 3.13-5.78c.53-.97.1-2.18-.5-3.1a4 4 0 1 1 6.89-4.06" }],
    ["path", { d: "m12 6 3.13 5.73C15.66 12.7 16.9 13 18 13a4 4 0 0 1 0 8" }]
  ];

  // node_modules/lucide/dist/esm/icons/weight.js
  var Weight = [
    ["circle", { cx: "12", cy: "5", r: "3" }],
    [
      "path",
      {
        d: "M6.5 8a2 2 0 0 0-1.905 1.46L2.1 18.5A2 2 0 0 0 4 21h16a2 2 0 0 0 1.925-2.54L19.4 9.5A2 2 0 0 0 17.48 8Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/wheat-off.js
  var WheatOff = [
    ["path", { d: "m2 22 10-10" }],
    ["path", { d: "m16 8-1.17 1.17" }],
    [
      "path",
      { d: "M3.47 12.53 5 11l1.53 1.53a3.5 3.5 0 0 1 0 4.94L5 19l-1.53-1.53a3.5 3.5 0 0 1 0-4.94Z" }
    ],
    ["path", { d: "m8 8-.53.53a3.5 3.5 0 0 0 0 4.94L9 15l1.53-1.53c.55-.55.88-1.25.98-1.97" }],
    ["path", { d: "M10.91 5.26c.15-.26.34-.51.56-.73L13 3l1.53 1.53a3.5 3.5 0 0 1 .28 4.62" }],
    ["path", { d: "M20 2h2v2a4 4 0 0 1-4 4h-2V6a4 4 0 0 1 4-4Z" }],
    [
      "path",
      {
        d: "M11.47 17.47 13 19l-1.53 1.53a3.5 3.5 0 0 1-4.94 0L5 19l1.53-1.53a3.5 3.5 0 0 1 4.94 0Z"
      }
    ],
    ["path", { d: "m16 16-.53.53a3.5 3.5 0 0 1-4.94 0L9 15l1.53-1.53a3.49 3.49 0 0 1 1.97-.98" }],
    ["path", { d: "M18.74 13.09c.26-.15.51-.34.73-.56L21 11l-1.53-1.53a3.5 3.5 0 0 0-4.62-.28" }],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/wheat.js
  var Wheat = [
    ["path", { d: "M2 22 16 8" }],
    [
      "path",
      { d: "M3.47 12.53 5 11l1.53 1.53a3.5 3.5 0 0 1 0 4.94L5 19l-1.53-1.53a3.5 3.5 0 0 1 0-4.94Z" }
    ],
    [
      "path",
      { d: "M7.47 8.53 9 7l1.53 1.53a3.5 3.5 0 0 1 0 4.94L9 15l-1.53-1.53a3.5 3.5 0 0 1 0-4.94Z" }
    ],
    [
      "path",
      { d: "M11.47 4.53 13 3l1.53 1.53a3.5 3.5 0 0 1 0 4.94L13 11l-1.53-1.53a3.5 3.5 0 0 1 0-4.94Z" }
    ],
    ["path", { d: "M20 2h2v2a4 4 0 0 1-4 4h-2V6a4 4 0 0 1 4-4Z" }],
    [
      "path",
      {
        d: "M11.47 17.47 13 19l-1.53 1.53a3.5 3.5 0 0 1-4.94 0L5 19l1.53-1.53a3.5 3.5 0 0 1 4.94 0Z"
      }
    ],
    [
      "path",
      {
        d: "M15.47 13.47 17 15l-1.53 1.53a3.5 3.5 0 0 1-4.94 0L9 15l1.53-1.53a3.5 3.5 0 0 1 4.94 0Z"
      }
    ],
    [
      "path",
      {
        d: "M19.47 9.47 21 11l-1.53 1.53a3.5 3.5 0 0 1-4.94 0L13 11l1.53-1.53a3.5 3.5 0 0 1 4.94 0Z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/whole-word.js
  var WholeWord = [
    ["circle", { cx: "7", cy: "12", r: "3" }],
    ["path", { d: "M10 9v6" }],
    ["circle", { cx: "17", cy: "12", r: "3" }],
    ["path", { d: "M14 7v8" }],
    ["path", { d: "M22 17v1c0 .5-.5 1-1 1H3c-.5 0-1-.5-1-1v-1" }]
  ];

  // node_modules/lucide/dist/esm/icons/wifi-high.js
  var WifiHigh = [
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M5 12.859a10 10 0 0 1 14 0" }],
    ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/wifi-low.js
  var WifiLow = [
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/wifi-off.js
  var WifiOff = [
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0" }],
    ["path", { d: "M5 12.859a10 10 0 0 1 5.17-2.69" }],
    ["path", { d: "M19 12.859a10 10 0 0 0-2.007-1.523" }],
    ["path", { d: "M2 8.82a15 15 0 0 1 4.177-2.643" }],
    ["path", { d: "M22 8.82a15 15 0 0 0-11.288-3.764" }],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/wifi-pen.js
  var WifiPen = [
    ["path", { d: "M2 8.82a15 15 0 0 1 20 0" }],
    [
      "path",
      {
        d: "M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"
      }
    ],
    ["path", { d: "M5 12.859a10 10 0 0 1 10.5-2.222" }],
    ["path", { d: "M8.5 16.429a5 5 0 0 1 3-1.406" }]
  ];

  // node_modules/lucide/dist/esm/icons/wifi-zero.js
  var WifiZero = [["path", { d: "M12 20h.01" }]];

  // node_modules/lucide/dist/esm/icons/wifi.js
  var Wifi = [
    ["path", { d: "M12 20h.01" }],
    ["path", { d: "M2 8.82a15 15 0 0 1 20 0" }],
    ["path", { d: "M5 12.859a10 10 0 0 1 14 0" }],
    ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0" }]
  ];

  // node_modules/lucide/dist/esm/icons/wind-arrow-down.js
  var WindArrowDown = [
    ["path", { d: "M10 2v8" }],
    ["path", { d: "M12.8 21.6A2 2 0 1 0 14 18H2" }],
    ["path", { d: "M17.5 10a2.5 2.5 0 1 1 2 4H2" }],
    ["path", { d: "m6 6 4 4 4-4" }]
  ];

  // node_modules/lucide/dist/esm/icons/wind.js
  var Wind = [
    ["path", { d: "M12.8 19.6A2 2 0 1 0 14 16H2" }],
    ["path", { d: "M17.5 8a2.5 2.5 0 1 1 2 4H2" }],
    ["path", { d: "M9.8 4.4A2 2 0 1 1 11 8H2" }]
  ];

  // node_modules/lucide/dist/esm/icons/wine-off.js
  var WineOff = [
    ["path", { d: "M8 22h8" }],
    ["path", { d: "M7 10h3m7 0h-1.343" }],
    ["path", { d: "M12 15v7" }],
    [
      "path",
      {
        d: "M7.307 7.307A12.33 12.33 0 0 0 7 10a5 5 0 0 0 7.391 4.391M8.638 2.981C8.75 2.668 8.872 2.34 9 2h6c1.5 4 2 6 2 8 0 .407-.05.809-.145 1.198"
      }
    ],
    ["line", { x1: "2", x2: "22", y1: "2", y2: "22" }]
  ];

  // node_modules/lucide/dist/esm/icons/workflow.js
  var Workflow = [
    ["rect", { width: "8", height: "8", x: "3", y: "3", rx: "2" }],
    ["path", { d: "M7 11v4a2 2 0 0 0 2 2h4" }],
    ["rect", { width: "8", height: "8", x: "13", y: "13", rx: "2" }]
  ];

  // node_modules/lucide/dist/esm/icons/wine.js
  var Wine = [
    ["path", { d: "M8 22h8" }],
    ["path", { d: "M7 10h10" }],
    ["path", { d: "M12 15v7" }],
    ["path", { d: "M12 15a5 5 0 0 0 5-5c0-2-.5-4-2-8H9c-1.5 4-2 6-2 8a5 5 0 0 0 5 5Z" }]
  ];

  // node_modules/lucide/dist/esm/icons/worm.js
  var Worm = [
    ["path", { d: "m19 12-1.5 3" }],
    ["path", { d: "M19.63 18.81 22 20" }],
    [
      "path",
      {
        d: "M6.47 8.23a1.68 1.68 0 0 1 2.44 1.93l-.64 2.08a6.76 6.76 0 0 0 10.16 7.67l.42-.27a1 1 0 1 0-2.73-4.21l-.42.27a1.76 1.76 0 0 1-2.63-1.99l.64-2.08A6.66 6.66 0 0 0 3.94 3.9l-.7.4a1 1 0 1 0 2.55 4.34z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/wrap-text.js
  var WrapText = [
    ["line", { x1: "3", x2: "21", y1: "6", y2: "6" }],
    ["path", { d: "M3 12h15a3 3 0 1 1 0 6h-4" }],
    ["polyline", { points: "16 16 14 18 16 20" }],
    ["line", { x1: "3", x2: "10", y1: "18", y2: "18" }]
  ];

  // node_modules/lucide/dist/esm/icons/wrench.js
  var Wrench = [
    [
      "path",
      {
        d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/x.js
  var X = [
    ["path", { d: "M18 6 6 18" }],
    ["path", { d: "m6 6 12 12" }]
  ];

  // node_modules/lucide/dist/esm/icons/youtube.js
  var Youtube = [
    [
      "path",
      {
        d: "M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17"
      }
    ],
    ["path", { d: "m10 15 5-3-5-3z" }]
  ];

  // node_modules/lucide/dist/esm/icons/zap-off.js
  var ZapOff = [
    ["path", { d: "M10.513 4.856 13.12 2.17a.5.5 0 0 1 .86.46l-1.377 4.317" }],
    ["path", { d: "M15.656 10H20a1 1 0 0 1 .78 1.63l-1.72 1.773" }],
    [
      "path",
      {
        d: "M16.273 16.273 10.88 21.83a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14H4a1 1 0 0 1-.78-1.63l4.507-4.643"
      }
    ],
    ["path", { d: "m2 2 20 20" }]
  ];

  // node_modules/lucide/dist/esm/icons/zap.js
  var Zap = [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"
      }
    ]
  ];

  // node_modules/lucide/dist/esm/icons/zoom-in.js
  var ZoomIn = [
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65" }],
    ["line", { x1: "11", x2: "11", y1: "8", y2: "14" }],
    ["line", { x1: "8", x2: "14", y1: "11", y2: "11" }]
  ];

  // node_modules/lucide/dist/esm/icons/zoom-out.js
  var ZoomOut = [
    ["circle", { cx: "11", cy: "11", r: "8" }],
    ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65" }],
    ["line", { x1: "8", x2: "14", y1: "11", y2: "11" }]
  ];

  // node_modules/lucide/dist/esm/lucide.js
  var createIcons = ({ icons = {}, nameAttr = "data-lucide", attrs = {} } = {}) => {
    if (!Object.values(icons).length) {
      throw new Error(
        "Please provide an icons object.\nIf you want to use all the icons you can import it like:\n `import { createIcons, icons } from 'lucide';\nlucide.createIcons({icons});`"
      );
    }
    if (typeof document === "undefined") {
      throw new Error("`createIcons()` only works in a browser environment.");
    }
    const elementsToReplace = document.querySelectorAll(`[${nameAttr}]`);
    Array.from(elementsToReplace).forEach(
      (element) => replaceElement(element, { nameAttr, icons, attrs })
    );
    if (nameAttr === "data-lucide") {
      const deprecatedElements = document.querySelectorAll("[icon-name]");
      if (deprecatedElements.length > 0) {
        console.warn(
          "[Lucide] Some icons were found with the now deprecated icon-name attribute. These will still be replaced for backwards compatibility, but will no longer be supported in v1.0 and you should switch to data-lucide"
        );
        Array.from(deprecatedElements).forEach(
          (element) => replaceElement(element, { nameAttr: "icon-name", icons, attrs })
        );
      }
    }
  };

  // app/javascript/application.js
  var application = Application.start();
  window.Stimulus = application;
  application.register("barcode", barcode_controller_default);
  application.register("scan", scan_controller_default);
  application.register("spinner", spinner_controller_default);
  application.register("memo-modal", memo_modal_controller_default);
  application.register("image-upload", image_upload_controller_default);
  application.register("modal-swipe", modal_swipe_controller_default);
  application.register("confirm-modal", confirm_modal_controller_default);
  application.register("tag-toggle", tag_toggle_controller_default);
  application.register("ui-toggle", ui_toggle_controller_default);
  application.register("column-selector", column_selector_controller_default);
  application.register("auto-remove", auto_remove_controller_default);
  application.register("auto-submit", auto_submit_controller_default);
  application.register("infinite-scroll", infinite_scroll_controller_default);
  application.register("safari-click-fix", safari_click_fix_controller_default);
  application.register("detail-card-column-selector", detail_card_column_selector_controller_default);
  application.register("book-edit", book_edit_controller_default);
  window.bootstrap = bootstrap_esm_exports;
  window.Turbo = turbo_es2017_esm_exports;
  document.addEventListener("turbo:load", () => {
    createIcons({ icons: iconsAndAliases_exports });
  });
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

bootstrap/dist/js/bootstrap.esm.js:
  (*!
    * Bootstrap v5.3.6 (https://getbootstrap.com/)
    * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.13
  Copyright © 2025 37signals LLC
   *)

lucide/dist/esm/defaultAttributes.js:
lucide/dist/esm/createElement.js:
lucide/dist/esm/replaceElement.js:
lucide/dist/esm/icons/a-arrow-down.js:
lucide/dist/esm/icons/a-arrow-up.js:
lucide/dist/esm/icons/a-large-small.js:
lucide/dist/esm/icons/accessibility.js:
lucide/dist/esm/icons/activity.js:
lucide/dist/esm/icons/air-vent.js:
lucide/dist/esm/icons/airplay.js:
lucide/dist/esm/icons/alarm-clock-check.js:
lucide/dist/esm/icons/alarm-clock-minus.js:
lucide/dist/esm/icons/alarm-clock-off.js:
lucide/dist/esm/icons/alarm-clock-plus.js:
lucide/dist/esm/icons/alarm-clock.js:
lucide/dist/esm/icons/alarm-smoke.js:
lucide/dist/esm/icons/album.js:
lucide/dist/esm/icons/align-center-vertical.js:
lucide/dist/esm/icons/align-center-horizontal.js:
lucide/dist/esm/icons/align-center.js:
lucide/dist/esm/icons/align-end-horizontal.js:
lucide/dist/esm/icons/align-end-vertical.js:
lucide/dist/esm/icons/align-horizontal-distribute-center.js:
lucide/dist/esm/icons/align-horizontal-distribute-end.js:
lucide/dist/esm/icons/align-horizontal-distribute-start.js:
lucide/dist/esm/icons/align-horizontal-justify-center.js:
lucide/dist/esm/icons/align-horizontal-justify-end.js:
lucide/dist/esm/icons/align-horizontal-justify-start.js:
lucide/dist/esm/icons/align-horizontal-space-around.js:
lucide/dist/esm/icons/align-horizontal-space-between.js:
lucide/dist/esm/icons/align-justify.js:
lucide/dist/esm/icons/align-left.js:
lucide/dist/esm/icons/align-right.js:
lucide/dist/esm/icons/align-start-horizontal.js:
lucide/dist/esm/icons/align-start-vertical.js:
lucide/dist/esm/icons/align-vertical-distribute-center.js:
lucide/dist/esm/icons/align-vertical-distribute-end.js:
lucide/dist/esm/icons/align-vertical-distribute-start.js:
lucide/dist/esm/icons/align-vertical-justify-center.js:
lucide/dist/esm/icons/align-vertical-justify-end.js:
lucide/dist/esm/icons/align-vertical-justify-start.js:
lucide/dist/esm/icons/align-vertical-space-around.js:
lucide/dist/esm/icons/align-vertical-space-between.js:
lucide/dist/esm/icons/ambulance.js:
lucide/dist/esm/icons/ampersand.js:
lucide/dist/esm/icons/ampersands.js:
lucide/dist/esm/icons/amphora.js:
lucide/dist/esm/icons/anchor.js:
lucide/dist/esm/icons/angry.js:
lucide/dist/esm/icons/antenna.js:
lucide/dist/esm/icons/annoyed.js:
lucide/dist/esm/icons/anvil.js:
lucide/dist/esm/icons/aperture.js:
lucide/dist/esm/icons/app-window-mac.js:
lucide/dist/esm/icons/app-window.js:
lucide/dist/esm/icons/apple.js:
lucide/dist/esm/icons/archive-restore.js:
lucide/dist/esm/icons/archive-x.js:
lucide/dist/esm/icons/archive.js:
lucide/dist/esm/icons/armchair.js:
lucide/dist/esm/icons/arrow-big-down-dash.js:
lucide/dist/esm/icons/arrow-big-down.js:
lucide/dist/esm/icons/arrow-big-left-dash.js:
lucide/dist/esm/icons/arrow-big-left.js:
lucide/dist/esm/icons/arrow-big-right-dash.js:
lucide/dist/esm/icons/arrow-big-up-dash.js:
lucide/dist/esm/icons/arrow-big-right.js:
lucide/dist/esm/icons/arrow-big-up.js:
lucide/dist/esm/icons/arrow-down-0-1.js:
lucide/dist/esm/icons/arrow-down-1-0.js:
lucide/dist/esm/icons/arrow-down-a-z.js:
lucide/dist/esm/icons/arrow-down-from-line.js:
lucide/dist/esm/icons/arrow-down-left.js:
lucide/dist/esm/icons/arrow-down-right.js:
lucide/dist/esm/icons/arrow-down-narrow-wide.js:
lucide/dist/esm/icons/arrow-down-to-dot.js:
lucide/dist/esm/icons/arrow-down-to-line.js:
lucide/dist/esm/icons/arrow-down-up.js:
lucide/dist/esm/icons/arrow-down-wide-narrow.js:
lucide/dist/esm/icons/arrow-down-z-a.js:
lucide/dist/esm/icons/arrow-down.js:
lucide/dist/esm/icons/arrow-left-from-line.js:
lucide/dist/esm/icons/arrow-left-right.js:
lucide/dist/esm/icons/arrow-left-to-line.js:
lucide/dist/esm/icons/arrow-left.js:
lucide/dist/esm/icons/arrow-right-from-line.js:
lucide/dist/esm/icons/arrow-right-left.js:
lucide/dist/esm/icons/arrow-right-to-line.js:
lucide/dist/esm/icons/arrow-right.js:
lucide/dist/esm/icons/arrow-up-0-1.js:
lucide/dist/esm/icons/arrow-up-1-0.js:
lucide/dist/esm/icons/arrow-up-a-z.js:
lucide/dist/esm/icons/arrow-up-down.js:
lucide/dist/esm/icons/arrow-up-from-dot.js:
lucide/dist/esm/icons/arrow-up-from-line.js:
lucide/dist/esm/icons/arrow-up-left.js:
lucide/dist/esm/icons/arrow-up-narrow-wide.js:
lucide/dist/esm/icons/arrow-up-right.js:
lucide/dist/esm/icons/arrow-up-to-line.js:
lucide/dist/esm/icons/arrow-up-wide-narrow.js:
lucide/dist/esm/icons/arrow-up-z-a.js:
lucide/dist/esm/icons/arrows-up-from-line.js:
lucide/dist/esm/icons/arrow-up.js:
lucide/dist/esm/icons/asterisk.js:
lucide/dist/esm/icons/at-sign.js:
lucide/dist/esm/icons/atom.js:
lucide/dist/esm/icons/audio-lines.js:
lucide/dist/esm/icons/audio-waveform.js:
lucide/dist/esm/icons/award.js:
lucide/dist/esm/icons/axe.js:
lucide/dist/esm/icons/axis-3d.js:
lucide/dist/esm/icons/baby.js:
lucide/dist/esm/icons/backpack.js:
lucide/dist/esm/icons/badge-alert.js:
lucide/dist/esm/icons/badge-cent.js:
lucide/dist/esm/icons/badge-check.js:
lucide/dist/esm/icons/badge-dollar-sign.js:
lucide/dist/esm/icons/badge-euro.js:
lucide/dist/esm/icons/badge-help.js:
lucide/dist/esm/icons/badge-indian-rupee.js:
lucide/dist/esm/icons/badge-info.js:
lucide/dist/esm/icons/badge-japanese-yen.js:
lucide/dist/esm/icons/badge-minus.js:
lucide/dist/esm/icons/badge-percent.js:
lucide/dist/esm/icons/badge-plus.js:
lucide/dist/esm/icons/badge-pound-sterling.js:
lucide/dist/esm/icons/badge-russian-ruble.js:
lucide/dist/esm/icons/badge-x.js:
lucide/dist/esm/icons/badge-swiss-franc.js:
lucide/dist/esm/icons/badge.js:
lucide/dist/esm/icons/baggage-claim.js:
lucide/dist/esm/icons/ban.js:
lucide/dist/esm/icons/banana.js:
lucide/dist/esm/icons/bandage.js:
lucide/dist/esm/icons/banknote-arrow-down.js:
lucide/dist/esm/icons/banknote-arrow-up.js:
lucide/dist/esm/icons/banknote-x.js:
lucide/dist/esm/icons/banknote.js:
lucide/dist/esm/icons/barcode.js:
lucide/dist/esm/icons/baseline.js:
lucide/dist/esm/icons/bath.js:
lucide/dist/esm/icons/battery-charging.js:
lucide/dist/esm/icons/battery-low.js:
lucide/dist/esm/icons/battery-full.js:
lucide/dist/esm/icons/battery-medium.js:
lucide/dist/esm/icons/battery-plus.js:
lucide/dist/esm/icons/battery-warning.js:
lucide/dist/esm/icons/battery.js:
lucide/dist/esm/icons/beaker.js:
lucide/dist/esm/icons/bean-off.js:
lucide/dist/esm/icons/bean.js:
lucide/dist/esm/icons/bed-double.js:
lucide/dist/esm/icons/bed-single.js:
lucide/dist/esm/icons/bed.js:
lucide/dist/esm/icons/beef.js:
lucide/dist/esm/icons/beer-off.js:
lucide/dist/esm/icons/beer.js:
lucide/dist/esm/icons/bell-dot.js:
lucide/dist/esm/icons/bell-electric.js:
lucide/dist/esm/icons/bell-minus.js:
lucide/dist/esm/icons/bell-plus.js:
lucide/dist/esm/icons/bell-off.js:
lucide/dist/esm/icons/bell.js:
lucide/dist/esm/icons/bell-ring.js:
lucide/dist/esm/icons/between-horizontal-end.js:
lucide/dist/esm/icons/between-horizontal-start.js:
lucide/dist/esm/icons/between-vertical-end.js:
lucide/dist/esm/icons/between-vertical-start.js:
lucide/dist/esm/icons/biceps-flexed.js:
lucide/dist/esm/icons/bike.js:
lucide/dist/esm/icons/binoculars.js:
lucide/dist/esm/icons/binary.js:
lucide/dist/esm/icons/biohazard.js:
lucide/dist/esm/icons/bird.js:
lucide/dist/esm/icons/bitcoin.js:
lucide/dist/esm/icons/blend.js:
lucide/dist/esm/icons/blinds.js:
lucide/dist/esm/icons/blocks.js:
lucide/dist/esm/icons/bluetooth-connected.js:
lucide/dist/esm/icons/bluetooth-off.js:
lucide/dist/esm/icons/bluetooth-searching.js:
lucide/dist/esm/icons/bold.js:
lucide/dist/esm/icons/bolt.js:
lucide/dist/esm/icons/bluetooth.js:
lucide/dist/esm/icons/bone.js:
lucide/dist/esm/icons/bomb.js:
lucide/dist/esm/icons/book-audio.js:
lucide/dist/esm/icons/book-check.js:
lucide/dist/esm/icons/book-a.js:
lucide/dist/esm/icons/book-copy.js:
lucide/dist/esm/icons/book-down.js:
lucide/dist/esm/icons/book-dashed.js:
lucide/dist/esm/icons/book-headphones.js:
lucide/dist/esm/icons/book-heart.js:
lucide/dist/esm/icons/book-image.js:
lucide/dist/esm/icons/book-key.js:
lucide/dist/esm/icons/book-marked.js:
lucide/dist/esm/icons/book-lock.js:
lucide/dist/esm/icons/book-minus.js:
lucide/dist/esm/icons/book-open-check.js:
lucide/dist/esm/icons/book-open-text.js:
lucide/dist/esm/icons/book-open.js:
lucide/dist/esm/icons/book-plus.js:
lucide/dist/esm/icons/book-text.js:
lucide/dist/esm/icons/book-type.js:
lucide/dist/esm/icons/book-up-2.js:
lucide/dist/esm/icons/book-up.js:
lucide/dist/esm/icons/book-user.js:
lucide/dist/esm/icons/book-x.js:
lucide/dist/esm/icons/book.js:
lucide/dist/esm/icons/bookmark-check.js:
lucide/dist/esm/icons/bookmark-minus.js:
lucide/dist/esm/icons/bookmark-plus.js:
lucide/dist/esm/icons/bookmark-x.js:
lucide/dist/esm/icons/bookmark.js:
lucide/dist/esm/icons/boom-box.js:
lucide/dist/esm/icons/bot-message-square.js:
lucide/dist/esm/icons/bot-off.js:
lucide/dist/esm/icons/bot.js:
lucide/dist/esm/icons/bow-arrow.js:
lucide/dist/esm/icons/box.js:
lucide/dist/esm/icons/boxes.js:
lucide/dist/esm/icons/braces.js:
lucide/dist/esm/icons/brackets.js:
lucide/dist/esm/icons/brain-cog.js:
lucide/dist/esm/icons/brain-circuit.js:
lucide/dist/esm/icons/brain.js:
lucide/dist/esm/icons/brick-wall-fire.js:
lucide/dist/esm/icons/brick-wall.js:
lucide/dist/esm/icons/briefcase-business.js:
lucide/dist/esm/icons/briefcase-conveyor-belt.js:
lucide/dist/esm/icons/briefcase-medical.js:
lucide/dist/esm/icons/bring-to-front.js:
lucide/dist/esm/icons/brush-cleaning.js:
lucide/dist/esm/icons/briefcase.js:
lucide/dist/esm/icons/brush.js:
lucide/dist/esm/icons/bug-off.js:
lucide/dist/esm/icons/bug-play.js:
lucide/dist/esm/icons/bubbles.js:
lucide/dist/esm/icons/bug.js:
lucide/dist/esm/icons/building-2.js:
lucide/dist/esm/icons/building.js:
lucide/dist/esm/icons/bus.js:
lucide/dist/esm/icons/cable-car.js:
lucide/dist/esm/icons/bus-front.js:
lucide/dist/esm/icons/cable.js:
lucide/dist/esm/icons/cake-slice.js:
lucide/dist/esm/icons/cake.js:
lucide/dist/esm/icons/calendar-1.js:
lucide/dist/esm/icons/calendar-arrow-down.js:
lucide/dist/esm/icons/calculator.js:
lucide/dist/esm/icons/calendar-arrow-up.js:
lucide/dist/esm/icons/calendar-check-2.js:
lucide/dist/esm/icons/calendar-check.js:
lucide/dist/esm/icons/calendar-clock.js:
lucide/dist/esm/icons/calendar-cog.js:
lucide/dist/esm/icons/calendar-days.js:
lucide/dist/esm/icons/calendar-fold.js:
lucide/dist/esm/icons/calendar-heart.js:
lucide/dist/esm/icons/calendar-minus-2.js:
lucide/dist/esm/icons/calendar-minus.js:
lucide/dist/esm/icons/calendar-off.js:
lucide/dist/esm/icons/calendar-plus-2.js:
lucide/dist/esm/icons/calendar-plus.js:
lucide/dist/esm/icons/calendar-range.js:
lucide/dist/esm/icons/calendar-search.js:
lucide/dist/esm/icons/calendar-sync.js:
lucide/dist/esm/icons/calendar-x-2.js:
lucide/dist/esm/icons/calendar-x.js:
lucide/dist/esm/icons/calendar.js:
lucide/dist/esm/icons/camera-off.js:
lucide/dist/esm/icons/camera.js:
lucide/dist/esm/icons/candy-cane.js:
lucide/dist/esm/icons/candy-off.js:
lucide/dist/esm/icons/candy.js:
lucide/dist/esm/icons/cannabis.js:
lucide/dist/esm/icons/captions-off.js:
lucide/dist/esm/icons/car-front.js:
lucide/dist/esm/icons/captions.js:
lucide/dist/esm/icons/car-taxi-front.js:
lucide/dist/esm/icons/car.js:
lucide/dist/esm/icons/caravan.js:
lucide/dist/esm/icons/carrot.js:
lucide/dist/esm/icons/case-lower.js:
lucide/dist/esm/icons/case-sensitive.js:
lucide/dist/esm/icons/case-upper.js:
lucide/dist/esm/icons/cassette-tape.js:
lucide/dist/esm/icons/cast.js:
lucide/dist/esm/icons/castle.js:
lucide/dist/esm/icons/cat.js:
lucide/dist/esm/icons/chart-area.js:
lucide/dist/esm/icons/cctv.js:
lucide/dist/esm/icons/chart-bar-big.js:
lucide/dist/esm/icons/chart-bar-decreasing.js:
lucide/dist/esm/icons/chart-bar-stacked.js:
lucide/dist/esm/icons/chart-bar-increasing.js:
lucide/dist/esm/icons/chart-bar.js:
lucide/dist/esm/icons/chart-candlestick.js:
lucide/dist/esm/icons/chart-column-big.js:
lucide/dist/esm/icons/chart-column-decreasing.js:
lucide/dist/esm/icons/chart-column-increasing.js:
lucide/dist/esm/icons/chart-column-stacked.js:
lucide/dist/esm/icons/chart-column.js:
lucide/dist/esm/icons/chart-gantt.js:
lucide/dist/esm/icons/chart-line.js:
lucide/dist/esm/icons/chart-network.js:
lucide/dist/esm/icons/chart-no-axes-column-decreasing.js:
lucide/dist/esm/icons/chart-no-axes-column-increasing.js:
lucide/dist/esm/icons/chart-no-axes-column.js:
lucide/dist/esm/icons/chart-no-axes-combined.js:
lucide/dist/esm/icons/chart-no-axes-gantt.js:
lucide/dist/esm/icons/chart-pie.js:
lucide/dist/esm/icons/chart-scatter.js:
lucide/dist/esm/icons/chart-spline.js:
lucide/dist/esm/icons/check-check.js:
lucide/dist/esm/icons/check.js:
lucide/dist/esm/icons/chef-hat.js:
lucide/dist/esm/icons/cherry.js:
lucide/dist/esm/icons/chevron-down.js:
lucide/dist/esm/icons/chevron-first.js:
lucide/dist/esm/icons/chevron-left.js:
lucide/dist/esm/icons/chevron-last.js:
lucide/dist/esm/icons/chevron-right.js:
lucide/dist/esm/icons/chevrons-down-up.js:
lucide/dist/esm/icons/chevron-up.js:
lucide/dist/esm/icons/chevrons-down.js:
lucide/dist/esm/icons/chevrons-left-right-ellipsis.js:
lucide/dist/esm/icons/chevrons-left-right.js:
lucide/dist/esm/icons/chevrons-left.js:
lucide/dist/esm/icons/chevrons-right-left.js:
lucide/dist/esm/icons/chevrons-up-down.js:
lucide/dist/esm/icons/chevrons-right.js:
lucide/dist/esm/icons/chevrons-up.js:
lucide/dist/esm/icons/chrome.js:
lucide/dist/esm/icons/cigarette-off.js:
lucide/dist/esm/icons/church.js:
lucide/dist/esm/icons/cigarette.js:
lucide/dist/esm/icons/circle-alert.js:
lucide/dist/esm/icons/circle-arrow-down.js:
lucide/dist/esm/icons/circle-arrow-left.js:
lucide/dist/esm/icons/circle-arrow-out-down-left.js:
lucide/dist/esm/icons/circle-arrow-out-down-right.js:
lucide/dist/esm/icons/circle-arrow-out-up-left.js:
lucide/dist/esm/icons/circle-arrow-out-up-right.js:
lucide/dist/esm/icons/circle-arrow-up.js:
lucide/dist/esm/icons/circle-arrow-right.js:
lucide/dist/esm/icons/circle-check-big.js:
lucide/dist/esm/icons/circle-check.js:
lucide/dist/esm/icons/circle-chevron-down.js:
lucide/dist/esm/icons/circle-chevron-left.js:
lucide/dist/esm/icons/circle-chevron-right.js:
lucide/dist/esm/icons/circle-chevron-up.js:
lucide/dist/esm/icons/circle-dashed.js:
lucide/dist/esm/icons/circle-divide.js:
lucide/dist/esm/icons/circle-dollar-sign.js:
lucide/dist/esm/icons/circle-dot-dashed.js:
lucide/dist/esm/icons/circle-dot.js:
lucide/dist/esm/icons/circle-ellipsis.js:
lucide/dist/esm/icons/circle-equal.js:
lucide/dist/esm/icons/circle-fading-arrow-up.js:
lucide/dist/esm/icons/circle-fading-plus.js:
lucide/dist/esm/icons/circle-gauge.js:
lucide/dist/esm/icons/circle-help.js:
lucide/dist/esm/icons/circle-minus.js:
lucide/dist/esm/icons/circle-off.js:
lucide/dist/esm/icons/circle-parking-off.js:
lucide/dist/esm/icons/circle-parking.js:
lucide/dist/esm/icons/circle-pause.js:
lucide/dist/esm/icons/circle-percent.js:
lucide/dist/esm/icons/circle-play.js:
lucide/dist/esm/icons/circle-plus.js:
lucide/dist/esm/icons/circle-power.js:
lucide/dist/esm/icons/circle-slash-2.js:
lucide/dist/esm/icons/circle-slash.js:
lucide/dist/esm/icons/circle-small.js:
lucide/dist/esm/icons/circle-stop.js:
lucide/dist/esm/icons/circle-user-round.js:
lucide/dist/esm/icons/circle-user.js:
lucide/dist/esm/icons/circle.js:
lucide/dist/esm/icons/circuit-board.js:
lucide/dist/esm/icons/circle-x.js:
lucide/dist/esm/icons/citrus.js:
lucide/dist/esm/icons/clapperboard.js:
lucide/dist/esm/icons/clipboard-check.js:
lucide/dist/esm/icons/clipboard-copy.js:
lucide/dist/esm/icons/clipboard-list.js:
lucide/dist/esm/icons/clipboard-minus.js:
lucide/dist/esm/icons/clipboard-paste.js:
lucide/dist/esm/icons/clipboard-pen-line.js:
lucide/dist/esm/icons/clipboard-pen.js:
lucide/dist/esm/icons/clipboard-plus.js:
lucide/dist/esm/icons/clipboard-type.js:
lucide/dist/esm/icons/clipboard-x.js:
lucide/dist/esm/icons/clipboard.js:
lucide/dist/esm/icons/clock-1.js:
lucide/dist/esm/icons/clock-10.js:
lucide/dist/esm/icons/clock-11.js:
lucide/dist/esm/icons/clock-12.js:
lucide/dist/esm/icons/clock-2.js:
lucide/dist/esm/icons/clock-3.js:
lucide/dist/esm/icons/clock-4.js:
lucide/dist/esm/icons/clock-5.js:
lucide/dist/esm/icons/clock-6.js:
lucide/dist/esm/icons/clock-7.js:
lucide/dist/esm/icons/clock-9.js:
lucide/dist/esm/icons/clock-8.js:
lucide/dist/esm/icons/clock-alert.js:
lucide/dist/esm/icons/clock-arrow-down.js:
lucide/dist/esm/icons/clock-arrow-up.js:
lucide/dist/esm/icons/clock-fading.js:
lucide/dist/esm/icons/clock-plus.js:
lucide/dist/esm/icons/clock.js:
lucide/dist/esm/icons/cloud-alert.js:
lucide/dist/esm/icons/cloud-cog.js:
lucide/dist/esm/icons/cloud-download.js:
lucide/dist/esm/icons/cloud-fog.js:
lucide/dist/esm/icons/cloud-drizzle.js:
lucide/dist/esm/icons/cloud-hail.js:
lucide/dist/esm/icons/cloud-lightning.js:
lucide/dist/esm/icons/cloud-moon-rain.js:
lucide/dist/esm/icons/cloud-moon.js:
lucide/dist/esm/icons/cloud-off.js:
lucide/dist/esm/icons/cloud-rain-wind.js:
lucide/dist/esm/icons/cloud-rain.js:
lucide/dist/esm/icons/cloud-snow.js:
lucide/dist/esm/icons/cloud-sun-rain.js:
lucide/dist/esm/icons/cloud-sun.js:
lucide/dist/esm/icons/cloud-upload.js:
lucide/dist/esm/icons/cloud.js:
lucide/dist/esm/icons/clover.js:
lucide/dist/esm/icons/cloudy.js:
lucide/dist/esm/icons/club.js:
lucide/dist/esm/icons/code-xml.js:
lucide/dist/esm/icons/code.js:
lucide/dist/esm/icons/codepen.js:
lucide/dist/esm/icons/codesandbox.js:
lucide/dist/esm/icons/coffee.js:
lucide/dist/esm/icons/cog.js:
lucide/dist/esm/icons/coins.js:
lucide/dist/esm/icons/columns-2.js:
lucide/dist/esm/icons/columns-3-cog.js:
lucide/dist/esm/icons/columns-3.js:
lucide/dist/esm/icons/columns-4.js:
lucide/dist/esm/icons/combine.js:
lucide/dist/esm/icons/command.js:
lucide/dist/esm/icons/component.js:
lucide/dist/esm/icons/compass.js:
lucide/dist/esm/icons/computer.js:
lucide/dist/esm/icons/concierge-bell.js:
lucide/dist/esm/icons/cone.js:
lucide/dist/esm/icons/construction.js:
lucide/dist/esm/icons/contact-round.js:
lucide/dist/esm/icons/contact.js:
lucide/dist/esm/icons/container.js:
lucide/dist/esm/icons/contrast.js:
lucide/dist/esm/icons/cookie.js:
lucide/dist/esm/icons/cooking-pot.js:
lucide/dist/esm/icons/copy-check.js:
lucide/dist/esm/icons/copy-minus.js:
lucide/dist/esm/icons/copy-plus.js:
lucide/dist/esm/icons/copy-slash.js:
lucide/dist/esm/icons/copy-x.js:
lucide/dist/esm/icons/copy.js:
lucide/dist/esm/icons/copyleft.js:
lucide/dist/esm/icons/copyright.js:
lucide/dist/esm/icons/corner-down-left.js:
lucide/dist/esm/icons/corner-down-right.js:
lucide/dist/esm/icons/corner-left-down.js:
lucide/dist/esm/icons/corner-left-up.js:
lucide/dist/esm/icons/corner-right-down.js:
lucide/dist/esm/icons/corner-right-up.js:
lucide/dist/esm/icons/corner-up-left.js:
lucide/dist/esm/icons/corner-up-right.js:
lucide/dist/esm/icons/cpu.js:
lucide/dist/esm/icons/creative-commons.js:
lucide/dist/esm/icons/credit-card.js:
lucide/dist/esm/icons/croissant.js:
lucide/dist/esm/icons/crop.js:
lucide/dist/esm/icons/cross.js:
lucide/dist/esm/icons/crosshair.js:
lucide/dist/esm/icons/crown.js:
lucide/dist/esm/icons/cuboid.js:
lucide/dist/esm/icons/cup-soda.js:
lucide/dist/esm/icons/currency.js:
lucide/dist/esm/icons/cylinder.js:
lucide/dist/esm/icons/database-backup.js:
lucide/dist/esm/icons/database-zap.js:
lucide/dist/esm/icons/database.js:
lucide/dist/esm/icons/dam.js:
lucide/dist/esm/icons/decimals-arrow-left.js:
lucide/dist/esm/icons/decimals-arrow-right.js:
lucide/dist/esm/icons/delete.js:
lucide/dist/esm/icons/dessert.js:
lucide/dist/esm/icons/diameter.js:
lucide/dist/esm/icons/diamond-minus.js:
lucide/dist/esm/icons/diamond-percent.js:
lucide/dist/esm/icons/diamond-plus.js:
lucide/dist/esm/icons/diamond.js:
lucide/dist/esm/icons/dice-1.js:
lucide/dist/esm/icons/dice-2.js:
lucide/dist/esm/icons/dice-3.js:
lucide/dist/esm/icons/dice-4.js:
lucide/dist/esm/icons/dice-5.js:
lucide/dist/esm/icons/dice-6.js:
lucide/dist/esm/icons/dices.js:
lucide/dist/esm/icons/diff.js:
lucide/dist/esm/icons/disc-2.js:
lucide/dist/esm/icons/disc-3.js:
lucide/dist/esm/icons/disc.js:
lucide/dist/esm/icons/disc-album.js:
lucide/dist/esm/icons/divide.js:
lucide/dist/esm/icons/dna-off.js:
lucide/dist/esm/icons/dock.js:
lucide/dist/esm/icons/dna.js:
lucide/dist/esm/icons/dog.js:
lucide/dist/esm/icons/dollar-sign.js:
lucide/dist/esm/icons/donut.js:
lucide/dist/esm/icons/door-closed.js:
lucide/dist/esm/icons/door-closed-locked.js:
lucide/dist/esm/icons/door-open.js:
lucide/dist/esm/icons/dot.js:
lucide/dist/esm/icons/download.js:
lucide/dist/esm/icons/drafting-compass.js:
lucide/dist/esm/icons/dribbble.js:
lucide/dist/esm/icons/drama.js:
lucide/dist/esm/icons/drill.js:
lucide/dist/esm/icons/droplet-off.js:
lucide/dist/esm/icons/droplet.js:
lucide/dist/esm/icons/droplets.js:
lucide/dist/esm/icons/drum.js:
lucide/dist/esm/icons/drumstick.js:
lucide/dist/esm/icons/dumbbell.js:
lucide/dist/esm/icons/ear.js:
lucide/dist/esm/icons/ear-off.js:
lucide/dist/esm/icons/earth-lock.js:
lucide/dist/esm/icons/earth.js:
lucide/dist/esm/icons/eclipse.js:
lucide/dist/esm/icons/egg-fried.js:
lucide/dist/esm/icons/egg-off.js:
lucide/dist/esm/icons/egg.js:
lucide/dist/esm/icons/ellipsis-vertical.js:
lucide/dist/esm/icons/ellipsis.js:
lucide/dist/esm/icons/equal-approximately.js:
lucide/dist/esm/icons/equal-not.js:
lucide/dist/esm/icons/equal.js:
lucide/dist/esm/icons/eraser.js:
lucide/dist/esm/icons/ethernet-port.js:
lucide/dist/esm/icons/euro.js:
lucide/dist/esm/icons/external-link.js:
lucide/dist/esm/icons/eye-closed.js:
lucide/dist/esm/icons/expand.js:
lucide/dist/esm/icons/eye-off.js:
lucide/dist/esm/icons/facebook.js:
lucide/dist/esm/icons/eye.js:
lucide/dist/esm/icons/factory.js:
lucide/dist/esm/icons/fan.js:
lucide/dist/esm/icons/fast-forward.js:
lucide/dist/esm/icons/feather.js:
lucide/dist/esm/icons/fence.js:
lucide/dist/esm/icons/ferris-wheel.js:
lucide/dist/esm/icons/figma.js:
lucide/dist/esm/icons/file-archive.js:
lucide/dist/esm/icons/file-audio-2.js:
lucide/dist/esm/icons/file-audio.js:
lucide/dist/esm/icons/file-axis-3d.js:
lucide/dist/esm/icons/file-badge.js:
lucide/dist/esm/icons/file-badge-2.js:
lucide/dist/esm/icons/file-box.js:
lucide/dist/esm/icons/file-chart-column-increasing.js:
lucide/dist/esm/icons/file-chart-column.js:
lucide/dist/esm/icons/file-chart-pie.js:
lucide/dist/esm/icons/file-chart-line.js:
lucide/dist/esm/icons/file-check-2.js:
lucide/dist/esm/icons/file-check.js:
lucide/dist/esm/icons/file-clock.js:
lucide/dist/esm/icons/file-code-2.js:
lucide/dist/esm/icons/file-code.js:
lucide/dist/esm/icons/file-cog.js:
lucide/dist/esm/icons/file-diff.js:
lucide/dist/esm/icons/file-digit.js:
lucide/dist/esm/icons/file-down.js:
lucide/dist/esm/icons/file-heart.js:
lucide/dist/esm/icons/file-image.js:
lucide/dist/esm/icons/file-input.js:
lucide/dist/esm/icons/file-json-2.js:
lucide/dist/esm/icons/file-json.js:
lucide/dist/esm/icons/file-key-2.js:
lucide/dist/esm/icons/file-key.js:
lucide/dist/esm/icons/file-lock-2.js:
lucide/dist/esm/icons/file-lock.js:
lucide/dist/esm/icons/file-minus-2.js:
lucide/dist/esm/icons/file-minus.js:
lucide/dist/esm/icons/file-music.js:
lucide/dist/esm/icons/file-output.js:
lucide/dist/esm/icons/file-pen-line.js:
lucide/dist/esm/icons/file-pen.js:
lucide/dist/esm/icons/file-plus-2.js:
lucide/dist/esm/icons/file-plus.js:
lucide/dist/esm/icons/file-question.js:
lucide/dist/esm/icons/file-scan.js:
lucide/dist/esm/icons/file-search-2.js:
lucide/dist/esm/icons/file-sliders.js:
lucide/dist/esm/icons/file-search.js:
lucide/dist/esm/icons/file-spreadsheet.js:
lucide/dist/esm/icons/file-stack.js:
lucide/dist/esm/icons/file-symlink.js:
lucide/dist/esm/icons/file-terminal.js:
lucide/dist/esm/icons/file-text.js:
lucide/dist/esm/icons/file-type-2.js:
lucide/dist/esm/icons/file-type.js:
lucide/dist/esm/icons/file-up.js:
lucide/dist/esm/icons/file-user.js:
lucide/dist/esm/icons/file-video-2.js:
lucide/dist/esm/icons/file-volume-2.js:
lucide/dist/esm/icons/file-video.js:
lucide/dist/esm/icons/file-warning.js:
lucide/dist/esm/icons/file-volume.js:
lucide/dist/esm/icons/file-x-2.js:
lucide/dist/esm/icons/file.js:
lucide/dist/esm/icons/file-x.js:
lucide/dist/esm/icons/files.js:
lucide/dist/esm/icons/film.js:
lucide/dist/esm/icons/fire-extinguisher.js:
lucide/dist/esm/icons/fingerprint.js:
lucide/dist/esm/icons/fish-off.js:
lucide/dist/esm/icons/fish-symbol.js:
lucide/dist/esm/icons/fish.js:
lucide/dist/esm/icons/flag-off.js:
lucide/dist/esm/icons/flag-triangle-left.js:
lucide/dist/esm/icons/flag-triangle-right.js:
lucide/dist/esm/icons/flag.js:
lucide/dist/esm/icons/flame-kindling.js:
lucide/dist/esm/icons/flame.js:
lucide/dist/esm/icons/flashlight-off.js:
lucide/dist/esm/icons/flashlight.js:
lucide/dist/esm/icons/flask-conical-off.js:
lucide/dist/esm/icons/flask-conical.js:
lucide/dist/esm/icons/flask-round.js:
lucide/dist/esm/icons/flip-horizontal-2.js:
lucide/dist/esm/icons/flip-horizontal.js:
lucide/dist/esm/icons/flip-vertical-2.js:
lucide/dist/esm/icons/flip-vertical.js:
lucide/dist/esm/icons/flower-2.js:
lucide/dist/esm/icons/focus.js:
lucide/dist/esm/icons/flower.js:
lucide/dist/esm/icons/fold-horizontal.js:
lucide/dist/esm/icons/folder-archive.js:
lucide/dist/esm/icons/fold-vertical.js:
lucide/dist/esm/icons/folder-check.js:
lucide/dist/esm/icons/folder-clock.js:
lucide/dist/esm/icons/folder-closed.js:
lucide/dist/esm/icons/folder-code.js:
lucide/dist/esm/icons/folder-cog.js:
lucide/dist/esm/icons/folder-dot.js:
lucide/dist/esm/icons/folder-down.js:
lucide/dist/esm/icons/folder-git.js:
lucide/dist/esm/icons/folder-heart.js:
lucide/dist/esm/icons/folder-git-2.js:
lucide/dist/esm/icons/folder-input.js:
lucide/dist/esm/icons/folder-kanban.js:
lucide/dist/esm/icons/folder-key.js:
lucide/dist/esm/icons/folder-lock.js:
lucide/dist/esm/icons/folder-minus.js:
lucide/dist/esm/icons/folder-open-dot.js:
lucide/dist/esm/icons/folder-open.js:
lucide/dist/esm/icons/folder-pen.js:
lucide/dist/esm/icons/folder-plus.js:
lucide/dist/esm/icons/folder-output.js:
lucide/dist/esm/icons/folder-root.js:
lucide/dist/esm/icons/folder-search.js:
lucide/dist/esm/icons/folder-search-2.js:
lucide/dist/esm/icons/folder-symlink.js:
lucide/dist/esm/icons/folder-tree.js:
lucide/dist/esm/icons/folder-sync.js:
lucide/dist/esm/icons/folder-up.js:
lucide/dist/esm/icons/folder-x.js:
lucide/dist/esm/icons/folder.js:
lucide/dist/esm/icons/folders.js:
lucide/dist/esm/icons/footprints.js:
lucide/dist/esm/icons/forklift.js:
lucide/dist/esm/icons/forward.js:
lucide/dist/esm/icons/frame.js:
lucide/dist/esm/icons/framer.js:
lucide/dist/esm/icons/frown.js:
lucide/dist/esm/icons/fuel.js:
lucide/dist/esm/icons/fullscreen.js:
lucide/dist/esm/icons/funnel-plus.js:
lucide/dist/esm/icons/funnel-x.js:
lucide/dist/esm/icons/funnel.js:
lucide/dist/esm/icons/gallery-horizontal-end.js:
lucide/dist/esm/icons/gallery-horizontal.js:
lucide/dist/esm/icons/gallery-thumbnails.js:
lucide/dist/esm/icons/gallery-vertical-end.js:
lucide/dist/esm/icons/gallery-vertical.js:
lucide/dist/esm/icons/gamepad-2.js:
lucide/dist/esm/icons/gauge.js:
lucide/dist/esm/icons/gamepad.js:
lucide/dist/esm/icons/gavel.js:
lucide/dist/esm/icons/gem.js:
lucide/dist/esm/icons/ghost.js:
lucide/dist/esm/icons/gift.js:
lucide/dist/esm/icons/git-branch-plus.js:
lucide/dist/esm/icons/git-branch.js:
lucide/dist/esm/icons/git-commit-horizontal.js:
lucide/dist/esm/icons/git-commit-vertical.js:
lucide/dist/esm/icons/git-compare.js:
lucide/dist/esm/icons/git-compare-arrows.js:
lucide/dist/esm/icons/git-fork.js:
lucide/dist/esm/icons/git-graph.js:
lucide/dist/esm/icons/git-merge.js:
lucide/dist/esm/icons/git-pull-request-arrow.js:
lucide/dist/esm/icons/git-pull-request-closed.js:
lucide/dist/esm/icons/git-pull-request-create-arrow.js:
lucide/dist/esm/icons/git-pull-request-create.js:
lucide/dist/esm/icons/git-pull-request-draft.js:
lucide/dist/esm/icons/github.js:
lucide/dist/esm/icons/git-pull-request.js:
lucide/dist/esm/icons/gitlab.js:
lucide/dist/esm/icons/glass-water.js:
lucide/dist/esm/icons/glasses.js:
lucide/dist/esm/icons/globe-lock.js:
lucide/dist/esm/icons/globe.js:
lucide/dist/esm/icons/goal.js:
lucide/dist/esm/icons/grab.js:
lucide/dist/esm/icons/graduation-cap.js:
lucide/dist/esm/icons/grape.js:
lucide/dist/esm/icons/grid-2x2-check.js:
lucide/dist/esm/icons/grid-2x2-plus.js:
lucide/dist/esm/icons/grid-2x2-x.js:
lucide/dist/esm/icons/grid-2x2.js:
lucide/dist/esm/icons/grid-3x3.js:
lucide/dist/esm/icons/grip-horizontal.js:
lucide/dist/esm/icons/grip-vertical.js:
lucide/dist/esm/icons/grip.js:
lucide/dist/esm/icons/group.js:
lucide/dist/esm/icons/guitar.js:
lucide/dist/esm/icons/ham.js:
lucide/dist/esm/icons/hamburger.js:
lucide/dist/esm/icons/hammer.js:
lucide/dist/esm/icons/hand-coins.js:
lucide/dist/esm/icons/hand-heart.js:
lucide/dist/esm/icons/hand-helping.js:
lucide/dist/esm/icons/hand-metal.js:
lucide/dist/esm/icons/hand-platter.js:
lucide/dist/esm/icons/hand.js:
lucide/dist/esm/icons/handshake.js:
lucide/dist/esm/icons/hard-drive-download.js:
lucide/dist/esm/icons/hard-drive-upload.js:
lucide/dist/esm/icons/hard-drive.js:
lucide/dist/esm/icons/hard-hat.js:
lucide/dist/esm/icons/hash.js:
lucide/dist/esm/icons/haze.js:
lucide/dist/esm/icons/hdmi-port.js:
lucide/dist/esm/icons/heading-1.js:
lucide/dist/esm/icons/heading-2.js:
lucide/dist/esm/icons/heading-3.js:
lucide/dist/esm/icons/heading-5.js:
lucide/dist/esm/icons/heading-6.js:
lucide/dist/esm/icons/heading-4.js:
lucide/dist/esm/icons/heading.js:
lucide/dist/esm/icons/headphone-off.js:
lucide/dist/esm/icons/headphones.js:
lucide/dist/esm/icons/headset.js:
lucide/dist/esm/icons/heart-crack.js:
lucide/dist/esm/icons/heart-handshake.js:
lucide/dist/esm/icons/heart-off.js:
lucide/dist/esm/icons/heart-minus.js:
lucide/dist/esm/icons/heart-plus.js:
lucide/dist/esm/icons/heart-pulse.js:
lucide/dist/esm/icons/heart.js:
lucide/dist/esm/icons/heater.js:
lucide/dist/esm/icons/hexagon.js:
lucide/dist/esm/icons/highlighter.js:
lucide/dist/esm/icons/hop-off.js:
lucide/dist/esm/icons/history.js:
lucide/dist/esm/icons/hop.js:
lucide/dist/esm/icons/hospital.js:
lucide/dist/esm/icons/hotel.js:
lucide/dist/esm/icons/hourglass.js:
lucide/dist/esm/icons/house-plug.js:
lucide/dist/esm/icons/house-wifi.js:
lucide/dist/esm/icons/house-plus.js:
lucide/dist/esm/icons/house.js:
lucide/dist/esm/icons/ice-cream-bowl.js:
lucide/dist/esm/icons/ice-cream-cone.js:
lucide/dist/esm/icons/id-card.js:
lucide/dist/esm/icons/image-down.js:
lucide/dist/esm/icons/image-minus.js:
lucide/dist/esm/icons/image-off.js:
lucide/dist/esm/icons/image-play.js:
lucide/dist/esm/icons/image-plus.js:
lucide/dist/esm/icons/image-up.js:
lucide/dist/esm/icons/image-upscale.js:
lucide/dist/esm/icons/image.js:
lucide/dist/esm/icons/images.js:
lucide/dist/esm/icons/import.js:
lucide/dist/esm/icons/inbox.js:
lucide/dist/esm/icons/indent-decrease.js:
lucide/dist/esm/icons/indent-increase.js:
lucide/dist/esm/icons/indian-rupee.js:
lucide/dist/esm/icons/infinity.js:
lucide/dist/esm/icons/info.js:
lucide/dist/esm/icons/inspection-panel.js:
lucide/dist/esm/icons/instagram.js:
lucide/dist/esm/icons/italic.js:
lucide/dist/esm/icons/iteration-ccw.js:
lucide/dist/esm/icons/iteration-cw.js:
lucide/dist/esm/icons/japanese-yen.js:
lucide/dist/esm/icons/joystick.js:
lucide/dist/esm/icons/kanban.js:
lucide/dist/esm/icons/key-round.js:
lucide/dist/esm/icons/key-square.js:
lucide/dist/esm/icons/key.js:
lucide/dist/esm/icons/keyboard-music.js:
lucide/dist/esm/icons/keyboard.js:
lucide/dist/esm/icons/keyboard-off.js:
lucide/dist/esm/icons/lamp-ceiling.js:
lucide/dist/esm/icons/lamp-floor.js:
lucide/dist/esm/icons/lamp-desk.js:
lucide/dist/esm/icons/lamp-wall-down.js:
lucide/dist/esm/icons/lamp-wall-up.js:
lucide/dist/esm/icons/land-plot.js:
lucide/dist/esm/icons/lamp.js:
lucide/dist/esm/icons/landmark.js:
lucide/dist/esm/icons/languages.js:
lucide/dist/esm/icons/laptop-minimal-check.js:
lucide/dist/esm/icons/laptop-minimal.js:
lucide/dist/esm/icons/laptop.js:
lucide/dist/esm/icons/lasso-select.js:
lucide/dist/esm/icons/lasso.js:
lucide/dist/esm/icons/laugh.js:
lucide/dist/esm/icons/layers-2.js:
lucide/dist/esm/icons/layers.js:
lucide/dist/esm/icons/layout-dashboard.js:
lucide/dist/esm/icons/layout-grid.js:
lucide/dist/esm/icons/layout-list.js:
lucide/dist/esm/icons/layout-panel-left.js:
lucide/dist/esm/icons/layout-panel-top.js:
lucide/dist/esm/icons/layout-template.js:
lucide/dist/esm/icons/leaf.js:
lucide/dist/esm/icons/leafy-green.js:
lucide/dist/esm/icons/lectern.js:
lucide/dist/esm/icons/letter-text.js:
lucide/dist/esm/icons/library-big.js:
lucide/dist/esm/icons/library.js:
lucide/dist/esm/icons/life-buoy.js:
lucide/dist/esm/icons/ligature.js:
lucide/dist/esm/icons/lightbulb-off.js:
lucide/dist/esm/icons/lightbulb.js:
lucide/dist/esm/icons/link-2-off.js:
lucide/dist/esm/icons/link-2.js:
lucide/dist/esm/icons/link.js:
lucide/dist/esm/icons/linkedin.js:
lucide/dist/esm/icons/list-check.js:
lucide/dist/esm/icons/list-checks.js:
lucide/dist/esm/icons/list-collapse.js:
lucide/dist/esm/icons/list-end.js:
lucide/dist/esm/icons/list-filter-plus.js:
lucide/dist/esm/icons/list-filter.js:
lucide/dist/esm/icons/list-minus.js:
lucide/dist/esm/icons/list-music.js:
lucide/dist/esm/icons/list-plus.js:
lucide/dist/esm/icons/list-ordered.js:
lucide/dist/esm/icons/list-restart.js:
lucide/dist/esm/icons/list-start.js:
lucide/dist/esm/icons/list-todo.js:
lucide/dist/esm/icons/list-tree.js:
lucide/dist/esm/icons/list-video.js:
lucide/dist/esm/icons/list-x.js:
lucide/dist/esm/icons/list.js:
lucide/dist/esm/icons/loader-circle.js:
lucide/dist/esm/icons/loader.js:
lucide/dist/esm/icons/locate-fixed.js:
lucide/dist/esm/icons/loader-pinwheel.js:
lucide/dist/esm/icons/locate-off.js:
lucide/dist/esm/icons/locate.js:
lucide/dist/esm/icons/location-edit.js:
lucide/dist/esm/icons/lock-keyhole-open.js:
lucide/dist/esm/icons/lock-keyhole.js:
lucide/dist/esm/icons/lock-open.js:
lucide/dist/esm/icons/lock.js:
lucide/dist/esm/icons/log-in.js:
lucide/dist/esm/icons/log-out.js:
lucide/dist/esm/icons/logs.js:
lucide/dist/esm/icons/lollipop.js:
lucide/dist/esm/icons/luggage.js:
lucide/dist/esm/icons/magnet.js:
lucide/dist/esm/icons/mail-check.js:
lucide/dist/esm/icons/mail-minus.js:
lucide/dist/esm/icons/mail-open.js:
lucide/dist/esm/icons/mail-plus.js:
lucide/dist/esm/icons/mail-question.js:
lucide/dist/esm/icons/mail-warning.js:
lucide/dist/esm/icons/mail-search.js:
lucide/dist/esm/icons/mail-x.js:
lucide/dist/esm/icons/mail.js:
lucide/dist/esm/icons/mailbox.js:
lucide/dist/esm/icons/mails.js:
lucide/dist/esm/icons/map-pin-check-inside.js:
lucide/dist/esm/icons/map-pin-check.js:
lucide/dist/esm/icons/map-pin-house.js:
lucide/dist/esm/icons/map-pin-minus-inside.js:
lucide/dist/esm/icons/map-pin-minus.js:
lucide/dist/esm/icons/map-pin-off.js:
lucide/dist/esm/icons/map-pin-plus-inside.js:
lucide/dist/esm/icons/map-pin-x-inside.js:
lucide/dist/esm/icons/map-pin-plus.js:
lucide/dist/esm/icons/map-pin.js:
lucide/dist/esm/icons/map-pin-x.js:
lucide/dist/esm/icons/map-pinned.js:
lucide/dist/esm/icons/map-plus.js:
lucide/dist/esm/icons/map.js:
lucide/dist/esm/icons/mars-stroke.js:
lucide/dist/esm/icons/mars.js:
lucide/dist/esm/icons/martini.js:
lucide/dist/esm/icons/maximize-2.js:
lucide/dist/esm/icons/maximize.js:
lucide/dist/esm/icons/medal.js:
lucide/dist/esm/icons/megaphone-off.js:
lucide/dist/esm/icons/meh.js:
lucide/dist/esm/icons/megaphone.js:
lucide/dist/esm/icons/memory-stick.js:
lucide/dist/esm/icons/menu.js:
lucide/dist/esm/icons/merge.js:
lucide/dist/esm/icons/message-circle-code.js:
lucide/dist/esm/icons/message-circle-dashed.js:
lucide/dist/esm/icons/message-circle-heart.js:
lucide/dist/esm/icons/message-circle-more.js:
lucide/dist/esm/icons/message-circle-plus.js:
lucide/dist/esm/icons/message-circle-question.js:
lucide/dist/esm/icons/message-circle-off.js:
lucide/dist/esm/icons/message-circle-reply.js:
lucide/dist/esm/icons/message-circle-warning.js:
lucide/dist/esm/icons/message-circle-x.js:
lucide/dist/esm/icons/message-circle.js:
lucide/dist/esm/icons/message-square-code.js:
lucide/dist/esm/icons/message-square-dashed.js:
lucide/dist/esm/icons/message-square-dot.js:
lucide/dist/esm/icons/message-square-heart.js:
lucide/dist/esm/icons/message-square-diff.js:
lucide/dist/esm/icons/message-square-lock.js:
lucide/dist/esm/icons/message-square-more.js:
lucide/dist/esm/icons/message-square-off.js:
lucide/dist/esm/icons/message-square-plus.js:
lucide/dist/esm/icons/message-square-quote.js:
lucide/dist/esm/icons/message-square-share.js:
lucide/dist/esm/icons/message-square-reply.js:
lucide/dist/esm/icons/message-square-text.js:
lucide/dist/esm/icons/message-square-warning.js:
lucide/dist/esm/icons/message-square-x.js:
lucide/dist/esm/icons/message-square.js:
lucide/dist/esm/icons/messages-square.js:
lucide/dist/esm/icons/mic-off.js:
lucide/dist/esm/icons/mic-vocal.js:
lucide/dist/esm/icons/mic.js:
lucide/dist/esm/icons/microchip.js:
lucide/dist/esm/icons/microwave.js:
lucide/dist/esm/icons/milestone.js:
lucide/dist/esm/icons/microscope.js:
lucide/dist/esm/icons/milk-off.js:
lucide/dist/esm/icons/milk.js:
lucide/dist/esm/icons/minimize-2.js:
lucide/dist/esm/icons/minimize.js:
lucide/dist/esm/icons/monitor-check.js:
lucide/dist/esm/icons/minus.js:
lucide/dist/esm/icons/monitor-cog.js:
lucide/dist/esm/icons/monitor-dot.js:
lucide/dist/esm/icons/monitor-down.js:
lucide/dist/esm/icons/monitor-off.js:
lucide/dist/esm/icons/monitor-pause.js:
lucide/dist/esm/icons/monitor-play.js:
lucide/dist/esm/icons/monitor-speaker.js:
lucide/dist/esm/icons/monitor-smartphone.js:
lucide/dist/esm/icons/monitor-stop.js:
lucide/dist/esm/icons/monitor-up.js:
lucide/dist/esm/icons/monitor-x.js:
lucide/dist/esm/icons/monitor.js:
lucide/dist/esm/icons/moon-star.js:
lucide/dist/esm/icons/mountain-snow.js:
lucide/dist/esm/icons/moon.js:
lucide/dist/esm/icons/mountain.js:
lucide/dist/esm/icons/mouse-off.js:
lucide/dist/esm/icons/mouse-pointer-2.js:
lucide/dist/esm/icons/mouse-pointer-ban.js:
lucide/dist/esm/icons/mouse-pointer-click.js:
lucide/dist/esm/icons/mouse-pointer.js:
lucide/dist/esm/icons/mouse.js:
lucide/dist/esm/icons/move-3d.js:
lucide/dist/esm/icons/move-diagonal-2.js:
lucide/dist/esm/icons/move-diagonal.js:
lucide/dist/esm/icons/move-down-left.js:
lucide/dist/esm/icons/move-down-right.js:
lucide/dist/esm/icons/move-down.js:
lucide/dist/esm/icons/move-horizontal.js:
lucide/dist/esm/icons/move-left.js:
lucide/dist/esm/icons/move-right.js:
lucide/dist/esm/icons/move-up-left.js:
lucide/dist/esm/icons/move-up.js:
lucide/dist/esm/icons/move-up-right.js:
lucide/dist/esm/icons/move-vertical.js:
lucide/dist/esm/icons/move.js:
lucide/dist/esm/icons/music-2.js:
lucide/dist/esm/icons/music-3.js:
lucide/dist/esm/icons/music-4.js:
lucide/dist/esm/icons/music.js:
lucide/dist/esm/icons/navigation-2-off.js:
lucide/dist/esm/icons/navigation-2.js:
lucide/dist/esm/icons/navigation-off.js:
lucide/dist/esm/icons/navigation.js:
lucide/dist/esm/icons/network.js:
lucide/dist/esm/icons/newspaper.js:
lucide/dist/esm/icons/nfc.js:
lucide/dist/esm/icons/non-binary.js:
lucide/dist/esm/icons/notebook-pen.js:
lucide/dist/esm/icons/notebook-tabs.js:
lucide/dist/esm/icons/notebook.js:
lucide/dist/esm/icons/notebook-text.js:
lucide/dist/esm/icons/notepad-text-dashed.js:
lucide/dist/esm/icons/notepad-text.js:
lucide/dist/esm/icons/nut-off.js:
lucide/dist/esm/icons/nut.js:
lucide/dist/esm/icons/octagon-alert.js:
lucide/dist/esm/icons/octagon-minus.js:
lucide/dist/esm/icons/octagon-pause.js:
lucide/dist/esm/icons/octagon.js:
lucide/dist/esm/icons/octagon-x.js:
lucide/dist/esm/icons/omega.js:
lucide/dist/esm/icons/option.js:
lucide/dist/esm/icons/orbit.js:
lucide/dist/esm/icons/origami.js:
lucide/dist/esm/icons/package-2.js:
lucide/dist/esm/icons/package-check.js:
lucide/dist/esm/icons/package-minus.js:
lucide/dist/esm/icons/package-open.js:
lucide/dist/esm/icons/package-plus.js:
lucide/dist/esm/icons/package-search.js:
lucide/dist/esm/icons/package-x.js:
lucide/dist/esm/icons/package.js:
lucide/dist/esm/icons/paint-bucket.js:
lucide/dist/esm/icons/paint-roller.js:
lucide/dist/esm/icons/paintbrush-vertical.js:
lucide/dist/esm/icons/paintbrush.js:
lucide/dist/esm/icons/palette.js:
lucide/dist/esm/icons/panel-bottom-close.js:
lucide/dist/esm/icons/panel-bottom-dashed.js:
lucide/dist/esm/icons/panel-bottom-open.js:
lucide/dist/esm/icons/panel-bottom.js:
lucide/dist/esm/icons/panel-left-close.js:
lucide/dist/esm/icons/panel-left-dashed.js:
lucide/dist/esm/icons/panel-left-open.js:
lucide/dist/esm/icons/panel-left.js:
lucide/dist/esm/icons/panel-right-close.js:
lucide/dist/esm/icons/panel-right-dashed.js:
lucide/dist/esm/icons/panel-right.js:
lucide/dist/esm/icons/panel-right-open.js:
lucide/dist/esm/icons/panel-top-close.js:
lucide/dist/esm/icons/panel-top-dashed.js:
lucide/dist/esm/icons/panel-top-open.js:
lucide/dist/esm/icons/panel-top.js:
lucide/dist/esm/icons/panels-left-bottom.js:
lucide/dist/esm/icons/panels-right-bottom.js:
lucide/dist/esm/icons/panels-top-left.js:
lucide/dist/esm/icons/paperclip.js:
lucide/dist/esm/icons/parentheses.js:
lucide/dist/esm/icons/parking-meter.js:
lucide/dist/esm/icons/party-popper.js:
lucide/dist/esm/icons/pause.js:
lucide/dist/esm/icons/paw-print.js:
lucide/dist/esm/icons/pc-case.js:
lucide/dist/esm/icons/pen-line.js:
lucide/dist/esm/icons/pen-off.js:
lucide/dist/esm/icons/pen-tool.js:
lucide/dist/esm/icons/pen.js:
lucide/dist/esm/icons/pencil-line.js:
lucide/dist/esm/icons/pencil-off.js:
lucide/dist/esm/icons/pencil-ruler.js:
lucide/dist/esm/icons/pencil.js:
lucide/dist/esm/icons/pentagon.js:
lucide/dist/esm/icons/percent.js:
lucide/dist/esm/icons/person-standing.js:
lucide/dist/esm/icons/philippine-peso.js:
lucide/dist/esm/icons/phone-call.js:
lucide/dist/esm/icons/phone-forwarded.js:
lucide/dist/esm/icons/phone-incoming.js:
lucide/dist/esm/icons/phone-missed.js:
lucide/dist/esm/icons/phone-off.js:
lucide/dist/esm/icons/phone-outgoing.js:
lucide/dist/esm/icons/phone.js:
lucide/dist/esm/icons/piano.js:
lucide/dist/esm/icons/pi.js:
lucide/dist/esm/icons/pickaxe.js:
lucide/dist/esm/icons/picture-in-picture-2.js:
lucide/dist/esm/icons/piggy-bank.js:
lucide/dist/esm/icons/picture-in-picture.js:
lucide/dist/esm/icons/pilcrow-left.js:
lucide/dist/esm/icons/pilcrow-right.js:
lucide/dist/esm/icons/pilcrow.js:
lucide/dist/esm/icons/pill-bottle.js:
lucide/dist/esm/icons/pill.js:
lucide/dist/esm/icons/pin-off.js:
lucide/dist/esm/icons/pin.js:
lucide/dist/esm/icons/plane-landing.js:
lucide/dist/esm/icons/pipette.js:
lucide/dist/esm/icons/pizza.js:
lucide/dist/esm/icons/plane-takeoff.js:
lucide/dist/esm/icons/plane.js:
lucide/dist/esm/icons/play.js:
lucide/dist/esm/icons/plug-2.js:
lucide/dist/esm/icons/plug-zap.js:
lucide/dist/esm/icons/plug.js:
lucide/dist/esm/icons/plus.js:
lucide/dist/esm/icons/pocket-knife.js:
lucide/dist/esm/icons/pocket.js:
lucide/dist/esm/icons/podcast.js:
lucide/dist/esm/icons/pointer-off.js:
lucide/dist/esm/icons/pointer.js:
lucide/dist/esm/icons/popcorn.js:
lucide/dist/esm/icons/popsicle.js:
lucide/dist/esm/icons/power-off.js:
lucide/dist/esm/icons/pound-sterling.js:
lucide/dist/esm/icons/power.js:
lucide/dist/esm/icons/presentation.js:
lucide/dist/esm/icons/printer-check.js:
lucide/dist/esm/icons/printer.js:
lucide/dist/esm/icons/projector.js:
lucide/dist/esm/icons/proportions.js:
lucide/dist/esm/icons/puzzle.js:
lucide/dist/esm/icons/pyramid.js:
lucide/dist/esm/icons/qr-code.js:
lucide/dist/esm/icons/quote.js:
lucide/dist/esm/icons/rabbit.js:
lucide/dist/esm/icons/radar.js:
lucide/dist/esm/icons/radiation.js:
lucide/dist/esm/icons/radical.js:
lucide/dist/esm/icons/radio-receiver.js:
lucide/dist/esm/icons/radio-tower.js:
lucide/dist/esm/icons/radio.js:
lucide/dist/esm/icons/radius.js:
lucide/dist/esm/icons/rail-symbol.js:
lucide/dist/esm/icons/rainbow.js:
lucide/dist/esm/icons/rat.js:
lucide/dist/esm/icons/ratio.js:
lucide/dist/esm/icons/receipt-cent.js:
lucide/dist/esm/icons/receipt-indian-rupee.js:
lucide/dist/esm/icons/receipt-euro.js:
lucide/dist/esm/icons/receipt-japanese-yen.js:
lucide/dist/esm/icons/receipt-pound-sterling.js:
lucide/dist/esm/icons/receipt-russian-ruble.js:
lucide/dist/esm/icons/receipt-swiss-franc.js:
lucide/dist/esm/icons/receipt.js:
lucide/dist/esm/icons/receipt-text.js:
lucide/dist/esm/icons/rectangle-ellipsis.js:
lucide/dist/esm/icons/rectangle-horizontal.js:
lucide/dist/esm/icons/rectangle-goggles.js:
lucide/dist/esm/icons/rectangle-vertical.js:
lucide/dist/esm/icons/recycle.js:
lucide/dist/esm/icons/redo-2.js:
lucide/dist/esm/icons/redo-dot.js:
lucide/dist/esm/icons/redo.js:
lucide/dist/esm/icons/refresh-ccw-dot.js:
lucide/dist/esm/icons/refresh-cw-off.js:
lucide/dist/esm/icons/refresh-ccw.js:
lucide/dist/esm/icons/refresh-cw.js:
lucide/dist/esm/icons/refrigerator.js:
lucide/dist/esm/icons/regex.js:
lucide/dist/esm/icons/remove-formatting.js:
lucide/dist/esm/icons/repeat-1.js:
lucide/dist/esm/icons/repeat-2.js:
lucide/dist/esm/icons/repeat.js:
lucide/dist/esm/icons/replace-all.js:
lucide/dist/esm/icons/replace.js:
lucide/dist/esm/icons/reply-all.js:
lucide/dist/esm/icons/reply.js:
lucide/dist/esm/icons/rewind.js:
lucide/dist/esm/icons/ribbon.js:
lucide/dist/esm/icons/rocket.js:
lucide/dist/esm/icons/rocking-chair.js:
lucide/dist/esm/icons/roller-coaster.js:
lucide/dist/esm/icons/rotate-3d.js:
lucide/dist/esm/icons/rotate-ccw-key.js:
lucide/dist/esm/icons/rotate-ccw-square.js:
lucide/dist/esm/icons/rotate-ccw.js:
lucide/dist/esm/icons/rotate-cw-square.js:
lucide/dist/esm/icons/rotate-cw.js:
lucide/dist/esm/icons/route-off.js:
lucide/dist/esm/icons/route.js:
lucide/dist/esm/icons/router.js:
lucide/dist/esm/icons/rows-2.js:
lucide/dist/esm/icons/rows-4.js:
lucide/dist/esm/icons/rows-3.js:
lucide/dist/esm/icons/rss.js:
lucide/dist/esm/icons/ruler-dimension-line.js:
lucide/dist/esm/icons/ruler.js:
lucide/dist/esm/icons/russian-ruble.js:
lucide/dist/esm/icons/sailboat.js:
lucide/dist/esm/icons/salad.js:
lucide/dist/esm/icons/sandwich.js:
lucide/dist/esm/icons/satellite-dish.js:
lucide/dist/esm/icons/satellite.js:
lucide/dist/esm/icons/saudi-riyal.js:
lucide/dist/esm/icons/save-all.js:
lucide/dist/esm/icons/save-off.js:
lucide/dist/esm/icons/save.js:
lucide/dist/esm/icons/scale-3d.js:
lucide/dist/esm/icons/scale.js:
lucide/dist/esm/icons/scaling.js:
lucide/dist/esm/icons/scan-barcode.js:
lucide/dist/esm/icons/scan-eye.js:
lucide/dist/esm/icons/scan-face.js:
lucide/dist/esm/icons/scan-heart.js:
lucide/dist/esm/icons/scan-qr-code.js:
lucide/dist/esm/icons/scan-line.js:
lucide/dist/esm/icons/scan-search.js:
lucide/dist/esm/icons/scan-text.js:
lucide/dist/esm/icons/scan.js:
lucide/dist/esm/icons/school.js:
lucide/dist/esm/icons/scissors-line-dashed.js:
lucide/dist/esm/icons/scissors.js:
lucide/dist/esm/icons/screen-share-off.js:
lucide/dist/esm/icons/screen-share.js:
lucide/dist/esm/icons/scroll-text.js:
lucide/dist/esm/icons/scroll.js:
lucide/dist/esm/icons/search-check.js:
lucide/dist/esm/icons/search-code.js:
lucide/dist/esm/icons/search-slash.js:
lucide/dist/esm/icons/search-x.js:
lucide/dist/esm/icons/section.js:
lucide/dist/esm/icons/search.js:
lucide/dist/esm/icons/send-horizontal.js:
lucide/dist/esm/icons/send-to-back.js:
lucide/dist/esm/icons/send.js:
lucide/dist/esm/icons/separator-horizontal.js:
lucide/dist/esm/icons/separator-vertical.js:
lucide/dist/esm/icons/server-cog.js:
lucide/dist/esm/icons/server-crash.js:
lucide/dist/esm/icons/server-off.js:
lucide/dist/esm/icons/server.js:
lucide/dist/esm/icons/settings-2.js:
lucide/dist/esm/icons/settings.js:
lucide/dist/esm/icons/shapes.js:
lucide/dist/esm/icons/share-2.js:
lucide/dist/esm/icons/sheet.js:
lucide/dist/esm/icons/share.js:
lucide/dist/esm/icons/shell.js:
lucide/dist/esm/icons/shield-alert.js:
lucide/dist/esm/icons/shield-ban.js:
lucide/dist/esm/icons/shield-check.js:
lucide/dist/esm/icons/shield-ellipsis.js:
lucide/dist/esm/icons/shield-half.js:
lucide/dist/esm/icons/shield-minus.js:
lucide/dist/esm/icons/shield-off.js:
lucide/dist/esm/icons/shield-plus.js:
lucide/dist/esm/icons/shield-question.js:
lucide/dist/esm/icons/shield-user.js:
lucide/dist/esm/icons/shield-x.js:
lucide/dist/esm/icons/ship-wheel.js:
lucide/dist/esm/icons/ship.js:
lucide/dist/esm/icons/shield.js:
lucide/dist/esm/icons/shirt.js:
lucide/dist/esm/icons/shopping-basket.js:
lucide/dist/esm/icons/shopping-bag.js:
lucide/dist/esm/icons/shopping-cart.js:
lucide/dist/esm/icons/shovel.js:
lucide/dist/esm/icons/shredder.js:
lucide/dist/esm/icons/shower-head.js:
lucide/dist/esm/icons/shrimp.js:
lucide/dist/esm/icons/shrink.js:
lucide/dist/esm/icons/shrub.js:
lucide/dist/esm/icons/shuffle.js:
lucide/dist/esm/icons/sigma.js:
lucide/dist/esm/icons/signal-high.js:
lucide/dist/esm/icons/signal-medium.js:
lucide/dist/esm/icons/signal-low.js:
lucide/dist/esm/icons/signal-zero.js:
lucide/dist/esm/icons/signature.js:
lucide/dist/esm/icons/signal.js:
lucide/dist/esm/icons/signpost-big.js:
lucide/dist/esm/icons/signpost.js:
lucide/dist/esm/icons/siren.js:
lucide/dist/esm/icons/skip-forward.js:
lucide/dist/esm/icons/skip-back.js:
lucide/dist/esm/icons/skull.js:
lucide/dist/esm/icons/slack.js:
lucide/dist/esm/icons/slash.js:
lucide/dist/esm/icons/slice.js:
lucide/dist/esm/icons/sliders-horizontal.js:
lucide/dist/esm/icons/sliders-vertical.js:
lucide/dist/esm/icons/smartphone-charging.js:
lucide/dist/esm/icons/smartphone-nfc.js:
lucide/dist/esm/icons/smartphone.js:
lucide/dist/esm/icons/smile-plus.js:
lucide/dist/esm/icons/smile.js:
lucide/dist/esm/icons/snail.js:
lucide/dist/esm/icons/snowflake.js:
lucide/dist/esm/icons/soap-dispenser-droplet.js:
lucide/dist/esm/icons/sofa.js:
lucide/dist/esm/icons/soup.js:
lucide/dist/esm/icons/space.js:
lucide/dist/esm/icons/spade.js:
lucide/dist/esm/icons/sparkles.js:
lucide/dist/esm/icons/sparkle.js:
lucide/dist/esm/icons/speaker.js:
lucide/dist/esm/icons/speech.js:
lucide/dist/esm/icons/spell-check-2.js:
lucide/dist/esm/icons/spline-pointer.js:
lucide/dist/esm/icons/split.js:
lucide/dist/esm/icons/spell-check.js:
lucide/dist/esm/icons/spline.js:
lucide/dist/esm/icons/sprout.js:
lucide/dist/esm/icons/spray-can.js:
lucide/dist/esm/icons/square-activity.js:
lucide/dist/esm/icons/square-arrow-down-left.js:
lucide/dist/esm/icons/square-arrow-down-right.js:
lucide/dist/esm/icons/square-arrow-down.js:
lucide/dist/esm/icons/square-arrow-left.js:
lucide/dist/esm/icons/square-arrow-out-down-left.js:
lucide/dist/esm/icons/square-arrow-out-up-left.js:
lucide/dist/esm/icons/square-arrow-out-up-right.js:
lucide/dist/esm/icons/square-arrow-out-down-right.js:
lucide/dist/esm/icons/square-arrow-right.js:
lucide/dist/esm/icons/square-arrow-up-left.js:
lucide/dist/esm/icons/square-arrow-up-right.js:
lucide/dist/esm/icons/square-arrow-up.js:
lucide/dist/esm/icons/square-asterisk.js:
lucide/dist/esm/icons/square-bottom-dashed-scissors.js:
lucide/dist/esm/icons/square-chart-gantt.js:
lucide/dist/esm/icons/square-check-big.js:
lucide/dist/esm/icons/square-check.js:
lucide/dist/esm/icons/square-chevron-down.js:
lucide/dist/esm/icons/square-chevron-left.js:
lucide/dist/esm/icons/square-chevron-right.js:
lucide/dist/esm/icons/square-chevron-up.js:
lucide/dist/esm/icons/square-code.js:
lucide/dist/esm/icons/square-dashed-bottom.js:
lucide/dist/esm/icons/square-dashed-bottom-code.js:
lucide/dist/esm/icons/square-dashed-kanban.js:
lucide/dist/esm/icons/square-dashed-mouse-pointer.js:
lucide/dist/esm/icons/square-dashed.js:
lucide/dist/esm/icons/square-divide.js:
lucide/dist/esm/icons/square-dot.js:
lucide/dist/esm/icons/square-equal.js:
lucide/dist/esm/icons/square-function.js:
lucide/dist/esm/icons/square-kanban.js:
lucide/dist/esm/icons/square-library.js:
lucide/dist/esm/icons/square-m.js:
lucide/dist/esm/icons/square-menu.js:
lucide/dist/esm/icons/square-minus.js:
lucide/dist/esm/icons/square-mouse-pointer.js:
lucide/dist/esm/icons/square-parking-off.js:
lucide/dist/esm/icons/square-parking.js:
lucide/dist/esm/icons/square-pen.js:
lucide/dist/esm/icons/square-percent.js:
lucide/dist/esm/icons/square-pi.js:
lucide/dist/esm/icons/square-pilcrow.js:
lucide/dist/esm/icons/square-play.js:
lucide/dist/esm/icons/square-plus.js:
lucide/dist/esm/icons/square-power.js:
lucide/dist/esm/icons/square-radical.js:
lucide/dist/esm/icons/square-round-corner.js:
lucide/dist/esm/icons/square-scissors.js:
lucide/dist/esm/icons/square-sigma.js:
lucide/dist/esm/icons/square-slash.js:
lucide/dist/esm/icons/square-split-horizontal.js:
lucide/dist/esm/icons/square-split-vertical.js:
lucide/dist/esm/icons/square-square.js:
lucide/dist/esm/icons/square-stack.js:
lucide/dist/esm/icons/square-user-round.js:
lucide/dist/esm/icons/square-terminal.js:
lucide/dist/esm/icons/square-x.js:
lucide/dist/esm/icons/square-user.js:
lucide/dist/esm/icons/square.js:
lucide/dist/esm/icons/squares-exclude.js:
lucide/dist/esm/icons/squares-intersect.js:
lucide/dist/esm/icons/squares-subtract.js:
lucide/dist/esm/icons/squares-unite.js:
lucide/dist/esm/icons/squircle.js:
lucide/dist/esm/icons/squirrel.js:
lucide/dist/esm/icons/stamp.js:
lucide/dist/esm/icons/star-half.js:
lucide/dist/esm/icons/star-off.js:
lucide/dist/esm/icons/star.js:
lucide/dist/esm/icons/step-back.js:
lucide/dist/esm/icons/step-forward.js:
lucide/dist/esm/icons/sticker.js:
lucide/dist/esm/icons/stethoscope.js:
lucide/dist/esm/icons/sticky-note.js:
lucide/dist/esm/icons/store.js:
lucide/dist/esm/icons/stretch-horizontal.js:
lucide/dist/esm/icons/stretch-vertical.js:
lucide/dist/esm/icons/strikethrough.js:
lucide/dist/esm/icons/subscript.js:
lucide/dist/esm/icons/sun-dim.js:
lucide/dist/esm/icons/sun-medium.js:
lucide/dist/esm/icons/sun-moon.js:
lucide/dist/esm/icons/sun.js:
lucide/dist/esm/icons/sunrise.js:
lucide/dist/esm/icons/sun-snow.js:
lucide/dist/esm/icons/sunset.js:
lucide/dist/esm/icons/superscript.js:
lucide/dist/esm/icons/swatch-book.js:
lucide/dist/esm/icons/switch-camera.js:
lucide/dist/esm/icons/sword.js:
lucide/dist/esm/icons/swiss-franc.js:
lucide/dist/esm/icons/swords.js:
lucide/dist/esm/icons/syringe.js:
lucide/dist/esm/icons/table-2.js:
lucide/dist/esm/icons/table-cells-merge.js:
lucide/dist/esm/icons/table-cells-split.js:
lucide/dist/esm/icons/table-columns-split.js:
lucide/dist/esm/icons/table-of-contents.js:
lucide/dist/esm/icons/table-properties.js:
lucide/dist/esm/icons/table-rows-split.js:
lucide/dist/esm/icons/table.js:
lucide/dist/esm/icons/tablet-smartphone.js:
lucide/dist/esm/icons/tablet.js:
lucide/dist/esm/icons/tag.js:
lucide/dist/esm/icons/tags.js:
lucide/dist/esm/icons/tablets.js:
lucide/dist/esm/icons/tally-1.js:
lucide/dist/esm/icons/tally-2.js:
lucide/dist/esm/icons/tally-3.js:
lucide/dist/esm/icons/tally-4.js:
lucide/dist/esm/icons/tally-5.js:
lucide/dist/esm/icons/target.js:
lucide/dist/esm/icons/tangent.js:
lucide/dist/esm/icons/tent-tree.js:
lucide/dist/esm/icons/telescope.js:
lucide/dist/esm/icons/tent.js:
lucide/dist/esm/icons/terminal.js:
lucide/dist/esm/icons/test-tube-diagonal.js:
lucide/dist/esm/icons/test-tube.js:
lucide/dist/esm/icons/test-tubes.js:
lucide/dist/esm/icons/text-cursor-input.js:
lucide/dist/esm/icons/text-cursor.js:
lucide/dist/esm/icons/text-quote.js:
lucide/dist/esm/icons/text-search.js:
lucide/dist/esm/icons/text-select.js:
lucide/dist/esm/icons/theater.js:
lucide/dist/esm/icons/text.js:
lucide/dist/esm/icons/thermometer-sun.js:
lucide/dist/esm/icons/thermometer-snowflake.js:
lucide/dist/esm/icons/thermometer.js:
lucide/dist/esm/icons/thumbs-down.js:
lucide/dist/esm/icons/thumbs-up.js:
lucide/dist/esm/icons/ticket-check.js:
lucide/dist/esm/icons/ticket-minus.js:
lucide/dist/esm/icons/ticket-percent.js:
lucide/dist/esm/icons/ticket-slash.js:
lucide/dist/esm/icons/ticket-plus.js:
lucide/dist/esm/icons/ticket-x.js:
lucide/dist/esm/icons/ticket.js:
lucide/dist/esm/icons/tickets-plane.js:
lucide/dist/esm/icons/tickets.js:
lucide/dist/esm/icons/timer-reset.js:
lucide/dist/esm/icons/timer.js:
lucide/dist/esm/icons/timer-off.js:
lucide/dist/esm/icons/toggle-left.js:
lucide/dist/esm/icons/toggle-right.js:
lucide/dist/esm/icons/toilet.js:
lucide/dist/esm/icons/tornado.js:
lucide/dist/esm/icons/torus.js:
lucide/dist/esm/icons/touchpad-off.js:
lucide/dist/esm/icons/touchpad.js:
lucide/dist/esm/icons/tower-control.js:
lucide/dist/esm/icons/toy-brick.js:
lucide/dist/esm/icons/tractor.js:
lucide/dist/esm/icons/traffic-cone.js:
lucide/dist/esm/icons/train-front-tunnel.js:
lucide/dist/esm/icons/train-front.js:
lucide/dist/esm/icons/train-track.js:
lucide/dist/esm/icons/tram-front.js:
lucide/dist/esm/icons/transgender.js:
lucide/dist/esm/icons/trash-2.js:
lucide/dist/esm/icons/trash.js:
lucide/dist/esm/icons/tree-deciduous.js:
lucide/dist/esm/icons/tree-palm.js:
lucide/dist/esm/icons/trees.js:
lucide/dist/esm/icons/tree-pine.js:
lucide/dist/esm/icons/trello.js:
lucide/dist/esm/icons/trending-down.js:
lucide/dist/esm/icons/trending-up-down.js:
lucide/dist/esm/icons/trending-up.js:
lucide/dist/esm/icons/triangle-alert.js:
lucide/dist/esm/icons/triangle-dashed.js:
lucide/dist/esm/icons/triangle-right.js:
lucide/dist/esm/icons/triangle.js:
lucide/dist/esm/icons/trophy.js:
lucide/dist/esm/icons/truck.js:
lucide/dist/esm/icons/truck-electric.js:
lucide/dist/esm/icons/turtle.js:
lucide/dist/esm/icons/tv-minimal-play.js:
lucide/dist/esm/icons/tv.js:
lucide/dist/esm/icons/twitch.js:
lucide/dist/esm/icons/tv-minimal.js:
lucide/dist/esm/icons/twitter.js:
lucide/dist/esm/icons/type-outline.js:
lucide/dist/esm/icons/type.js:
lucide/dist/esm/icons/umbrella-off.js:
lucide/dist/esm/icons/underline.js:
lucide/dist/esm/icons/umbrella.js:
lucide/dist/esm/icons/undo-2.js:
lucide/dist/esm/icons/undo-dot.js:
lucide/dist/esm/icons/undo.js:
lucide/dist/esm/icons/unfold-horizontal.js:
lucide/dist/esm/icons/ungroup.js:
lucide/dist/esm/icons/unfold-vertical.js:
lucide/dist/esm/icons/university.js:
lucide/dist/esm/icons/unlink.js:
lucide/dist/esm/icons/unlink-2.js:
lucide/dist/esm/icons/unplug.js:
lucide/dist/esm/icons/upload.js:
lucide/dist/esm/icons/usb.js:
lucide/dist/esm/icons/user-check.js:
lucide/dist/esm/icons/user-cog.js:
lucide/dist/esm/icons/user-lock.js:
lucide/dist/esm/icons/user-minus.js:
lucide/dist/esm/icons/user-pen.js:
lucide/dist/esm/icons/user-plus.js:
lucide/dist/esm/icons/user-round-check.js:
lucide/dist/esm/icons/user-round-cog.js:
lucide/dist/esm/icons/user-round-minus.js:
lucide/dist/esm/icons/user-round-pen.js:
lucide/dist/esm/icons/user-round-plus.js:
lucide/dist/esm/icons/user-round-search.js:
lucide/dist/esm/icons/user-round-x.js:
lucide/dist/esm/icons/user-round.js:
lucide/dist/esm/icons/user-search.js:
lucide/dist/esm/icons/user-x.js:
lucide/dist/esm/icons/user.js:
lucide/dist/esm/icons/users-round.js:
lucide/dist/esm/icons/users.js:
lucide/dist/esm/icons/utensils.js:
lucide/dist/esm/icons/utility-pole.js:
lucide/dist/esm/icons/utensils-crossed.js:
lucide/dist/esm/icons/variable.js:
lucide/dist/esm/icons/vault.js:
lucide/dist/esm/icons/venetian-mask.js:
lucide/dist/esm/icons/vegan.js:
lucide/dist/esm/icons/venus-and-mars.js:
lucide/dist/esm/icons/venus.js:
lucide/dist/esm/icons/vibrate-off.js:
lucide/dist/esm/icons/vibrate.js:
lucide/dist/esm/icons/video.js:
lucide/dist/esm/icons/video-off.js:
lucide/dist/esm/icons/videotape.js:
lucide/dist/esm/icons/view.js:
lucide/dist/esm/icons/voicemail.js:
lucide/dist/esm/icons/volleyball.js:
lucide/dist/esm/icons/volume-1.js:
lucide/dist/esm/icons/volume-2.js:
lucide/dist/esm/icons/volume-off.js:
lucide/dist/esm/icons/volume-x.js:
lucide/dist/esm/icons/volume.js:
lucide/dist/esm/icons/vote.js:
lucide/dist/esm/icons/wallet-cards.js:
lucide/dist/esm/icons/wallet-minimal.js:
lucide/dist/esm/icons/wallet.js:
lucide/dist/esm/icons/wallpaper.js:
lucide/dist/esm/icons/wand-sparkles.js:
lucide/dist/esm/icons/wand.js:
lucide/dist/esm/icons/warehouse.js:
lucide/dist/esm/icons/washing-machine.js:
lucide/dist/esm/icons/watch.js:
lucide/dist/esm/icons/waves-ladder.js:
lucide/dist/esm/icons/waves.js:
lucide/dist/esm/icons/waypoints.js:
lucide/dist/esm/icons/webcam.js:
lucide/dist/esm/icons/webhook-off.js:
lucide/dist/esm/icons/webhook.js:
lucide/dist/esm/icons/weight.js:
lucide/dist/esm/icons/wheat-off.js:
lucide/dist/esm/icons/wheat.js:
lucide/dist/esm/icons/whole-word.js:
lucide/dist/esm/icons/wifi-high.js:
lucide/dist/esm/icons/wifi-low.js:
lucide/dist/esm/icons/wifi-off.js:
lucide/dist/esm/icons/wifi-pen.js:
lucide/dist/esm/icons/wifi-zero.js:
lucide/dist/esm/icons/wifi.js:
lucide/dist/esm/icons/wind-arrow-down.js:
lucide/dist/esm/icons/wind.js:
lucide/dist/esm/icons/wine-off.js:
lucide/dist/esm/icons/workflow.js:
lucide/dist/esm/icons/wine.js:
lucide/dist/esm/icons/worm.js:
lucide/dist/esm/icons/wrap-text.js:
lucide/dist/esm/icons/wrench.js:
lucide/dist/esm/icons/x.js:
lucide/dist/esm/icons/youtube.js:
lucide/dist/esm/icons/zap-off.js:
lucide/dist/esm/icons/zap.js:
lucide/dist/esm/icons/zoom-in.js:
lucide/dist/esm/icons/zoom-out.js:
lucide/dist/esm/iconsAndAliases.js:
lucide/dist/esm/lucide.js:
  (**
   * @license lucide v0.507.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=application.js.map
