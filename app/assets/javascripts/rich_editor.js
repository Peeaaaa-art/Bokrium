(() => {
  // app/assets/javascripts/rich_editor.js
  (() => {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __commonJS = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __copyProps = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var require_react_development = __commonJS({
      "node_modules/react/cjs/react.development.js"(exports, module) {
        "use strict";
        (function() {
          function defineDeprecationWarning(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                console.warn(
                  "%s(...) is deprecated in plain JavaScript React classes. %s",
                  info[0],
                  info[1]
                );
              }
            });
          }
          function getIteratorFn(maybeIterable) {
            if (null === maybeIterable || "object" !== typeof maybeIterable)
              return null;
            maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
            return "function" === typeof maybeIterable ? maybeIterable : null;
          }
          function warnNoop(publicInstance, callerName) {
            publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
            var warningKey = publicInstance + "." + callerName;
            didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
              "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
              callerName,
              publicInstance
            ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
          }
          function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          function ComponentDummy() {
          }
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            try {
              testStringCoercion(value);
              var JSCompiler_inline_result = false;
            } catch (e) {
              JSCompiler_inline_result = true;
            }
            if (JSCompiler_inline_result) {
              JSCompiler_inline_result = console;
              var JSCompiler_temp_const = JSCompiler_inline_result.error;
              var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              JSCompiler_temp_const.call(
                JSCompiler_inline_result,
                "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
                JSCompiler_inline_result$jscomp$0
              );
              return testStringCoercion(value);
            }
          }
          function getComponentNameFromType(type) {
            if (null == type) return null;
            if ("function" === typeof type)
              return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
              case REACT_ACTIVITY_TYPE:
                return "Activity";
            }
            if ("object" === typeof type)
              switch ("number" === typeof type.tag && console.error(
                "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
              ), type.$$typeof) {
                case REACT_PORTAL_TYPE:
                  return "Portal";
                case REACT_CONTEXT_TYPE:
                  return (type.displayName || "Context") + ".Provider";
                case REACT_CONSUMER_TYPE:
                  return (type._context.displayName || "Context") + ".Consumer";
                case REACT_FORWARD_REF_TYPE:
                  var innerType = type.render;
                  type = type.displayName;
                  type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                  return type;
                case REACT_MEMO_TYPE:
                  return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE:
                  innerType = type._payload;
                  type = type._init;
                  try {
                    return getComponentNameFromType(type(innerType));
                  } catch (x) {
                  }
              }
            return null;
          }
          function getTaskName(type) {
            if (type === REACT_FRAGMENT_TYPE) return "<>";
            if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
              return "<...>";
            try {
              var name = getComponentNameFromType(type);
              return name ? "<" + name + ">" : "<...>";
            } catch (x) {
              return "<...>";
            }
          }
          function getOwner() {
            var dispatcher = ReactSharedInternals.A;
            return null === dispatcher ? null : dispatcher.getOwner();
          }
          function UnknownOwner() {
            return Error("react-stack-top-frame");
          }
          function hasValidKey(config) {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) return false;
            }
            return void 0 !== config.key;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            function warnAboutAccessingKey() {
              specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
                "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
                displayName
              ));
            }
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function elementRefGetterWithDeprecationWarning() {
            var componentName = getComponentNameFromType(this.type);
            didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
              "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
            ));
            componentName = this.props.ref;
            return void 0 !== componentName ? componentName : null;
          }
          function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
            self = props.ref;
            type = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              props,
              _owner: owner
            };
            null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
              enumerable: false,
              get: elementRefGetterWithDeprecationWarning
            }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
            type._store = {};
            Object.defineProperty(type._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: 0
            });
            Object.defineProperty(type, "_debugInfo", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: null
            });
            Object.defineProperty(type, "_debugStack", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: debugStack
            });
            Object.defineProperty(type, "_debugTask", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: debugTask
            });
            Object.freeze && (Object.freeze(type.props), Object.freeze(type));
            return type;
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            newKey = ReactElement(
              oldElement.type,
              newKey,
              void 0,
              void 0,
              oldElement._owner,
              oldElement.props,
              oldElement._debugStack,
              oldElement._debugTask
            );
            oldElement._store && (newKey._store.validated = oldElement._store.validated);
            return newKey;
          }
          function isValidElement(object) {
            return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function escape(key) {
            var escaperLookup = { "=": "=0", ":": "=2" };
            return "$" + key.replace(/[=:]/g, function(match) {
              return escaperLookup[match];
            });
          }
          function getElementKey(element, index) {
            return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
          }
          function noop$1() {
          }
          function resolveThenable(thenable) {
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
              default:
                switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                  function(fulfilledValue) {
                    "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                  },
                  function(error) {
                    "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                  }
                )), thenable.status) {
                  case "fulfilled":
                    return thenable.value;
                  case "rejected":
                    throw thenable.reason;
                }
            }
            throw thenable;
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if ("undefined" === type || "boolean" === type) children = null;
            var invokeCallback = false;
            if (null === children) invokeCallback = true;
            else
              switch (type) {
                case "bigint":
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                      break;
                    case REACT_LAZY_TYPE:
                      return invokeCallback = children._init, mapIntoArray(
                        invokeCallback(children._payload),
                        array,
                        escapedPrefix,
                        nameSoFar,
                        callback
                      );
                  }
              }
            if (invokeCallback) {
              invokeCallback = children;
              callback = callback(invokeCallback);
              var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
              isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
              })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
                callback,
                escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                  userProvidedKeyEscapeRegex,
                  "$&/"
                ) + "/") + childKey
              ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
              return 1;
            }
            invokeCallback = 0;
            childKey = "" === nameSoFar ? "." : nameSoFar + ":";
            if (isArrayImpl(children))
              for (var i2 = 0; i2 < children.length; i2++)
                nameSoFar = children[i2], type = childKey + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
                  nameSoFar,
                  array,
                  escapedPrefix,
                  type,
                  callback
                );
            else if (i2 = getIteratorFn(children), "function" === typeof i2)
              for (i2 === children.entries && (didWarnAboutMaps || console.warn(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ), didWarnAboutMaps = true), children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
                nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
                  nameSoFar,
                  array,
                  escapedPrefix,
                  type,
                  callback
                );
            else if ("object" === type) {
              if ("function" === typeof children.then)
                return mapIntoArray(
                  resolveThenable(children),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
              array = String(children);
              throw Error(
                "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
              );
            }
            return invokeCallback;
          }
          function mapChildren2(children, func, context) {
            if (null == children) return children;
            var result = [], count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function lazyInitializer(payload) {
            if (-1 === payload._status) {
              var ctor = payload._result;
              ctor = ctor();
              ctor.then(
                function(moduleObject) {
                  if (0 === payload._status || -1 === payload._status)
                    payload._status = 1, payload._result = moduleObject;
                },
                function(error) {
                  if (0 === payload._status || -1 === payload._status)
                    payload._status = 2, payload._result = error;
                }
              );
              -1 === payload._status && (payload._status = 0, payload._result = ctor);
            }
            if (1 === payload._status)
              return ctor = payload._result, void 0 === ctor && console.error(
                "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
                ctor
              ), "default" in ctor || console.error(
                "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
                ctor
              ), ctor.default;
            throw payload._result;
          }
          function resolveDispatcher() {
            var dispatcher = ReactSharedInternals.H;
            null === dispatcher && console.error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
            );
            return dispatcher;
          }
          function noop() {
          }
          function enqueueTask(task) {
            if (null === enqueueTaskImpl)
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                enqueueTaskImpl = (module && module[requireString]).call(
                  module,
                  "timers"
                ).setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                    "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                  ));
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            return enqueueTaskImpl(task);
          }
          function aggregateErrors(errors) {
            return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
          }
          function popActScope(prevActQueue, prevActScopeDepth) {
            prevActScopeDepth !== actScopeDepth - 1 && console.error(
              "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
            );
            actScopeDepth = prevActScopeDepth;
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            var queue = ReactSharedInternals.actQueue;
            if (null !== queue)
              if (0 !== queue.length)
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                  return;
                } catch (error) {
                  ReactSharedInternals.thrownErrors.push(error);
                }
              else ReactSharedInternals.actQueue = null;
            0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
          }
          function flushActQueue(queue) {
            if (!isFlushing) {
              isFlushing = true;
              var i2 = 0;
              try {
                for (; i2 < queue.length; i2++) {
                  var callback = queue[i2];
                  do {
                    ReactSharedInternals.didUsePromise = false;
                    var continuation = callback(false);
                    if (null !== continuation) {
                      if (ReactSharedInternals.didUsePromise) {
                        queue[i2] = callback;
                        queue.splice(0, i2);
                        return;
                      }
                      callback = continuation;
                    } else break;
                  } while (1);
                }
                queue.length = 0;
              } catch (error) {
                queue.splice(0, i2 + 1), ReactSharedInternals.thrownErrors.push(error);
              } finally {
                isFlushing = false;
              }
            }
          }
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
          var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          Symbol.for("react.provider");
          var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
            isMounted: function() {
              return false;
            },
            enqueueForceUpdate: function(publicInstance) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance) {
              warnNoop(publicInstance, "setState");
            }
          }, assign = Object.assign, emptyObject = {};
          Object.freeze(emptyObject);
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
              throw Error(
                "takes an object of state variables to update or a function which returns an object of state variables."
              );
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          var deprecatedAPIs = {
            isMounted: [
              "isMounted",
              "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
            ],
            replaceState: [
              "replaceState",
              "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
            ]
          }, fnName;
          for (fnName in deprecatedAPIs)
            deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          ComponentDummy.prototype = Component.prototype;
          deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
          deprecatedAPIs.constructor = PureComponent;
          assign(deprecatedAPIs, Component.prototype);
          deprecatedAPIs.isPureReactComponent = true;
          var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
            H: null,
            A: null,
            T: null,
            S: null,
            V: null,
            actQueue: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false,
            didUsePromise: false,
            thrownErrors: [],
            getCurrentStack: null,
            recentlyCreatedOwnerStacks: 0
          }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
            return null;
          };
          deprecatedAPIs = {
            "react-stack-bottom-frame": function(callStackForError) {
              return callStackForError();
            }
          };
          var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
          var didWarnAboutElementRef = {};
          var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
          var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
          var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
              var event = new window.ErrorEvent("error", {
                bubbles: true,
                cancelable: true,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error
              });
              if (!window.dispatchEvent(event)) return;
            } else if ("object" === typeof process && "function" === typeof process.emit) {
              process.emit("uncaughtException", error);
              return;
            }
            console.error(error);
          }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
            queueMicrotask(function() {
              return queueMicrotask(callback);
            });
          } : enqueueTask;
          deprecatedAPIs = Object.freeze({
            __proto__: null,
            c: function(size) {
              return resolveDispatcher().useMemoCache(size);
            }
          });
          exports.Children = {
            map: mapChildren2,
            forEach: function(children, forEachFunc, forEachContext) {
              mapChildren2(
                children,
                function() {
                  forEachFunc.apply(this, arguments);
                },
                forEachContext
              );
            },
            count: function(children) {
              var n = 0;
              mapChildren2(children, function() {
                n++;
              });
              return n;
            },
            toArray: function(children) {
              return mapChildren2(children, function(child) {
                return child;
              }) || [];
            },
            only: function(children) {
              if (!isValidElement(children))
                throw Error(
                  "React.Children.only expected to receive a single React element child."
                );
              return children;
            }
          };
          exports.Component = Component;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
          exports.__COMPILER_RUNTIME = deprecatedAPIs;
          exports.act = function(callback) {
            var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
            try {
              var result = callback();
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
            if (0 < ReactSharedInternals.thrownErrors.length)
              throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
            if (null !== result && "object" === typeof result && "function" === typeof result.then) {
              var thenable = result;
              queueSeveralMicrotasks(function() {
                didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                  "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
                ));
              });
              return {
                then: function(resolve, reject) {
                  didAwaitActCall = true;
                  thenable.then(
                    function(returnValue) {
                      popActScope(prevActQueue, prevActScopeDepth);
                      if (0 === prevActScopeDepth) {
                        try {
                          flushActQueue(queue), enqueueTask(function() {
                            return recursivelyFlushAsyncActWork(
                              returnValue,
                              resolve,
                              reject
                            );
                          });
                        } catch (error$0) {
                          ReactSharedInternals.thrownErrors.push(error$0);
                        }
                        if (0 < ReactSharedInternals.thrownErrors.length) {
                          var _thrownError = aggregateErrors(
                            ReactSharedInternals.thrownErrors
                          );
                          ReactSharedInternals.thrownErrors.length = 0;
                          reject(_thrownError);
                        }
                      } else resolve(returnValue);
                    },
                    function(error) {
                      popActScope(prevActQueue, prevActScopeDepth);
                      0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                    }
                  );
                }
              };
            }
            var returnValue$jscomp$0 = result;
            popActScope(prevActQueue, prevActScopeDepth);
            0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
              ));
            }), ReactSharedInternals.actQueue = null);
            if (0 < ReactSharedInternals.thrownErrors.length)
              throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(
                    returnValue$jscomp$0,
                    resolve,
                    reject
                  );
                })) : resolve(returnValue$jscomp$0);
              }
            };
          };
          exports.cache = function(fn) {
            return function() {
              return fn.apply(null, arguments);
            };
          };
          exports.captureOwnerStack = function() {
            var getCurrentStack = ReactSharedInternals.getCurrentStack;
            return null === getCurrentStack ? null : getCurrentStack();
          };
          exports.cloneElement = function(element, config, children) {
            if (null === element || void 0 === element)
              throw Error(
                "The argument must be a React element, but you passed " + element + "."
              );
            var props = assign({}, element.props), key = element.key, owner = element._owner;
            if (null != config) {
              var JSCompiler_inline_result;
              a: {
                if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                  config,
                  "ref"
                ).get) && JSCompiler_inline_result.isReactWarning) {
                  JSCompiler_inline_result = false;
                  break a;
                }
                JSCompiler_inline_result = void 0 !== config.ref;
              }
              JSCompiler_inline_result && (owner = getOwner());
              hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
              for (propName in config)
                !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
            }
            var propName = arguments.length - 2;
            if (1 === propName) props.children = children;
            else if (1 < propName) {
              JSCompiler_inline_result = Array(propName);
              for (var i2 = 0; i2 < propName; i2++)
                JSCompiler_inline_result[i2] = arguments[i2 + 2];
              props.children = JSCompiler_inline_result;
            }
            props = ReactElement(
              element.type,
              key,
              void 0,
              void 0,
              owner,
              props,
              element._debugStack,
              element._debugTask
            );
            for (key = 2; key < arguments.length; key++)
              owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
            return props;
          };
          exports.createContext = function(defaultValue) {
            defaultValue = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null
            };
            defaultValue.Provider = defaultValue;
            defaultValue.Consumer = {
              $$typeof: REACT_CONSUMER_TYPE,
              _context: defaultValue
            };
            defaultValue._currentRenderer = null;
            defaultValue._currentRenderer2 = null;
            return defaultValue;
          };
          exports.createElement = function(type, config, children) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              var node = arguments[i2];
              isValidElement(node) && node._store && (node._store.validated = 1);
            }
            i2 = {};
            node = null;
            if (null != config)
              for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
                "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
              )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
                hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i2[propName] = config[propName]);
            var childrenLength = arguments.length - 2;
            if (1 === childrenLength) i2.children = children;
            else if (1 < childrenLength) {
              for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
                childArray[_i] = arguments[_i + 2];
              Object.freeze && Object.freeze(childArray);
              i2.children = childArray;
            }
            if (type && type.defaultProps)
              for (propName in childrenLength = type.defaultProps, childrenLength)
                void 0 === i2[propName] && (i2[propName] = childrenLength[propName]);
            node && defineKeyPropWarningGetter(
              i2,
              "function" === typeof type ? type.displayName || type.name || "Unknown" : type
            );
            var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
            return ReactElement(
              type,
              node,
              void 0,
              void 0,
              getOwner(),
              i2,
              propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
              propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
            );
          };
          exports.createRef = function() {
            var refObject = { current: null };
            Object.seal(refObject);
            return refObject;
          };
          exports.forwardRef = function(render) {
            null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
              "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
            ) : "function" !== typeof render ? console.error(
              "forwardRef requires a render function but was given %s.",
              null === render ? "null" : typeof render
            ) : 0 !== render.length && 2 !== render.length && console.error(
              "forwardRef render functions accept exactly two parameters: props and ref. %s",
              1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
            );
            null != render && null != render.defaultProps && console.error(
              "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
            );
            var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
              }
            });
            return elementType;
          };
          exports.isValidElement = isValidElement;
          exports.lazy = function(ctor) {
            return {
              $$typeof: REACT_LAZY_TYPE,
              _payload: { _status: -1, _result: ctor },
              _init: lazyInitializer
            };
          };
          exports.memo = function(type, compare) {
            null == type && console.error(
              "memo: The first argument must be a component. Instead received: %s",
              null === type ? "null" : typeof type
            );
            compare = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: void 0 === compare ? null : compare
            };
            var ownName;
            Object.defineProperty(compare, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
              }
            });
            return compare;
          };
          exports.startTransition = function(scope) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
            } catch (error) {
              reportGlobalError(error);
            } finally {
              null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              )), ReactSharedInternals.T = prevTransition;
            }
          };
          exports.unstable_useCacheRefresh = function() {
            return resolveDispatcher().useCacheRefresh();
          };
          exports.use = function(usable) {
            return resolveDispatcher().use(usable);
          };
          exports.useActionState = function(action, initialState, permalink) {
            return resolveDispatcher().useActionState(
              action,
              initialState,
              permalink
            );
          };
          exports.useCallback = function(callback, deps) {
            return resolveDispatcher().useCallback(callback, deps);
          };
          exports.useContext = function(Context) {
            var dispatcher = resolveDispatcher();
            Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
              "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
            );
            return dispatcher.useContext(Context);
          };
          exports.useDebugValue = function(value, formatterFn) {
            return resolveDispatcher().useDebugValue(value, formatterFn);
          };
          exports.useDeferredValue = function(value, initialValue) {
            return resolveDispatcher().useDeferredValue(value, initialValue);
          };
          exports.useEffect = function(create, createDeps, update) {
            null == create && console.warn(
              "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
            );
            var dispatcher = resolveDispatcher();
            if ("function" === typeof update)
              throw Error(
                "useEffect CRUD overload is not enabled in this build of React."
              );
            return dispatcher.useEffect(create, createDeps);
          };
          exports.useId = function() {
            return resolveDispatcher().useId();
          };
          exports.useImperativeHandle = function(ref, create, deps) {
            return resolveDispatcher().useImperativeHandle(ref, create, deps);
          };
          exports.useInsertionEffect = function(create, deps) {
            null == create && console.warn(
              "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
            );
            return resolveDispatcher().useInsertionEffect(create, deps);
          };
          exports.useLayoutEffect = function(create, deps) {
            null == create && console.warn(
              "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
            );
            return resolveDispatcher().useLayoutEffect(create, deps);
          };
          exports.useMemo = function(create, deps) {
            return resolveDispatcher().useMemo(create, deps);
          };
          exports.useOptimistic = function(passthrough, reducer) {
            return resolveDispatcher().useOptimistic(passthrough, reducer);
          };
          exports.useReducer = function(reducer, initialArg, init) {
            return resolveDispatcher().useReducer(reducer, initialArg, init);
          };
          exports.useRef = function(initialValue) {
            return resolveDispatcher().useRef(initialValue);
          };
          exports.useState = function(initialState) {
            return resolveDispatcher().useState(initialState);
          };
          exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
            return resolveDispatcher().useSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          };
          exports.useTransition = function() {
            return resolveDispatcher().useTransition();
          };
          exports.version = "19.1.0";
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
        })();
      }
    });
    var require_react = __commonJS({
      "node_modules/react/index.js"(exports, module) {
        "use strict";
        if (false) {
          module.exports = null;
        } else {
          module.exports = require_react_development();
        }
      }
    });
    var require_scheduler_development = __commonJS({
      "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
        "use strict";
        (function() {
          function performWorkUntilDeadline() {
            needsPaint = false;
            if (isMessageLoopRunning) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasMoreWork = true;
              try {
                a: {
                  isHostCallbackScheduled = false;
                  isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                  isPerformingWork = true;
                  var previousPriorityLevel = currentPriorityLevel;
                  try {
                    b: {
                      advanceTimers(currentTime);
                      for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                        var callback = currentTask.callback;
                        if ("function" === typeof callback) {
                          currentTask.callback = null;
                          currentPriorityLevel = currentTask.priorityLevel;
                          var continuationCallback = callback(
                            currentTask.expirationTime <= currentTime
                          );
                          currentTime = exports.unstable_now();
                          if ("function" === typeof continuationCallback) {
                            currentTask.callback = continuationCallback;
                            advanceTimers(currentTime);
                            hasMoreWork = true;
                            break b;
                          }
                          currentTask === peek(taskQueue) && pop(taskQueue);
                          advanceTimers(currentTime);
                        } else pop(taskQueue);
                        currentTask = peek(taskQueue);
                      }
                      if (null !== currentTask) hasMoreWork = true;
                      else {
                        var firstTimer = peek(timerQueue);
                        null !== firstTimer && requestHostTimeout(
                          handleTimeout,
                          firstTimer.startTime - currentTime
                        );
                        hasMoreWork = false;
                      }
                    }
                    break a;
                  } finally {
                    currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                  }
                  hasMoreWork = void 0;
                }
              } finally {
                hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
              }
            }
          }
          function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            a: for (; 0 < index; ) {
              var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
              if (0 < compare(parent, node))
                heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
              else break a;
            }
          }
          function peek(heap) {
            return 0 === heap.length ? null : heap[0];
          }
          function pop(heap) {
            if (0 === heap.length) return null;
            var first2 = heap[0], last = heap.pop();
            if (last !== first2) {
              heap[0] = last;
              a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
                var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                if (0 > compare(left, last))
                  rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
                else if (rightIndex < length && 0 > compare(right, last))
                  heap[index] = right, heap[rightIndex] = last, index = rightIndex;
                else break a;
              }
            }
            return first2;
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return 0 !== diff ? diff : a.id - b.id;
          }
          function advanceTimers(currentTime) {
            for (var timer = peek(timerQueue); null !== timer; ) {
              if (null === timer.callback) pop(timerQueue);
              else if (timer.startTime <= currentTime)
                pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
              else break;
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled)
              if (null !== peek(taskQueue))
                isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
              else {
                var firstTimer = peek(timerQueue);
                null !== firstTimer && requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              }
          }
          function shouldYieldToHost() {
            return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
          exports.unstable_now = void 0;
          if ("object" === typeof performance && "function" === typeof performance.now) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date, initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
          if ("function" === typeof localSetImmediate)
            var schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          else if ("undefined" !== typeof MessageChannel) {
            var channel = new MessageChannel(), port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          exports.unstable_IdlePriority = 5;
          exports.unstable_ImmediatePriority = 1;
          exports.unstable_LowPriority = 4;
          exports.unstable_NormalPriority = 3;
          exports.unstable_Profiling = null;
          exports.unstable_UserBlockingPriority = 2;
          exports.unstable_cancelCallback = function(task) {
            task.callback = null;
          };
          exports.unstable_forceFrameRate = function(fps) {
            0 > fps || 125 < fps ? console.error(
              "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
            ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
          };
          exports.unstable_getCurrentPriorityLevel = function() {
            return currentPriorityLevel;
          };
          exports.unstable_next = function(eventHandler) {
            switch (currentPriorityLevel) {
              case 1:
              case 2:
              case 3:
                var priorityLevel = 3;
                break;
              default:
                priorityLevel = currentPriorityLevel;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
          exports.unstable_requestPaint = function() {
            needsPaint = true;
          };
          exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                priorityLevel = 3;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
          exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
            switch (priorityLevel) {
              case 1:
                var timeout = -1;
                break;
              case 2:
                timeout = 250;
                break;
              case 5:
                timeout = 1073741823;
                break;
              case 4:
                timeout = 1e4;
                break;
              default:
                timeout = 5e3;
            }
            timeout = options + timeout;
            priorityLevel = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: options,
              expirationTime: timeout,
              sortIndex: -1
            };
            options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
            return priorityLevel;
          };
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = function(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          };
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
        })();
      }
    });
    var require_scheduler = __commonJS({
      "node_modules/scheduler/index.js"(exports, module) {
        "use strict";
        if (false) {
          module.exports = null;
        } else {
          module.exports = require_scheduler_development();
        }
      }
    });
    var require_react_dom_development = __commonJS({
      "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
        "use strict";
        (function() {
          function noop() {
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function createPortal$1(children, containerInfo, implementation) {
            var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            try {
              testStringCoercion(key);
              var JSCompiler_inline_result = false;
            } catch (e) {
              JSCompiler_inline_result = true;
            }
            JSCompiler_inline_result && (console.error(
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
            ), testStringCoercion(key));
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: null == key ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          function getCrossOriginStringAs(as, input) {
            if ("font" === as) return "";
            if ("string" === typeof input)
              return "use-credentials" === input ? input : "";
          }
          function getValueDescriptorExpectingObjectForWarning(thing) {
            return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
          }
          function getValueDescriptorExpectingEnumForWarning(thing) {
            return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
          }
          function resolveDispatcher() {
            var dispatcher = ReactSharedInternals.H;
            null === dispatcher && console.error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
            );
            return dispatcher;
          }
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
          var React4 = require_react(), Internals = {
            d: {
              f: noop,
              r: function() {
                throw Error(
                  "Invalid form element. requestFormReset must be passed a form that was rendered by React."
                );
              },
              D: noop,
              C: noop,
              L: noop,
              m: noop,
              X: noop,
              S: noop,
              M: noop
            },
            p: 0,
            findDOMNode: null
          }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
          "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
            "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
          );
          exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
          exports.createPortal = function(children, container) {
            var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
              throw Error("Target container is not a DOM element.");
            return createPortal$1(children, container, null, key);
          };
          exports.flushSync = function(fn) {
            var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
            try {
              if (ReactSharedInternals.T = null, Internals.p = 2, fn)
                return fn();
            } finally {
              ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
                "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
              );
            }
          };
          exports.preconnect = function(href, options) {
            "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
              "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : null != options && "string" !== typeof options.crossOrigin && console.error(
              "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
              getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
            ) : console.error(
              "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
            "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
          };
          exports.prefetchDNS = function(href) {
            if ("string" !== typeof href || !href)
              console.error(
                "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
                getValueDescriptorExpectingObjectForWarning(href)
              );
            else if (1 < arguments.length) {
              var options = arguments[1];
              "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
                "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
                getValueDescriptorExpectingEnumForWarning(options)
              ) : console.error(
                "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
                getValueDescriptorExpectingEnumForWarning(options)
              );
            }
            "string" === typeof href && Internals.d.D(href);
          };
          exports.preinit = function(href, options) {
            "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
              "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : "style" !== options.as && "script" !== options.as && console.error(
              'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
              getValueDescriptorExpectingEnumForWarning(options.as)
            ) : console.error(
              "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
            if ("string" === typeof href && options && "string" === typeof options.as) {
              var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
              "style" === as ? Internals.d.S(
                href,
                "string" === typeof options.precedence ? options.precedence : void 0,
                {
                  crossOrigin,
                  integrity,
                  fetchPriority
                }
              ) : "script" === as && Internals.d.X(href, {
                crossOrigin,
                integrity,
                fetchPriority,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          };
          exports.preinitModule = function(href, options) {
            var encountered = "";
            "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
            void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
            if (encountered)
              console.error(
                "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
                encountered
              );
            else
              switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
                case "script":
                  break;
                default:
                  encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                    'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                    encountered,
                    href
                  );
              }
            if ("string" === typeof href)
              if ("object" === typeof options && null !== options) {
                if (null == options.as || "script" === options.as)
                  encountered = getCrossOriginStringAs(
                    options.as,
                    options.crossOrigin
                  ), Internals.d.M(href, {
                    crossOrigin: encountered,
                    integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                    nonce: "string" === typeof options.nonce ? options.nonce : void 0
                  });
              } else null == options && Internals.d.M(href);
          };
          exports.preload = function(href, options) {
            var encountered = "";
            "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
            null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
            encountered && console.error(
              'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
              encountered
            );
            if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
              encountered = options.as;
              var crossOrigin = getCrossOriginStringAs(
                encountered,
                options.crossOrigin
              );
              Internals.d.L(href, encountered, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0,
                type: "string" === typeof options.type ? options.type : void 0,
                fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
                referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
                imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
                imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
                media: "string" === typeof options.media ? options.media : void 0
              });
            }
          };
          exports.preloadModule = function(href, options) {
            var encountered = "";
            "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
            void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
            encountered && console.error(
              'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
              encountered
            );
            "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            ), Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin: encountered,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            })) : Internals.d.m(href));
          };
          exports.requestFormReset = function(form) {
            Internals.d.r(form);
          };
          exports.unstable_batchedUpdates = function(fn, a) {
            return fn(a);
          };
          exports.useFormState = function(action, initialState, permalink) {
            return resolveDispatcher().useFormState(action, initialState, permalink);
          };
          exports.useFormStatus = function() {
            return resolveDispatcher().useHostTransitionStatus();
          };
          exports.version = "19.1.0";
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
        })();
      }
    });
    var require_react_dom = __commonJS({
      "node_modules/react-dom/index.js"(exports, module) {
        "use strict";
        if (false) {
          checkDCE();
          module.exports = null;
        } else {
          module.exports = require_react_dom_development();
        }
      }
    });
    var require_react_dom_client_development = __commonJS({
      "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
        "use strict";
        (function() {
          function findHook(fiber, id) {
            for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
              fiber = fiber.next, id--;
            return fiber;
          }
          function copyWithSetImpl(obj, path, index, value) {
            if (index >= path.length) return value;
            var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
            updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
            return updated;
          }
          function copyWithRename(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length)
              console.warn("copyWithRename() expects paths of the same length");
            else {
              for (var i2 = 0; i2 < newPath.length - 1; i2++)
                if (oldPath[i2] !== newPath[i2]) {
                  console.warn(
                    "copyWithRename() expects paths to be the same except for the deepest key"
                  );
                  return;
                }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            }
          }
          function copyWithRenameImpl(obj, oldPath, newPath, index) {
            var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
            index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
              obj[oldKey],
              oldPath,
              newPath,
              index + 1
            );
            return updated;
          }
          function copyWithDeleteImpl(obj, path, index) {
            var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
            if (index + 1 === path.length)
              return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
            updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
            return updated;
          }
          function shouldSuspendImpl() {
            return false;
          }
          function shouldErrorImpl() {
            return null;
          }
          function warnForMissingKey() {
          }
          function warnInvalidHookAccess() {
            console.error(
              "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
            );
          }
          function warnInvalidContextAccess() {
            console.error(
              "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
            );
          }
          function noop$2() {
          }
          function setToSortedString(set) {
            var array = [];
            set.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          }
          function createFiber(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          }
          function scheduleRoot(root2, element) {
            root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
          }
          function scheduleRefresh(root2, update) {
            if (null !== resolveFamily) {
              var staleFamilies = update.staleFamilies;
              update = update.updatedFamilies;
              flushPendingEffects();
              scheduleFibersWithFamiliesRecursively(
                root2.current,
                update,
                staleFamilies
              );
              flushSyncWork$1();
            }
          }
          function setRefreshHandler(handler) {
            resolveFamily = handler;
          }
          function isValidContainer(node) {
            return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
          }
          function getNearestMountedFiber(fiber) {
            var node = fiber, nearestMounted = fiber;
            if (fiber.alternate) for (; node.return; ) node = node.return;
            else {
              fiber = node;
              do
                node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
              while (fiber);
            }
            return 3 === node.tag ? nearestMounted : null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (13 === fiber.tag) {
              var suspenseState = fiber.memoizedState;
              null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
              if (null !== suspenseState) return suspenseState.dehydrated;
            }
            return null;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber)
              throw Error("Unable to find node on an unmounted component.");
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              alternate = getNearestMountedFiber(fiber);
              if (null === alternate)
                throw Error("Unable to find node on an unmounted component.");
              return alternate !== fiber ? null : fiber;
            }
            for (var a = fiber, b = alternate; ; ) {
              var parentA = a.return;
              if (null === parentA) break;
              var parentB = parentA.alternate;
              if (null === parentB) {
                b = parentA.return;
                if (null !== b) {
                  a = b;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                for (parentB = parentA.child; parentB; ) {
                  if (parentB === a) return assertIsMounted(parentA), fiber;
                  if (parentB === b) return assertIsMounted(parentA), alternate;
                  parentB = parentB.sibling;
                }
                throw Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) a = parentA, b = parentB;
              else {
                for (var didFindChild = false, _child = parentA.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  for (_child = parentB.child; _child; ) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild)
                    throw Error(
                      "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                    );
                }
              }
              if (a.alternate !== b)
                throw Error(
                  "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
                );
            }
            if (3 !== a.tag)
              throw Error("Unable to find node on an unmounted component.");
            return a.stateNode.current === a ? fiber : alternate;
          }
          function findCurrentHostFiberImpl(node) {
            var tag = node.tag;
            if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
            for (node = node.child; null !== node; ) {
              tag = findCurrentHostFiberImpl(node);
              if (null !== tag) return tag;
              node = node.sibling;
            }
            return null;
          }
          function getIteratorFn(maybeIterable) {
            if (null === maybeIterable || "object" !== typeof maybeIterable)
              return null;
            maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
            return "function" === typeof maybeIterable ? maybeIterable : null;
          }
          function getComponentNameFromType(type) {
            if (null == type) return null;
            if ("function" === typeof type)
              return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
              case REACT_ACTIVITY_TYPE:
                return "Activity";
            }
            if ("object" === typeof type)
              switch ("number" === typeof type.tag && console.error(
                "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
              ), type.$$typeof) {
                case REACT_PORTAL_TYPE:
                  return "Portal";
                case REACT_CONTEXT_TYPE:
                  return (type.displayName || "Context") + ".Provider";
                case REACT_CONSUMER_TYPE:
                  return (type._context.displayName || "Context") + ".Consumer";
                case REACT_FORWARD_REF_TYPE:
                  var innerType = type.render;
                  type = type.displayName;
                  type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                  return type;
                case REACT_MEMO_TYPE:
                  return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE:
                  innerType = type._payload;
                  type = type._init;
                  try {
                    return getComponentNameFromType(type(innerType));
                  } catch (x) {
                  }
              }
            return null;
          }
          function getComponentNameFromOwner(owner) {
            return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
          }
          function getComponentNameFromFiber(fiber) {
            var type = fiber.type;
            switch (fiber.tag) {
              case 31:
                return "Activity";
              case 24:
                return "Cache";
              case 9:
                return (type._context.displayName || "Context") + ".Consumer";
              case 10:
                return (type.displayName || "Context") + ".Provider";
              case 18:
                return "DehydratedFragment";
              case 11:
                return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
              case 7:
                return "Fragment";
              case 26:
              case 27:
              case 5:
                return type;
              case 4:
                return "Portal";
              case 3:
                return "Root";
              case 6:
                return "Text";
              case 16:
                return getComponentNameFromType(type);
              case 8:
                return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
              case 22:
                return "Offscreen";
              case 12:
                return "Profiler";
              case 21:
                return "Scope";
              case 13:
                return "Suspense";
              case 19:
                return "SuspenseList";
              case 25:
                return "TracingMarker";
              case 1:
              case 0:
              case 14:
              case 15:
                if ("function" === typeof type)
                  return type.displayName || type.name || null;
                if ("string" === typeof type) return type;
                break;
              case 29:
                type = fiber._debugInfo;
                if (null != type) {
                  for (var i2 = type.length - 1; 0 <= i2; i2--)
                    if ("string" === typeof type[i2].name) return type[i2].name;
                }
                if (null !== fiber.return)
                  return getComponentNameFromFiber(fiber.return);
            }
            return null;
          }
          function createCursor(defaultValue) {
            return { current: defaultValue };
          }
          function pop(cursor, fiber) {
            0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
          }
          function push(cursor, value, fiber) {
            index$jscomp$0++;
            valueStack[index$jscomp$0] = cursor.current;
            fiberStack[index$jscomp$0] = fiber;
            cursor.current = value;
          }
          function requiredContext(c) {
            null === c && console.error(
              "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
            );
            return c;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor, null, fiber);
            var nextRootContext = nextRootInstance.nodeType;
            switch (nextRootContext) {
              case 9:
              case 11:
                nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
                nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
                break;
              default:
                if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                  nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                    nextRootInstance,
                    nextRootContext
                  );
                else
                  switch (nextRootContext) {
                    case "svg":
                      nextRootInstance = HostContextNamespaceSvg;
                      break;
                    case "math":
                      nextRootInstance = HostContextNamespaceMath;
                      break;
                    default:
                      nextRootInstance = HostContextNamespaceNone;
                  }
            }
            nextRootContext = nextRootContext.toLowerCase();
            nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
            nextRootContext = {
              context: nextRootInstance,
              ancestorInfo: nextRootContext
            };
            pop(contextStackCursor, fiber);
            push(contextStackCursor, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            return requiredContext(contextStackCursor.current);
          }
          function pushHostContext(fiber) {
            null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
            var context = requiredContext(contextStackCursor.current);
            var type = fiber.type;
            var nextContext = getChildHostContextProd(context.context, type);
            type = updatedAncestorInfoDev(context.ancestorInfo, type);
            nextContext = { context: nextContext, ancestorInfo: type };
            context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
          }
          function popHostContext(fiber) {
            contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
            hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
          }
          function typeName(value) {
            return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          }
          function willCoercionThrow(value) {
            try {
              return testStringCoercion(value), false;
            } catch (e) {
              return true;
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            if (willCoercionThrow(value))
              return console.error(
                "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
                attributeName,
                typeName(value)
              ), testStringCoercion(value);
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            if (willCoercionThrow(value))
              return console.error(
                "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
                propName,
                typeName(value)
              ), testStringCoercion(value);
          }
          function checkFormFieldValueStringCoercion(value) {
            if (willCoercionThrow(value))
              return console.error(
                "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
                typeName(value)
              ), testStringCoercion(value);
          }
          function injectInternals(internals) {
            if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) return true;
            if (!hook.supportsFiber)
              return console.error(
                "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
              ), true;
            try {
              rendererID = hook.inject(internals), injectedHook = hook;
            } catch (err) {
              console.error("React instrumentation encountered an error: %s.", err);
            }
            return hook.checkDCE ? true : false;
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
            if (injectedHook && "function" === typeof injectedHook.setStrictMode)
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function markCommitStopped() {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
          }
          function markComponentRenderStarted(fiber) {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
          }
          function markComponentRenderStopped() {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
          }
          function markRenderStarted(lanes) {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
          }
          function markRenderStopped() {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
          }
          function markStateUpdateScheduled(fiber, lane) {
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
          }
          function clz32Fallback(x) {
            x >>>= 0;
            return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
          }
          function getLabelForLane(lane) {
            if (lane & 1) return "SyncHydrationLane";
            if (lane & 2) return "Sync";
            if (lane & 4) return "InputContinuousHydration";
            if (lane & 8) return "InputContinuous";
            if (lane & 16) return "DefaultHydration";
            if (lane & 32) return "Default";
            if (lane & 128) return "TransitionHydration";
            if (lane & 4194048) return "Transition";
            if (lane & 62914560) return "Retry";
            if (lane & 67108864) return "SelectiveHydration";
            if (lane & 134217728) return "IdleHydration";
            if (lane & 268435456) return "Idle";
            if (lane & 536870912) return "Offscreen";
            if (lane & 1073741824) return "Deferred";
          }
          function getHighestPriorityLanes(lanes) {
            var pendingSyncLanes = lanes & 42;
            if (0 !== pendingSyncLanes) return pendingSyncLanes;
            switch (lanes & -lanes) {
              case 1:
                return 1;
              case 2:
                return 2;
              case 4:
                return 4;
              case 8:
                return 8;
              case 16:
                return 16;
              case 32:
                return 32;
              case 64:
                return 64;
              case 128:
                return 128;
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return lanes & 4194048;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return lanes & 62914560;
              case 67108864:
                return 67108864;
              case 134217728:
                return 134217728;
              case 268435456:
                return 268435456;
              case 536870912:
                return 536870912;
              case 1073741824:
                return 0;
              default:
                return console.error(
                  "Should have found matching lanes. This is a bug in React."
                ), lanes;
            }
          }
          function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
            var pendingLanes = root2.pendingLanes;
            if (0 === pendingLanes) return 0;
            var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
            root2 = root2.warmLanes;
            var nonIdlePendingLanes = pendingLanes & 134217727;
            0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
            return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
          }
          function checkIfRootIsPrerendering(root2, renderLanes2) {
            return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case 1:
              case 2:
              case 4:
              case 8:
              case 64:
                return currentTime + 250;
              case 16:
              case 32:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
                return currentTime + 5e3;
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                return -1;
              case 67108864:
              case 134217728:
              case 268435456:
              case 536870912:
              case 1073741824:
                return -1;
              default:
                return console.error(
                  "Should have found matching lanes. This is a bug in React."
                ), -1;
            }
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
            return lane;
          }
          function createLaneMap(initial) {
            for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
            return laneMap;
          }
          function markRootUpdated$1(root2, updateLane) {
            root2.pendingLanes |= updateLane;
            268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
          }
          function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
            var previouslyPendingLanes = root2.pendingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = 0;
            root2.pingedLanes = 0;
            root2.warmLanes = 0;
            root2.expiredLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            root2.errorRecoveryDisabledLanes &= remainingLanes;
            root2.shellSuspendCounter = 0;
            var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
            for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
              var index = 31 - clz32(remainingLanes), lane = 1 << index;
              entanglements[index] = 0;
              expirationTimes[index] = -1;
              var hiddenUpdatesForLane = hiddenUpdates[index];
              if (null !== hiddenUpdatesForLane)
                for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                  var update = hiddenUpdatesForLane[index];
                  null !== update && (update.lane &= -536870913);
                }
              remainingLanes &= ~lane;
            }
            0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
            0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
          }
          function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
            root2.pendingLanes |= spawnedLane;
            root2.suspendedLanes &= ~spawnedLane;
            var spawnedLaneIndex = 31 - clz32(spawnedLane);
            root2.entangledLanes |= spawnedLane;
            root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
          }
          function markRootEntangled(root2, entangledLanes) {
            var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
            for (root2 = root2.entanglements; rootEntangledLanes; ) {
              var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
              lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
              rootEntangledLanes &= ~lane;
            }
          }
          function getBumpedLaneForHydrationByLane(lane) {
            switch (lane) {
              case 2:
                lane = 1;
                break;
              case 8:
                lane = 4;
                break;
              case 32:
                lane = 16;
                break;
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
                lane = 128;
                break;
              case 268435456:
                lane = 134217728;
                break;
              default:
                lane = 0;
            }
            return lane;
          }
          function addFiberToLanesMap(root2, fiber, lanes) {
            if (isDevToolsPresent)
              for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
                var index = 31 - clz32(lanes), lane = 1 << index;
                root2[index].add(fiber);
                lanes &= ~lane;
              }
          }
          function movePendingFibersToMemoized(root2, lanes) {
            if (isDevToolsPresent)
              for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
                var index = 31 - clz32(lanes);
                root2 = 1 << index;
                index = pendingUpdatersLaneMap[index];
                0 < index.size && (index.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
                }), index.clear());
                lanes &= ~root2;
              }
          }
          function lanesToEventPriority(lanes) {
            lanes &= -lanes;
            return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
          }
          function resolveUpdatePriority() {
            var updatePriority = ReactDOMSharedInternals.p;
            if (0 !== updatePriority) return updatePriority;
            updatePriority = window.event;
            return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
          }
          function runWithPriority(priority, fn) {
            var previousPriority = ReactDOMSharedInternals.p;
            try {
              return ReactDOMSharedInternals.p = priority, fn();
            } finally {
              ReactDOMSharedInternals.p = previousPriority;
            }
          }
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) return targetInst;
            for (var parentNode2 = targetNode.parentNode; parentNode2; ) {
              if (targetInst = parentNode2[internalContainerInstanceKey] || parentNode2[internalInstanceKey]) {
                parentNode2 = targetInst.alternate;
                if (null !== targetInst.child || null !== parentNode2 && null !== parentNode2.child)
                  for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                    if (parentNode2 = targetNode[internalInstanceKey])
                      return parentNode2;
                    targetNode = getParentSuspenseInstance(targetNode);
                  }
                return targetInst;
              }
              targetNode = parentNode2;
              parentNode2 = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
              var tag = node.tag;
              if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
                return node;
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            var tag = inst.tag;
            if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
              return inst.stateNode;
            throw Error("getNodeFromInstance: Invalid argument.");
          }
          function getResourcesFromRoot(root2) {
            var resources = root2[internalRootNodeResourcesKey];
            resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
            return resources;
          }
          function markNodeAsHoistable(node) {
            node[internalHoistableMarker] = true;
          }
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            registrationNameDependencies[registrationName] && console.error(
              "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
              registrationName
            );
            registrationNameDependencies[registrationName] = dependencies;
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
            for (registrationName = 0; registrationName < dependencies.length; registrationName++)
              allNativeEvents.add(dependencies[registrationName]);
          }
          function checkControlledValueProps(tagName, props) {
            hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
            ) : console.error(
              "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
            ));
            props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
              "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
            );
          }
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
              return true;
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
              return false;
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
              return validatedAttributeNameCache[attributeName] = true;
            illegalAttributeNameCache[attributeName] = true;
            console.error("Invalid attribute name: `%s`", attributeName);
            return false;
          }
          function getValueForAttributeOnCustomComponent(node, name, expected) {
            if (isAttributeNameSafe(name)) {
              if (!node.hasAttribute(name)) {
                switch (typeof expected) {
                  case "symbol":
                  case "object":
                    return expected;
                  case "function":
                    return expected;
                  case "boolean":
                    if (false === expected) return expected;
                }
                return void 0 === expected ? void 0 : null;
              }
              node = node.getAttribute(name);
              if ("" === node && true === expected) return true;
              checkAttributeStringCoercion(expected, name);
              return node === "" + expected ? expected : node;
            }
          }
          function setValueForAttribute(node, name, value) {
            if (isAttributeNameSafe(name))
              if (null === value) node.removeAttribute(name);
              else {
                switch (typeof value) {
                  case "undefined":
                  case "function":
                  case "symbol":
                    node.removeAttribute(name);
                    return;
                  case "boolean":
                    var prefix2 = name.toLowerCase().slice(0, 5);
                    if ("data-" !== prefix2 && "aria-" !== prefix2) {
                      node.removeAttribute(name);
                      return;
                    }
                }
                checkAttributeStringCoercion(value, name);
                node.setAttribute(name, "" + value);
              }
          }
          function setValueForKnownAttribute(node, name, value) {
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                  node.removeAttribute(name);
                  return;
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
          }
          function setValueForNamespacedAttribute(node, namespace, name, value) {
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                  node.removeAttribute(name);
                  return;
              }
              checkAttributeStringCoercion(value, name);
              node.setAttributeNS(namespace, name, "" + value);
            }
          }
          function disabledLog() {
          }
          function disableLogs() {
            if (0 === disabledDepth) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
          function reenableLogs() {
            disabledDepth--;
            if (0 === disabledDepth) {
              var props = { configurable: true, enumerable: true, writable: true };
              Object.defineProperties(console, {
                log: assign({}, props, { value: prevLog }),
                info: assign({}, props, { value: prevInfo }),
                warn: assign({}, props, { value: prevWarn }),
                error: assign({}, props, { value: prevError }),
                group: assign({}, props, { value: prevGroup }),
                groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
                groupEnd: assign({}, props, { value: prevGroupEnd })
              });
            }
            0 > disabledDepth && console.error(
              "disabledDepth fell below zero. This is a bug in React. Please file an issue."
            );
          }
          function describeBuiltInComponentFrame(name) {
            if (void 0 === prefix)
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
                suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
              }
            return "\n" + prefix + name + suffix;
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) return "";
            var frame = componentFrameCache.get(fn);
            if (void 0 !== frame) return frame;
            reentry = true;
            frame = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher2 = null;
            previousDispatcher2 = ReactSharedInternals.H;
            ReactSharedInternals.H = null;
            disableLogs();
            try {
              var RunInRootFrame = {
                DetermineComponentFrameRoot: function() {
                  try {
                    if (construct) {
                      var Fake = function() {
                        throw Error();
                      };
                      Object.defineProperty(Fake.prototype, "props", {
                        set: function() {
                          throw Error();
                        }
                      });
                      if ("object" === typeof Reflect && Reflect.construct) {
                        try {
                          Reflect.construct(Fake, []);
                        } catch (x) {
                          var control = x;
                        }
                        Reflect.construct(fn, [], Fake);
                      } else {
                        try {
                          Fake.call();
                        } catch (x$0) {
                          control = x$0;
                        }
                        fn.call(Fake.prototype);
                      }
                    } else {
                      try {
                        throw Error();
                      } catch (x$1) {
                        control = x$1;
                      }
                      (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                      });
                    }
                  } catch (sample) {
                    if (sample && control && "string" === typeof sample.stack)
                      return [sample.stack, control.stack];
                  }
                  return [null, null];
                }
              };
              RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
              var namePropDescriptor = Object.getOwnPropertyDescriptor(
                RunInRootFrame.DetermineComponentFrameRoot,
                "name"
              );
              namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
                RunInRootFrame.DetermineComponentFrameRoot,
                "name",
                { value: "DetermineComponentFrameRoot" }
              );
              var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
              if (sampleStack && controlStack) {
                var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                  "DetermineComponentFrameRoot"
                ); )
                  namePropDescriptor++;
                for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                  "DetermineComponentFrameRoot"
                ); )
                  _RunInRootFrame$Deter++;
                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                  for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                    _RunInRootFrame$Deter--;
                for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                  if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                      do
                        if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                          var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                            " at new ",
                            " at "
                          );
                          fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                          "function" === typeof fn && componentFrameCache.set(fn, _frame);
                          return _frame;
                        }
                      while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                    }
                    break;
                  }
              }
            } finally {
              reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
            }
            sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
            "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
            return sampleLines;
          }
          function formatOwnerStack(error) {
            var prevPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            error = error.stack;
            Error.prepareStackTrace = prevPrepareStackTrace;
            error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
            prevPrepareStackTrace = error.indexOf("\n");
            -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
            prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
            -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
              "\n",
              prevPrepareStackTrace
            ));
            if (-1 !== prevPrepareStackTrace)
              error = error.slice(0, prevPrepareStackTrace);
            else return "";
            return error;
          }
          function describeFiber(fiber) {
            switch (fiber.tag) {
              case 26:
              case 27:
              case 5:
                return describeBuiltInComponentFrame(fiber.type);
              case 16:
                return describeBuiltInComponentFrame("Lazy");
              case 13:
                return describeBuiltInComponentFrame("Suspense");
              case 19:
                return describeBuiltInComponentFrame("SuspenseList");
              case 0:
              case 15:
                return describeNativeComponentFrame(fiber.type, false);
              case 11:
                return describeNativeComponentFrame(fiber.type.render, false);
              case 1:
                return describeNativeComponentFrame(fiber.type, true);
              case 31:
                return describeBuiltInComponentFrame("Activity");
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              do {
                info += describeFiber(workInProgress2);
                var debugInfo = workInProgress2._debugInfo;
                if (debugInfo)
                  for (var i2 = debugInfo.length - 1; 0 <= i2; i2--) {
                    var entry = debugInfo[i2];
                    if ("string" === typeof entry.name) {
                      var JSCompiler_temp_const = info, env = entry.env;
                      var JSCompiler_inline_result = describeBuiltInComponentFrame(
                        entry.name + (env ? " [" + env + "]" : "")
                      );
                      info = JSCompiler_temp_const + JSCompiler_inline_result;
                    }
                  }
                workInProgress2 = workInProgress2.return;
              } while (workInProgress2);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function describeFunctionComponentFrameWithoutLineNumber(fn) {
            return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
          }
          function getCurrentFiberOwnerNameInDevOrNull() {
            if (null === current) return null;
            var owner = current._debugOwner;
            return null != owner ? getComponentNameFromOwner(owner) : null;
          }
          function getCurrentFiberStackInDev() {
            if (null === current) return "";
            var workInProgress2 = current;
            try {
              var info = "";
              6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
              switch (workInProgress2.tag) {
                case 26:
                case 27:
                case 5:
                  info += describeBuiltInComponentFrame(workInProgress2.type);
                  break;
                case 13:
                  info += describeBuiltInComponentFrame("Suspense");
                  break;
                case 19:
                  info += describeBuiltInComponentFrame("SuspenseList");
                  break;
                case 31:
                  info += describeBuiltInComponentFrame("Activity");
                  break;
                case 30:
                case 0:
                case 15:
                case 1:
                  workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                    workInProgress2.type
                  ));
                  break;
                case 11:
                  workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                    workInProgress2.type.render
                  ));
              }
              for (; workInProgress2; )
                if ("number" === typeof workInProgress2.tag) {
                  var fiber = workInProgress2;
                  workInProgress2 = fiber._debugOwner;
                  var debugStack = fiber._debugStack;
                  workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
                } else if (null != workInProgress2.debugStack) {
                  var ownerStack = workInProgress2.debugStack;
                  (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
                } else break;
              var JSCompiler_inline_result = info;
            } catch (x) {
              JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
            }
            return JSCompiler_inline_result;
          }
          function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
            var previousFiber = current;
            setCurrentFiber(fiber);
            try {
              return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
                callback.bind(null, arg0, arg1, arg2, arg3, arg4)
              ) : callback(arg0, arg1, arg2, arg3, arg4);
            } finally {
              setCurrentFiber(previousFiber);
            }
            throw Error(
              "runWithFiberInDEV should never be called in production. This is a bug in React."
            );
          }
          function setCurrentFiber(fiber) {
            ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
            isRendering = false;
            current = fiber;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "bigint":
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                return checkFormFieldValueStringCoercion(value), value;
              default:
                return "";
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
              node.constructor.prototype,
              valueField
            );
            checkFormFieldValueStringCoercion(node[valueField]);
            var currentValue = "" + node[valueField];
            if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
              var get2 = descriptor.get, set = descriptor.set;
              Object.defineProperty(node, valueField, {
                configurable: true,
                get: function() {
                  return get2.call(this);
                },
                set: function(value) {
                  checkFormFieldValueStringCoercion(value);
                  currentValue = "" + value;
                  set.call(this, value);
                }
              });
              Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable
              });
              return {
                getValue: function() {
                  return currentValue;
                },
                setValue: function(value) {
                  checkFormFieldValueStringCoercion(value);
                  currentValue = "" + value;
                },
                stopTracking: function() {
                  node._valueTracker = null;
                  delete node[valueField];
                }
              };
            }
          }
          function track(node) {
            node._valueTracker || (node._valueTracker = trackValueOnNode(node));
          }
          function updateValueIfChanged(node) {
            if (!node) return false;
            var tracker = node._valueTracker;
            if (!tracker) return true;
            var lastValue = tracker.getValue();
            var value = "";
            node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
            node = value;
            return node !== lastValue ? (tracker.setValue(node), true) : false;
          }
          function getActiveElement(doc3) {
            doc3 = doc3 || ("undefined" !== typeof document ? document : void 0);
            if ("undefined" === typeof doc3) return null;
            try {
              return doc3.activeElement || doc3.body;
            } catch (e) {
              return doc3.body;
            }
          }
          function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
            return value.replace(
              escapeSelectorAttributeValueInsideDoubleQuotesRegex,
              function(ch) {
                return "\\" + ch.charCodeAt(0).toString(16) + " ";
              }
            );
          }
          function validateInputProps(element, props) {
            void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
              "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              getCurrentFiberOwnerNameInDevOrNull() || "A component",
              props.type
            ), didWarnCheckedDefaultChecked = true);
            void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
              "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
              getCurrentFiberOwnerNameInDevOrNull() || "A component",
              props.type
            ), didWarnValueDefaultValue$1 = true);
          }
          function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
            element.name = "";
            null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
            if (null != value)
              if ("number" === type) {
                if (0 === value && "" === element.value || element.value != value)
                  element.value = "" + getToStringValue(value);
              } else
                element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
            else
              "submit" !== type && "reset" !== type || element.removeAttribute("value");
            null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
            null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
            null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
            null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
          }
          function initInput2(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
            null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
            if (null != value || null != defaultValue) {
              if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
                return;
              defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
              value = null != value ? "" + getToStringValue(value) : defaultValue;
              isHydrating2 || value === element.value || (element.value = value);
              element.defaultValue = value;
            }
            checked = null != checked ? checked : defaultChecked;
            checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
            element.checked = isHydrating2 ? element.checked : !!checked;
            element.defaultChecked = !!checked;
            null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
          }
          function setDefaultValue(node, type, value) {
            "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
          }
          function validateOptionProps(element, props) {
            null == props.value && ("object" === typeof props.children && null !== props.children ? React4.Children.forEach(props.children, function(child) {
              null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
                "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
              ));
            }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
              "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
            )));
            null == props.selected || didWarnSelectedSetOnOption || (console.error(
              "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
            ), didWarnSelectedSetOnOption = true);
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            node = node.options;
            if (multiple) {
              multiple = {};
              for (var i2 = 0; i2 < propValue.length; i2++)
                multiple["$" + propValue[i2]] = true;
              for (propValue = 0; propValue < node.length; propValue++)
                i2 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i2 && (node[propValue].selected = i2), i2 && setDefaultSelected && (node[propValue].defaultSelected = true);
            } else {
              propValue = "" + getToStringValue(propValue);
              multiple = null;
              for (i2 = 0; i2 < node.length; i2++) {
                if (node[i2].value === propValue) {
                  node[i2].selected = true;
                  setDefaultSelected && (node[i2].defaultSelected = true);
                  return;
                }
                null !== multiple || node[i2].disabled || (multiple = node[i2]);
              }
              null !== multiple && (multiple.selected = true);
            }
          }
          function validateSelectProps(element, props) {
            for (element = 0; element < valuePropNames.length; element++) {
              var propName = valuePropNames[element];
              if (null != props[propName]) {
                var propNameIsArray = isArrayImpl(props[propName]);
                props.multiple && !propNameIsArray ? console.error(
                  "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                  propName,
                  getDeclarationErrorAddendum()
                ) : !props.multiple && propNameIsArray && console.error(
                  "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                  propName,
                  getDeclarationErrorAddendum()
                );
              }
            }
            void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
              "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
            ), didWarnValueDefaultValue = true);
          }
          function validateTextareaProps(element, props) {
            void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
              "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
              getCurrentFiberOwnerNameInDevOrNull() || "A component"
            ), didWarnValDefaultVal = true);
            null != props.children && null == props.value && console.error(
              "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
            );
          }
          function updateTextarea(element, value, defaultValue) {
            if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
              element.defaultValue !== value && (element.defaultValue = value);
              return;
            }
            element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          }
          function initTextarea(element, value, defaultValue, children) {
            if (null == value) {
              if (null != children) {
                if (null != defaultValue)
                  throw Error(
                    "If you supply `defaultValue` on a <textarea>, do not pass children."
                  );
                if (isArrayImpl(children)) {
                  if (1 < children.length)
                    throw Error("<textarea> can only have at most one child.");
                  children = children[0];
                }
                defaultValue = children;
              }
              null == defaultValue && (defaultValue = "");
              value = defaultValue;
            }
            defaultValue = getToStringValue(value);
            element.defaultValue = defaultValue;
            children = element.textContent;
            children === defaultValue && "" !== children && null !== children && (element.value = children);
          }
          function findNotableNode(node, indent) {
            return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
          }
          function indentation(indent) {
            return "  " + "  ".repeat(indent);
          }
          function added(indent) {
            return "+ " + "  ".repeat(indent);
          }
          function removed(indent) {
            return "- " + "  ".repeat(indent);
          }
          function describeFiberType(fiber) {
            switch (fiber.tag) {
              case 26:
              case 27:
              case 5:
                return fiber.type;
              case 16:
                return "Lazy";
              case 13:
                return "Suspense";
              case 19:
                return "SuspenseList";
              case 0:
              case 15:
                return fiber = fiber.type, fiber.displayName || fiber.name || null;
              case 11:
                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
              case 1:
                return fiber = fiber.type, fiber.displayName || fiber.name || null;
              default:
                return null;
            }
          }
          function describeTextNode(content, maxLength) {
            return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
          }
          function describeTextDiff(clientText, serverProps, indent) {
            var maxLength = 120 - 2 * indent;
            if (null === serverProps)
              return added(indent) + describeTextNode(clientText, maxLength) + "\n";
            if ("string" === typeof serverProps) {
              for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
              firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
              return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
            }
            return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
          }
          function objectName(object) {
            return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
              return p0;
            });
          }
          function describeValue(value, maxLength) {
            switch (typeof value) {
              case "string":
                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
              case "object":
                if (null === value) return "null";
                if (isArrayImpl(value)) return "[...]";
                if (value.$$typeof === REACT_ELEMENT_TYPE)
                  return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
                var name = objectName(value);
                if ("Object" === name) {
                  name = "";
                  maxLength -= 2;
                  for (var propName in value)
                    if (value.hasOwnProperty(propName)) {
                      var jsonPropName = JSON.stringify(propName);
                      jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                      maxLength -= propName.length - 2;
                      jsonPropName = describeValue(
                        value[propName],
                        15 > maxLength ? maxLength : 15
                      );
                      maxLength -= jsonPropName.length;
                      if (0 > maxLength) {
                        name += "" === name ? "..." : ", ...";
                        break;
                      }
                      name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                    }
                  return "{" + name + "}";
                }
                return name;
              case "function":
                return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
              default:
                return String(value);
            }
          }
          function describePropValue(value, maxLength) {
            return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
          }
          function describeExpandedElement(type, props, rowPrefix) {
            var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
            for (propName in props)
              if (props.hasOwnProperty(propName) && "children" !== propName) {
                var propValue = describePropValue(
                  props[propName],
                  120 - rowPrefix.length - propName.length - 1
                );
                remainingRowLength -= propName.length + propValue.length + 2;
                properties.push(propName + "=" + propValue);
              }
            return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
          }
          function describePropertiesDiff(clientObject, serverObject, indent) {
            var properties = "", remainingServerProperties = assign({}, serverObject), propName;
            for (propName in clientObject)
              if (clientObject.hasOwnProperty(propName)) {
                delete remainingServerProperties[propName];
                var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
                serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
              }
            for (var _propName in remainingServerProperties)
              remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
                remainingServerProperties[_propName],
                120 - 2 * indent - _propName.length - 2
              ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
            return properties;
          }
          function describeElementDiff(type, clientProps, serverProps, indent) {
            var content = "", serverPropNames = /* @__PURE__ */ new Map();
            for (propName$jscomp$0 in serverProps)
              serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
                propName$jscomp$0.toLowerCase(),
                propName$jscomp$0
              );
            if (1 === serverPropNames.size && serverPropNames.has("children"))
              content += describeExpandedElement(
                type,
                clientProps,
                indentation(indent)
              );
            else {
              for (var _propName2 in clientProps)
                if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                  var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                  if (void 0 !== serverPropName) {
                    serverPropNames.delete(_propName2.toLowerCase());
                    var propName$jscomp$0 = clientProps[_propName2];
                    serverPropName = serverProps[serverPropName];
                    var clientPropValue = describePropValue(
                      propName$jscomp$0,
                      maxLength$jscomp$0
                    );
                    maxLength$jscomp$0 = describePropValue(
                      serverPropName,
                      maxLength$jscomp$0
                    );
                    "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                      propName$jscomp$0,
                      serverPropName,
                      indent + 2
                    ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                  } else
                    content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
                }
              serverPropNames.forEach(function(propName) {
                if ("children" !== propName) {
                  var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                  content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
                }
              });
              content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
            }
            type = serverProps.children;
            clientProps = clientProps.children;
            if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
              serverPropNames = "";
              if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
                serverPropNames = "" + clientProps;
              content += describeTextDiff(serverPropNames, "" + type, indent + 1);
            } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
            return content;
          }
          function describeSiblingFiber(fiber, indent) {
            var type = describeFiberType(fiber);
            if (null === type) {
              type = "";
              for (fiber = fiber.child; fiber; )
                type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
              return type;
            }
            return indentation(indent) + "<" + type + ">\n";
          }
          function describeNode(node, indent) {
            var skipToNode = findNotableNode(node, indent);
            if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
              return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
            skipToNode = "";
            var debugInfo = node.fiber._debugInfo;
            if (debugInfo)
              for (var i2 = 0; i2 < debugInfo.length; i2++) {
                var serverComponentName = debugInfo[i2].name;
                "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
              }
            debugInfo = "";
            i2 = node.fiber.pendingProps;
            if (6 === node.fiber.tag)
              debugInfo = describeTextDiff(i2, node.serverProps, indent), indent++;
            else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
              if (void 0 === node.serverProps) {
                debugInfo = indent;
                var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
                for (propName in i2)
                  if (i2.hasOwnProperty(propName) && "children" !== propName) {
                    var propValue = describePropValue(i2[propName], 15);
                    maxLength -= propName.length + propValue.length + 2;
                    if (0 > maxLength) {
                      content += " ...";
                      break;
                    }
                    content += " " + propName + "=" + propValue;
                  }
                debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
                indent++;
              } else
                null === node.serverProps ? (debugInfo = describeExpandedElement(
                  serverComponentName,
                  i2,
                  added(indent)
                ), indent++) : "string" === typeof node.serverProps ? console.error(
                  "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
                ) : (debugInfo = describeElementDiff(
                  serverComponentName,
                  i2,
                  node.serverProps,
                  indent
                ), indent++);
            var propName = "";
            i2 = node.fiber.child;
            for (serverComponentName = 0; i2 && serverComponentName < node.children.length; )
              maxLength = node.children[serverComponentName], maxLength.fiber === i2 ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i2, indent), i2 = i2.sibling;
            i2 && 0 < node.children.length && (propName += indentation(indent) + "...\n");
            i2 = node.serverTail;
            null === node.serverProps && indent--;
            for (node = 0; node < i2.length; node++)
              serverComponentName = i2[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
                serverComponentName.type,
                serverComponentName.props,
                removed(indent)
              );
            return skipToNode + debugInfo + propName;
          }
          function describeDiff(rootNode) {
            try {
              return "\n\n" + describeNode(rootNode, 0);
            } catch (x) {
              return "";
            }
          }
          function describeAncestors(ancestor, child, props) {
            for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
              fiber === ancestor && (distanceFromLeaf = 0), node = {
                fiber,
                children: null !== node ? [node] : [],
                serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
                serverTail: [],
                distanceFromLeaf
              }, distanceFromLeaf++, fiber = fiber.return;
            return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
          }
          function updatedAncestorInfoDev(oldInfo, tag) {
            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
            -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
            -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
            -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
            ancestorInfo.current = info;
            "form" === tag && (ancestorInfo.formTag = info);
            "a" === tag && (ancestorInfo.aTagInScope = info);
            "button" === tag && (ancestorInfo.buttonTagInScope = info);
            "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
            "p" === tag && (ancestorInfo.pTagInButtonScope = info);
            "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
            if ("dd" === tag || "dt" === tag)
              ancestorInfo.dlItemTagAutoclosing = info;
            "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
            null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
            return ancestorInfo;
          }
          function isTagValidWithParent(tag, parentTag, implicitRootScope) {
            switch (parentTag) {
              case "select":
                return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
              case "optgroup":
                return "option" === tag || "#text" === tag;
              case "option":
                return "#text" === tag;
              case "tr":
                return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
              case "tbody":
              case "thead":
              case "tfoot":
                return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
              case "colgroup":
                return "col" === tag || "template" === tag;
              case "table":
                return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
              case "head":
                return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
              case "html":
                if (implicitRootScope) break;
                return "head" === tag || "body" === tag || "frameset" === tag;
              case "frameset":
                return "frame" === tag;
              case "#document":
                if (!implicitRootScope) return "html" === tag;
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
              case "rp":
              case "rt":
                return -1 === impliedEndTags.indexOf(parentTag);
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return null == parentTag;
              case "head":
                return implicitRootScope || null === parentTag;
              case "html":
                return implicitRootScope && "#document" === parentTag || null === parentTag;
              case "body":
                return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
            }
            return true;
          }
          function findInvalidAncestorForTag(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          }
          function findAncestor(parent, tagName) {
            for (; parent; ) {
              switch (parent.tag) {
                case 5:
                case 26:
                case 27:
                  if (parent.type === tagName) return parent;
              }
              parent = parent.return;
            }
            return null;
          }
          function validateDOMNesting(childTag, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
            var parentInfo = ancestorInfo.current;
            ancestorInfo = (parentInfo = isTagValidWithParent(
              childTag,
              parentInfo && parentInfo.tag,
              ancestorInfo.implicitRootScope
            ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            ancestorInfo = parentInfo || ancestorInfo;
            if (!ancestorInfo) return true;
            var ancestorTag = ancestorInfo.tag;
            ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
            if (didWarn[ancestorInfo]) return false;
            didWarn[ancestorInfo] = true;
            var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
            parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
              "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
              tagDisplayName,
              ancestorTag,
              parentInfo,
              ancestorDescription
            )) : console.error(
              "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
              tagDisplayName,
              ancestorTag,
              ancestorDescription
            );
            ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
              console.error(
                "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
                ancestorTag,
                tagDisplayName
              );
            }));
            return false;
          }
          function validateTextNesting(childText, parentTag, implicitRootScope) {
            if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
              return true;
            implicitRootScope = "#text|" + parentTag;
            if (didWarn[implicitRootScope]) return false;
            didWarn[implicitRootScope] = true;
            var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
            implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
              ancestor,
              implicitRootScope,
              6 !== implicitRootScope.tag ? { children: null } : null
            ) : "";
            /\S/.test(childText) ? console.error(
              "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
              parentTag,
              implicitRootScope
            ) : console.error(
              "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
              parentTag,
              implicitRootScope
            );
            return false;
          }
          function setTextContent(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          }
          function camelize(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          }
          function setValueForStyle(style3, styleName, value) {
            var isCustomProperty = 0 === styleName.indexOf("--");
            isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
              "Unsupported style property %s. Did you mean %s?",
              styleName,
              camelize(styleName.replace(msPattern, "ms-"))
            )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
              "Unsupported vendor-prefixed style property %s. Did you mean %s?",
              styleName,
              styleName.charAt(0).toUpperCase() + styleName.slice(1)
            )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
              `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
              styleName,
              value.replace(badStyleValueWithSemicolonPattern, "")
            )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
              "`NaN` is an invalid value for the `%s` css style property.",
              styleName
            )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
              "`Infinity` is an invalid value for the `%s` css style property.",
              styleName
            ))));
            null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style3[styleName] = ("" + value).trim()) : style3[styleName] = value + "px";
          }
          function setValueForStyles(node, styles, prevStyles) {
            if (null != styles && "object" !== typeof styles)
              throw Error(
                "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
              );
            styles && Object.freeze(styles);
            node = node.style;
            if (null != prevStyles) {
              if (styles) {
                var expandedUpdates = {};
                if (prevStyles) {
                  for (var key in prevStyles)
                    if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                      for (var longhands = shorthandToLonghand[key] || [key], i2 = 0; i2 < longhands.length; i2++)
                        expandedUpdates[longhands[i2]] = key;
                }
                for (var _key in styles)
                  if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                    for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                      expandedUpdates[key[longhands]] = _key;
                _key = {};
                for (var key$jscomp$0 in styles)
                  for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                    _key[key[longhands]] = key$jscomp$0;
                key$jscomp$0 = {};
                for (var _key2 in expandedUpdates)
                  if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i2 = key + "," + longhands, !key$jscomp$0[i2])) {
                    key$jscomp$0[i2] = true;
                    i2 = console;
                    var value = styles[key];
                    i2.error.call(
                      i2,
                      "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                      null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                      key,
                      longhands
                    );
                  }
              }
              for (var styleName in prevStyles)
                !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
              for (var _styleName in styles)
                _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
            } else
              for (expandedUpdates in styles)
                styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
          }
          function isCustomElement(tagName) {
            if (-1 === tagName.indexOf("-")) return false;
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          function getAttributeAlias(name) {
            return aliases.get(name) || name;
          }
          function validateProperty$1(tagName, name) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
              return true;
            if (rARIACamel$1.test(name)) {
              tagName = "aria-" + name.slice(4).toLowerCase();
              tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
              if (null == tagName)
                return console.error(
                  "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                  name
                ), warnedProperties$1[name] = true;
              if (name !== tagName)
                return console.error(
                  "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                  name,
                  tagName
                ), warnedProperties$1[name] = true;
            }
            if (rARIA$1.test(name)) {
              tagName = name.toLowerCase();
              tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
              if (null == tagName) return warnedProperties$1[name] = true, false;
              name !== tagName && (console.error(
                "Unknown ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true);
            }
            return true;
          }
          function validateProperties$2(type, props) {
            var invalidProps = [], key;
            for (key in props)
              validateProperty$1(type, key) || invalidProps.push(key);
            props = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            1 === invalidProps.length ? console.error(
              "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
              props,
              type
            ) : 1 < invalidProps.length && console.error(
              "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
              props,
              type
            );
          }
          function validateProperty(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
              return true;
            var lowerCasedName = name.toLowerCase();
            if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
              return console.error(
                "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
              ), warnedProperties[name] = true;
            if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
              return true;
            if (null != eventRegistry) {
              tagName = eventRegistry.possibleRegistrationNames;
              if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
                return true;
              eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
              if (null != eventRegistry)
                return console.error(
                  "Invalid event handler property `%s`. Did you mean `%s`?",
                  name,
                  eventRegistry
                ), warnedProperties[name] = true;
              if (EVENT_NAME_REGEX.test(name))
                return console.error(
                  "Unknown event handler property `%s`. It will be ignored.",
                  name
                ), warnedProperties[name] = true;
            } else if (EVENT_NAME_REGEX.test(name))
              return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
                "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
                name
              ), warnedProperties[name] = true;
            if (rARIA.test(name) || rARIACamel.test(name)) return true;
            if ("innerhtml" === lowerCasedName)
              return console.error(
                "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
              ), warnedProperties[name] = true;
            if ("aria" === lowerCasedName)
              return console.error(
                "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
              ), warnedProperties[name] = true;
            if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
              return console.error(
                "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
                typeof value
              ), warnedProperties[name] = true;
            if ("number" === typeof value && isNaN(value))
              return console.error(
                "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
                name
              ), warnedProperties[name] = true;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
                return console.error(
                  "Invalid DOM property `%s`. Did you mean `%s`?",
                  name,
                  lowerCasedName
                ), warnedProperties[name] = true;
            } else if (name !== lowerCasedName)
              return console.error(
                "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
            switch (name) {
              case "dangerouslySetInnerHTML":
              case "children":
              case "style":
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "ref":
                return true;
              case "innerText":
              case "textContent":
                return true;
            }
            switch (typeof value) {
              case "boolean":
                switch (name) {
                  case "autoFocus":
                  case "checked":
                  case "multiple":
                  case "muted":
                  case "selected":
                  case "contentEditable":
                  case "spellCheck":
                  case "draggable":
                  case "value":
                  case "autoReverse":
                  case "externalResourcesRequired":
                  case "focusable":
                  case "preserveAlpha":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "capture":
                  case "download":
                  case "inert":
                    return true;
                  default:
                    lowerCasedName = name.toLowerCase().slice(0, 5);
                    if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                      return true;
                    value ? console.error(
                      'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                      value,
                      name,
                      name,
                      value,
                      name
                    ) : console.error(
                      'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                      value,
                      name,
                      name,
                      value,
                      name,
                      name,
                      name
                    );
                    return warnedProperties[name] = true;
                }
              case "function":
              case "symbol":
                return warnedProperties[name] = true, false;
              case "string":
                if ("false" === value || "true" === value) {
                  switch (name) {
                    case "checked":
                    case "selected":
                    case "multiple":
                    case "muted":
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                    case "inert":
                      break;
                    default:
                      return true;
                  }
                  console.error(
                    "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                    value,
                    name,
                    "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                    name,
                    value
                  );
                  warnedProperties[name] = true;
                }
            }
            return true;
          }
          function warnUnknownProperties(type, props, eventRegistry) {
            var unknownProps = [], key;
            for (key in props)
              validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
            props = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            1 === unknownProps.length ? console.error(
              "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
              props,
              type
            ) : 1 < unknownProps.length && console.error(
              "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
              props,
              type
            );
          }
          function sanitizeURL(url) {
            return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
          }
          function getEventTarget(nativeEvent) {
            nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
            nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
            return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
          }
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (internalInstance && (target = internalInstance.stateNode)) {
              var props = target[internalPropsKey] || null;
              a: switch (target = internalInstance.stateNode, internalInstance.type) {
                case "input":
                  updateInput(
                    target,
                    props.value,
                    props.defaultValue,
                    props.defaultValue,
                    props.checked,
                    props.defaultChecked,
                    props.type,
                    props.name
                  );
                  internalInstance = props.name;
                  if ("radio" === props.type && null != internalInstance) {
                    for (props = target; props.parentNode; ) props = props.parentNode;
                    checkAttributeStringCoercion(internalInstance, "name");
                    props = props.querySelectorAll(
                      'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                        "" + internalInstance
                      ) + '"][type="radio"]'
                    );
                    for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                      var otherNode = props[internalInstance];
                      if (otherNode !== target && otherNode.form === target.form) {
                        var otherProps = otherNode[internalPropsKey] || null;
                        if (!otherProps)
                          throw Error(
                            "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                          );
                        updateInput(
                          otherNode,
                          otherProps.value,
                          otherProps.defaultValue,
                          otherProps.defaultValue,
                          otherProps.checked,
                          otherProps.defaultChecked,
                          otherProps.type,
                          otherProps.name
                        );
                      }
                    }
                    for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                      otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                  }
                  break a;
                case "textarea":
                  updateTextarea(target, props.value, props.defaultValue);
                  break a;
                case "select":
                  internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
              }
            }
          }
          function batchedUpdates$1(fn, a, b) {
            if (isInsideEventHandler) return fn(a, b);
            isInsideEventHandler = true;
            try {
              var JSCompiler_inline_result = fn(a);
              return JSCompiler_inline_result;
            } finally {
              if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
                if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                  for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
              }
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (null === stateNode) return null;
            var props = stateNode[internalPropsKey] || null;
            if (null === props) return null;
            stateNode = props[registrationName];
            a: switch (registrationName) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
                inst = !props;
                break a;
              default:
                inst = false;
            }
            if (inst) return null;
            if (stateNode && "function" !== typeof stateNode)
              throw Error(
                "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
              );
            return stateNode;
          }
          function getData() {
            if (fallbackText) return fallbackText;
            var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
            for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
            return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
          }
          function getEventCharCode(nativeEvent) {
            var keyCode = nativeEvent.keyCode;
            "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
            10 === nativeEvent && (nativeEvent = 13);
            return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var propName in Interface)
                Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
              this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          function modifierStateGetter(keyArg) {
            var nativeEvent = this.nativeEvent;
            return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
          }
          function getEventModifierState() {
            return modifierStateGetter;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            nativeEvent = nativeEvent.detail;
            return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                if (nativeEvent.which !== SPACEBAR_CODE) return null;
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing)
              return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                  if (nativeEvent.char && 1 < nativeEvent.char.length)
                    return nativeEvent.char;
                  if (nativeEvent.which)
                    return String.fromCharCode(nativeEvent.which);
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) return false;
            eventNameSuffix = "on" + eventNameSuffix;
            var isSupported = eventNameSuffix in document;
            isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
            return isSupported;
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
            inst = accumulateTwoPhaseListeners(inst, "onChange");
            0 < inst.length && (nativeEvent = new SyntheticEvent(
              "onChange",
              "change",
              null,
              nativeEvent,
              target
            ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) return targetInst;
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if ("change" === domEventName) return targetInst;
          }
          function stopWatchingForValueChange() {
            activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
          }
          function handlePropertyChange(nativeEvent) {
            if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
              var dispatchQueue = [];
              createAndAccumulateChangeEvent(
                dispatchQueue,
                activeElementInst$1,
                nativeEvent,
                getEventTarget(nativeEvent)
              );
              batchedUpdates$1(runEventInBatch, dispatchQueue);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
          }
          function getTargetInstForInputEventPolyfill(domEventName) {
            if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
              return getInstIfValueChanged(activeElementInst$1);
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if ("click" === domEventName) return getInstIfValueChanged(targetInst);
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if ("input" === domEventName || "change" === domEventName)
              return getInstIfValueChanged(targetInst);
          }
          function is(x, y) {
            return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
          }
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) return true;
            if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
              return false;
            var keysA = Object.keys(objA), keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) return false;
            for (keysB = 0; keysB < keysA.length; keysB++) {
              var currentKey = keysA[keysB];
              if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
                return false;
            }
            return true;
          }
          function getLeafNode(node) {
            for (; node && node.firstChild; ) node = node.firstChild;
            return node;
          }
          function getNodeForCharacterOffset(root2, offset) {
            var node = getLeafNode(root2);
            root2 = 0;
            for (var nodeEnd; node; ) {
              if (3 === node.nodeType) {
                nodeEnd = root2 + node.textContent.length;
                if (root2 <= offset && nodeEnd >= offset)
                  return { node, offset: offset - root2 };
                root2 = nodeEnd;
              }
              a: {
                for (; node; ) {
                  if (node.nextSibling) {
                    node = node.nextSibling;
                    break a;
                  }
                  node = node.parentNode;
                }
                node = void 0;
              }
              node = getLeafNode(node);
            }
          }
          function containsNode(outerNode, innerNode) {
            return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
          }
          function getActiveElementDeep(containerInfo) {
            containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
            for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
              try {
                var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
              } catch (err) {
                JSCompiler_inline_result = false;
              }
              if (JSCompiler_inline_result) containerInfo = element.contentWindow;
              else break;
              element = getActiveElement(containerInfo.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc3 = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
            mouseDown || null == activeElement || activeElement !== getActiveElement(doc3) || (doc3 = activeElement, "selectionStart" in doc3 && hasSelectionCapabilities(doc3) ? doc3 = { start: doc3.selectionStart, end: doc3.selectionEnd } : (doc3 = (doc3.ownerDocument && doc3.ownerDocument.defaultView || window).getSelection(), doc3 = {
              anchorNode: doc3.anchorNode,
              anchorOffset: doc3.anchorOffset,
              focusNode: doc3.focusNode,
              focusOffset: doc3.focusOffset
            }), lastSelection && shallowEqual(lastSelection, doc3) || (lastSelection = doc3, doc3 = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc3.length && (nativeEvent = new SyntheticEvent(
              "onSelect",
              "select",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: nativeEvent, listeners: doc3 }), nativeEvent.target = activeElement)));
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes = {};
            prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes["Webkit" + styleProp] = "webkit" + eventName;
            prefixes["Moz" + styleProp] = "moz" + eventName;
            return prefixes;
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
            if (!vendorPrefixes[eventName]) return eventName;
            var prefixMap = vendorPrefixes[eventName], styleProp;
            for (styleProp in prefixMap)
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
                return prefixedEventNames[eventName] = prefixMap[styleProp];
            return eventName;
          }
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function createCapturedValueAtFiber(value, source) {
            if ("object" === typeof value && null !== value) {
              var existing = CapturedStacks.get(value);
              if (void 0 !== existing) return existing;
              source = {
                value,
                source,
                stack: getStackByFiberInDevAndProd(source)
              };
              CapturedStacks.set(value, source);
              return source;
            }
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
          }
          function finishQueueingConcurrentUpdates() {
            for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
              var fiber = concurrentQueues[i2];
              concurrentQueues[i2++] = null;
              var queue = concurrentQueues[i2];
              concurrentQueues[i2++] = null;
              var update = concurrentQueues[i2];
              concurrentQueues[i2++] = null;
              var lane = concurrentQueues[i2];
              concurrentQueues[i2++] = null;
              if (null !== queue && null !== update) {
                var pending = queue.pending;
                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
                queue.pending = update;
              }
              0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
            }
          }
          function enqueueUpdate$1(fiber, queue, update, lane) {
            concurrentQueues[concurrentQueuesIndex++] = fiber;
            concurrentQueues[concurrentQueuesIndex++] = queue;
            concurrentQueues[concurrentQueuesIndex++] = update;
            concurrentQueues[concurrentQueuesIndex++] = lane;
            concurrentlyUpdatedLanes |= lane;
            fiber.lanes |= lane;
            fiber = fiber.alternate;
            null !== fiber && (fiber.lanes |= lane);
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            enqueueUpdate$1(fiber, queue, update, lane);
            return getRootForUpdatedFiber(fiber);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            enqueueUpdate$1(fiber, null, null, lane);
            return getRootForUpdatedFiber(fiber);
          }
          function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
            sourceFiber.lanes |= lane;
            var alternate = sourceFiber.alternate;
            null !== alternate && (alternate.lanes |= lane);
            for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
              parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
            return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
          }
          function getRootForUpdatedFiber(sourceFiber) {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
              throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
                "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
              );
            nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
              "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
            ));
            null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            for (var node = sourceFiber, parent = node.return; null !== parent; )
              null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
            return 3 === node.tag ? node.stateNode : null;
          }
          function resolveFunctionForHotReloading(type) {
            if (null === resolveFamily) return type;
            var family = resolveFamily(type);
            return void 0 === family ? type : family.current;
          }
          function resolveForwardRefForHotReloading(type) {
            if (null === resolveFamily) return type;
            var family = resolveFamily(type);
            return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            if (null === resolveFamily) return false;
            var prevType = fiber.elementType;
            element = element.type;
            var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
            switch (fiber.tag) {
              case 1:
                "function" === typeof element && (needsCompareFamilies = true);
                break;
              case 0:
                "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
                break;
              case 11:
                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
                break;
              case 14:
              case 15:
                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
                break;
              default:
                return false;
            }
            return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
          }
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
            switch (tag) {
              case 0:
              case 15:
              case 1:
                candidateType = type;
                break;
              case 11:
                candidateType = type.render;
            }
            if (null === resolveFamily)
              throw Error("Expected resolveFamily to be set during hot reload.");
            var needsRender = false;
            type = false;
            null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (1 === tag ? type = true : needsRender = true)));
            null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = true);
            type && (fiber._debugNeedsRemount = true);
            if (type || needsRender)
              alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
            null === child || type || scheduleFibersWithFamiliesRecursively(
              child,
              updatedFamilies,
              staleFamilies
            );
            null !== sibling && scheduleFibersWithFamiliesRecursively(
              sibling,
              updatedFamilies,
              staleFamilies
            );
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
            this.index = 0;
            this.refCleanup = this.ref = null;
            this.pendingProps = pendingProps;
            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
            this.mode = mode;
            this.subtreeFlags = this.flags = 0;
            this.deletions = null;
            this.childLanes = this.lanes = 0;
            this.alternate = null;
            this.actualDuration = -0;
            this.actualStartTime = -1.1;
            this.treeBaseDuration = this.selfBaseDuration = -0;
            this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
          }
          function shouldConstruct(Component) {
            Component = Component.prototype;
            return !(!Component || !Component.isReactComponent);
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            null === workInProgress2 ? (workInProgress2 = createFiber(
              current2.tag,
              pendingProps,
              current2.key,
              current2.mode
            ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
            workInProgress2.flags = current2.flags & 65011712;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            pendingProps = current2.dependencies;
            workInProgress2.dependencies = null === pendingProps ? null : {
              lanes: pendingProps.lanes,
              firstContext: pendingProps.firstContext,
              _debugThenableState: pendingProps._debugThenableState
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            workInProgress2.refCleanup = current2.refCleanup;
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            workInProgress2._debugInfo = current2._debugInfo;
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case 0:
              case 15:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case 1:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case 11:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= 65011714;
            var current2 = workInProgress2.alternate;
            null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
              lanes: renderLanes2.lanes,
              firstContext: renderLanes2.firstContext,
              _debugThenableState: renderLanes2._debugThenableState
            }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
            return workInProgress2;
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = 0, resolvedType = type;
            if ("function" === typeof type)
              shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
            else if ("string" === typeof type)
              fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
            else
              a: switch (type) {
                case REACT_ACTIVITY_TYPE:
                  return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(
                    pendingProps.children,
                    mode,
                    lanes,
                    key
                  );
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = 8;
                  mode |= StrictLegacyMode;
                  mode |= StrictEffectsMode;
                  break;
                case REACT_PROFILER_TYPE:
                  return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                    'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                    typeof type.id
                  ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
                case REACT_SUSPENSE_TYPE:
                  return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
                case REACT_SUSPENSE_LIST_TYPE:
                  return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
                default:
                  if ("object" === typeof type && null !== type)
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                      case REACT_CONTEXT_TYPE:
                        fiberTag = 10;
                        break a;
                      case REACT_CONSUMER_TYPE:
                        fiberTag = 9;
                        break a;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = 11;
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        break a;
                      case REACT_MEMO_TYPE:
                        fiberTag = 14;
                        break a;
                      case REACT_LAZY_TYPE:
                        fiberTag = 16;
                        resolvedType = null;
                        break a;
                    }
                  resolvedType = "";
                  if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                    resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                  null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                  (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                  fiberTag = 29;
                  pendingProps = Error(
                    "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                  );
                  resolvedType = null;
              }
            key = createFiber(fiberTag, pendingProps, key, mode);
            key.elementType = type;
            key.type = resolvedType;
            key.lanes = lanes;
            key._debugOwner = owner;
            return key;
          }
          function createFiberFromElement(element, mode, lanes) {
            mode = createFiberFromTypeAndProps(
              element.type,
              element.key,
              element.props,
              element._owner,
              mode,
              lanes
            );
            mode._debugOwner = element._owner;
            mode._debugStack = element._debugStack;
            mode._debugTask = element._debugTask;
            return mode;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            elements = createFiber(7, elements, key, mode);
            elements.lanes = lanes;
            return elements;
          }
          function createFiberFromText(content, mode, lanes) {
            content = createFiber(6, content, null, mode);
            content.lanes = lanes;
            return content;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            mode = createFiber(
              4,
              null !== portal.children ? portal.children : [],
              portal.key,
              mode
            );
            mode.lanes = lanes;
            mode.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return mode;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            workInProgress2 = treeContextOverflow;
            var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
            baseIdWithLeadingBit &= ~(1 << baseLength);
            index += 1;
            var length = 32 - clz32(totalChildren) + baseLength;
            if (30 < length) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
              baseIdWithLeadingBit >>= numberOfOverflowBits;
              baseLength -= numberOfOverflowBits;
              treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
              treeContextOverflow = length + workInProgress2;
            } else
              treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
          }
          function popTreeContext(workInProgress2) {
            for (; workInProgress2 === treeForkProvider; )
              treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
            for (; workInProgress2 === treeContextProvider; )
              treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
          }
          function warnIfNotHydrating() {
            isHydrating || console.error(
              "Expected to be hydrating. This is a bug in React. Please file an issue."
            );
          }
          function buildHydrationDiffNode(fiber, distanceFromLeaf) {
            if (null === fiber.return) {
              if (null === hydrationDiffRootDEV)
                hydrationDiffRootDEV = {
                  fiber,
                  children: [],
                  serverProps: void 0,
                  serverTail: [],
                  distanceFromLeaf
                };
              else {
                if (hydrationDiffRootDEV.fiber !== fiber)
                  throw Error(
                    "Saw multiple hydration diff roots in a pass. This is a bug in React."
                  );
                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
              }
              return hydrationDiffRootDEV;
            }
            var siblings = buildHydrationDiffNode(
              fiber.return,
              distanceFromLeaf + 1
            ).children;
            if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
              return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
            distanceFromLeaf = {
              fiber,
              children: [],
              serverProps: void 0,
              serverTail: [],
              distanceFromLeaf
            };
            siblings.push(distanceFromLeaf);
            return distanceFromLeaf;
          }
          function warnNonHydratedInstance(fiber, rejectedCandidate) {
            didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
          }
          function throwOnHydrationMismatch(fiber) {
            var diff = "", diffRoot = hydrationDiffRootDEV;
            null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
            queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
                ),
                fiber
              )
            );
            throw HydrationMismatchException;
          }
          function prepareToHydrateHostInstance(fiber) {
            var didHydrate = fiber.stateNode;
            var type = fiber.type, props = fiber.memoizedProps;
            didHydrate[internalInstanceKey] = fiber;
            didHydrate[internalPropsKey] = props;
            validatePropertiesInDevelopment(type, props);
            switch (type) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", didHydrate);
                listenToNonDelegatedEvent("close", didHydrate);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", didHydrate);
                break;
              case "video":
              case "audio":
                for (type = 0; type < mediaEventTypes.length; type++)
                  listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
                break;
              case "source":
                listenToNonDelegatedEvent("error", didHydrate);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", didHydrate);
                listenToNonDelegatedEvent("load", didHydrate);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", didHydrate);
                break;
              case "input":
                checkControlledValueProps("input", props);
                listenToNonDelegatedEvent("invalid", didHydrate);
                validateInputProps(didHydrate, props);
                initInput2(
                  didHydrate,
                  props.value,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name,
                  true
                );
                track(didHydrate);
                break;
              case "option":
                validateOptionProps(didHydrate, props);
                break;
              case "select":
                checkControlledValueProps("select", props);
                listenToNonDelegatedEvent("invalid", didHydrate);
                validateSelectProps(didHydrate, props);
                break;
              case "textarea":
                checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                  didHydrate,
                  props.value,
                  props.defaultValue,
                  props.children
                ), track(didHydrate);
            }
            type = props.children;
            "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
            didHydrate || throwOnHydrationMismatch(fiber);
          }
          function popToNextHostParent(fiber) {
            for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
              switch (hydrationParentFiber.tag) {
                case 5:
                case 13:
                  rootOrSingletonContext = false;
                  return;
                case 27:
                case 3:
                  rootOrSingletonContext = true;
                  return;
                default:
                  hydrationParentFiber = hydrationParentFiber.return;
              }
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) return false;
            if (!isHydrating)
              return popToNextHostParent(fiber), isHydrating = true, false;
            var tag = fiber.tag, JSCompiler_temp;
            if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
              if (JSCompiler_temp = 5 === tag)
                JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
              JSCompiler_temp = !JSCompiler_temp;
            }
            if (JSCompiler_temp && nextHydratableInstance) {
              for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
                diffNode.serverTail.push(description);
                JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
              }
              throwOnHydrationMismatch(fiber);
            }
            popToNextHostParent(fiber);
            if (13 === tag) {
              fiber = fiber.memoizedState;
              fiber = null !== fiber ? fiber.dehydrated : null;
              if (!fiber)
                throw Error(
                  "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                );
              nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
            } else
              27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
            return true;
          }
          function resetHydrationState() {
            nextHydratableInstance = hydrationParentFiber = null;
            didSuspendOrErrorDEV = isHydrating = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            var queuedErrors = hydrationErrors;
            null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
              workInProgressRootRecoverableErrors,
              queuedErrors
            ), hydrationErrors = null);
            return queuedErrors;
          }
          function queueHydrationError(error) {
            null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
          }
          function emitPendingHydrationWarnings() {
            var diffRoot = hydrationDiffRootDEV;
            if (null !== diffRoot) {
              hydrationDiffRootDEV = null;
              for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
                diffRoot = diffRoot.children[0];
              runWithFiberInDEV(diffRoot.fiber, function() {
                console.error(
                  "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                  "https://react.dev/link/hydration-mismatch",
                  diff
                );
              });
            }
          }
          function resetContextDependencies() {
            lastContextDependency = currentlyRenderingFiber$1 = null;
            isDisallowedContextReadInDEV = false;
          }
          function pushProvider(providerFiber, context, nextValue) {
            push(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            push(rendererCursorDEV, context._currentRenderer, providerFiber);
            void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
              "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
            );
            context._currentRenderer = rendererSigil;
          }
          function popProvider(context, providerFiber) {
            context._currentValue = valueCursor.current;
            var currentRenderer = rendererCursorDEV.current;
            pop(rendererCursorDEV, providerFiber);
            context._currentRenderer = currentRenderer;
            pop(valueCursor, providerFiber);
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            for (; null !== parent; ) {
              var alternate = parent.alternate;
              (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
              if (parent === propagationRoot) break;
              parent = parent.return;
            }
            parent !== propagationRoot && console.error(
              "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
            );
          }
          function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
            var fiber = workInProgress2.child;
            null !== fiber && (fiber.return = workInProgress2);
            for (; null !== fiber; ) {
              var list = fiber.dependencies;
              if (null !== list) {
                var nextFiber = fiber.child;
                list = list.firstContext;
                a: for (; null !== list; ) {
                  var dependency = list;
                  list = fiber;
                  for (var i2 = 0; i2 < contexts.length; i2++)
                    if (dependency.context === contexts[i2]) {
                      list.lanes |= renderLanes2;
                      dependency = list.alternate;
                      null !== dependency && (dependency.lanes |= renderLanes2);
                      scheduleContextWorkOnParentPath(
                        list.return,
                        renderLanes2,
                        workInProgress2
                      );
                      forcePropagateEntireTree || (nextFiber = null);
                      break a;
                    }
                  list = dependency.next;
                }
              } else if (18 === fiber.tag) {
                nextFiber = fiber.return;
                if (null === nextFiber)
                  throw Error(
                    "We just came from a parent so we must have had a parent. This is a bug in React."
                  );
                nextFiber.lanes |= renderLanes2;
                list = nextFiber.alternate;
                null !== list && (list.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  nextFiber,
                  renderLanes2,
                  workInProgress2
                );
                nextFiber = null;
              } else nextFiber = fiber.child;
              if (null !== nextFiber) nextFiber.return = fiber;
              else
                for (nextFiber = fiber; null !== nextFiber; ) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  fiber = nextFiber.sibling;
                  if (null !== fiber) {
                    fiber.return = nextFiber.return;
                    nextFiber = fiber;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              fiber = nextFiber;
            }
          }
          function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
            current2 = null;
            for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
              if (!isInsidePropagationBailout) {
                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
                else if (0 !== (parent.flags & 262144)) break;
              }
              if (10 === parent.tag) {
                var currentParent = parent.alternate;
                if (null === currentParent)
                  throw Error("Should have a current fiber. This is a bug in React.");
                currentParent = currentParent.memoizedProps;
                if (null !== currentParent) {
                  var context = parent.type;
                  objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
                }
              } else if (parent === hostTransitionProviderCursor.current) {
                currentParent = parent.alternate;
                if (null === currentParent)
                  throw Error("Should have a current fiber. This is a bug in React.");
                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
              }
              parent = parent.return;
            }
            null !== current2 && propagateContextChanges(
              workInProgress2,
              current2,
              renderLanes2,
              forcePropagateEntireTree
            );
            workInProgress2.flags |= 262144;
          }
          function checkIfContextChanged(currentDependencies) {
            for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
              if (!objectIs(
                currentDependencies.context._currentValue,
                currentDependencies.memoizedValue
              ))
                return true;
              currentDependencies = currentDependencies.next;
            }
            return false;
          }
          function prepareToReadContext(workInProgress2) {
            currentlyRenderingFiber$1 = workInProgress2;
            lastContextDependency = null;
            workInProgress2 = workInProgress2.dependencies;
            null !== workInProgress2 && (workInProgress2.firstContext = null);
          }
          function readContext(context) {
            isDisallowedContextReadInDEV && console.error(
              "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
            );
            return readContextForConsumer(currentlyRenderingFiber$1, context);
          }
          function readContextDuringReconciliation(consumer, context) {
            null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
            return readContextForConsumer(consumer, context);
          }
          function readContextForConsumer(consumer, context) {
            var value = context._currentValue;
            context = { context, memoizedValue: value, next: null };
            if (null === lastContextDependency) {
              if (null === consumer)
                throw Error(
                  "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
                );
              lastContextDependency = context;
              consumer.dependencies = {
                lanes: 0,
                firstContext: context,
                _debugThenableState: null
              };
              consumer.flags |= 524288;
            } else lastContextDependency = lastContextDependency.next = context;
            return value;
          }
          function createCache() {
            return {
              controller: new AbortControllerLocal(),
              data: /* @__PURE__ */ new Map(),
              refCount: 0
            };
          }
          function retainCache(cache) {
            cache.controller.signal.aborted && console.warn(
              "A cache instance was retained after it was already freed. This likely indicates a bug in React."
            );
            cache.refCount++;
          }
          function releaseCache(cache) {
            cache.refCount--;
            0 > cache.refCount && console.warn(
              "A cache instance was released after it was already freed. This likely indicates a bug in React."
            );
            0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
              cache.controller.abort();
            });
          }
          function pushNestedEffectDurations() {
            var prevEffectDuration = profilerEffectDuration;
            profilerEffectDuration = 0;
            return prevEffectDuration;
          }
          function popNestedEffectDurations(prevEffectDuration) {
            var elapsedTime = profilerEffectDuration;
            profilerEffectDuration = prevEffectDuration;
            return elapsedTime;
          }
          function bubbleNestedEffectDurations(prevEffectDuration) {
            var elapsedTime = profilerEffectDuration;
            profilerEffectDuration += prevEffectDuration;
            return elapsedTime;
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now();
            0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
          }
          function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
            if (0 <= profilerStartTime) {
              var elapsedTime = now() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              fiber.selfBaseDuration = elapsedTime;
              profilerStartTime = -1;
            }
          }
          function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
            if (0 <= profilerStartTime) {
              var elapsedTime = now() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              profilerStartTime = -1;
            }
          }
          function recordEffectDuration() {
            if (0 <= profilerStartTime) {
              var elapsedTime = now() - profilerStartTime;
              profilerStartTime = -1;
              profilerEffectDuration += elapsedTime;
            }
          }
          function startEffectTimer() {
            profilerStartTime = now();
          }
          function transferActualDuration(fiber) {
            for (var child = fiber.child; child; )
              fiber.actualDuration += child.actualDuration, child = child.sibling;
          }
          function entangleAsyncAction(transition, thenable) {
            if (null === currentEntangledListeners) {
              var entangledListeners = currentEntangledListeners = [];
              currentEntangledPendingCount = 0;
              currentEntangledLane = requestTransitionLane();
              currentEntangledActionThenable = {
                status: "pending",
                value: void 0,
                then: function(resolve) {
                  entangledListeners.push(resolve);
                }
              };
            }
            currentEntangledPendingCount++;
            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
            return thenable;
          }
          function pingEngtangledActionScope() {
            if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
              null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
              var listeners = currentEntangledListeners;
              currentEntangledListeners = null;
              currentEntangledLane = 0;
              currentEntangledActionThenable = null;
              for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
            }
          }
          function chainThenableValue(thenable, result) {
            var listeners = [], thenableWithOverride = {
              status: "pending",
              value: null,
              reason: null,
              then: function(resolve) {
                listeners.push(resolve);
              }
            };
            thenable.then(
              function() {
                thenableWithOverride.status = "fulfilled";
                thenableWithOverride.value = result;
                for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
              },
              function(error) {
                thenableWithOverride.status = "rejected";
                thenableWithOverride.reason = error;
                for (error = 0; error < listeners.length; error++)
                  (0, listeners[error])(void 0);
              }
            );
            return thenableWithOverride;
          }
          function peekCacheFromPool() {
            var cacheResumedFromPreviousRender = resumedCache.current;
            return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
          }
          function pushTransition(offscreenWorkInProgress, prevCachePool) {
            null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
          }
          function getSuspendedCache() {
            var cacheFromPool = peekCacheFromPool();
            return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
          }
          function createThenableState() {
            return { didWarnAboutUncachedPromise: false, thenables: [] };
          }
          function isThenableResolved(thenable) {
            thenable = thenable.status;
            return "fulfilled" === thenable || "rejected" === thenable;
          }
          function noop$3() {
          }
          function trackUsedThenable(thenableState2, thenable, index) {
            null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
            var trackedThenables = thenableState2.thenables;
            index = trackedThenables[index];
            void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
              "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
            )), thenable.then(noop$3, noop$3), thenable = index);
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              default:
                if ("string" === typeof thenable.status)
                  thenable.then(noop$3, noop$3);
                else {
                  thenableState2 = workInProgressRoot;
                  if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                    throw Error(
                      "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                    );
                  thenableState2 = thenable;
                  thenableState2.status = "pending";
                  thenableState2.then(
                    function(fulfilledValue) {
                      if ("pending" === thenable.status) {
                        var fulfilledThenable = thenable;
                        fulfilledThenable.status = "fulfilled";
                        fulfilledThenable.value = fulfilledValue;
                      }
                    },
                    function(error) {
                      if ("pending" === thenable.status) {
                        var rejectedThenable = thenable;
                        rejectedThenable.status = "rejected";
                        rejectedThenable.reason = error;
                      }
                    }
                  );
                }
                switch (thenable.status) {
                  case "fulfilled":
                    return thenable.value;
                  case "rejected":
                    throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
                }
                suspendedThenable = thenable;
                needsToResetSuspendedThenableDEV = true;
                throw SuspenseException;
            }
          }
          function getSuspendedThenable() {
            if (null === suspendedThenable)
              throw Error(
                "Expected a suspended thenable. This is a bug in React. Please file an issue."
              );
            var thenable = suspendedThenable;
            suspendedThenable = null;
            needsToResetSuspendedThenableDEV = false;
            return thenable;
          }
          function checkIfUseWrappedInAsyncCatch(rejectedReason) {
            if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
              throw Error(
                "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
          }
          function initializeUpdateQueue(fiber) {
            fiber.updateQueue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: { pending: null, lanes: 0, hiddenCallbacks: null },
              callbacks: null
            };
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            current2 = current2.updateQueue;
            workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
              baseState: current2.baseState,
              firstBaseUpdate: current2.firstBaseUpdate,
              lastBaseUpdate: current2.lastBaseUpdate,
              shared: current2.shared,
              callbacks: null
            });
          }
          function createUpdate(lane) {
            return {
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (null === updateQueue) return null;
            updateQueue = updateQueue.shared;
            if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
              var componentName2 = getComponentNameFromFiber(fiber);
              console.error(
                "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
                componentName2
              );
              didWarnUpdateInsideUpdate = true;
            }
            if ((executionContext & RenderContext) !== NoContext)
              return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
            enqueueUpdate$1(fiber, updateQueue, update, lane);
            return getRootForUpdatedFiber(fiber);
          }
          function entangleTransitions(root2, fiber, lane) {
            fiber = fiber.updateQueue;
            if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
              var queueLanes = fiber.lanes;
              queueLanes &= root2.pendingLanes;
              lane |= queueLanes;
              fiber.lanes = lane;
              markRootEntangled(root2, lane);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
            if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
              var newFirst = null, newLast = null;
              queue = queue.firstBaseUpdate;
              if (null !== queue) {
                do {
                  var clone = {
                    lane: queue.lane,
                    tag: queue.tag,
                    payload: queue.payload,
                    callback: null,
                    next: null
                  };
                  null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                  queue = queue.next;
                } while (null !== queue);
                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
              } else newFirst = newLast = capturedUpdate;
              queue = {
                baseState: current2.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: current2.shared,
                callbacks: current2.callbacks
              };
              workInProgress2.updateQueue = queue;
              return;
            }
            workInProgress2 = queue.lastBaseUpdate;
            null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
            queue.lastBaseUpdate = capturedUpdate;
          }
          function suspendIfUpdateReadFromEntangledAsyncAction() {
            if (didReadFromEntangledAsyncAction) {
              var entangledActionThenable = currentEntangledActionThenable;
              if (null !== entangledActionThenable) throw entangledActionThenable;
            }
          }
          function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
            didReadFromEntangledAsyncAction = false;
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            currentlyProcessingQueue = queue.shared;
            var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
            if (null !== pendingQueue) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
            }
            if (null !== firstBaseUpdate) {
              var newState = queue.baseState;
              lastBaseUpdate = 0;
              current2 = firstPendingUpdate = lastPendingUpdate = null;
              pendingQueue = firstBaseUpdate;
              do {
                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                  0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                  null !== current2 && (current2 = current2.next = {
                    lane: 0,
                    tag: pendingQueue.tag,
                    payload: pendingQueue.payload,
                    callback: null,
                    next: null
                  });
                  a: {
                    updateLane = workInProgress2;
                    var partialState = pendingQueue;
                    var nextProps = props, instance = instance$jscomp$0;
                    switch (partialState.tag) {
                      case ReplaceState:
                        partialState = partialState.payload;
                        if ("function" === typeof partialState) {
                          isDisallowedContextReadInDEV = true;
                          var nextState = partialState.call(
                            instance,
                            newState,
                            nextProps
                          );
                          if (updateLane.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                              partialState.call(instance, newState, nextProps);
                            } finally {
                              setIsStrictModeForDevtools(false);
                            }
                          }
                          isDisallowedContextReadInDEV = false;
                          newState = nextState;
                          break a;
                        }
                        newState = partialState;
                        break a;
                      case CaptureUpdate:
                        updateLane.flags = updateLane.flags & -65537 | 128;
                      case UpdateState:
                        nextState = partialState.payload;
                        if ("function" === typeof nextState) {
                          isDisallowedContextReadInDEV = true;
                          partialState = nextState.call(
                            instance,
                            newState,
                            nextProps
                          );
                          if (updateLane.mode & StrictLegacyMode) {
                            setIsStrictModeForDevtools(true);
                            try {
                              nextState.call(instance, newState, nextProps);
                            } finally {
                              setIsStrictModeForDevtools(false);
                            }
                          }
                          isDisallowedContextReadInDEV = false;
                        } else partialState = nextState;
                        if (null === partialState || void 0 === partialState) break a;
                        newState = assign({}, newState, partialState);
                        break a;
                      case ForceUpdate:
                        hasForceUpdate = true;
                    }
                  }
                  updateLane = pendingQueue.callback;
                  null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
                } else
                  isHiddenUpdate = {
                    lane: updateLane,
                    tag: pendingQueue.tag,
                    payload: pendingQueue.payload,
                    callback: pendingQueue.callback,
                    next: null
                  }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
                pendingQueue = pendingQueue.next;
                if (null === pendingQueue)
                  if (pendingQueue = queue.shared.pending, null === pendingQueue)
                    break;
                  else
                    isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
              } while (1);
              null === current2 && (lastPendingUpdate = newState);
              queue.baseState = lastPendingUpdate;
              queue.firstBaseUpdate = firstPendingUpdate;
              queue.lastBaseUpdate = current2;
              null === firstBaseUpdate && (queue.shared.lanes = 0);
              workInProgressRootSkippedLanes |= lastBaseUpdate;
              workInProgress2.lanes = lastBaseUpdate;
              workInProgress2.memoizedState = newState;
            }
            currentlyProcessingQueue = null;
          }
          function callCallback(callback, context) {
            if ("function" !== typeof callback)
              throw Error(
                "Invalid argument passed as callback. Expected a function. Instead received: " + callback
              );
            callback.call(context);
          }
          function commitHiddenCallbacks(updateQueue, context) {
            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
                callCallback(hiddenCallbacks[updateQueue], context);
          }
          function commitCallbacks(updateQueue, context) {
            var callbacks = updateQueue.callbacks;
            if (null !== callbacks)
              for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
                callCallback(callbacks[updateQueue], context);
          }
          function pushHiddenContext(fiber, context) {
            var prevEntangledRenderLanes = entangledRenderLanes;
            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
            push(currentTreeHiddenStackCursor, context, fiber);
            entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
          }
          function reuseHiddenContextOnStack(fiber) {
            push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
            push(
              currentTreeHiddenStackCursor,
              currentTreeHiddenStackCursor.current,
              fiber
            );
          }
          function popHiddenContext(fiber) {
            entangledRenderLanes = prevEntangledRenderLanesCursor.current;
            pop(currentTreeHiddenStackCursor, fiber);
            pop(prevEntangledRenderLanesCursor, fiber);
          }
          function mountHookTypesDev() {
            var hookName = currentHookNameInDev;
            null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
          }
          function updateHookTypesDev() {
            var hookName = currentHookNameInDev;
            if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
              var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
                for (var table = "", i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                  var oldHookName = hookTypesDev[i2], newHookName = i2 === hookTypesUpdateIndexDev ? hookName : oldHookName;
                  for (oldHookName = i2 + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                    oldHookName += " ";
                  oldHookName += newHookName + "\n";
                  table += oldHookName;
                }
                console.error(
                  "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                  componentName2,
                  table
                );
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
              "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
              currentHookNameInDev,
              typeof deps
            );
          }
          function warnOnUseFormStateInDev() {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
              "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
              componentName2
            ));
          }
          function throwInvalidHookError() {
            throw Error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
            );
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            if (ignorePreviousDependencies) return false;
            if (null === prevDeps)
              return console.error(
                "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
                currentHookNameInDev
              ), false;
            nextDeps.length !== prevDeps.length && console.error(
              "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
              currentHookNameInDev,
              "[" + prevDeps.join(", ") + "]",
              "[" + nextDeps.join(", ") + "]"
            );
            for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
              if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber = workInProgress2;
            hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
            if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
              nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
                "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
                null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
              ));
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = 0;
            ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
            shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
            var children = callComponentInDEV(Component, props, secondArg);
            shouldDoubleInvokeUserFnsInHooksDEV = false;
            didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
              workInProgress2,
              Component,
              props,
              secondArg
            ));
            if (nextRenderLanes) {
              setIsStrictModeForDevtools(true);
              try {
                children = renderWithHooksAgain(
                  workInProgress2,
                  Component,
                  props,
                  secondArg
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            finishRenderingHooks(current2, workInProgress2);
            return children;
          }
          function finishRenderingHooks(current2, workInProgress2) {
            workInProgress2._debugHookTypes = hookTypesDev;
            null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
              lanes: 0,
              firstContext: null,
              _debugThenableState: thenableState$1
            }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
            ReactSharedInternals.H = ContextOnlyDispatcher;
            var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
            renderLanes = 0;
            hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
            hookTypesUpdateIndexDev = -1;
            null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
              "Internal React error: Expected static flag was missing. Please notify the React team."
            );
            didScheduleRenderPhaseUpdate = false;
            thenableIndexCounter$1 = 0;
            thenableState$1 = null;
            if (didRenderTooFewHooks)
              throw Error(
                "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
              );
            null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
            needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
            current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
              "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
            )));
          }
          function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
            currentlyRenderingFiber = workInProgress2;
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
              thenableIndexCounter$1 = 0;
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              if (numberOfReRenders >= RE_RENDER_LIMIT)
                throw Error(
                  "Too many re-renders. React limits the number of renders to prevent an infinite loop."
                );
              numberOfReRenders += 1;
              ignorePreviousDependencies = false;
              workInProgressHook = currentHook = null;
              if (null != workInProgress2.updateQueue) {
                var children = workInProgress2.updateQueue;
                children.lastEffect = null;
                children.events = null;
                children.stores = null;
                null != children.memoCache && (children.memoCache.index = 0);
              }
              hookTypesUpdateIndexDev = -1;
              ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
              children = callComponentInDEV(Component, props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
            return children;
          }
          function TransitionAwareHostComponent() {
            var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
            maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
            dispatcher = dispatcher.useState()[0];
            (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
            return maybeThenable;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = 0 !== localIdCounter;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
            current2.lanes &= ~lanes;
          }
          function resetHooksOnUnwind(workInProgress2) {
            if (didScheduleRenderPhaseUpdate) {
              for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
                var queue = workInProgress2.queue;
                null !== queue && (queue.pending = null);
                workInProgress2 = workInProgress2.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = 0;
            hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            thenableIndexCounter$1 = localIdCounter = 0;
            thenableState$1 = null;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            if (null === currentHook) {
              var nextCurrentHook = currentlyRenderingFiber.alternate;
              nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
            } else nextCurrentHook = currentHook.next;
            var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
            if (null !== nextWorkInProgressHook)
              workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
            else {
              if (null === nextCurrentHook) {
                if (null === currentlyRenderingFiber.alternate)
                  throw Error(
                    "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                  );
                throw Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              nextCurrentHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return { lastEffect: null, events: null, stores: null, memoCache: null };
          }
          function useThenable(thenable) {
            var index = thenableIndexCounter$1;
            thenableIndexCounter$1 += 1;
            null === thenableState$1 && (thenableState$1 = createThenableState());
            thenable = trackUsedThenable(thenableState$1, thenable, index);
            index = currentlyRenderingFiber;
            null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
            return thenable;
          }
          function use(usable) {
            if (null !== usable && "object" === typeof usable) {
              if ("function" === typeof usable.then) return useThenable(usable);
              if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
            }
            throw Error("An unsupported type was passed to use(): " + String(usable));
          }
          function useMemoCache(size) {
            var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
            null !== updateQueue && (memoCache = updateQueue.memoCache);
            if (null == memoCache) {
              var current2 = currentlyRenderingFiber.alternate;
              null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
                data: current2.data.map(function(array) {
                  return array.slice();
                }),
                index: 0
              })));
            }
            null == memoCache && (memoCache = { data: [], index: 0 });
            null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
            updateQueue.memoCache = memoCache;
            updateQueue = memoCache.data[memoCache.index];
            if (void 0 === updateQueue || ignorePreviousDependencies)
              for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
                updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
            else
              updateQueue.length !== size && console.error(
                "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
                updateQueue.length,
                size
              );
            memoCache.index++;
            return updateQueue;
          }
          function basicStateReducer(state, action) {
            return "function" === typeof action ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            if (void 0 !== init) {
              var initialState = init(initialArg);
              if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                try {
                  init(initialArg);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            } else initialState = initialArg;
            hook.memoizedState = hook.baseState = initialState;
            reducer = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = reducer;
            reducer = reducer.dispatch = dispatchReducerAction.bind(
              null,
              currentlyRenderingFiber,
              reducer
            );
            return [hook.memoizedState, reducer];
          }
          function updateReducer(reducer) {
            var hook = updateWorkInProgressHook();
            return updateReducerImpl(hook, currentHook, reducer);
          }
          function updateReducerImpl(hook, current2, reducer) {
            var queue = hook.queue;
            if (null === queue)
              throw Error(
                "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
              );
            queue.lastRenderedReducer = reducer;
            var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
            if (null !== pendingQueue) {
              if (null !== baseQueue) {
                var baseFirst = baseQueue.next;
                baseQueue.next = pendingQueue.next;
                pendingQueue.next = baseFirst;
              }
              current2.baseQueue !== baseQueue && console.error(
                "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
              );
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            pendingQueue = hook.baseState;
            if (null === baseQueue) hook.memoizedState = pendingQueue;
            else {
              current2 = baseQueue.next;
              var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
              do {
                var updateLane = update.lane & -536870913;
                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                  var revertLane = update.revertLane;
                  if (0 === revertLane)
                    null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                      lane: 0,
                      revertLane: 0,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  else if ((renderLanes & revertLane) === revertLane) {
                    update = update.next;
                    revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                    continue;
                  } else
                    updateLane = {
                      lane: 0,
                      revertLane: update.revertLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                  updateLane = update.action;
                  shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                  pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
                } else
                  revertLane = {
                    lane: updateLane,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
                update = update.next;
              } while (null !== update && update !== current2);
              null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
              if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
                throw reducer;
              hook.memoizedState = pendingQueue;
              hook.baseState = baseFirst;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = pendingQueue;
            }
            null === baseQueue && (queue.lanes = 0);
            return [hook.memoizedState, queue.dispatch];
          }
          function rerenderReducer(reducer) {
            var hook = updateWorkInProgressHook(), queue = hook.queue;
            if (null === queue)
              throw Error(
                "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
              );
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
            if (null !== lastRenderPhaseUpdate) {
              queue.pending = null;
              var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              do
                newState = reducer(newState, update.action), update = update.next;
              while (update !== lastRenderPhaseUpdate);
              objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
              hook.memoizedState = newState;
              null === hook.baseQueue && (hook.baseState = newState);
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
            if (isHydrating) {
              if (void 0 === getServerSnapshot)
                throw Error(
                  "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
                );
              var nextSnapshot = getServerSnapshot();
              didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
                "The result of getServerSnapshot should be cached to avoid an infinite loop"
              ), didWarnUncachedGetSnapshot = true);
            } else {
              nextSnapshot = getSnapshot();
              didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
                "The result of getSnapshot should be cached to avoid an infinite loop"
              ), didWarnUncachedGetSnapshot = true));
              if (null === workInProgressRoot)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
            hook.memoizedState = nextSnapshot;
            getServerSnapshot = { value: nextSnapshot, getSnapshot };
            hook.queue = getServerSnapshot;
            mountEffect(
              subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
              [subscribe]
            );
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              createEffectInstance(),
              updateStoreInstance.bind(
                null,
                fiber,
                getServerSnapshot,
                nextSnapshot,
                getSnapshot
              ),
              null
            );
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
            if (isHydrating$jscomp$0) {
              if (void 0 === getServerSnapshot)
                throw Error(
                  "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
                );
              getServerSnapshot = getServerSnapshot();
            } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
                "The result of getSnapshot should be cached to avoid an infinite loop"
              ), didWarnUncachedGetSnapshot = true);
            }
            if (cachedSnapshot = !objectIs(
              (currentHook || hook).memoizedState,
              getServerSnapshot
            ))
              hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
            hook = hook.queue;
            var create = subscribeToStore.bind(null, fiber, hook, subscribe);
            updateEffectImpl(2048, Passive, create, [subscribe]);
            if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= 2048;
              pushSimpleEffect(
                HasEffect | Passive,
                createEffectInstance(),
                updateStoreInstance.bind(
                  null,
                  fiber,
                  hook,
                  getServerSnapshot,
                  getSnapshot
                ),
                null
              );
              if (null === workInProgressRoot)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
            }
            return getServerSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= 16384;
            fiber = { getSnapshot, value: renderedSnapshot };
            getSnapshot = currentlyRenderingFiber.updateQueue;
            null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          }
          function subscribeToStore(fiber, inst, subscribe) {
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
            });
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            inst = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(inst, nextValue);
            } catch (error) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
          }
          function mountStateImpl(initialState) {
            var hook = mountWorkInProgressHook();
            if ("function" === typeof initialState) {
              var initialStateInitializer = initialState;
              initialState = initialStateInitializer();
              if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                try {
                  initialStateInitializer();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            hook.memoizedState = hook.baseState = initialState;
            hook.queue = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            return hook;
          }
          function mountState(initialState) {
            initialState = mountStateImpl(initialState);
            var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
            queue.dispatch = dispatch;
            return [initialState.memoizedState, dispatch];
          }
          function mountOptimistic(passthrough) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = hook.baseState = passthrough;
            var queue = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: null,
              lastRenderedState: null
            };
            hook.queue = queue;
            hook = dispatchOptimisticSetState.bind(
              null,
              currentlyRenderingFiber,
              true,
              queue
            );
            queue.dispatch = hook;
            return [passthrough, hook];
          }
          function updateOptimistic(passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          }
          function updateOptimisticImpl(hook, current2, passthrough, reducer) {
            hook.baseState = passthrough;
            return updateReducerImpl(
              hook,
              currentHook,
              "function" === typeof reducer ? reducer : basicStateReducer
            );
          }
          function rerenderOptimistic(passthrough, reducer) {
            var hook = updateWorkInProgressHook();
            if (null !== currentHook)
              return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
            hook.baseState = passthrough;
            return [passthrough, hook.queue.dispatch];
          }
          function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
            if (isRenderPhaseUpdate(fiber))
              throw Error("Cannot update form state while rendering.");
            fiber = actionQueue.action;
            if (null !== fiber) {
              var actionNode = {
                payload,
                action: fiber,
                next: null,
                isTransition: true,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(listener) {
                  actionNode.listeners.push(listener);
                }
              };
              null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
              setState(actionNode);
              setPendingState = actionQueue.pending;
              null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
            }
          }
          function runActionStateAction(actionQueue, node) {
            var action = node.action, payload = node.payload, prevState = actionQueue.state;
            if (node.isTransition) {
              var prevTransition = ReactSharedInternals.T, currentTransition = {};
              ReactSharedInternals.T = currentTransition;
              ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
              try {
                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                handleActionReturnValue(actionQueue, node, returnValue);
              } catch (error) {
                onActionError(actionQueue, node, error);
              } finally {
                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                  "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
                ));
              }
            } else
              try {
                currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
              } catch (error$4) {
                onActionError(actionQueue, node, error$4);
              }
          }
          function handleActionReturnValue(actionQueue, node, returnValue) {
            null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
              function(nextState) {
                onActionSuccess(actionQueue, node, nextState);
              },
              function(error) {
                return onActionError(actionQueue, node, error);
              }
            ), node.isTransition || console.error(
              "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
            )) : onActionSuccess(actionQueue, node, returnValue);
          }
          function onActionSuccess(actionQueue, actionNode, nextState) {
            actionNode.status = "fulfilled";
            actionNode.value = nextState;
            notifyActionListeners(actionNode);
            actionQueue.state = nextState;
            actionNode = actionQueue.pending;
            null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
          }
          function onActionError(actionQueue, actionNode, error) {
            var last = actionQueue.pending;
            actionQueue.pending = null;
            if (null !== last) {
              last = last.next;
              do
                actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
              while (actionNode !== last);
            }
            actionQueue.action = null;
          }
          function notifyActionListeners(actionNode) {
            actionNode = actionNode.listeners;
            for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
          }
          function actionStateReducer(oldState, newState) {
            return newState;
          }
          function mountActionState(action, initialStateProp) {
            if (isHydrating) {
              var ssrFormState = workInProgressRoot.formState;
              if (null !== ssrFormState) {
                a: {
                  var isMatching = currentlyRenderingFiber;
                  if (isHydrating) {
                    if (nextHydratableInstance) {
                      b: {
                        var markerInstance = nextHydratableInstance;
                        for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                          if (!inRootOrSingleton) {
                            markerInstance = null;
                            break b;
                          }
                          markerInstance = getNextHydratable(
                            markerInstance.nextSibling
                          );
                          if (null === markerInstance) {
                            markerInstance = null;
                            break b;
                          }
                        }
                        inRootOrSingleton = markerInstance.data;
                        markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                      }
                      if (markerInstance) {
                        nextHydratableInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                        break a;
                      }
                    }
                    throwOnHydrationMismatch(isMatching);
                  }
                  isMatching = false;
                }
                isMatching && (initialStateProp = ssrFormState[0]);
              }
            }
            ssrFormState = mountWorkInProgressHook();
            ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
            isMatching = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: actionStateReducer,
              lastRenderedState: initialStateProp
            };
            ssrFormState.queue = isMatching;
            ssrFormState = dispatchSetState.bind(
              null,
              currentlyRenderingFiber,
              isMatching
            );
            isMatching.dispatch = ssrFormState;
            isMatching = mountStateImpl(false);
            inRootOrSingleton = dispatchOptimisticSetState.bind(
              null,
              currentlyRenderingFiber,
              false,
              isMatching.queue
            );
            isMatching = mountWorkInProgressHook();
            markerInstance = {
              state: initialStateProp,
              dispatch: null,
              action,
              pending: null
            };
            isMatching.queue = markerInstance;
            ssrFormState = dispatchActionState.bind(
              null,
              currentlyRenderingFiber,
              markerInstance,
              inRootOrSingleton,
              ssrFormState
            );
            markerInstance.dispatch = ssrFormState;
            isMatching.memoizedState = action;
            return [initialStateProp, ssrFormState, false];
          }
          function updateActionState(action) {
            var stateHook = updateWorkInProgressHook();
            return updateActionStateImpl(stateHook, currentHook, action);
          }
          function updateActionStateImpl(stateHook, currentStateHook, action) {
            currentStateHook = updateReducerImpl(
              stateHook,
              currentStateHook,
              actionStateReducer
            )[0];
            stateHook = updateReducer(basicStateReducer)[0];
            if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
              try {
                var state = useThenable(currentStateHook);
              } catch (x) {
                if (x === SuspenseException) throw SuspenseActionException;
                throw x;
              }
            else state = currentStateHook;
            currentStateHook = updateWorkInProgressHook();
            var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
            action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
              HasEffect | Passive,
              createEffectInstance(),
              actionStateActionEffect.bind(null, actionQueue, action),
              null
            ));
            return [state, dispatch, stateHook];
          }
          function actionStateActionEffect(actionQueue, action) {
            actionQueue.action = action;
          }
          function rerenderActionState(action) {
            var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
            if (null !== currentStateHook)
              return updateActionStateImpl(stateHook, currentStateHook, action);
            updateWorkInProgressHook();
            stateHook = stateHook.memoizedState;
            currentStateHook = updateWorkInProgressHook();
            var dispatch = currentStateHook.queue.dispatch;
            currentStateHook.memoizedState = action;
            return [stateHook, dispatch, false];
          }
          function pushSimpleEffect(tag, inst, create, createDeps) {
            tag = {
              tag,
              create,
              deps: createDeps,
              inst,
              next: null
            };
            inst = currentlyRenderingFiber.updateQueue;
            null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
            create = inst.lastEffect;
            null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
            return tag;
          }
          function createEffectInstance() {
            return { destroy: void 0, resource: void 0 };
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            initialValue = { current: initialValue };
            return hook.memoizedState = initialValue;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
            var hook = mountWorkInProgressHook();
            createDeps = void 0 === createDeps ? null : createDeps;
            currentlyRenderingFiber.flags |= fiberFlags;
            hook.memoizedState = pushSimpleEffect(
              HasEffect | hookFlags,
              createEffectInstance(),
              create,
              createDeps
            );
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var inst = hook.memoizedState.inst;
            null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
              HasEffect | hookFlags,
              inst,
              create,
              deps
            ));
          }
          function mountEffect(create, createDeps) {
            (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = 4194308;
            (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if ("function" === typeof ref) {
              create = create();
              var refCleanup = ref(create);
              return function() {
                "function" === typeof refCleanup ? refCleanup() : ref(null);
              };
            }
            if (null !== ref && void 0 !== ref)
              return ref.hasOwnProperty("current") || console.error(
                "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
                "an object with keys {" + Object.keys(ref).join(", ") + "}"
              ), create = create(), ref.current = create, function() {
                ref.current = null;
              };
          }
          function mountImperativeHandle(ref, create, deps) {
            "function" !== typeof create && console.error(
              "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
              null !== create ? typeof create : "null"
            );
            deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
            var fiberFlags = 4194308;
            (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
            mountEffectImpl(
              fiberFlags,
              Layout,
              imperativeHandleEffect.bind(null, create, ref),
              deps
            );
          }
          function updateImperativeHandle(ref, create, deps) {
            "function" !== typeof create && console.error(
              "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
              null !== create ? typeof create : "null"
            );
            deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
            updateEffectImpl(
              4,
              Layout,
              imperativeHandleEffect.bind(null, create, ref),
              deps
            );
          }
          function mountCallback(callback, deps) {
            mountWorkInProgressHook().memoizedState = [
              callback,
              void 0 === deps ? null : deps
            ];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var prevState = hook.memoizedState;
            if (null !== deps && areHookInputsEqual(deps, prevState[1]))
              return prevState[0];
            hook.memoizedState = [callback, deps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var nextValue = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                nextCreate();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            hook.memoizedState = [nextValue, deps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var prevState = hook.memoizedState;
            if (null !== deps && areHookInputsEqual(deps, prevState[1]))
              return prevState[0];
            prevState = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                nextCreate();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            hook.memoizedState = [prevState, deps];
            return prevState;
          }
          function mountDeferredValue(value, initialValue) {
            var hook = mountWorkInProgressHook();
            return mountDeferredValueImpl(hook, value, initialValue);
          }
          function updateDeferredValue(value, initialValue) {
            var hook = updateWorkInProgressHook();
            return updateDeferredValueImpl(
              hook,
              currentHook.memoizedState,
              value,
              initialValue
            );
          }
          function rerenderDeferredValue(value, initialValue) {
            var hook = updateWorkInProgressHook();
            return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
              hook,
              currentHook.memoizedState,
              value,
              initialValue
            );
          }
          function mountDeferredValueImpl(hook, value, initialValue) {
            if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
              return hook.memoizedState = value;
            hook.memoizedState = initialValue;
            hook = requestDeferredLane();
            currentlyRenderingFiber.lanes |= hook;
            workInProgressRootSkippedLanes |= hook;
            return initialValue;
          }
          function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
            if (objectIs(value, prevValue)) return value;
            if (null !== currentTreeHiddenStackCursor.current)
              return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
            if (0 === (renderLanes & 42))
              return didReceiveUpdate = true, hook.memoizedState = value;
            hook = requestDeferredLane();
            currentlyRenderingFiber.lanes |= hook;
            workInProgressRootSkippedLanes |= hook;
            return prevValue;
          }
          function startTransition(fiber, queue, pendingState, finishedState, callback) {
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            dispatchOptimisticSetState(fiber, false, queue, pendingState);
            currentTransition._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
                var thenableForFinishedState = chainThenableValue(
                  returnValue,
                  finishedState
                );
                dispatchSetStateInternal(
                  fiber,
                  queue,
                  thenableForFinishedState,
                  requestUpdateLane(fiber)
                );
              } else
                dispatchSetStateInternal(
                  fiber,
                  queue,
                  finishedState,
                  requestUpdateLane(fiber)
                );
            } catch (error) {
              dispatchSetStateInternal(
                fiber,
                queue,
                { then: function() {
                }, status: "rejected", reason: error },
                requestUpdateLane(fiber)
              );
            } finally {
              ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          }
          function startHostTransition(formFiber, pendingState, action, formData) {
            if (5 !== formFiber.tag)
              throw Error(
                "Expected the form instance to be a HostComponent. This is a bug in React."
              );
            var queue = ensureFormComponentIsStateful(formFiber).queue;
            startTransition(
              formFiber,
              queue,
              pendingState,
              NotPendingTransition,
              null === action ? noop$2 : function() {
                requestFormReset$1(formFiber);
                return action(formData);
              }
            );
          }
          function ensureFormComponentIsStateful(formFiber) {
            var existingStateHook = formFiber.memoizedState;
            if (null !== existingStateHook) return existingStateHook;
            existingStateHook = {
              memoizedState: NotPendingTransition,
              baseState: NotPendingTransition,
              baseQueue: null,
              queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: NotPendingTransition
              },
              next: null
            };
            var initialResetState = {};
            existingStateHook.next = {
              memoizedState: initialResetState,
              baseState: initialResetState,
              baseQueue: null,
              queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialResetState
              },
              next: null
            };
            formFiber.memoizedState = existingStateHook;
            formFiber = formFiber.alternate;
            null !== formFiber && (formFiber.memoizedState = existingStateHook);
            return existingStateHook;
          }
          function requestFormReset$1(formFiber) {
            null === ReactSharedInternals.T && console.error(
              "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
            );
            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
            dispatchSetStateInternal(
              formFiber,
              resetStateQueue,
              {},
              requestUpdateLane(formFiber)
            );
          }
          function mountTransition() {
            var stateHook = mountStateImpl(false);
            stateHook = startTransition.bind(
              null,
              currentlyRenderingFiber,
              stateHook.queue,
              true,
              false
            );
            mountWorkInProgressHook().memoizedState = stateHook;
            return [false, stateHook];
          }
          function updateTransition() {
            var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
            return [
              "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
              start
            ];
          }
          function rerenderTransition() {
            var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
            return [
              "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
              start
            ];
          }
          function useHostTransitionStatus() {
            return readContext(HostTransitionContext);
          }
          function mountId() {
            var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
            if (isHydrating) {
              var treeId = treeContextOverflow;
              var idWithLeadingBit = treeContextId;
              treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
              identifierPrefix = "\xAB" + identifierPrefix + "R" + treeId;
              treeId = localIdCounter++;
              0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
              identifierPrefix += "\xBB";
            } else
              treeId = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + treeId.toString(32) + "\xBB";
            return hook.memoizedState = identifierPrefix;
          }
          function mountRefresh() {
            return mountWorkInProgressHook().memoizedState = refreshCache.bind(
              null,
              currentlyRenderingFiber
            );
          }
          function refreshCache(fiber, seedKey) {
            for (var provider = fiber.return; null !== provider; ) {
              switch (provider.tag) {
                case 24:
                case 3:
                  var lane = requestUpdateLane(provider);
                  fiber = createUpdate(lane);
                  var root2 = enqueueUpdate(provider, fiber, lane);
                  null !== root2 && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                  provider = createCache();
                  null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                    "The seed argument is not enabled outside experimental channels."
                  );
                  fiber.payload = { cache: provider };
                  return;
              }
              provider = provider.return;
            }
          }
          function dispatchReducerAction(fiber, queue, action) {
            var args = arguments;
            "function" === typeof args[3] && console.error(
              "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
            );
            args = requestUpdateLane(fiber);
            var update = {
              lane: args,
              revertLane: 0,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
            markStateUpdateScheduled(fiber, args);
          }
          function dispatchSetState(fiber, queue, action) {
            var args = arguments;
            "function" === typeof args[3] && console.error(
              "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
            );
            args = requestUpdateLane(fiber);
            dispatchSetStateInternal(fiber, queue, action, args);
            markStateUpdateScheduled(fiber, args);
          }
          function dispatchSetStateInternal(fiber, queue, action, lane) {
            var update = {
              lane,
              revertLane: 0,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
            else {
              var alternate = fiber.alternate;
              if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
                var prevDispatcher = ReactSharedInternals.H;
                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                  update.hasEagerState = true;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState))
                    return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
                } catch (error) {
                } finally {
                  ReactSharedInternals.H = prevDispatcher;
                }
              }
              action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (null !== action)
                return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
            }
            return false;
          }
          function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
            null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
              "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
            );
            action = {
              lane: 2,
              revertLane: requestTransitionLane(),
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              if (throwIfDuringRender)
                throw Error("Cannot update optimistic state while rendering.");
              console.error("Cannot call startTransition while rendering.");
            } else
              throwIfDuringRender = enqueueConcurrentHookUpdate(
                fiber,
                queue,
                action,
                2
              ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
            markStateUpdateScheduled(fiber, 2);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          function entangleTransitionUpdate(root2, queue, lane) {
            if (0 !== (lane & 4194048)) {
              var queueLanes = queue.lanes;
              queueLanes &= root2.pendingLanes;
              lane |= queueLanes;
              queue.lanes = lane;
              markRootEntangled(root2, lane);
            }
          }
          function pushDebugInfo(debugInfo) {
            var previousDebugInfo = currentDebugInfo;
            null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
            return previousDebugInfo;
          }
          function validateFragmentProps(element, fiber, returnFiber) {
            for (var keys2 = Object.keys(element.props), i2 = 0; i2 < keys2.length; i2++) {
              var key = keys2[i2];
              if ("children" !== key && "key" !== key) {
                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
                runWithFiberInDEV(
                  fiber,
                  function(erroredKey) {
                    console.error(
                      "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                      erroredKey
                    );
                  },
                  key
                );
                break;
              }
            }
          }
          function unwrapThenable(thenable) {
            var index = thenableIndexCounter;
            thenableIndexCounter += 1;
            null === thenableState && (thenableState = createThenableState());
            return trackUsedThenable(thenableState, thenable, index);
          }
          function coerceRef(workInProgress2, element) {
            element = element.props.ref;
            workInProgress2.ref = void 0 !== element ? element : null;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
              throw Error(
                'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
              );
            returnFiber = Object.prototype.toString.call(newChild);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          function warnOnFunctionType(returnFiber, invalidChild) {
            var parentName = getComponentNameFromFiber(returnFiber) || "Component";
            ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
              invalidChild,
              invalidChild,
              invalidChild
            ) : console.error(
              "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
              invalidChild,
              invalidChild,
              parentName,
              invalidChild,
              parentName
            ));
          }
          function warnOnSymbolType(returnFiber, invalidChild) {
            var parentName = getComponentNameFromFiber(returnFiber) || "Component";
            ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
              "Symbols are not valid as a React child.\n  root.render(%s)",
              invalidChild
            ) : console.error(
              "Symbols are not valid as a React child.\n  <%s>%s</%s>",
              parentName,
              invalidChild,
              parentName
            ));
          }
          function createChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (shouldTrackSideEffects) {
                var deletions = returnFiber.deletions;
                null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) return null;
              for (; null !== currentFirstChild; )
                deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
              return null;
            }
            function mapRemainingChildren(currentFirstChild) {
              for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
                null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              fiber = createWorkInProgress(fiber, pendingProps);
              fiber.index = 0;
              fiber.sibling = null;
              return fiber;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects)
                return newFiber.flags |= 1048576, lastPlacedIndex;
              newIndex = newFiber.alternate;
              if (null !== newIndex)
                return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
              newFiber.flags |= 67108866;
              return lastPlacedIndex;
            }
            function placeSingleChild(newFiber) {
              shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (null === current2 || 6 !== current2.tag)
                return current2 = createFiberFromText(
                  textContent,
                  returnFiber.mode,
                  lanes
                ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
              current2 = useFiber(current2, textContent);
              current2.return = returnFiber;
              current2._debugInfo = currentDebugInfo;
              return current2;
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE)
                return current2 = updateFragment(
                  returnFiber,
                  current2,
                  element.props.children,
                  lanes,
                  element.key
                ), validateFragmentProps(element, current2, returnFiber), current2;
              if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
                return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
              current2 = createFiberFromElement(element, returnFiber.mode, lanes);
              coerceRef(current2, element);
              current2.return = returnFiber;
              current2._debugInfo = currentDebugInfo;
              return current2;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
                return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
              current2 = useFiber(current2, portal.children || []);
              current2.return = returnFiber;
              current2._debugInfo = currentDebugInfo;
              return current2;
            }
            function updateFragment(returnFiber, current2, fragment, lanes, key) {
              if (null === current2 || 7 !== current2.tag)
                return current2 = createFiberFromFragment(
                  fragment,
                  returnFiber.mode,
                  lanes,
                  key
                ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
              current2 = useFiber(current2, fragment);
              current2.return = returnFiber;
              current2._debugInfo = currentDebugInfo;
              return current2;
            }
            function createChild(returnFiber, newChild, lanes) {
              if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                return newChild = createFiberFromText(
                  "" + newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
              if ("object" === typeof newChild && null !== newChild) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                  case REACT_PORTAL_TYPE:
                    return newChild = createFiberFromPortal(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                  case REACT_LAZY_TYPE:
                    var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                    newChild = callLazyInitInDEV(newChild);
                    returnFiber = createChild(returnFiber, newChild, lanes);
                    currentDebugInfo = _prevDebugInfo;
                    return returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild))
                  return lanes = createFiberFromFragment(
                    newChild,
                    returnFiber.mode,
                    lanes,
                    null
                  ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                if ("function" === typeof newChild.then)
                  return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                    returnFiber,
                    unwrapThenable(newChild),
                    lanes
                  ), currentDebugInfo = _prevDebugInfo, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                  return createChild(
                    returnFiber,
                    readContextDuringReconciliation(returnFiber, newChild),
                    lanes
                  );
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
              "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = null !== oldFiber ? oldFiber.key : null;
              if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              if ("object" === typeof newChild && null !== newChild) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                      returnFiber,
                      oldFiber,
                      newChild,
                      lanes
                    ), currentDebugInfo = key, returnFiber) : null;
                  case REACT_PORTAL_TYPE:
                    return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                  case REACT_LAZY_TYPE:
                    return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                      returnFiber,
                      oldFiber,
                      newChild,
                      lanes
                    ), currentDebugInfo = key, returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                  if (null !== key) return null;
                  key = pushDebugInfo(newChild._debugInfo);
                  returnFiber = updateFragment(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes,
                    null
                  );
                  currentDebugInfo = key;
                  return returnFiber;
                }
                if ("function" === typeof newChild.then)
                  return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    unwrapThenable(newChild),
                    lanes
                  ), currentDebugInfo = key, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                  return updateSlot(
                    returnFiber,
                    oldFiber,
                    readContextDuringReconciliation(returnFiber, newChild),
                    lanes
                  );
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
              "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
              if ("object" === typeof newChild && null !== newChild) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return newIdx = existingChildren.get(
                      null === newChild.key ? newIdx : newChild.key
                    ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                      returnFiber,
                      newIdx,
                      newChild,
                      lanes
                    ), currentDebugInfo = existingChildren, returnFiber;
                  case REACT_PORTAL_TYPE:
                    return existingChildren = existingChildren.get(
                      null === newChild.key ? newIdx : newChild.key
                    ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                  case REACT_LAZY_TYPE:
                    var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                    newChild = callLazyInitInDEV(newChild);
                    returnFiber = updateFromMap(
                      existingChildren,
                      returnFiber,
                      newIdx,
                      newChild,
                      lanes
                    );
                    currentDebugInfo = _prevDebugInfo7;
                    return returnFiber;
                }
                if (isArrayImpl(newChild) || getIteratorFn(newChild))
                  return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes,
                    null
                  ), currentDebugInfo = existingChildren, returnFiber;
                if ("function" === typeof newChild.then)
                  return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    unwrapThenable(newChild),
                    lanes
                  ), currentDebugInfo = _prevDebugInfo7, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                  return updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    readContextDuringReconciliation(returnFiber, newChild),
                    lanes
                  );
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
              "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
              return null;
            }
            function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
              if ("object" !== typeof child || null === child) return knownKeys;
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(returnFiber, workInProgress2, child);
                  var key = child.key;
                  if ("string" !== typeof key) break;
                  if (null === knownKeys) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key);
                    break;
                  }
                  if (!knownKeys.has(key)) {
                    knownKeys.add(key);
                    break;
                  }
                  runWithFiberInDEV(workInProgress2, function() {
                    console.error(
                      "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                      key
                    );
                  });
                  break;
                case REACT_LAZY_TYPE:
                  child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  lanes
                );
                if (null === newFiber) {
                  null === oldFiber && (oldFiber = nextOldFiber);
                  break;
                }
                knownKeys = warnOnInvalidKey(
                  returnFiber,
                  newFiber,
                  newChildren[newIdx],
                  knownKeys
                );
                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length)
                return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
              if (null === oldFiber) {
                for (; newIdx < newChildren.length; newIdx++)
                  oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                    returnFiber,
                    oldFiber,
                    newChildren[newIdx],
                    knownKeys
                  ), currentFirstChild = placeChild(
                    oldFiber,
                    currentFirstChild,
                    newIdx
                  ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
              }
              for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
                nextOldFiber = updateFromMap(
                  oldFiber,
                  returnFiber,
                  newIdx,
                  newChildren[newIdx],
                  lanes
                ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  nextOldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ), currentFirstChild = placeChild(
                  nextOldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
              shouldTrackSideEffects && oldFiber.forEach(function(child) {
                return deleteChild(returnFiber, child);
              });
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
              if (null == newChildren)
                throw Error("An iterable object provided no iterator.");
              for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (null === newFiber) {
                  null === oldFiber && (oldFiber = nextOldFiber);
                  break;
                }
                knownKeys = warnOnInvalidKey(
                  returnFiber,
                  newFiber,
                  step.value,
                  knownKeys
                );
                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done)
                return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
              if (null === oldFiber) {
                for (; !step.done; newIdx++, step = newChildren.next())
                  oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                    returnFiber,
                    oldFiber,
                    step.value,
                    knownKeys
                  ), currentFirstChild = placeChild(
                    oldFiber,
                    currentFirstChild,
                    newIdx
                  ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
              }
              for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
                nextOldFiber = updateFromMap(
                  oldFiber,
                  returnFiber,
                  newIdx,
                  step.value,
                  lanes
                ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  nextOldFiber,
                  step.value,
                  knownKeys
                ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                  null === nextOldFiber.key ? newIdx : nextOldFiber.key
                ), currentFirstChild = placeChild(
                  nextOldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
              shouldTrackSideEffects && oldFiber.forEach(function(child) {
                return deleteChild(returnFiber, child);
              });
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
              "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
              if ("object" === typeof newChild && null !== newChild) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                    a: {
                      for (var key = newChild.key; null !== currentFirstChild; ) {
                        if (currentFirstChild.key === key) {
                          key = newChild.type;
                          if (key === REACT_FRAGMENT_TYPE) {
                            if (7 === currentFirstChild.tag) {
                              deleteRemainingChildren(
                                returnFiber,
                                currentFirstChild.sibling
                              );
                              lanes = useFiber(
                                currentFirstChild,
                                newChild.props.children
                              );
                              lanes.return = returnFiber;
                              lanes._debugOwner = newChild._owner;
                              lanes._debugInfo = currentDebugInfo;
                              validateFragmentProps(newChild, lanes, returnFiber);
                              returnFiber = lanes;
                              break a;
                            }
                          } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                            currentFirstChild,
                            newChild
                          ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(currentFirstChild, newChild.props);
                            coerceRef(lanes, newChild);
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            returnFiber = lanes;
                            break a;
                          }
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        } else deleteChild(returnFiber, currentFirstChild);
                        currentFirstChild = currentFirstChild.sibling;
                      }
                      newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                        newChild.props.children,
                        returnFiber.mode,
                        lanes,
                        newChild.key
                      ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                        newChild,
                        returnFiber.mode,
                        lanes
                      ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                    }
                    returnFiber = placeSingleChild(returnFiber);
                    currentDebugInfo = prevDebugInfo;
                    return returnFiber;
                  case REACT_PORTAL_TYPE:
                    a: {
                      prevDebugInfo = newChild;
                      for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                        if (currentFirstChild.key === newChild)
                          if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              prevDebugInfo.children || []
                            );
                            lanes.return = returnFiber;
                            returnFiber = lanes;
                            break a;
                          } else {
                            deleteRemainingChildren(returnFiber, currentFirstChild);
                            break;
                          }
                        else deleteChild(returnFiber, currentFirstChild);
                        currentFirstChild = currentFirstChild.sibling;
                      }
                      lanes = createFiberFromPortal(
                        prevDebugInfo,
                        returnFiber.mode,
                        lanes
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                    }
                    return placeSingleChild(returnFiber);
                  case REACT_LAZY_TYPE:
                    return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                      returnFiber,
                      currentFirstChild,
                      newChild,
                      lanes
                    ), currentDebugInfo = prevDebugInfo, returnFiber;
                }
                if (isArrayImpl(newChild))
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
                if (getIteratorFn(newChild)) {
                  prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  key = getIteratorFn(newChild);
                  if ("function" !== typeof key)
                    throw Error(
                      "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                    );
                  var newChildren = key.call(newChild);
                  if (newChildren === newChild) {
                    if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                      didWarnAboutGenerators || console.error(
                        "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                      ), didWarnAboutGenerators = true;
                  } else
                    newChild.entries !== key || didWarnAboutMaps || (console.error(
                      "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                    ), didWarnAboutMaps = true);
                  returnFiber = reconcileChildrenIterator(
                    returnFiber,
                    currentFirstChild,
                    newChildren,
                    lanes
                  );
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                }
                if ("function" === typeof newChild.then)
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    unwrapThenable(newChild),
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
                if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                  return reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    readContextDuringReconciliation(returnFiber, newChild),
                    lanes
                  );
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
                return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                  returnFiber,
                  currentFirstChild.sibling
                ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                  prevDebugInfo,
                  returnFiber.mode,
                  lanes
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
              "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
              "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return function(returnFiber, currentFirstChild, newChild, lanes) {
              var prevDebugInfo = currentDebugInfo;
              currentDebugInfo = null;
              try {
                thenableIndexCounter = 0;
                var firstChildFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
                thenableState = null;
                return firstChildFiber;
              } catch (x) {
                if (x === SuspenseException || x === SuspenseActionException) throw x;
                var fiber = createFiber(29, x, null, returnFiber.mode);
                fiber.lanes = lanes;
                fiber.return = returnFiber;
                var debugInfo = fiber._debugInfo = currentDebugInfo;
                fiber._debugOwner = returnFiber._debugOwner;
                fiber._debugTask = returnFiber._debugTask;
                if (null != debugInfo) {
                  for (var i2 = debugInfo.length - 1; 0 <= i2; i2--)
                    if ("string" === typeof debugInfo[i2].stack) {
                      fiber._debugOwner = debugInfo[i2];
                      fiber._debugTask = debugInfo[i2].debugTask;
                      break;
                    }
                }
                return fiber;
              } finally {
                currentDebugInfo = prevDebugInfo;
              }
            };
          }
          function pushPrimaryTreeSuspenseHandler(handler) {
            var current2 = handler.alternate;
            push(
              suspenseStackCursor,
              suspenseStackCursor.current & SubtreeSuspenseContextMask,
              handler
            );
            push(suspenseHandlerStackCursor, handler, handler);
            null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
          }
          function pushOffscreenSuspenseHandler(fiber) {
            if (22 === fiber.tag) {
              if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
                var current2 = fiber.alternate;
                null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
              }
            } else reuseSuspenseHandlerOnStack(fiber);
          }
          function reuseSuspenseHandlerOnStack(fiber) {
            push(suspenseStackCursor, suspenseStackCursor.current, fiber);
            push(
              suspenseHandlerStackCursor,
              suspenseHandlerStackCursor.current,
              fiber
            );
          }
          function popSuspenseHandler(fiber) {
            pop(suspenseHandlerStackCursor, fiber);
            shellBoundary === fiber && (shellBoundary = null);
            pop(suspenseStackCursor, fiber);
          }
          function findFirstSuspended(row) {
            for (var node = row; null !== node; ) {
              if (13 === node.tag) {
                var state = node.memoizedState;
                if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
                  return node;
              } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
                if (0 !== (node.flags & 128)) return node;
              } else if (null !== node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === row) return null;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function warnOnInvalidCallback(callback) {
            if (null !== callback && "function" !== typeof callback) {
              var key = String(callback);
              didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
                "Expected the last optional `callback` argument to be a function. Instead received: %s.",
                callback
              ));
            }
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
              "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
              ctor
            )));
            prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = prevState;
            0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
          }
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if ("function" === typeof instance.shouldComponentUpdate) {
              oldProps = instance.shouldComponentUpdate(
                newProps,
                newState,
                nextContext
              );
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  oldProps = instance.shouldComponentUpdate(
                    newProps,
                    newState,
                    nextContext
                  );
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              void 0 === oldProps && console.error(
                "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
                getComponentNameFromType(ctor) || "Component"
              );
              return oldProps;
            }
            return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
            "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
              "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              workInProgress2
            )), classComponentUpdater.enqueueReplaceState(
              instance,
              instance.state,
              null
            ));
          }
          function resolveClassComponentProps(Component, baseProps) {
            var newProps = baseProps;
            if ("ref" in baseProps) {
              newProps = {};
              for (var propName in baseProps)
                "ref" !== propName && (newProps[propName] = baseProps[propName]);
            }
            if (Component = Component.defaultProps) {
              newProps === baseProps && (newProps = assign({}, newProps));
              for (var _propName in Component)
                void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
            }
            return newProps;
          }
          function defaultOnUncaughtError(error) {
            reportGlobalError(error);
            console.warn(
              "%s\n\n%s\n",
              componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
              "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
            );
          }
          function defaultOnCaughtError(error) {
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
            if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
              var JSCompiler_inline_result = error.environmentName;
              error = [
                "%o\n\n%s\n\n%s\n",
                error,
                componentNameMessage,
                recreateMessage
              ].slice(0);
              "string" === typeof error[0] ? error.splice(
                0,
                1,
                badgeFormat + error[0],
                badgeStyle,
                pad + JSCompiler_inline_result + pad,
                resetStyle
              ) : error.splice(
                0,
                0,
                badgeFormat,
                badgeStyle,
                pad + JSCompiler_inline_result + pad,
                resetStyle
              );
              error.unshift(console);
              JSCompiler_inline_result = bind2.apply(console.error, error);
              JSCompiler_inline_result();
            } else
              console.error(
                "%o\n\n%s\n\n%s\n",
                error,
                componentNameMessage,
                recreateMessage
              );
          }
          function defaultOnRecoverableError(error) {
            reportGlobalError(error);
          }
          function logUncaughtError(root2, errorInfo) {
            try {
              componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
              errorBoundaryName = null;
              var error = errorInfo.value;
              if (null !== ReactSharedInternals.actQueue)
                ReactSharedInternals.thrownErrors.push(error);
              else {
                var onUncaughtError = root2.onUncaughtError;
                onUncaughtError(error, { componentStack: errorInfo.stack });
              }
            } catch (e$5) {
              setTimeout(function() {
                throw e$5;
              });
            }
          }
          function logCaughtError(root2, boundary, errorInfo) {
            try {
              componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
              errorBoundaryName = getComponentNameFromFiber(boundary);
              var onCaughtError = root2.onCaughtError;
              onCaughtError(errorInfo.value, {
                componentStack: errorInfo.stack,
                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
              });
            } catch (e$6) {
              setTimeout(function() {
                throw e$6;
              });
            }
          }
          function createRootErrorUpdate(root2, errorInfo, lane) {
            lane = createUpdate(lane);
            lane.tag = CaptureUpdate;
            lane.payload = { element: null };
            lane.callback = function() {
              runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
            };
            return lane;
          }
          function createClassErrorUpdate(lane) {
            lane = createUpdate(lane);
            lane.tag = CaptureUpdate;
            return lane;
          }
          function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if ("function" === typeof getDerivedStateFromError) {
              var error = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error);
              };
              update.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
                runWithFiberInDEV(
                  errorInfo.source,
                  logCaughtError,
                  root2,
                  fiber,
                  errorInfo
                );
              };
            }
            var inst = fiber.stateNode;
            null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
              "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
              callComponentDidCatchInDEV(this, errorInfo);
              "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
                "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
                getComponentNameFromFiber(fiber) || "Unknown"
              );
            });
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= 32768;
            isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
            if (null !== value && "object" === typeof value && "function" === typeof value.then) {
              returnFiber = sourceFiber.alternate;
              null !== returnFiber && propagateParentContextChanges(
                returnFiber,
                sourceFiber,
                rootRenderLanes,
                true
              );
              isHydrating && (didSuspendOrErrorDEV = true);
              sourceFiber = suspenseHandlerStackCursor.current;
              if (null !== sourceFiber) {
                switch (sourceFiber.tag) {
                  case 13:
                    return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                  case 22:
                    return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: /* @__PURE__ */ new Set([value])
                    }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
                }
                throw Error(
                  "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
                );
              }
              attachPingListener(root2, value, rootRenderLanes);
              renderDidSuspendDelayIfPossible();
              return false;
            }
            if (isHydrating)
              return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
                createCapturedValueAtFiber(
                  Error(
                    "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                    { cause: value }
                  ),
                  sourceFiber
                )
              )) : (value !== HydrationMismatchException && queueHydrationError(
                createCapturedValueAtFiber(
                  Error(
                    "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                    { cause: value }
                  ),
                  sourceFiber
                )
              ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
                root2.stateNode,
                value,
                rootRenderLanes
              ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
            var error = createCapturedValueAtFiber(
              Error(
                "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
                { cause: value }
              ),
              sourceFiber
            );
            null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
            workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
            if (null === returnFiber) return true;
            value = createCapturedValueAtFiber(value, sourceFiber);
            sourceFiber = returnFiber;
            do {
              switch (sourceFiber.tag) {
                case 3:
                  return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                    sourceFiber.stateNode,
                    value,
                    root2
                  ), enqueueCapturedUpdate(sourceFiber, root2), false;
                case 1:
                  if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                    return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                      rootRenderLanes,
                      root2,
                      sourceFiber,
                      value
                    ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
              }
              sourceFiber = sourceFiber.return;
            } while (null !== sourceFiber);
            return false;
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
              workInProgress2,
              current2.child,
              nextChildren,
              renderLanes2
            );
          }
          function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
            Component = Component.render;
            var ref = workInProgress2.ref;
            if ("ref" in nextProps) {
              var propsWithoutRef = {};
              for (var key in nextProps)
                "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
            } else propsWithoutRef = nextProps;
            prepareToReadContext(workInProgress2);
            markComponentRenderStarted(workInProgress2);
            nextProps = renderWithHooks(
              current2,
              workInProgress2,
              Component,
              propsWithoutRef,
              ref,
              renderLanes2
            );
            key = checkDidRenderIdHook();
            markComponentRenderStopped();
            if (null !== current2 && !didReceiveUpdate)
              return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            isHydrating && key && pushMaterializedTreeId(workInProgress2);
            workInProgress2.flags |= 1;
            reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            if (null === current2) {
              var type = Component.type;
              if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
                return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                  current2,
                  workInProgress2,
                  Component,
                  nextProps,
                  renderLanes2
                );
              current2 = createFiberFromTypeAndProps(
                Component.type,
                null,
                nextProps,
                workInProgress2,
                workInProgress2.mode,
                renderLanes2
              );
              current2.ref = workInProgress2.ref;
              current2.return = workInProgress2;
              return workInProgress2.child = current2;
            }
            type = current2.child;
            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
              var prevProps = type.memoizedProps;
              Component = Component.compare;
              Component = null !== Component ? Component : shallowEqual;
              if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
                return bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
            }
            workInProgress2.flags |= 1;
            current2 = createWorkInProgress(type, nextProps);
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            if (null !== current2) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
                if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                  0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
                else
                  return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            return updateFunctionComponent(
              current2,
              workInProgress2,
              Component,
              nextProps,
              renderLanes2
            );
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
            if ("hidden" === nextProps.mode) {
              if (0 !== (workInProgress2.flags & 128)) {
                nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
                if (null !== current2) {
                  nextChildren = workInProgress2.child = current2.child;
                  for (prevState = 0; null !== nextChildren; )
                    prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                  workInProgress2.childLanes = prevState & ~nextProps;
                } else workInProgress2.childLanes = 0, workInProgress2.child = null;
                return deferHiddenOffscreenComponent(
                  current2,
                  workInProgress2,
                  nextProps,
                  renderLanes2
                );
              }
              if (0 !== (renderLanes2 & 536870912))
                workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                  workInProgress2,
                  null !== prevState ? prevState.cachePool : null
                ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
              else
                return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                  current2,
                  workInProgress2,
                  null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                  renderLanes2
                );
            } else
              null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
            var JSCompiler_inline_result = peekCacheFromPool();
            JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
              parent: CacheContext._currentValue,
              pool: JSCompiler_inline_result
            };
            workInProgress2.memoizedState = {
              baseLanes: nextBaseLanes,
              cachePool: JSCompiler_inline_result
            };
            null !== current2 && pushTransition(workInProgress2, null);
            reuseHiddenContextOnStack(workInProgress2);
            pushOffscreenSuspenseHandler(workInProgress2);
            null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
            return null;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (null === ref)
              null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
            else {
              if ("function" !== typeof ref && "object" !== typeof ref)
                throw Error(
                  "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
                );
              if (null === current2 || current2.ref !== ref)
                workInProgress2.flags |= 4194816;
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            if (Component.prototype && "function" === typeof Component.prototype.render) {
              var componentName2 = getComponentNameFromType(Component) || "Unknown";
              didWarnAboutBadClass[componentName2] || (console.error(
                "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
                componentName2,
                componentName2
              ), didWarnAboutBadClass[componentName2] = true);
            }
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              null
            );
            null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
              componentName2
            ))));
            prepareToReadContext(workInProgress2);
            markComponentRenderStarted(workInProgress2);
            Component = renderWithHooks(
              current2,
              workInProgress2,
              Component,
              nextProps,
              void 0,
              renderLanes2
            );
            nextProps = checkDidRenderIdHook();
            markComponentRenderStopped();
            if (null !== current2 && !didReceiveUpdate)
              return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
            workInProgress2.flags |= 1;
            reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            return workInProgress2.child;
          }
          function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
            prepareToReadContext(workInProgress2);
            markComponentRenderStarted(workInProgress2);
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
            workInProgress2.updateQueue = null;
            nextProps = renderWithHooksAgain(
              workInProgress2,
              Component,
              nextProps,
              secondArg
            );
            finishRenderingHooks(current2, workInProgress2);
            Component = checkDidRenderIdHook();
            markComponentRenderStopped();
            if (null !== current2 && !didReceiveUpdate)
              return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            isHydrating && Component && pushMaterializedTreeId(workInProgress2);
            workInProgress2.flags |= 1;
            reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            switch (shouldErrorImpl(workInProgress2)) {
              case false:
                var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                  workInProgress2.memoizedProps,
                  _instance.context
                ).state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              case true:
                workInProgress2.flags |= 128;
                workInProgress2.flags |= 65536;
                _instance = Error("Simulated error coming from DevTools");
                var lane = renderLanes2 & -renderLanes2;
                workInProgress2.lanes |= lane;
                state = workInProgressRoot;
                if (null === state)
                  throw Error(
                    "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                  );
                lane = createClassErrorUpdate(lane);
                initializeClassErrorUpdate(
                  lane,
                  state,
                  workInProgress2,
                  createCapturedValueAtFiber(_instance, workInProgress2)
                );
                enqueueCapturedUpdate(workInProgress2, lane);
            }
            prepareToReadContext(workInProgress2);
            if (null === workInProgress2.stateNode) {
              state = emptyContextObject;
              _instance = Component.contextType;
              "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
                "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
                getComponentNameFromType(Component) || "Component",
                lane
              ));
              "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
              _instance = new Component(nextProps, state);
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  _instance = new Component(nextProps, state);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
              _instance.updater = classComponentUpdater;
              workInProgress2.stateNode = _instance;
              _instance._reactInternals = workInProgress2;
              _instance._reactInternalInstance = fakeInternalInstance;
              "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
                "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
                state,
                null === _instance.state ? "null" : "undefined",
                state
              )));
              if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
                var foundWillUpdateName = lane = state = null;
                "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
                "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
                "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
                if (null !== state || null !== lane || null !== foundWillUpdateName) {
                  _instance = getComponentNameFromType(Component) || "Component";
                  var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                    "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                    _instance,
                    newApiName,
                    null !== state ? "\n  " + state : "",
                    null !== lane ? "\n  " + lane : "",
                    null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                  ));
                }
              }
              _instance = workInProgress2.stateNode;
              state = getComponentNameFromType(Component) || "Component";
              _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
                "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
                state
              ) : console.error(
                "No `render` method found on the %s instance: you may have forgotten to define `render`.",
                state
              ));
              !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
                "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
                state
              );
              _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
                "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
                state
              );
              _instance.contextType && console.error(
                "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
                state
              );
              Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
                "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
                state
              ));
              Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
                "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
                state
              ));
              "function" === typeof _instance.componentShouldUpdate && console.error(
                "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
                state
              );
              Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
                "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
                getComponentNameFromType(Component) || "A pure component"
              );
              "function" === typeof _instance.componentDidUnmount && console.error(
                "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
                state
              );
              "function" === typeof _instance.componentDidReceiveProps && console.error(
                "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
                state
              );
              "function" === typeof _instance.componentWillRecieveProps && console.error(
                "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
                state
              );
              "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
                "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
                state
              );
              lane = _instance.props !== nextProps;
              void 0 !== _instance.props && lane && console.error(
                "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
                state
              );
              _instance.defaultProps && console.error(
                "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
                state,
                state
              );
              "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
                "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
                getComponentNameFromType(Component)
              ));
              "function" === typeof _instance.getDerivedStateFromProps && console.error(
                "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                state
              );
              "function" === typeof _instance.getDerivedStateFromError && console.error(
                "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
                state
              );
              "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
                "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
                state
              );
              (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
              "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
                "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
                state
              );
              _instance = workInProgress2.stateNode;
              _instance.props = nextProps;
              _instance.state = workInProgress2.memoizedState;
              _instance.refs = {};
              initializeUpdateQueue(workInProgress2);
              state = Component.contextType;
              _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
              _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
                "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
                state
              )));
              workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
                workInProgress2,
                _instance
              );
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
                workInProgress2,
                _instance
              );
              _instance.state = workInProgress2.memoizedState;
              state = Component.getDerivedStateFromProps;
              "function" === typeof state && (applyDerivedStateFromProps(
                workInProgress2,
                Component,
                state,
                nextProps
              ), _instance.state = workInProgress2.memoizedState);
              "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
                "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
                getComponentNameFromFiber(workInProgress2) || "Component"
              ), classComponentUpdater.enqueueReplaceState(
                _instance,
                _instance.state,
                null
              )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
              "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
              (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
              _instance = true;
            } else if (null === current2) {
              _instance = workInProgress2.stateNode;
              var unresolvedOldProps = workInProgress2.memoizedProps;
              lane = resolveClassComponentProps(Component, unresolvedOldProps);
              _instance.props = lane;
              var oldContext = _instance.context;
              foundWillUpdateName = Component.contextType;
              state = emptyContextObject;
              "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
              newApiName = Component.getDerivedStateFromProps;
              foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
              unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
              foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
                workInProgress2,
                _instance,
                nextProps,
                state
              );
              hasForceUpdate = false;
              var oldState = workInProgress2.memoizedState;
              _instance.state = oldState;
              processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
              suspendIfUpdateReadFromEntangledAsyncAction();
              oldContext = workInProgress2.memoizedState;
              unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
                workInProgress2,
                Component,
                newApiName,
                nextProps
              ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
                workInProgress2,
                Component,
                lane,
                nextProps,
                oldState,
                oldContext,
                state
              )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
            } else {
              _instance = workInProgress2.stateNode;
              cloneUpdateQueue(current2, workInProgress2);
              state = workInProgress2.memoizedProps;
              foundWillUpdateName = resolveClassComponentProps(Component, state);
              _instance.props = foundWillUpdateName;
              newApiName = workInProgress2.pendingProps;
              oldState = _instance.context;
              oldContext = Component.contextType;
              lane = emptyContextObject;
              "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
              unresolvedOldProps = Component.getDerivedStateFromProps;
              (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
                workInProgress2,
                _instance,
                nextProps,
                lane
              );
              hasForceUpdate = false;
              oldState = workInProgress2.memoizedState;
              _instance.state = oldState;
              processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
              suspendIfUpdateReadFromEntangledAsyncAction();
              var newState = workInProgress2.memoizedState;
              state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
                workInProgress2,
                Component,
                unresolvedOldProps,
                nextProps
              ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
                workInProgress2,
                Component,
                foundWillUpdateName,
                nextProps,
                oldState,
                newState,
                lane
              ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
                nextProps,
                newState,
                lane
              )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
            }
            lane = _instance;
            markRef(current2, workInProgress2);
            state = 0 !== (workInProgress2.flags & 128);
            if (lane || state) {
              lane = workInProgress2.stateNode;
              setCurrentFiber(workInProgress2);
              if (state && "function" !== typeof Component.getDerivedStateFromError)
                Component = null, profilerStartTime = -1;
              else {
                markComponentRenderStarted(workInProgress2);
                Component = callRenderInDEV(lane);
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    callRenderInDEV(lane);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                markComponentRenderStopped();
              }
              workInProgress2.flags |= 1;
              null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                current2.child,
                null,
                renderLanes2
              ), workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                Component,
                renderLanes2
              )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
              workInProgress2.memoizedState = lane.state;
              current2 = workInProgress2.child;
            } else
              current2 = bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
            renderLanes2 = workInProgress2.stateNode;
            _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
              "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
              getComponentNameFromFiber(workInProgress2) || "a component"
            ), didWarnAboutReassigningProps = true);
            return current2;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
            resetHydrationState();
            workInProgress2.flags |= 256;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function validateFunctionComponentInDev(workInProgress2, Component) {
            Component && Component.childContextTypes && console.error(
              "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
              Component.displayName || Component.name || "Component"
            );
            "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
              "%s: Function components do not support getDerivedStateFromProps.",
              workInProgress2
            ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
            "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
              "%s: Function components do not support contextType.",
              Component
            ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
          }
          function mountSuspenseOffscreenState(renderLanes2) {
            return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
          }
          function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
            current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
            primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
            return current2;
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var JSCompiler_object_inline_digest_2451;
            var JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
            shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
            var JSCompiler_object_inline_componentStack_2453 = false;
            var didSuspend = 0 !== (workInProgress2.flags & 128);
            (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
            JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
            JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress2.flags & 32);
            workInProgress2.flags &= -33;
            if (null === current2) {
              if (isHydrating) {
                JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
                if (isHydrating) {
                  var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
                  var JSCompiler_temp;
                  if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
                    c: {
                      var instance = JSCompiler_object_inline_message_2450;
                      for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
                        if (!JSCompiler_temp) {
                          JSCompiler_temp = null;
                          break c;
                        }
                        instance = getNextHydratable(instance.nextSibling);
                        if (null === instance) {
                          JSCompiler_temp = null;
                          break c;
                        }
                      }
                      JSCompiler_temp = instance;
                    }
                    null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                      dehydrated: JSCompiler_temp,
                      treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                      retryLane: 536870912,
                      hydrationErrors: null
                    }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
                    JSCompiler_temp = !JSCompiler_temp;
                  }
                  JSCompiler_temp && (warnNonHydratedInstance(
                    workInProgress2,
                    JSCompiler_object_inline_message_2450
                  ), throwOnHydrationMismatch(workInProgress2));
                }
                JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
                if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450))
                  return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
                popSuspenseHandler(workInProgress2);
              }
              JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
              JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
              if (JSCompiler_object_inline_componentStack_2453)
                return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "hidden",
                    children: JSCompiler_object_inline_message_2450
                  },
                  JSCompiler_object_inline_componentStack_2453
                ), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
                  JSCompiler_object_inline_stack_2452,
                  JSCompiler_object_inline_componentStack_2453,
                  renderLanes2,
                  null
                ), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2451,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              return mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_message_2450
              );
            }
            var prevState = current2.memoizedState;
            if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
              if (didSuspend)
                workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber(
                  {
                    mode: "visible",
                    children: JSCompiler_object_inline_stack_2452.children
                  },
                  JSCompiler_object_inline_message_2450
                ), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
                  JSCompiler_object_inline_componentStack_2453,
                  JSCompiler_object_inline_message_2450,
                  renderLanes2,
                  null
                ), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(
                  workInProgress2,
                  current2.child,
                  null,
                  renderLanes2
                ), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(
                  current2,
                  JSCompiler_object_inline_digest_2451,
                  renderLanes2
                ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453);
              else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
                "We should not be hydrating here. This is a bug in React. Please file a bug."
              ), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
                JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
                if (JSCompiler_object_inline_digest_2451) {
                  JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
                  var message = JSCompiler_object_inline_digest_2451.msg;
                  instance = JSCompiler_object_inline_digest_2451.stck;
                  var componentStack = JSCompiler_object_inline_digest_2451.cstck;
                }
                JSCompiler_object_inline_message_2450 = message;
                JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
                JSCompiler_object_inline_stack_2452 = instance;
                JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
                JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error(
                  "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
                );
                JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
                JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
                JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
                JSCompiler_object_inline_stack_2452 = {
                  value: JSCompiler_object_inline_componentStack_2453,
                  source: null,
                  stack: JSCompiler_object_inline_digest_2451
                };
                "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(
                  JSCompiler_object_inline_componentStack_2453,
                  JSCompiler_object_inline_stack_2452
                );
                queueHydrationError(JSCompiler_object_inline_stack_2452);
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else if (didReceiveUpdate || propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
                JSCompiler_object_inline_digest_2451 = workInProgressRoot;
                if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(
                  JSCompiler_object_inline_stack_2452
                ), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(
                    current2,
                    JSCompiler_object_inline_stack_2452
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2451,
                    current2,
                    JSCompiler_object_inline_stack_2452
                  ), SelectiveHydrationException;
                JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
                workInProgress2 = retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              } else
                JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                  JSCompiler_object_inline_message_2450.nextSibling
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                  workInProgress2,
                  JSCompiler_object_inline_stack_2452.children
                ), workInProgress2.flags |= 4096);
              return workInProgress2;
            }
            if (JSCompiler_object_inline_componentStack_2453)
              return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(
                JSCompiler_temp,
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_stack_2452.children
                }
              ), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(
                instance,
                JSCompiler_object_inline_componentStack_2453
              ) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_message_2450,
                renderLanes2,
                null
              ), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
                baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
                cachePool: JSCompiler_temp
              }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            renderLanes2 = current2.child;
            current2 = renderLanes2.sibling;
            renderLanes2 = createWorkInProgress(renderLanes2, {
              mode: "visible",
              children: JSCompiler_object_inline_stack_2452.children
            });
            renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
            null !== current2 && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
            workInProgress2.child = renderLanes2;
            workInProgress2.memoizedState = null;
            return renderLanes2;
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
            primaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: primaryChildren },
              workInProgress2.mode
            );
            primaryChildren.return = workInProgress2;
            return workInProgress2.child = primaryChildren;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
            offscreenProps = createFiber(22, offscreenProps, null, mode);
            offscreenProps.lanes = 0;
            offscreenProps.stateNode = {
              _visibility: OffscreenVisible,
              _pendingMarkers: null,
              _retryCache: null,
              _transitions: null
            };
            return offscreenProps;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            current2 = mountSuspensePrimaryChildren(
              workInProgress2,
              workInProgress2.pendingProps.children
            );
            current2.flags |= 2;
            workInProgress2.memoizedState = null;
            return current2;
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes |= renderLanes2;
            var alternate = fiber.alternate;
            null !== alternate && (alternate.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(
              fiber.return,
              renderLanes2,
              propagationRoot
            );
          }
          function validateSuspenseListNestedChild(childSlot, index) {
            var isAnArray = isArrayImpl(childSlot);
            childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
            return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
              "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
              isAnArray,
              index,
              isAnArray
            ), false) : true;
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            null === renderState ? workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
            nextProps = nextProps.children;
            if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
              if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards":
                    console.error(
                      '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                      revealOrder,
                      revealOrder.toLowerCase()
                    );
                    break;
                  case "forward":
                  case "backward":
                    console.error(
                      '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                      revealOrder,
                      revealOrder.toLowerCase()
                    );
                    break;
                  default:
                    console.error(
                      '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                      revealOrder
                    );
                }
              else
                console.error(
                  '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                  revealOrder
                );
            void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
              '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
              tailMode
            )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
              '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
              tailMode
            )));
            a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
              if (isArrayImpl(nextProps))
                for (var i2 = 0; i2 < nextProps.length; i2++) {
                  if (!validateSuspenseListNestedChild(nextProps[i2], i2)) break a;
                }
              else if (i2 = getIteratorFn(nextProps), "function" === typeof i2) {
                if (i2 = i2.call(nextProps))
                  for (var step = i2.next(), _i = 0; !step.done; step = i2.next()) {
                    if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                    _i++;
                  }
              } else
                console.error(
                  'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                  revealOrder
                );
            reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
            nextProps = suspenseStackCursor.current;
            if (0 !== (nextProps & ForceSuspenseFallback))
              nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
            else {
              if (null !== current2 && 0 !== (current2.flags & 128))
                a: for (current2 = workInProgress2.child; null !== current2; ) {
                  if (13 === current2.tag)
                    null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
                      current2,
                      renderLanes2,
                      workInProgress2
                    );
                  else if (19 === current2.tag)
                    scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
                  else if (null !== current2.child) {
                    current2.child.return = current2;
                    current2 = current2.child;
                    continue;
                  }
                  if (current2 === workInProgress2) break a;
                  for (; null === current2.sibling; ) {
                    if (null === current2.return || current2.return === workInProgress2)
                      break a;
                    current2 = current2.return;
                  }
                  current2.sibling.return = current2.return;
                  current2 = current2.sibling;
                }
              nextProps &= SubtreeSuspenseContextMask;
            }
            push(suspenseStackCursor, nextProps, workInProgress2);
            switch (revealOrder) {
              case "forwards":
                renderLanes2 = workInProgress2.child;
                for (revealOrder = null; null !== renderLanes2; )
                  current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
                renderLanes2 = revealOrder;
                null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  revealOrder,
                  renderLanes2,
                  tailMode
                );
                break;
              case "backwards":
                renderLanes2 = null;
                revealOrder = workInProgress2.child;
                for (workInProgress2.child = null; null !== revealOrder; ) {
                  current2 = revealOrder.alternate;
                  if (null !== current2 && null === findFirstSuspended(current2)) {
                    workInProgress2.child = revealOrder;
                    break;
                  }
                  current2 = revealOrder.sibling;
                  revealOrder.sibling = renderLanes2;
                  renderLanes2 = revealOrder;
                  revealOrder = current2;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  renderLanes2,
                  null,
                  tailMode
                );
                break;
              case "together":
                initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
                break;
              default:
                workInProgress2.memoizedState = null;
            }
            return workInProgress2.child;
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            null !== current2 && (workInProgress2.dependencies = current2.dependencies);
            profilerStartTime = -1;
            workInProgressRootSkippedLanes |= workInProgress2.lanes;
            if (0 === (renderLanes2 & workInProgress2.childLanes))
              if (null !== current2) {
                if (propagateParentContextChanges(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  false
                ), 0 === (renderLanes2 & workInProgress2.childLanes))
                  return null;
              } else return null;
            if (null !== current2 && workInProgress2.child !== current2.child)
              throw Error("Resuming work not yet implemented.");
            if (null !== workInProgress2.child) {
              current2 = workInProgress2.child;
              renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
              workInProgress2.child = renderLanes2;
              for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
                current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
              renderLanes2.sibling = null;
            }
            return workInProgress2.child;
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            if (0 !== (current2.lanes & renderLanes2)) return true;
            current2 = current2.dependencies;
            return null !== current2 && checkIfContextChanged(current2) ? true : false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case 3:
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                pushProvider(
                  workInProgress2,
                  CacheContext,
                  current2.memoizedState.cache
                );
                resetHydrationState();
                break;
              case 27:
              case 5:
                pushHostContext(workInProgress2);
                break;
              case 4:
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                break;
              case 10:
                pushProvider(
                  workInProgress2,
                  workInProgress2.type,
                  workInProgress2.memoizedProps.value
                );
                break;
              case 12:
                0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
                workInProgress2.flags |= 2048;
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = -0;
                stateNode.passiveEffectDuration = -0;
                break;
              case 13:
                stateNode = workInProgress2.memoizedState;
                if (null !== stateNode) {
                  if (null !== stateNode.dehydrated)
                    return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                  if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                    return updateSuspenseComponent(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                  pushPrimaryTreeSuspenseHandler(workInProgress2);
                  current2 = bailoutOnAlreadyFinishedWork(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                  return null !== current2 ? current2.sibling : null;
                }
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                break;
              case 19:
                var didSuspendBefore = 0 !== (current2.flags & 128);
                stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
                stateNode || (propagateParentContextChanges(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  false
                ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
                if (didSuspendBefore) {
                  if (stateNode)
                    return updateSuspenseListComponent(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                  workInProgress2.flags |= 128;
                }
                didSuspendBefore = workInProgress2.memoizedState;
                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
                push(
                  suspenseStackCursor,
                  suspenseStackCursor.current,
                  workInProgress2
                );
                if (stateNode) break;
                else return null;
              case 22:
              case 23:
                return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              case 24:
                pushProvider(
                  workInProgress2,
                  CacheContext,
                  current2.memoizedState.cache
                );
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            if (workInProgress2._debugNeedsRemount && null !== current2) {
              renderLanes2 = createFiberFromTypeAndProps(
                workInProgress2.type,
                workInProgress2.key,
                workInProgress2.pendingProps,
                workInProgress2._debugOwner || null,
                workInProgress2.mode,
                workInProgress2.lanes
              );
              renderLanes2._debugStack = workInProgress2._debugStack;
              renderLanes2._debugTask = workInProgress2._debugTask;
              var returnFiber = workInProgress2.return;
              if (null === returnFiber) throw Error("Cannot swap the root fiber.");
              current2.alternate = null;
              workInProgress2.alternate = null;
              renderLanes2.index = workInProgress2.index;
              renderLanes2.sibling = workInProgress2.sibling;
              renderLanes2.return = workInProgress2.return;
              renderLanes2.ref = workInProgress2.ref;
              renderLanes2._debugInfo = workInProgress2._debugInfo;
              if (workInProgress2 === returnFiber.child)
                returnFiber.child = renderLanes2;
              else {
                var prevSibling = returnFiber.child;
                if (null === prevSibling)
                  throw Error("Expected parent to have a child.");
                for (; prevSibling.sibling !== workInProgress2; )
                  if (prevSibling = prevSibling.sibling, null === prevSibling)
                    throw Error("Expected to find the previous sibling.");
                prevSibling.sibling = renderLanes2;
              }
              workInProgress2 = returnFiber.deletions;
              null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
              renderLanes2.flags |= 2;
              return renderLanes2;
            }
            if (null !== current2)
              if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
                didReceiveUpdate = true;
              else {
                if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                  return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
              }
            else {
              didReceiveUpdate = false;
              if (returnFiber = isHydrating)
                warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
              returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
            }
            workInProgress2.lanes = 0;
            switch (workInProgress2.tag) {
              case 16:
                a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                  shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                    current2,
                    returnFiber
                  ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                    null,
                    workInProgress2,
                    current2,
                    returnFiber,
                    renderLanes2
                  ));
                else {
                  if (void 0 !== current2 && null !== current2) {
                    if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                      workInProgress2.tag = 11;
                      workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                      workInProgress2 = updateForwardRef(
                        null,
                        workInProgress2,
                        current2,
                        returnFiber,
                        renderLanes2
                      );
                      break a;
                    } else if (prevSibling === REACT_MEMO_TYPE) {
                      workInProgress2.tag = 14;
                      workInProgress2 = updateMemoComponent(
                        null,
                        workInProgress2,
                        current2,
                        returnFiber,
                        renderLanes2
                      );
                      break a;
                    }
                  }
                  workInProgress2 = "";
                  null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                  current2 = getComponentNameFromType(current2) || current2;
                  throw Error(
                    "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                  );
                }
                return workInProgress2;
              case 0:
                return updateFunctionComponent(
                  current2,
                  workInProgress2,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  renderLanes2
                );
              case 1:
                return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                  returnFiber,
                  workInProgress2.pendingProps
                ), updateClassComponent(
                  current2,
                  workInProgress2,
                  returnFiber,
                  prevSibling,
                  renderLanes2
                );
              case 3:
                a: {
                  pushHostContainer(
                    workInProgress2,
                    workInProgress2.stateNode.containerInfo
                  );
                  if (null === current2)
                    throw Error(
                      "Should have a current fiber. This is a bug in React."
                    );
                  returnFiber = workInProgress2.pendingProps;
                  var prevState = workInProgress2.memoizedState;
                  prevSibling = prevState.element;
                  cloneUpdateQueue(current2, workInProgress2);
                  processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                  var nextState = workInProgress2.memoizedState;
                  returnFiber = nextState.cache;
                  pushProvider(workInProgress2, CacheContext, returnFiber);
                  returnFiber !== prevState.cache && propagateContextChanges(
                    workInProgress2,
                    [CacheContext],
                    renderLanes2,
                    true
                  );
                  suspendIfUpdateReadFromEntangledAsyncAction();
                  returnFiber = nextState.element;
                  if (prevState.isDehydrated)
                    if (prevState = {
                      element: returnFiber,
                      isDehydrated: false,
                      cache: nextState.cache
                    }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                      workInProgress2 = mountHostRootWithoutHydrating(
                        current2,
                        workInProgress2,
                        returnFiber,
                        renderLanes2
                      );
                      break a;
                    } else if (returnFiber !== prevSibling) {
                      prevSibling = createCapturedValueAtFiber(
                        Error(
                          "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                        ),
                        workInProgress2
                      );
                      queueHydrationError(prevSibling);
                      workInProgress2 = mountHostRootWithoutHydrating(
                        current2,
                        workInProgress2,
                        returnFiber,
                        renderLanes2
                      );
                      break a;
                    } else {
                      current2 = workInProgress2.stateNode.containerInfo;
                      switch (current2.nodeType) {
                        case 9:
                          current2 = current2.body;
                          break;
                        default:
                          current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                      }
                      nextHydratableInstance = getNextHydratable(current2.firstChild);
                      hydrationParentFiber = workInProgress2;
                      isHydrating = true;
                      hydrationErrors = null;
                      didSuspendOrErrorDEV = false;
                      hydrationDiffRootDEV = null;
                      rootOrSingletonContext = true;
                      current2 = mountChildFibers(
                        workInProgress2,
                        null,
                        returnFiber,
                        renderLanes2
                      );
                      for (workInProgress2.child = current2; current2; )
                        current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
                    }
                  else {
                    resetHydrationState();
                    if (returnFiber === prevSibling) {
                      workInProgress2 = bailoutOnAlreadyFinishedWork(
                        current2,
                        workInProgress2,
                        renderLanes2
                      );
                      break a;
                    }
                    reconcileChildren(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                  }
                  workInProgress2 = workInProgress2.child;
                }
                return workInProgress2;
              case 26:
                return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
                  workInProgress2.type,
                  null,
                  workInProgress2.pendingProps,
                  null
                )) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                  rootInstanceStackCursor.current
                ), returnFiber = getOwnerDocumentFromRootContainer(
                  returnFiber
                ).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                  workInProgress2.type,
                  current2.memoizedProps,
                  workInProgress2.pendingProps,
                  current2.memoizedState
                ), null;
              case 27:
                return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  returnFiber,
                  prevSibling,
                  false
                ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                  returnFiber,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  prevSibling
                ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                  returnFiber.firstChild
                )) : nextHydratableInstance = prevSibling), reconcileChildren(
                  current2,
                  workInProgress2,
                  workInProgress2.pendingProps.children,
                  renderLanes2
                ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
              case 5:
                return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                  workInProgress2.type,
                  prevState.ancestorInfo
                ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                  prevSibling,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                  nextState,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  prevState
                ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  nextState.firstChild
                ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                  current2,
                  workInProgress2,
                  TransitionAwareHostComponent,
                  null,
                  null,
                  renderLanes2
                ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                  current2,
                  workInProgress2,
                  returnFiber,
                  renderLanes2
                ), workInProgress2.child;
              case 6:
                return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = null != returnFiber ? validateTextNesting(
                  current2,
                  returnFiber.tag,
                  renderLanes2.ancestorInfo.implicitRootScope
                ) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
              case 13:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case 4:
                return pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                  workInProgress2,
                  null,
                  returnFiber,
                  renderLanes2
                ) : reconcileChildren(
                  current2,
                  workInProgress2,
                  returnFiber,
                  renderLanes2
                ), workInProgress2.child;
              case 11:
                return updateForwardRef(
                  current2,
                  workInProgress2,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  renderLanes2
                );
              case 7:
                return reconcileChildren(
                  current2,
                  workInProgress2,
                  workInProgress2.pendingProps,
                  renderLanes2
                ), workInProgress2.child;
              case 8:
                return reconcileChildren(
                  current2,
                  workInProgress2,
                  workInProgress2.pendingProps.children,
                  renderLanes2
                ), workInProgress2.child;
              case 12:
                return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                  current2,
                  workInProgress2,
                  workInProgress2.pendingProps.children,
                  renderLanes2
                ), workInProgress2.child;
              case 10:
                return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                  "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
                )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                  current2,
                  workInProgress2,
                  prevSibling.children,
                  renderLanes2
                ), workInProgress2.child;
              case 9:
                return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                  "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
                ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
                  returnFiber,
                  prevSibling,
                  void 0
                ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
                  current2,
                  workInProgress2,
                  returnFiber,
                  renderLanes2
                ), workInProgress2.child;
              case 14:
                return updateMemoComponent(
                  current2,
                  workInProgress2,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  renderLanes2
                );
              case 15:
                return updateSimpleMemoComponent(
                  current2,
                  workInProgress2,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  renderLanes2
                );
              case 19:
                return updateSuspenseListComponent(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              case 31:
                return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
                  mode: returnFiber.mode,
                  children: returnFiber.children
                }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
                  returnFiber,
                  renderLanes2
                ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
              case 22:
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              case 24:
                return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                  parent: returnFiber,
                  cache: prevSibling
                }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                  parent: returnFiber,
                  cache: returnFiber
                }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                ))), reconcileChildren(
                  current2,
                  workInProgress2,
                  workInProgress2.pendingProps.children,
                  renderLanes2
                ), workInProgress2.child;
              case 29:
                throw workInProgress2.pendingProps;
            }
            throw Error(
              "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
            );
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= 4;
          }
          function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
            if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
              workInProgress2.flags &= -16777217;
            else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
              resource = suspenseHandlerStackCursor.current;
              if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
                throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
              workInProgress2.flags |= 8192;
            }
          }
          function scheduleRetryEffect(workInProgress2, retryQueue) {
            null !== retryQueue && (workInProgress2.flags |= 4);
            workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (!isHydrating)
              switch (renderState.tailMode) {
                case "hidden":
                  hasRenderedATailFallback = renderState.tail;
                  for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                    null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                  null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                  break;
                case "collapsed":
                  lastTailNode = renderState.tail;
                  for (var _lastTailNode = null; null !== lastTailNode; )
                    null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                  null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
              }
          }
          function bubbleProperties(completedWork) {
            var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
            if (didBailout)
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                  newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else
                for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                  newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
            else if ((completedWork.mode & ProfileMode) !== NoMode) {
              _treeBaseDuration = completedWork.actualDuration;
              _child2 = completedWork.selfBaseDuration;
              for (var child = completedWork.child; null !== child; )
                newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
              completedWork.actualDuration = _treeBaseDuration;
              completedWork.treeBaseDuration = _child2;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
            completedWork.subtreeFlags |= subtreeFlags;
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case 31:
              case 16:
              case 15:
              case 0:
              case 11:
              case 7:
              case 8:
              case 12:
              case 9:
              case 14:
                return bubbleProperties(workInProgress2), null;
              case 1:
                return bubbleProperties(workInProgress2), null;
              case 3:
                renderLanes2 = workInProgress2.stateNode;
                newProps = null;
                null !== current2 && (newProps = current2.memoizedState.cache);
                workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
                popProvider(CacheContext, workInProgress2);
                popHostContainer(workInProgress2);
                renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
                if (null === current2 || null === current2.child)
                  popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
                bubbleProperties(workInProgress2);
                return null;
              case 26:
                return renderLanes2 = workInProgress2.memoizedState, null === current2 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                  workInProgress2,
                  renderLanes2
                )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                  workInProgress2,
                  renderLanes2
                )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
              case 27:
                popHostContext(workInProgress2);
                renderLanes2 = requiredContext(rootInstanceStackCursor.current);
                var _type = workInProgress2.type;
                if (null !== current2 && null != workInProgress2.stateNode)
                  current2.memoizedProps !== newProps && markUpdate(workInProgress2);
                else {
                  if (!newProps) {
                    if (null === workInProgress2.stateNode)
                      throw Error(
                        "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                      );
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  current2 = getHostContext();
                  popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                    _type,
                    newProps,
                    renderLanes2,
                    current2,
                    true
                  ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
                }
                bubbleProperties(workInProgress2);
                return null;
              case 5:
                popHostContext(workInProgress2);
                renderLanes2 = workInProgress2.type;
                if (null !== current2 && null != workInProgress2.stateNode)
                  current2.memoizedProps !== newProps && markUpdate(workInProgress2);
                else {
                  if (!newProps) {
                    if (null === workInProgress2.stateNode)
                      throw Error(
                        "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                      );
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  _type = getHostContext();
                  if (popHydrationState(workInProgress2))
                    prepareToHydrateHostInstance(workInProgress2, _type);
                  else {
                    current2 = requiredContext(rootInstanceStackCursor.current);
                    validateDOMNesting(renderLanes2, _type.ancestorInfo);
                    _type = _type.context;
                    current2 = getOwnerDocumentFromRootContainer(current2);
                    switch (_type) {
                      case HostContextNamespaceSvg:
                        current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                        break;
                      case HostContextNamespaceMath:
                        current2 = current2.createElementNS(
                          MATH_NAMESPACE,
                          renderLanes2
                        );
                        break;
                      default:
                        switch (renderLanes2) {
                          case "svg":
                            current2 = current2.createElementNS(
                              SVG_NAMESPACE,
                              renderLanes2
                            );
                            break;
                          case "math":
                            current2 = current2.createElementNS(
                              MATH_NAMESPACE,
                              renderLanes2
                            );
                            break;
                          case "script":
                            current2 = current2.createElement("div");
                            current2.innerHTML = "<script><\/script>";
                            current2 = current2.removeChild(current2.firstChild);
                            break;
                          case "select":
                            current2 = "string" === typeof newProps.is ? current2.createElement("select", { is: newProps.is }) : current2.createElement("select");
                            newProps.multiple ? current2.multiple = true : newProps.size && (current2.size = newProps.size);
                            break;
                          default:
                            current2 = "string" === typeof newProps.is ? current2.createElement(renderLanes2, {
                              is: newProps.is
                            }) : current2.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
                              "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                              renderLanes2
                            ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current2) || hasOwnProperty.call(
                              warnedUnknownTags,
                              renderLanes2
                            ) || (warnedUnknownTags[renderLanes2] = true, console.error(
                              "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                              renderLanes2
                            )));
                        }
                    }
                    current2[internalInstanceKey] = workInProgress2;
                    current2[internalPropsKey] = newProps;
                    a: for (_type = workInProgress2.child; null !== _type; ) {
                      if (5 === _type.tag || 6 === _type.tag)
                        current2.appendChild(_type.stateNode);
                      else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                        _type.child.return = _type;
                        _type = _type.child;
                        continue;
                      }
                      if (_type === workInProgress2) break a;
                      for (; null === _type.sibling; ) {
                        if (null === _type.return || _type.return === workInProgress2)
                          break a;
                        _type = _type.return;
                      }
                      _type.sibling.return = _type.return;
                      _type = _type.sibling;
                    }
                    workInProgress2.stateNode = current2;
                    a: switch (setInitialProperties(current2, renderLanes2, newProps), renderLanes2) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        current2 = !!newProps.autoFocus;
                        break a;
                      case "img":
                        current2 = true;
                        break a;
                      default:
                        current2 = false;
                    }
                    current2 && markUpdate(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                workInProgress2.flags &= -16777217;
                return null;
              case 6:
                if (current2 && null != workInProgress2.stateNode)
                  current2.memoizedProps !== newProps && markUpdate(workInProgress2);
                else {
                  if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  current2 = requiredContext(rootInstanceStackCursor.current);
                  renderLanes2 = getHostContext();
                  if (popHydrationState(workInProgress2)) {
                    current2 = workInProgress2.stateNode;
                    renderLanes2 = workInProgress2.memoizedProps;
                    _type = !didSuspendOrErrorDEV;
                    newProps = null;
                    var returnFiber = hydrationParentFiber;
                    if (null !== returnFiber)
                      switch (returnFiber.tag) {
                        case 3:
                          _type && (_type = diffHydratedTextForDevWarnings(
                            current2,
                            renderLanes2,
                            newProps
                          ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                          break;
                        case 27:
                        case 5:
                          newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
                            current2,
                            renderLanes2,
                            newProps
                          ), null !== _type && (buildHydrationDiffNode(
                            workInProgress2,
                            0
                          ).serverProps = _type));
                      }
                    current2[internalInstanceKey] = workInProgress2;
                    current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                    current2 || throwOnHydrationMismatch(workInProgress2);
                  } else
                    _type = renderLanes2.ancestorInfo.current, null != _type && validateTextNesting(
                      newProps,
                      _type.tag,
                      renderLanes2.ancestorInfo.implicitRootScope
                    ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                      newProps
                    ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
                }
                bubbleProperties(workInProgress2);
                return null;
              case 13:
                newProps = workInProgress2.memoizedState;
                if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                  _type = popHydrationState(workInProgress2);
                  if (null !== newProps && null !== newProps.dehydrated) {
                    if (null === current2) {
                      if (!_type)
                        throw Error(
                          "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                        );
                      _type = workInProgress2.memoizedState;
                      _type = null !== _type ? _type.dehydrated : null;
                      if (!_type)
                        throw Error(
                          "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                        );
                      _type[internalInstanceKey] = workInProgress2;
                      bubbleProperties(workInProgress2);
                      (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                    } else
                      emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                    _type = false;
                  } else
                    _type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = _type), _type = true;
                  if (!_type) {
                    if (workInProgress2.flags & 256)
                      return popSuspenseHandler(workInProgress2), workInProgress2;
                    popSuspenseHandler(workInProgress2);
                    return null;
                  }
                }
                popSuspenseHandler(workInProgress2);
                if (0 !== (workInProgress2.flags & 128))
                  return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
                renderLanes2 = null !== newProps;
                current2 = null !== current2 && null !== current2.memoizedState;
                renderLanes2 && (newProps = workInProgress2.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
                renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
                scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
                return null;
              case 4:
                return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                  workInProgress2.stateNode.containerInfo
                ), bubbleProperties(workInProgress2), null;
              case 10:
                return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
              case 19:
                pop(suspenseStackCursor, workInProgress2);
                _type = workInProgress2.memoizedState;
                if (null === _type) return bubbleProperties(workInProgress2), null;
                newProps = 0 !== (workInProgress2.flags & 128);
                returnFiber = _type.rendering;
                if (null === returnFiber)
                  if (newProps) cutOffTailIfNeeded(_type, false);
                  else {
                    if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                      for (current2 = workInProgress2.child; null !== current2; ) {
                        returnFiber = findFirstSuspended(current2);
                        if (null !== returnFiber) {
                          workInProgress2.flags |= 128;
                          cutOffTailIfNeeded(_type, false);
                          current2 = returnFiber.updateQueue;
                          workInProgress2.updateQueue = current2;
                          scheduleRetryEffect(workInProgress2, current2);
                          workInProgress2.subtreeFlags = 0;
                          current2 = renderLanes2;
                          for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                            resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                          push(
                            suspenseStackCursor,
                            suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                            workInProgress2
                          );
                          return workInProgress2.child;
                        }
                        current2 = current2.sibling;
                      }
                    null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                  }
                else {
                  if (!newProps)
                    if (current2 = findFirstSuspended(returnFiber), null !== current2) {
                      if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
                        return bubbleProperties(workInProgress2), null;
                    } else
                      2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                  _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
                }
                if (null !== _type.tail)
                  return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
                bubbleProperties(workInProgress2);
                return null;
              case 22:
              case 23:
                return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
              case 24:
                return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
              case 25:
                return null;
              case 30:
                return null;
            }
            throw Error(
              "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
            );
          }
          function unwindWork(current2, workInProgress2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case 1:
                return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
              case 3:
                return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
              case 26:
              case 27:
              case 5:
                return popHostContext(workInProgress2), null;
              case 13:
                popSuspenseHandler(workInProgress2);
                current2 = workInProgress2.memoizedState;
                if (null !== current2 && null !== current2.dehydrated) {
                  if (null === workInProgress2.alternate)
                    throw Error(
                      "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                    );
                  resetHydrationState();
                }
                current2 = workInProgress2.flags;
                return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
              case 19:
                return pop(suspenseStackCursor, workInProgress2), null;
              case 4:
                return popHostContainer(workInProgress2), null;
              case 10:
                return popProvider(workInProgress2.type, workInProgress2), null;
              case 22:
              case 23:
                return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
              case 24:
                return popProvider(CacheContext, workInProgress2), null;
              case 25:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case 3:
                popProvider(CacheContext, interruptedWork);
                popHostContainer(interruptedWork);
                break;
              case 26:
              case 27:
              case 5:
                popHostContext(interruptedWork);
                break;
              case 4:
                popHostContainer(interruptedWork);
                break;
              case 13:
                popSuspenseHandler(interruptedWork);
                break;
              case 19:
                pop(suspenseStackCursor, interruptedWork);
                break;
              case 10:
                popProvider(interruptedWork.type, interruptedWork);
                break;
              case 22:
              case 23:
                popSuspenseHandler(interruptedWork);
                popHiddenContext(interruptedWork);
                null !== current2 && pop(resumedCache, interruptedWork);
                break;
              case 24:
                popProvider(CacheContext, interruptedWork);
            }
          }
          function shouldProfile(current2) {
            return (current2.mode & ProfileMode) !== NoMode;
          }
          function commitHookLayoutEffects(finishedWork, hookFlags) {
            shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
          }
          function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
            shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
              hookFlags,
              finishedWork,
              nearestMountedAncestor
            ), recordEffectDuration()) : commitHookEffectListUnmount(
              hookFlags,
              finishedWork,
              nearestMountedAncestor
            );
          }
          function commitHookEffectListMount(flags, finishedWork) {
            try {
              var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
              if (null !== lastEffect) {
                var firstEffect = lastEffect.next;
                updateQueue = firstEffect;
                do {
                  if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                    finishedWork
                  ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                    finishedWork
                  ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                    finishedWork,
                    callCreateInDEV,
                    updateQueue
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                    var hookName = void 0;
                    hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                    var addendum = void 0;
                    addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                    runWithFiberInDEV(
                      finishedWork,
                      function(n, a) {
                        console.error(
                          "%s must not return anything besides a function, which is used for clean-up.%s",
                          n,
                          a
                        );
                      },
                      hookName,
                      addendum
                    );
                  }
                  updateQueue = updateQueue.next;
                } while (updateQueue !== firstEffect);
              }
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            try {
              var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
              if (null !== lastEffect) {
                var firstEffect = lastEffect.next;
                updateQueue = firstEffect;
                do {
                  if ((updateQueue.tag & flags) === flags) {
                    var inst = updateQueue.inst, destroy = inst.destroy;
                    void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                      finishedWork
                    ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                      finishedWork
                    ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                      lastEffect,
                      callDestroyInDEV,
                      lastEffect,
                      nearestMountedAncestor,
                      destroy
                    ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                  }
                  updateQueue = updateQueue.next;
                } while (updateQueue !== firstEffect);
              }
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function commitHookPassiveMountEffects(finishedWork, hookFlags) {
            shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
          }
          function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
            shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
              hookFlags,
              finishedWork,
              nearestMountedAncestor
            ), recordEffectDuration()) : commitHookEffectListUnmount(
              hookFlags,
              finishedWork,
              nearestMountedAncestor
            );
          }
          function commitClassCallbacks(finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            if (null !== updateQueue) {
              var instance = finishedWork.stateNode;
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
                "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                getComponentNameFromFiber(finishedWork) || "instance"
              ), instance.state !== finishedWork.memoizedState && console.error(
                "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                getComponentNameFromFiber(finishedWork) || "instance"
              ));
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitCallbacks,
                  updateQueue,
                  instance
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
            return instance.getSnapshotBeforeUpdate(prevProps, prevState);
          }
          function commitClassSnapshot(finishedWork, current2) {
            var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
            current2 = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), current2.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              var resolvedPrevProps = resolveClassComponentProps(
                finishedWork.type,
                prevProps,
                finishedWork.elementType === finishedWork.type
              );
              var snapshot = runWithFiberInDEV(
                finishedWork,
                callGetSnapshotBeforeUpdates,
                current2,
                resolvedPrevProps,
                prevState
              );
              prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
              void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
                console.error(
                  "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                  getComponentNameFromFiber(finishedWork)
                );
              }));
              current2.__reactInternalSnapshotBeforeUpdate = snapshot;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            instance.props = resolveClassComponentProps(
              current2.type,
              current2.memoizedProps
            );
            instance.state = current2.memoizedState;
            shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
              current2,
              callComponentWillUnmountInDEV,
              current2,
              nearestMountedAncestor,
              instance
            ), recordEffectDuration()) : runWithFiberInDEV(
              current2,
              callComponentWillUnmountInDEV,
              current2,
              nearestMountedAncestor,
              instance
            );
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (null !== ref) {
              switch (finishedWork.tag) {
                case 26:
                case 27:
                case 5:
                  var instanceToUse = finishedWork.stateNode;
                  break;
                case 30:
                  instanceToUse = finishedWork.stateNode;
                  break;
                default:
                  instanceToUse = finishedWork.stateNode;
              }
              if ("function" === typeof ref)
                if (shouldProfile(finishedWork))
                  try {
                    startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                  } finally {
                    recordEffectDuration();
                  }
                else finishedWork.refCleanup = ref(instanceToUse);
              else
                "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                  "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                  getComponentNameFromFiber(finishedWork)
                ), ref.current = instanceToUse;
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              runWithFiberInDEV(current2, commitAttachRef, current2);
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref, refCleanup = current2.refCleanup;
            if (null !== ref)
              if ("function" === typeof refCleanup)
                try {
                  if (shouldProfile(current2))
                    try {
                      startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                    } finally {
                      recordEffectDuration(current2);
                    }
                  else runWithFiberInDEV(current2, refCleanup);
                } catch (error) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error);
                } finally {
                  current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
                }
              else if ("function" === typeof ref)
                try {
                  if (shouldProfile(current2))
                    try {
                      startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                    } finally {
                      recordEffectDuration(current2);
                    }
                  else runWithFiberInDEV(current2, ref, null);
                } catch (error$7) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
                }
              else ref.current = null;
          }
          function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
            var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
            _finishedWork$memoize = _finishedWork$memoize.onRender;
            current2 = null === current2 ? "mount" : "update";
            currentUpdateIsNested && (current2 = "nested-update");
            "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
              id,
              current2,
              finishedWork.actualDuration,
              finishedWork.treeBaseDuration,
              finishedWork.actualStartTime,
              commitStartTime2
            );
            "function" === typeof onCommit && onCommit(
              finishedWork.memoizedProps.id,
              current2,
              effectDuration,
              commitStartTime2
            );
          }
          function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
            var _finishedWork$memoize2 = finishedWork.memoizedProps;
            finishedWork = _finishedWork$memoize2.id;
            _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
            current2 = null === current2 ? "mount" : "update";
            currentUpdateIsNested && (current2 = "nested-update");
            "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
              finishedWork,
              current2,
              passiveEffectDuration,
              commitStartTime2
            );
          }
          function commitHostMount(finishedWork) {
            var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
            try {
              runWithFiberInDEV(
                finishedWork,
                commitMount,
                instance,
                type,
                props,
                finishedWork
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function commitHostUpdate(finishedWork, newProps, oldProps) {
            try {
              runWithFiberInDEV(
                finishedWork,
                commitUpdate,
                finishedWork.stateNode,
                finishedWork.type,
                oldProps,
                newProps,
                finishedWork
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function isHostParent(fiber) {
            return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
          }
          function getHostSibling(fiber) {
            a: for (; ; ) {
              for (; null === fiber.sibling; ) {
                if (null === fiber.return || isHostParent(fiber.return)) return null;
                fiber = fiber.return;
              }
              fiber.sibling.return = fiber.return;
              for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
                if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
                if (fiber.flags & 2) continue a;
                if (null === fiber.child || 4 === fiber.tag) continue a;
                else fiber.child.return = fiber, fiber = fiber.child;
              }
              if (!(fiber.flags & 2)) return fiber.stateNode;
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            if (5 === tag || 6 === tag)
              node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
            else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
              for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
                insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            if (5 === tag || 6 === tag)
              node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
            else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
              for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
                insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
          }
          function commitPlacement(finishedWork) {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber)
              throw Error(
                "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
              );
            switch (hostParentFiber.tag) {
              case 27:
                hostParentFiber = hostParentFiber.stateNode;
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(
                  finishedWork,
                  parentFiber,
                  hostParentFiber
                );
                break;
              case 5:
                parentFiber = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
                hostParentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(
                  finishedWork,
                  hostParentFiber,
                  parentFiber
                );
                break;
              case 3:
              case 4:
                hostParentFiber = hostParentFiber.stateNode.containerInfo;
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  parentFiber,
                  hostParentFiber
                );
                break;
              default:
                throw Error(
                  "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
                );
            }
          }
          function commitHostSingletonAcquisition(finishedWork) {
            var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
            try {
              runWithFiberInDEV(
                finishedWork,
                acquireSingletonInstance,
                finishedWork.type,
                props,
                singleton,
                finishedWork
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          function commitBeforeMutationEffects(root2, firstChild) {
            root2 = root2.containerInfo;
            eventsEnabled = _enabled;
            root2 = getActiveElementDeep(root2);
            if (hasSelectionCapabilities(root2)) {
              if ("selectionStart" in root2)
                var JSCompiler_temp = {
                  start: root2.selectionStart,
                  end: root2.selectionEnd
                };
              else
                a: {
                  JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                  var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                  if (selection && 0 !== selection.rangeCount) {
                    JSCompiler_temp = selection.anchorNode;
                    var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                    selection = selection.focusOffset;
                    try {
                      JSCompiler_temp.nodeType, focusNode.nodeType;
                    } catch (e$2) {
                      JSCompiler_temp = null;
                      break a;
                    }
                    var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode2 = null;
                    b: for (; ; ) {
                      for (var next; ; ) {
                        node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                        node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                        3 === node.nodeType && (length += node.nodeValue.length);
                        if (null === (next = node.firstChild)) break;
                        parentNode2 = node;
                        node = next;
                      }
                      for (; ; ) {
                        if (node === root2) break b;
                        parentNode2 === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                        parentNode2 === focusNode && ++indexWithinFocus === selection && (end = length);
                        if (null !== (next = node.nextSibling)) break;
                        node = parentNode2;
                        parentNode2 = node.parentNode;
                      }
                      node = next;
                    }
                    JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                  } else JSCompiler_temp = null;
                }
              JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
            } else JSCompiler_temp = null;
            selectionInformation = {
              focusedElem: root2,
              selectionRange: JSCompiler_temp
            };
            _enabled = false;
            for (nextEffect = firstChild; null !== nextEffect; )
              if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
                root2.return = firstChild, nextEffect = root2;
              else
                for (; null !== nextEffect; ) {
                  root2 = firstChild = nextEffect;
                  JSCompiler_temp = root2.alternate;
                  anchorOffset = root2.flags;
                  switch (root2.tag) {
                    case 0:
                      break;
                    case 11:
                    case 15:
                      break;
                    case 1:
                      0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                      break;
                    case 3:
                      if (0 !== (anchorOffset & 1024)) {
                        if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                          clearContainerSparingly(root2);
                        else if (1 === JSCompiler_temp)
                          switch (root2.nodeName) {
                            case "HEAD":
                            case "HTML":
                            case "BODY":
                              clearContainerSparingly(root2);
                              break;
                            default:
                              root2.textContent = "";
                          }
                      }
                      break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      if (0 !== (anchorOffset & 1024))
                        throw Error(
                          "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                        );
                  }
                  root2 = firstChild.sibling;
                  if (null !== root2) {
                    root2.return = firstChild.return;
                    nextEffect = root2;
                    break;
                  }
                  nextEffect = firstChild.return;
                }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
                break;
              case 1:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                if (flags & 4)
                  if (finishedRoot = finishedWork.stateNode, null === current2)
                    finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                      "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                      getComponentNameFromFiber(finishedWork) || "instance"
                    ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                      "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                      getComponentNameFromFiber(finishedWork) || "instance"
                    )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    ), recordEffectDuration()) : runWithFiberInDEV(
                      finishedWork,
                      callComponentDidMountInDEV,
                      finishedWork,
                      finishedRoot
                    );
                  else {
                    var prevProps = resolveClassComponentProps(
                      finishedWork.type,
                      current2.memoizedProps
                    );
                    current2 = current2.memoizedState;
                    finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                      "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                      getComponentNameFromFiber(finishedWork) || "instance"
                    ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                      "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                      getComponentNameFromFiber(finishedWork) || "instance"
                    ));
                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                      finishedWork,
                      callComponentDidUpdateInDEV,
                      finishedWork,
                      finishedRoot,
                      prevProps,
                      current2,
                      finishedRoot.__reactInternalSnapshotBeforeUpdate
                    ), recordEffectDuration()) : runWithFiberInDEV(
                      finishedWork,
                      callComponentDidUpdateInDEV,
                      finishedWork,
                      finishedRoot,
                      prevProps,
                      current2,
                      finishedRoot.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                flags & 64 && commitClassCallbacks(finishedWork);
                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 3:
                current2 = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                  prevProps = null;
                  if (null !== finishedWork.child)
                    switch (finishedWork.child.tag) {
                      case 27:
                      case 5:
                        prevProps = finishedWork.child.stateNode;
                        break;
                      case 1:
                        prevProps = finishedWork.child.stateNode;
                    }
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitCallbacks,
                      flags,
                      prevProps
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                }
                finishedRoot.effectDuration += popNestedEffectDurations(current2);
                break;
              case 27:
                null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
              case 26:
              case 5:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                null === current2 && flags & 4 && commitHostMount(finishedWork);
                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 12:
                if (flags & 4) {
                  flags = pushNestedEffectDurations();
                  recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  finishedRoot = finishedWork.stateNode;
                  finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitProfiler,
                      finishedWork,
                      current2,
                      commitStartTime,
                      finishedRoot.effectDuration
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                break;
              case 13:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
                  null,
                  finishedWork
                ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
                break;
              case 22:
                flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
                if (!flags) {
                  current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                  prevProps = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = flags;
                  (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                    finishedRoot,
                    finishedWork,
                    0 !== (finishedWork.subtreeFlags & 8772)
                  ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                  offscreenSubtreeIsHidden = prevProps;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                }
                break;
              case 30:
                break;
              default:
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            }
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
            fiber.stateNode = null;
            fiber._debugOwner = null;
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            for (parent = parent.child; null !== parent; )
              commitDeletionEffectsOnFiber(
                finishedRoot,
                nearestMountedAncestor,
                parent
              ), parent = parent.sibling;
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
              try {
                injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            switch (deletedFiber.tag) {
              case 26:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
                break;
              case 27:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
                isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                runWithFiberInDEV(
                  deletedFiber,
                  releaseSingletonInstance,
                  deletedFiber.stateNode
                );
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                break;
              case 5:
                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              case 6:
                prevHostParent = hostParent;
                prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (null !== hostParent)
                  if (hostParentIsContainer)
                    try {
                      runWithFiberInDEV(
                        deletedFiber,
                        removeChildFromContainer,
                        hostParent,
                        deletedFiber.stateNode
                      );
                    } catch (error) {
                      captureCommitPhaseError(
                        deletedFiber,
                        nearestMountedAncestor,
                        error
                      );
                    }
                  else
                    try {
                      runWithFiberInDEV(
                        deletedFiber,
                        removeChild,
                        hostParent,
                        deletedFiber.stateNode
                      );
                    } catch (error) {
                      captureCommitPhaseError(
                        deletedFiber,
                        nearestMountedAncestor,
                        error
                      );
                    }
                break;
              case 18:
                null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
                  9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                  deletedFiber.stateNode
                ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
                break;
              case 4:
                prevHostParent = hostParent;
                prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                break;
              case 0:
              case 11:
              case 14:
              case 15:
                offscreenSubtreeWasHidden || commitHookEffectListUnmount(
                  Insertion,
                  deletedFiber,
                  nearestMountedAncestor
                );
                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                  deletedFiber,
                  nearestMountedAncestor,
                  Layout
                );
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                break;
              case 1:
                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                  deletedFiber,
                  nearestMountedAncestor,
                  prevHostParent
                ));
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                break;
              case 21:
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                break;
              case 22:
                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
                offscreenSubtreeWasHidden = prevHostParent;
                break;
              default:
                recursivelyTraverseDeletionEffects(
                  finishedRoot,
                  nearestMountedAncestor,
                  deletedFiber
                );
            }
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
              try {
                runWithFiberInDEV(
                  finishedWork,
                  commitHydratedSuspenseInstance,
                  finishedRoot
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
          }
          function getRetryCache(finishedWork) {
            switch (finishedWork.tag) {
              case 13:
              case 19:
                var retryCache = finishedWork.stateNode;
                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
                return retryCache;
              case 22:
                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
              default:
                throw Error(
                  "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
                );
            }
          }
          function attachSuspenseRetryListeners(finishedWork, wakeables) {
            var retryCache = getRetryCache(finishedWork);
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                if (isDevToolsPresent)
                  if (null !== inProgressLanes && null !== inProgressRoot)
                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                  else
                    throw Error(
                      "Expected finished root and lanes to be set. This is a bug in React."
                    );
                wakeable.then(retry, retry);
              }
            });
          }
          function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
            var deletions = parentFiber.deletions;
            if (null !== deletions)
              for (var i2 = 0; i2 < deletions.length; i2++) {
                var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i2], parent = returnFiber;
                a: for (; null !== parent; ) {
                  switch (parent.tag) {
                    case 27:
                      if (isSingletonScope(parent.type)) {
                        hostParent = parent.stateNode;
                        hostParentIsContainer = false;
                        break a;
                      }
                      break;
                    case 5:
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    case 3:
                    case 4:
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break a;
                  }
                  parent = parent.return;
                }
                if (null === hostParent)
                  throw Error(
                    "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                  );
                commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
                hostParent = null;
                hostParentIsContainer = false;
                root2 = deletedFiber;
                returnFiber = root2.alternate;
                null !== returnFiber && (returnFiber.return = null);
                root2.return = null;
              }
            if (parentFiber.subtreeFlags & 13878)
              for (parentFiber = parentFiber.child; null !== parentFiber; )
                commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
          }
          function commitMutationEffectsOnFiber(finishedWork, root2) {
            var current2 = finishedWork.alternate, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 4 && (commitHookEffectListUnmount(
                  Insertion | HasEffect,
                  finishedWork,
                  finishedWork.return
                ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                  finishedWork,
                  finishedWork.return,
                  Layout | HasEffect
                ));
                break;
              case 1:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
                break;
              case 26:
                var hoistableRoot = currentHoistableRoot;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
                if (flags & 4)
                  if (root2 = null !== current2 ? current2.memoizedState : null, flags = finishedWork.memoizedState, null === current2)
                    if (null === flags)
                      if (null === finishedWork.stateNode) {
                        a: {
                          flags = finishedWork.type;
                          current2 = finishedWork.memoizedProps;
                          root2 = hoistableRoot.ownerDocument || hoistableRoot;
                          b: switch (flags) {
                            case "title":
                              hoistableRoot = root2.getElementsByTagName("title")[0];
                              if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                                hoistableRoot = root2.createElement(flags), root2.head.insertBefore(
                                  hoistableRoot,
                                  root2.querySelector("head > title")
                                );
                              setInitialProperties(hoistableRoot, flags, current2);
                              hoistableRoot[internalInstanceKey] = finishedWork;
                              markNodeAsHoistable(hoistableRoot);
                              flags = hoistableRoot;
                              break a;
                            case "link":
                              var maybeNodes = getHydratableHoistableCache(
                                "link",
                                "href",
                                root2
                              ).get(flags + (current2.href || ""));
                              if (maybeNodes) {
                                for (var i2 = 0; i2 < maybeNodes.length; i2++)
                                  if (hoistableRoot = maybeNodes[i2], hoistableRoot.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && hoistableRoot.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && hoistableRoot.getAttribute("title") === (null == current2.title ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                    maybeNodes.splice(i2, 1);
                                    break b;
                                  }
                              }
                              hoistableRoot = root2.createElement(flags);
                              setInitialProperties(hoistableRoot, flags, current2);
                              root2.head.appendChild(hoistableRoot);
                              break;
                            case "meta":
                              if (maybeNodes = getHydratableHoistableCache(
                                "meta",
                                "content",
                                root2
                              ).get(flags + (current2.content || ""))) {
                                for (i2 = 0; i2 < maybeNodes.length; i2++)
                                  if (hoistableRoot = maybeNodes[i2], checkAttributeStringCoercion(
                                    current2.content,
                                    "content"
                                  ), hoistableRoot.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (null == current2.name ? null : current2.name) && hoistableRoot.getAttribute("property") === (null == current2.property ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                    maybeNodes.splice(i2, 1);
                                    break b;
                                  }
                              }
                              hoistableRoot = root2.createElement(flags);
                              setInitialProperties(hoistableRoot, flags, current2);
                              root2.head.appendChild(hoistableRoot);
                              break;
                            default:
                              throw Error(
                                'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                              );
                          }
                          hoistableRoot[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(hoistableRoot);
                          flags = hoistableRoot;
                        }
                        finishedWork.stateNode = flags;
                      } else
                        mountHoistable(
                          hoistableRoot,
                          finishedWork.type,
                          finishedWork.stateNode
                        );
                    else
                      finishedWork.stateNode = acquireResource(
                        hoistableRoot,
                        flags,
                        finishedWork.memoizedProps
                      );
                  else
                    root2 !== flags ? (null === root2 ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root2.count--, null === flags ? mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    ) : acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps
                    )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                      finishedWork,
                      finishedWork.memoizedProps,
                      current2.memoizedProps
                    );
                break;
              case 27:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
                null !== current2 && flags & 4 && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current2.memoizedProps
                );
                break;
              case 5:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
                if (finishedWork.flags & 32) {
                  root2 = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(finishedWork, resetTextContent, root2);
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                }
                flags & 4 && null != finishedWork.stateNode && (root2 = finishedWork.memoizedProps, commitHostUpdate(
                  finishedWork,
                  root2,
                  null !== current2 ? current2.memoizedProps : root2
                ));
                flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                  "Unexpected host component type. Expected a form. This is a bug in React."
                ));
                break;
              case 6:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & 4) {
                  if (null === finishedWork.stateNode)
                    throw Error(
                      "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                    );
                  flags = finishedWork.memoizedProps;
                  current2 = null !== current2 ? current2.memoizedProps : flags;
                  root2 = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitTextUpdate,
                      root2,
                      current2,
                      flags
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                }
                break;
              case 3:
                hoistableRoot = pushNestedEffectDurations();
                tagCaches = null;
                maybeNodes = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(root2.containerInfo);
                recursivelyTraverseMutationEffects(root2, finishedWork);
                currentHoistableRoot = maybeNodes;
                commitReconciliationEffects(finishedWork);
                if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHydratedContainer,
                      root2.containerInfo
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
                root2.effectDuration += popNestedEffectDurations(hoistableRoot);
                break;
              case 4:
                flags = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(
                  finishedWork.stateNode.containerInfo
                );
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                currentHoistableRoot = flags;
                break;
              case 12:
                flags = pushNestedEffectDurations();
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
                break;
              case 13:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                break;
              case 22:
                hoistableRoot = null !== finishedWork.memoizedState;
                var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                commitReconciliationEffects(finishedWork);
                if (flags & 8192)
                  a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root2 = finishedWork; ; ) {
                    if (5 === root2.tag || 26 === root2.tag) {
                      if (null === current2) {
                        wasHidden = current2 = root2;
                        try {
                          maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(
                            wasHidden,
                            unhideInstance,
                            wasHidden.stateNode,
                            wasHidden.memoizedProps
                          );
                        } catch (error) {
                          captureCommitPhaseError(wasHidden, wasHidden.return, error);
                        }
                      }
                    } else if (6 === root2.tag) {
                      if (null === current2) {
                        wasHidden = root2;
                        try {
                          i2 = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i2) : runWithFiberInDEV(
                            wasHidden,
                            unhideTextInstance,
                            i2,
                            wasHidden.memoizedProps
                          );
                        } catch (error) {
                          captureCommitPhaseError(wasHidden, wasHidden.return, error);
                        }
                      }
                    } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                      root2.child.return = root2;
                      root2 = root2.child;
                      continue;
                    }
                    if (root2 === finishedWork) break a;
                    for (; null === root2.sibling; ) {
                      if (null === root2.return || root2.return === finishedWork)
                        break a;
                      current2 === root2 && (current2 = null);
                      root2 = root2.return;
                    }
                    current2 === root2 && (current2 = null);
                    root2.sibling.return = root2.return;
                    root2 = root2.sibling;
                  }
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
                break;
              case 19:
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
                break;
              case 30:
                break;
              case 21:
                break;
              default:
                recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & 2) {
              try {
                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
              finishedWork.flags &= -3;
            }
            flags & 4096 && (finishedWork.flags &= -4097);
          }
          function recursivelyResetForms(parentFiber) {
            if (parentFiber.subtreeFlags & 1024)
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var fiber = parentFiber;
                recursivelyResetForms(fiber);
                5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
                parentFiber = parentFiber.sibling;
              }
          }
          function recursivelyTraverseLayoutEffects(root2, parentFiber) {
            if (parentFiber.subtreeFlags & 8772)
              for (parentFiber = parentFiber.child; null !== parentFiber; )
                commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
          }
          function disappearLayoutEffects(finishedWork) {
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                commitHookLayoutUnmountEffects(
                  finishedWork,
                  finishedWork.return,
                  Layout
                );
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 1:
                safelyDetachRef(finishedWork, finishedWork.return);
                var instance = finishedWork.stateNode;
                "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                  finishedWork,
                  finishedWork.return,
                  instance
                );
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 27:
                runWithFiberInDEV(
                  finishedWork,
                  releaseSingletonInstance,
                  finishedWork.stateNode
                );
              case 26:
              case 5:
                safelyDetachRef(finishedWork, finishedWork.return);
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 22:
                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              case 30:
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
                break;
              default:
                recursivelyTraverseDisappearLayoutEffects(finishedWork);
            }
          }
          function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
          }
          function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                commitHookLayoutEffects(finishedWork, Layout);
                break;
              case 1:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                current2 = finishedWork.stateNode;
                "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                  finishedWork,
                  callComponentDidMountInDEV,
                  finishedWork,
                  current2
                );
                current2 = finishedWork.updateQueue;
                if (null !== current2) {
                  finishedRoot = finishedWork.stateNode;
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitHiddenCallbacks,
                      current2,
                      finishedRoot
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                }
                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 27:
                commitHostSingletonAcquisition(finishedWork);
              case 26:
              case 5:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 12:
                if (includeWorkInProgressEffects && flags & 4) {
                  flags = pushNestedEffectDurations();
                  recursivelyTraverseReappearLayoutEffects(
                    finishedRoot,
                    finishedWork,
                    includeWorkInProgressEffects
                  );
                  includeWorkInProgressEffects = finishedWork.stateNode;
                  includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitProfiler,
                      finishedWork,
                      current2,
                      commitStartTime,
                      includeWorkInProgressEffects.effectDuration
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                } else
                  recursivelyTraverseReappearLayoutEffects(
                    finishedRoot,
                    finishedWork,
                    includeWorkInProgressEffects
                  );
                break;
              case 13:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              case 22:
                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                safelyAttachRef(finishedWork, finishedWork.return);
                break;
              case 30:
                break;
              default:
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
            }
          }
          function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
            includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              reappearLayoutEffects(
                finishedRoot,
                parentFiber.alternate,
                parentFiber,
                includeWorkInProgressEffects
              ), parentFiber = parentFiber.sibling;
          }
          function commitOffscreenPassiveMountEffects(current2, finishedWork) {
            var previousCache = null;
            null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
            current2 = null;
            null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
            current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
          }
          function commitCachePassiveMountEffect(current2, finishedWork) {
            current2 = null;
            null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
            finishedWork = finishedWork.memoizedState.cache;
            finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
          }
          function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
            if (parentFiber.subtreeFlags & 10256)
              for (parentFiber = parentFiber.child; null !== parentFiber; )
                commitPassiveMountOnFiber(
                  root2,
                  parentFiber,
                  committedLanes,
                  committedTransitions
                ), parentFiber = parentFiber.sibling;
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
                break;
              case 1:
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                break;
              case 3:
                var prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
                break;
              case 12:
                if (flags & 2048) {
                  flags = pushNestedEffectDurations();
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
                  finishedRoot = finishedWork.stateNode;
                  finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                  try {
                    runWithFiberInDEV(
                      finishedWork,
                      commitProfilerPostCommitImpl,
                      finishedWork,
                      finishedWork.alternate,
                      commitStartTime,
                      finishedRoot.passiveEffectDuration
                    );
                  } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                  }
                } else
                  recursivelyTraversePassiveMountEffects(
                    finishedRoot,
                    finishedWork,
                    committedLanes,
                    committedTransitions
                  );
                break;
              case 13:
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                break;
              case 23:
                break;
              case 22:
                prevEffectDuration = finishedWork.stateNode;
                var _current = finishedWork.alternate;
                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                ) : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  0 !== (finishedWork.subtreeFlags & 10256)
                ));
                flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
                break;
              case 24:
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
            }
          }
          function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
            includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              reconnectPassiveEffects(
                finishedRoot,
                parentFiber,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ), parentFiber = parentFiber.sibling;
          }
          function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                );
                commitHookPassiveMountEffects(finishedWork, Passive);
                break;
              case 23:
                break;
              case 22:
                var _instance2 = finishedWork.stateNode;
                null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                ) : recursivelyTraverseAtomicPassiveEffects(
                  finishedRoot,
                  finishedWork
                ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                ));
                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseReconnectPassiveEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions,
                  includeWorkInProgressEffects
                );
            }
          }
          function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
            if (parentFiber.subtreeFlags & 10256)
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
                switch (finishedWork.tag) {
                  case 22:
                    recursivelyTraverseAtomicPassiveEffects(
                      finishedRoot,
                      finishedWork
                    );
                    flags & 2048 && commitOffscreenPassiveMountEffects(
                      finishedWork.alternate,
                      finishedWork
                    );
                    break;
                  case 24:
                    recursivelyTraverseAtomicPassiveEffects(
                      finishedRoot,
                      finishedWork
                    );
                    flags & 2048 && commitCachePassiveMountEffect(
                      finishedWork.alternate,
                      finishedWork
                    );
                    break;
                  default:
                    recursivelyTraverseAtomicPassiveEffects(
                      finishedRoot,
                      finishedWork
                    );
                }
                parentFiber = parentFiber.sibling;
              }
          }
          function recursivelyAccumulateSuspenseyCommit(parentFiber) {
            if (parentFiber.subtreeFlags & suspenseyCommitFlag)
              for (parentFiber = parentFiber.child; null !== parentFiber; )
                accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
          }
          function accumulateSuspenseyCommitOnFiber(fiber) {
            switch (fiber.tag) {
              case 26:
                recursivelyAccumulateSuspenseyCommit(fiber);
                fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                  currentHoistableRoot,
                  fiber.memoizedState,
                  fiber.memoizedProps
                );
                break;
              case 5:
                recursivelyAccumulateSuspenseyCommit(fiber);
                break;
              case 3:
              case 4:
                var previousHoistableRoot = currentHoistableRoot;
                currentHoistableRoot = getHoistableRoot(
                  fiber.stateNode.containerInfo
                );
                recursivelyAccumulateSuspenseyCommit(fiber);
                currentHoistableRoot = previousHoistableRoot;
                break;
              case 22:
                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
                break;
              default:
                recursivelyAccumulateSuspenseyCommit(fiber);
            }
          }
          function detachAlternateSiblings(parentFiber) {
            var previousFiber = parentFiber.alternate;
            if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
              previousFiber.child = null;
              do
                previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
              while (null !== parentFiber);
            }
          }
          function recursivelyTraversePassiveUnmountEffects(parentFiber) {
            var deletions = parentFiber.deletions;
            if (0 !== (parentFiber.flags & 16)) {
              if (null !== deletions)
                for (var i2 = 0; i2 < deletions.length; i2++) {
                  var childToDelete = deletions[i2];
                  nextEffect = childToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                    childToDelete,
                    parentFiber
                  );
                }
              detachAlternateSiblings(parentFiber);
            }
            if (parentFiber.subtreeFlags & 10256)
              for (parentFiber = parentFiber.child; null !== parentFiber; )
                commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                  finishedWork,
                  finishedWork.return,
                  Passive | HasEffect
                );
                break;
              case 3:
                var prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
                break;
              case 12:
                prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveUnmountEffects(finishedWork);
                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
                break;
              case 22:
                prevEffectDuration = finishedWork.stateNode;
                null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
                break;
              default:
                recursivelyTraversePassiveUnmountEffects(finishedWork);
            }
          }
          function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
            var deletions = parentFiber.deletions;
            if (0 !== (parentFiber.flags & 16)) {
              if (null !== deletions)
                for (var i2 = 0; i2 < deletions.length; i2++) {
                  var childToDelete = deletions[i2];
                  nextEffect = childToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                    childToDelete,
                    parentFiber
                  );
                }
              detachAlternateSiblings(parentFiber);
            }
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
          }
          function disconnectPassiveEffect(finishedWork) {
            switch (finishedWork.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  finishedWork,
                  finishedWork.return,
                  Passive
                );
                recursivelyTraverseDisconnectPassiveEffects(finishedWork);
                break;
              case 22:
                var instance = finishedWork.stateNode;
                instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
                break;
              default:
                recursivelyTraverseDisconnectPassiveEffects(finishedWork);
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            for (; null !== nextEffect; ) {
              var fiber = nextEffect, current2 = fiber;
              switch (current2.tag) {
                case 0:
                case 11:
                case 15:
                  commitHookPassiveUnmountEffects(
                    current2,
                    nearestMountedAncestor,
                    Passive
                  );
                  break;
                case 23:
                case 22:
                  null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
                  break;
                case 24:
                  releaseCache(current2.memoizedState.cache);
              }
              current2 = fiber.child;
              if (null !== current2) current2.return = fiber, nextEffect = current2;
              else
                a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                  current2 = nextEffect;
                  var sibling = current2.sibling, returnFiber = current2.return;
                  detachFiberAfterEffects(current2);
                  if (current2 === fiber) {
                    nextEffect = null;
                    break a;
                  }
                  if (null !== sibling) {
                    sibling.return = returnFiber;
                    nextEffect = sibling;
                    break a;
                  }
                  nextEffect = returnFiber;
                }
            }
          }
          function onCommitRoot() {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
          function isConcurrentActEnvironment() {
            var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
            isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
              "The current testing environment is not configured to support act(...)"
            );
            return isReactActEnvironmentGlobal;
          }
          function requestUpdateLane(fiber) {
            if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
              return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
            var transition = ReactSharedInternals.T;
            return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
          }
          function requestDeferredLane() {
            0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
            var suspenseHandler = suspenseHandlerStackCursor.current;
            null !== suspenseHandler && (suspenseHandler.flags |= 32);
            return workInProgressDeferredLane;
          }
          function scheduleUpdateOnFiber(root2, fiber, lane) {
            isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
            isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
            if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
              prepareFreshStack(root2, 0), markRootSuspended(
                root2,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                false
              );
            markRootUpdated$1(root2, lane);
            if (0 !== (executionContext & RenderContext) && root2 === workInProgressRoot) {
              if (isRendering)
                switch (fiber.tag) {
                  case 0:
                  case 11:
                  case 15:
                    root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                      "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                      fiber,
                      root2,
                      root2
                    ));
                    break;
                  case 1:
                    didWarnAboutUpdateInRender || (console.error(
                      "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                    ), didWarnAboutUpdateInRender = true);
                }
            } else
              isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
                root2,
                workInProgressRootRenderLanes,
                workInProgressDeferredLane,
                false
              )), ensureRootIsScheduled(root2);
          }
          function performWorkOnRoot(root2, lanes, forceSync) {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Should not already be working.");
            var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
            do {
              if (exitStatus === RootInProgress) {
                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
                break;
              } else {
                forceSync = root2.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                  exitStatus = renderRootSync(root2, lanes, false);
                  renderWasConcurrent = false;
                  continue;
                }
                if (exitStatus === RootErrored) {
                  renderWasConcurrent = lanes;
                  if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                    var errorRetryLanes = 0;
                  else
                    errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                  if (0 !== errorRetryLanes) {
                    lanes = errorRetryLanes;
                    a: {
                      exitStatus = root2;
                      var errorRetryLanes$jscomp$0 = errorRetryLanes;
                      errorRetryLanes = workInProgressRootConcurrentErrors;
                      var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                      wasRootDehydrated && (prepareFreshStack(
                        exitStatus,
                        errorRetryLanes$jscomp$0
                      ).flags |= 256);
                      errorRetryLanes$jscomp$0 = renderRootSync(
                        exitStatus,
                        errorRetryLanes$jscomp$0,
                        false
                      );
                      if (errorRetryLanes$jscomp$0 !== RootErrored) {
                        if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                          exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                          workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                          exitStatus = RootSuspendedWithDelay;
                          break a;
                        }
                        exitStatus = workInProgressRootRecoverableErrors;
                        workInProgressRootRecoverableErrors = errorRetryLanes;
                        null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
                          workInProgressRootRecoverableErrors,
                          exitStatus
                        ));
                      }
                      exitStatus = errorRetryLanes$jscomp$0;
                    }
                    renderWasConcurrent = false;
                    if (exitStatus !== RootErrored) continue;
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  prepareFreshStack(root2, 0);
                  markRootSuspended(root2, lanes, 0, true);
                  break;
                }
                a: {
                  shouldTimeSlice = root2;
                  switch (exitStatus) {
                    case RootInProgress:
                    case RootFatalErrored:
                      throw Error("Root did not complete. This is a bug in React.");
                    case RootSuspendedWithDelay:
                      if ((lanes & 4194048) !== lanes) break;
                    case RootSuspendedAtTheShell:
                      markRootSuspended(
                        shouldTimeSlice,
                        lanes,
                        workInProgressDeferredLane,
                        !workInProgressRootDidSkipSuspendedSiblings
                      );
                      break a;
                    case RootErrored:
                      workInProgressRootRecoverableErrors = null;
                      break;
                    case RootSuspended:
                    case RootCompleted:
                      break;
                    default:
                      throw Error("Unknown root exit status.");
                  }
                  if (null !== ReactSharedInternals.actQueue)
                    commitRoot(
                      shouldTimeSlice,
                      forceSync,
                      lanes,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes
                    );
                  else {
                    if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                      markRootSuspended(
                        shouldTimeSlice,
                        lanes,
                        workInProgressDeferredLane,
                        !workInProgressRootDidSkipSuspendedSiblings
                      );
                      if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                      shouldTimeSlice.timeoutHandle = scheduleTimeout(
                        commitRootWhenReady.bind(
                          null,
                          shouldTimeSlice,
                          forceSync,
                          workInProgressRootRecoverableErrors,
                          workInProgressTransitions,
                          workInProgressRootDidIncludeRecursiveRenderUpdate,
                          lanes,
                          workInProgressDeferredLane,
                          workInProgressRootInterleavedUpdatedLanes,
                          workInProgressSuspendedRetryLanes,
                          workInProgressRootDidSkipSuspendedSiblings,
                          exitStatus,
                          THROTTLED_COMMIT,
                          renderStartTime,
                          0
                        ),
                        renderWasConcurrent
                      );
                      break a;
                    }
                    commitRootWhenReady(
                      shouldTimeSlice,
                      forceSync,
                      workInProgressRootRecoverableErrors,
                      workInProgressTransitions,
                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                      lanes,
                      workInProgressDeferredLane,
                      workInProgressRootInterleavedUpdatedLanes,
                      workInProgressSuspendedRetryLanes,
                      workInProgressRootDidSkipSuspendedSiblings,
                      exitStatus,
                      IMMEDIATE_COMMIT,
                      renderStartTime,
                      0
                    );
                  }
                }
              }
              break;
            } while (1);
            ensureRootIsScheduled(root2);
          }
          function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
            root2.timeoutHandle = noTimeout;
            suspendedCommitReason = finishedWork.subtreeFlags;
            if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
              if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
                root2.cancelPendingCommit = suspendedCommitReason(
                  commitRoot.bind(
                    null,
                    root2,
                    finishedWork,
                    lanes,
                    recoverableErrors,
                    transitions,
                    didIncludeRenderPhaseUpdate,
                    spawnedLane,
                    updatedLanes,
                    suspendedRetryLanes,
                    exitStatus,
                    SUSPENDED_COMMIT,
                    completedRenderStartTime,
                    completedRenderEndTime
                  )
                );
                markRootSuspended(
                  root2,
                  lanes,
                  spawnedLane,
                  !didSkipSuspendedSiblings
                );
                return;
              }
            }
            commitRoot(
              root2,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            for (var node = finishedWork; ; ) {
              var tag = node.tag;
              if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
                for (var i2 = 0; i2 < tag.length; i2++) {
                  var check = tag[i2], getSnapshot = check.getSnapshot;
                  check = check.value;
                  try {
                    if (!objectIs(getSnapshot(), check)) return false;
                  } catch (error) {
                    return false;
                  }
                }
              tag = node.child;
              if (node.subtreeFlags & 16384 && null !== tag)
                tag.return = node, node = tag;
              else {
                if (node === finishedWork) break;
                for (; null === node.sibling; ) {
                  if (null === node.return || node.return === finishedWork) return true;
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return true;
          }
          function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
            suspendedLanes &= ~workInProgressRootPingedLanes;
            suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
            didAttemptEntireTree = root2.expirationTimes;
            for (var lanes = suspendedLanes; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              didAttemptEntireTree[index] = -1;
              lanes &= ~lane;
            }
            0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
          }
          function flushSyncWork$1() {
            return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
          }
          function resetWorkInProgressStack() {
            if (null !== workInProgress) {
              if (workInProgressSuspendedReason === NotSuspended)
                var interruptedWork = workInProgress.return;
              else
                interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
              for (; null !== interruptedWork; )
                unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
              workInProgress = null;
            }
          }
          function prepareFreshStack(root2, lanes) {
            var timeoutHandle = root2.timeoutHandle;
            timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
            timeoutHandle = root2.cancelPendingCommit;
            null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
            resetWorkInProgressStack();
            workInProgressRoot = root2;
            workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
            workInProgressRootRenderLanes = lanes;
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            workInProgressRootDidSkipSuspendedSiblings = false;
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
            workInProgressRootDidAttachPingListener = false;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
            workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
            workInProgressRootDidIncludeRecursiveRenderUpdate = false;
            0 !== (lanes & 8) && (lanes |= lanes & 32);
            var allEntangledLanes = root2.entangledLanes;
            if (0 !== allEntangledLanes)
              for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
                var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
                lanes |= root2[index];
                allEntangledLanes &= ~lane;
              }
            entangledRenderLanes = lanes;
            finishQueueingConcurrentUpdates();
            lanes = getCurrentTime();
            1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
            ReactStrictModeWarnings.discardPendingWarnings();
            return timeoutHandle;
          }
          function handleThrow(root2, thrownValue) {
            currentlyRenderingFiber = null;
            ReactSharedInternals.H = ContextOnlyDispatcher;
            ReactSharedInternals.getCurrentStack = null;
            isRendering = false;
            current = null;
            thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
            workInProgressThrownValue = thrownValue;
            var erroredWork = workInProgress;
            if (null === erroredWork)
              workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
            else
              switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
                case SuspendedOnError:
                  null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                    erroredWork,
                    thrownValue,
                    workInProgressRootRenderLanes
                  );
                  break;
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnImmediate:
                case SuspendedOnDeprecatedThrowPromise:
                case SuspendedAndReadyToContinue:
                  null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                    erroredWork,
                    thrownValue,
                    workInProgressRootRenderLanes
                  );
              }
          }
          function pushDispatcher() {
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = ContextOnlyDispatcher;
            return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
          }
          function pushAsyncDispatcher() {
            var prevAsyncDispatcher = ReactSharedInternals.A;
            ReactSharedInternals.A = DefaultAsyncDispatcher;
            return prevAsyncDispatcher;
          }
          function renderDidSuspendDelayIfPossible() {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
            workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
            0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
              workInProgressRoot,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          }
          function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
                movePendingFibersToMemoized(root2, lanes);
              }
              workInProgressTransitions = null;
              prepareFreshStack(root2, lanes);
            }
            markRenderStarted(lanes);
            lanes = false;
            memoizedUpdaters = workInProgressRootExitStatus;
            a: do
              try {
                if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                  var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                  switch (workInProgressSuspendedReason) {
                    case SuspendedOnHydration:
                      resetWorkInProgressStack();
                      memoizedUpdaters = RootSuspendedAtTheShell;
                      break a;
                    case SuspendedOnImmediate:
                    case SuspendedOnData:
                    case SuspendedOnAction:
                    case SuspendedOnDeprecatedThrowPromise:
                      null === suspenseHandlerStackCursor.current && (lanes = true);
                      var reason = workInProgressSuspendedReason;
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                      if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                        memoizedUpdaters = RootInProgress;
                        break a;
                      }
                      break;
                    default:
                      reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  }
                }
                workLoopSync();
                memoizedUpdaters = workInProgressRootExitStatus;
                break;
              } catch (thrownValue$8) {
                handleThrow(root2, thrownValue$8);
              }
            while (1);
            lanes && root2.shellSuspendCounter++;
            resetContextDependencies();
            executionContext = prevExecutionContext;
            ReactSharedInternals.H = prevDispatcher;
            ReactSharedInternals.A = prevAsyncDispatcher;
            markRenderStopped();
            null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
            return memoizedUpdaters;
          }
          function workLoopSync() {
            for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
                movePendingFibersToMemoized(root2, lanes);
              }
              workInProgressTransitions = null;
              workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
              prepareFreshStack(root2, lanes);
            } else
              workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
                root2,
                lanes
              );
            markRenderStarted(lanes);
            a: do
              try {
                if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                  b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                    case SuspendedOnError:
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(
                        root2,
                        lanes,
                        memoizedUpdaters,
                        SuspendedOnError
                      );
                      break;
                    case SuspendedOnData:
                    case SuspendedOnAction:
                      if (isThenableResolved(memoizedUpdaters)) {
                        workInProgressSuspendedReason = NotSuspended;
                        workInProgressThrownValue = null;
                        replaySuspendedUnitOfWork(lanes);
                        break;
                      }
                      lanes = function() {
                        workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                        ensureRootIsScheduled(root2);
                      };
                      memoizedUpdaters.then(lanes, lanes);
                      break a;
                    case SuspendedOnImmediate:
                      workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                      break a;
                    case SuspendedOnInstance:
                      workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                      break a;
                    case SuspendedAndReadyToContinue:
                      isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                        root2,
                        lanes,
                        memoizedUpdaters,
                        SuspendedAndReadyToContinue
                      ));
                      break;
                    case SuspendedOnInstanceAndReadyToContinue:
                      var resource = null;
                      switch (workInProgress.tag) {
                        case 26:
                          resource = workInProgress.memoizedState;
                        case 5:
                        case 27:
                          var hostFiber = workInProgress;
                          if (resource ? preloadResource(resource) : 1) {
                            workInProgressSuspendedReason = NotSuspended;
                            workInProgressThrownValue = null;
                            var sibling = hostFiber.sibling;
                            if (null !== sibling) workInProgress = sibling;
                            else {
                              var returnFiber = hostFiber.return;
                              null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                            }
                            break b;
                          }
                          break;
                        default:
                          console.error(
                            "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                          );
                      }
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(
                        root2,
                        lanes,
                        memoizedUpdaters,
                        SuspendedOnInstanceAndReadyToContinue
                      );
                      break;
                    case SuspendedOnDeprecatedThrowPromise:
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(
                        root2,
                        lanes,
                        memoizedUpdaters,
                        SuspendedOnDeprecatedThrowPromise
                      );
                      break;
                    case SuspendedOnHydration:
                      resetWorkInProgressStack();
                      workInProgressRootExitStatus = RootSuspendedAtTheShell;
                      break a;
                    default:
                      throw Error(
                        "Unexpected SuspendedReason. This is a bug in React."
                      );
                  }
                null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
                break;
              } catch (thrownValue$9) {
                handleThrow(root2, thrownValue$9);
              }
            while (1);
            resetContextDependencies();
            ReactSharedInternals.H = prevDispatcher;
            ReactSharedInternals.A = prevAsyncDispatcher;
            executionContext = prevExecutionContext;
            if (null !== workInProgress)
              return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
            markRenderStopped();
            workInProgressRoot = null;
            workInProgressRootRenderLanes = 0;
            finishQueueingConcurrentUpdates();
            return workInProgressRootExitStatus;
          }
          function workLoopConcurrentByScheduler() {
            for (; null !== workInProgress && !shouldYield(); )
              performUnitOfWork(workInProgress);
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
              unitOfWork,
              beginWork,
              current2,
              unitOfWork,
              entangledRenderLanes
            ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
              unitOfWork,
              beginWork,
              current2,
              unitOfWork,
              entangledRenderLanes
            );
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
          }
          function replaySuspendedUnitOfWork(unitOfWork) {
            var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
          }
          function replayBeginWork(unitOfWork) {
            var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
            isProfilingMode && startProfilerTimer(unitOfWork);
            switch (unitOfWork.tag) {
              case 15:
              case 0:
                current2 = replayFunctionComponent(
                  current2,
                  unitOfWork,
                  unitOfWork.pendingProps,
                  unitOfWork.type,
                  void 0,
                  workInProgressRootRenderLanes
                );
                break;
              case 11:
                current2 = replayFunctionComponent(
                  current2,
                  unitOfWork,
                  unitOfWork.pendingProps,
                  unitOfWork.type.render,
                  unitOfWork.ref,
                  workInProgressRootRenderLanes
                );
                break;
              case 5:
                resetHooksOnUnwind(unitOfWork);
              default:
                unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
            }
            isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
            return current2;
          }
          function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
            resetContextDependencies();
            resetHooksOnUnwind(unitOfWork);
            thenableState = null;
            thenableIndexCounter = 0;
            var returnFiber = unitOfWork.return;
            try {
              if (throwException(
                root2,
                returnFiber,
                unitOfWork,
                thrownValue,
                workInProgressRootRenderLanes
              )) {
                workInProgressRootExitStatus = RootFatalErrored;
                logUncaughtError(
                  root2,
                  createCapturedValueAtFiber(thrownValue, root2.current)
                );
                workInProgress = null;
                return;
              }
            } catch (error) {
              if (null !== returnFiber) throw workInProgress = returnFiber, error;
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
            if (unitOfWork.flags & 32768) {
              if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
              else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
                root2 = false;
              else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
                suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
              unwindUnitOfWork(unitOfWork, root2);
            } else completeUnitOfWork(unitOfWork);
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              if (0 !== (completedWork.flags & 32768)) {
                unwindUnitOfWork(
                  completedWork,
                  workInProgressRootDidSkipSuspendedSiblings
                );
                return;
              }
              var current2 = completedWork.alternate;
              unitOfWork = completedWork.return;
              startProfilerTimer(completedWork);
              current2 = runWithFiberInDEV(
                completedWork,
                completeWork,
                current2,
                completedWork,
                entangledRenderLanes
              );
              (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
              if (null !== current2) {
                workInProgress = current2;
                return;
              }
              completedWork = completedWork.sibling;
              if (null !== completedWork) {
                workInProgress = completedWork;
                return;
              }
              workInProgress = completedWork = unitOfWork;
            } while (null !== completedWork);
            workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
          }
          function unwindUnitOfWork(unitOfWork, skipSiblings) {
            do {
              var next = unwindWork(unitOfWork.alternate, unitOfWork);
              if (null !== next) {
                next.flags &= 32767;
                workInProgress = next;
                return;
              }
              if ((unitOfWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
                next = unitOfWork.actualDuration;
                for (var child = unitOfWork.child; null !== child; )
                  next += child.actualDuration, child = child.sibling;
                unitOfWork.actualDuration = next;
              }
              next = unitOfWork.return;
              null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
              if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
                workInProgress = unitOfWork;
                return;
              }
              workInProgress = unitOfWork = next;
            } while (null !== unitOfWork);
            workInProgressRootExitStatus = RootSuspendedAtTheShell;
            workInProgress = null;
          }
          function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
            root2.cancelPendingCommit = null;
            do
              flushPendingEffects();
            while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
            ReactStrictModeWarnings.flushLegacyContextWarning();
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Should not already be working.");
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
            if (null === finishedWork) markCommitStopped();
            else {
              0 === lanes && console.error(
                "finishedLanes should not be empty during a commit. This is a bug in React."
              );
              if (finishedWork === root2.current)
                throw Error(
                  "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
                );
              didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
              didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
              markRootFinished(
                root2,
                lanes,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes
              );
              root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
              pendingFinishedWork = finishedWork;
              pendingEffectsRoot = root2;
              pendingEffectsLanes = lanes;
              pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
              pendingPassiveTransitions = transitions;
              pendingRecoverableErrors = recoverableErrors;
              0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
                flushPassiveEffects(true);
                return null;
              })) : (root2.callbackNode = null, root2.callbackPriority = 0);
              commitStartTime = now();
              recoverableErrors = 0 !== (finishedWork.flags & 13878);
              if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
                recoverableErrors = ReactSharedInternals.T;
                ReactSharedInternals.T = null;
                transitions = ReactDOMSharedInternals.p;
                ReactDOMSharedInternals.p = DiscreteEventPriority;
                spawnedLane = executionContext;
                executionContext |= CommitContext;
                try {
                  commitBeforeMutationEffects(root2, finishedWork, lanes);
                } finally {
                  executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
                }
              }
              pendingEffectsStatus = PENDING_MUTATION_PHASE;
              flushMutationEffects();
              flushLayoutEffects();
              flushSpawnedWork();
            }
          }
          function flushMutationEffects() {
            if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
              pendingEffectsStatus = NO_PENDING_EFFECTS;
              var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
              if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
                rootMutationHasEffect = ReactSharedInternals.T;
                ReactSharedInternals.T = null;
                var previousPriority = ReactDOMSharedInternals.p;
                ReactDOMSharedInternals.p = DiscreteEventPriority;
                var prevExecutionContext = executionContext;
                executionContext |= CommitContext;
                try {
                  inProgressLanes = lanes;
                  inProgressRoot = root2;
                  commitMutationEffectsOnFiber(finishedWork, root2);
                  inProgressRoot = inProgressLanes = null;
                  lanes = selectionInformation;
                  var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                  if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                    priorFocusedElem.ownerDocument.documentElement,
                    priorFocusedElem
                  )) {
                    if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                      var start = priorSelectionRange.start, end = priorSelectionRange.end;
                      void 0 === end && (end = start);
                      if ("selectionStart" in priorFocusedElem)
                        priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                          end,
                          priorFocusedElem.value.length
                        );
                      else {
                        var doc3 = priorFocusedElem.ownerDocument || document, win = doc3 && doc3.defaultView || window;
                        if (win.getSelection) {
                          var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                            priorSelectionRange.start,
                            length
                          ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                          !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                          var startMarker = getNodeForCharacterOffset(
                            priorFocusedElem,
                            start$jscomp$0
                          ), endMarker = getNodeForCharacterOffset(
                            priorFocusedElem,
                            end$jscomp$0
                          );
                          if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                            var range = doc3.createRange();
                            range.setStart(startMarker.node, startMarker.offset);
                            selection.removeAllRanges();
                            start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                          }
                        }
                      }
                    }
                    doc3 = [];
                    for (selection = priorFocusedElem; selection = selection.parentNode; )
                      1 === selection.nodeType && doc3.push({
                        element: selection,
                        left: selection.scrollLeft,
                        top: selection.scrollTop
                      });
                    "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                    for (priorFocusedElem = 0; priorFocusedElem < doc3.length; priorFocusedElem++) {
                      var info = doc3[priorFocusedElem];
                      info.element.scrollLeft = info.left;
                      info.element.scrollTop = info.top;
                    }
                  }
                  _enabled = !!eventsEnabled;
                  selectionInformation = eventsEnabled = null;
                } finally {
                  executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
                }
              }
              root2.current = finishedWork;
              pendingEffectsStatus = PENDING_LAYOUT_PHASE;
            }
          }
          function flushLayoutEffects() {
            if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
              pendingEffectsStatus = NO_PENDING_EFFECTS;
              var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
              if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
                rootHasLayoutEffect = ReactSharedInternals.T;
                ReactSharedInternals.T = null;
                var previousPriority = ReactDOMSharedInternals.p;
                ReactDOMSharedInternals.p = DiscreteEventPriority;
                var prevExecutionContext = executionContext;
                executionContext |= CommitContext;
                try {
                  null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root2, commitLayoutEffectOnFiber(
                    root2,
                    finishedWork.alternate,
                    finishedWork
                  ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
                } finally {
                  executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
                }
              }
              pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
            }
          }
          function flushSpawnedWork() {
            if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
              pendingEffectsStatus = NO_PENDING_EFFECTS;
              requestPaint();
              var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
              rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
              var remainingLanes = root2.pendingLanes;
              0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
              rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2);
              rootDidHavePassiveEffects = lanesToEventPriority(lanes);
              finishedWork = finishedWork.stateNode;
              if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
                try {
                  var didError = 128 === (finishedWork.current.flags & 128);
                  switch (rootDidHavePassiveEffects) {
                    case DiscreteEventPriority:
                      var schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority$1;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority$1;
                  }
                  injectedHook.onCommitFiberRoot(
                    rendererID,
                    finishedWork,
                    schedulerPriority,
                    didError
                  );
                } catch (err) {
                  hasLoggedError || (hasLoggedError = true, console.error(
                    "React instrumentation encountered an error: %s",
                    err
                  ));
                }
              isDevToolsPresent && root2.memoizedUpdaters.clear();
              onCommitRoot();
              if (null !== recoverableErrors) {
                didError = ReactSharedInternals.T;
                schedulerPriority = ReactDOMSharedInternals.p;
                ReactDOMSharedInternals.p = DiscreteEventPriority;
                ReactSharedInternals.T = null;
                try {
                  var onRecoverableError = root2.onRecoverableError;
                  for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
                    var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                    runWithFiberInDEV(
                      recoverableError.source,
                      onRecoverableError,
                      recoverableError.value,
                      errorInfo
                    );
                  }
                } finally {
                  ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
                }
              }
              0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
              ensureRootIsScheduled(root2);
              remainingLanes = root2.pendingLanes;
              0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
              flushSyncWorkAcrossRoots_impl(0, false);
              markCommitStopped();
            }
          }
          function makeErrorInfo(componentStack) {
            componentStack = { componentStack };
            Object.defineProperty(componentStack, "digest", {
              get: function() {
                console.error(
                  'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
                );
              }
            });
            return componentStack;
          }
          function releaseRootPooledCache(root2, remainingLanes) {
            0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
          }
          function flushPendingEffects(wasDelayedCommit) {
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
            return flushPassiveEffects(wasDelayedCommit);
          }
          function flushPassiveEffects() {
            if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
            var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
            pendingEffectsRemainingLanes = 0;
            var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
            renderPriority = ReactSharedInternals.T;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
              ReactDOMSharedInternals.p = priority;
              ReactSharedInternals.T = null;
              priority = pendingPassiveTransitions;
              pendingPassiveTransitions = null;
              var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
              pendingEffectsStatus = NO_PENDING_EFFECTS;
              pendingFinishedWork = pendingEffectsRoot = null;
              pendingEffectsLanes = 0;
              if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
                throw Error("Cannot flush passive effects while already rendering.");
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              commitPassiveUnmountOnFiber(root$jscomp$0.current);
              commitPassiveMountOnFiber(
                root$jscomp$0,
                root$jscomp$0.current,
                lanes,
                priority
              );
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
              commitDoubleInvokeEffectsInDEV(root$jscomp$0);
              executionContext = prevExecutionContext;
              flushSyncWorkAcrossRoots_impl(0, false);
              didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
              didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
              if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
                try {
                  injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
                } catch (err) {
                  hasLoggedError || (hasLoggedError = true, console.error(
                    "React instrumentation encountered an error: %s",
                    err
                  ));
                }
              var stateNode = root$jscomp$0.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
              return true;
            } finally {
              ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
            }
          }
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
            rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
            null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
            isRunningInsertionEffect = false;
            if (3 === sourceFiber.tag)
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
            else {
              for (; null !== nearestMountedAncestor; ) {
                if (3 === nearestMountedAncestor.tag) {
                  captureCommitPhaseErrorOnRoot(
                    nearestMountedAncestor,
                    sourceFiber,
                    error
                  );
                  return;
                }
                if (1 === nearestMountedAncestor.tag) {
                  var instance = nearestMountedAncestor.stateNode;
                  if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                    error = createClassErrorUpdate(2);
                    instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                    null !== instance && (initializeClassErrorUpdate(
                      error,
                      instance,
                      nearestMountedAncestor,
                      sourceFiber
                    ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                    return;
                  }
                }
                nearestMountedAncestor = nearestMountedAncestor.return;
              }
              console.error(
                "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
                error
              );
            }
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            if (null === pingCache) {
              pingCache = root2.pingCache = new PossiblyWeakMap();
              var threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else
              threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
            threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            null !== pingCache && pingCache.delete(wakeable);
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
            root2.warmLanes &= ~pingedLanes;
            isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
              "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
            );
            workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
            ensureRootIsScheduled(root2);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            0 === retryLane && (retryLane = claimNextRetryLane());
            boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = 0;
            switch (boundaryFiber.tag) {
              case 13:
                var retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                null !== suspenseState && (retryLane = suspenseState.retryLane);
                break;
              case 19:
                retryCache = boundaryFiber.stateNode;
                break;
              case 22:
                retryCache = boundaryFiber.stateNode._retryCache;
                break;
              default:
                throw Error(
                  "Pinged unknown suspense boundary type. This is probably a bug in React."
                );
            }
            null !== retryCache && retryCache.delete(wakeable);
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
            if (0 !== (parentFiber.subtreeFlags & 67117056))
              for (parentFiber = parentFiber.child; null !== parentFiber; ) {
                var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
                isStrictModeFiber = isInStrictMode || isStrictModeFiber;
                22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                  fiber,
                  doubleInvokeEffectsOnFiber,
                  root2,
                  fiber,
                  (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
                ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                  root2,
                  fiber,
                  isStrictModeFiber
                ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                  fiber,
                  doubleInvokeEffectsOnFiber,
                  root2,
                  fiber
                ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                  fiber,
                  recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                  root2,
                  fiber,
                  isStrictModeFiber
                ));
                parentFiber = parentFiber.sibling;
              }
          }
          function doubleInvokeEffectsOnFiber(root2, fiber) {
            var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
            setIsStrictModeForDevtools(true);
            try {
              disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          function commitDoubleInvokeEffectsInDEV(root2) {
            var doubleInvokeEffects = true;
            root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
            recursivelyTraverseAndDoubleInvokeEffectsInDEV(
              root2,
              root2.current,
              doubleInvokeEffects
            );
          }
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            if ((executionContext & RenderContext) === NoContext) {
              var tag = fiber.tag;
              if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
                tag = getComponentNameFromFiber(fiber) || "ReactComponent";
                if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                  if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                  didWarnStateUpdateForNotYetMountedComponent.add(tag);
                } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
                runWithFiberInDEV(fiber, function() {
                  console.error(
                    "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
                  );
                });
              }
            }
          }
          function restorePendingUpdaters(root2, lanes) {
            isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
              addFiberToLanesMap(root2, schedulingFiber, lanes);
            });
          }
          function scheduleCallback$1(priorityLevel, callback) {
            var actQueue = ReactSharedInternals.actQueue;
            return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
              console.error(
                "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
                getComponentNameFromFiber(fiber)
              );
            });
          }
          function ensureRootIsScheduled(root2) {
            root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
            mightHavePendingSyncWork = true;
            null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
          }
          function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
            if (!isFlushingWork && mightHavePendingSyncWork) {
              isFlushingWork = true;
              do {
                var didPerformSomeWork = false;
                for (var root2 = firstScheduledRoot; null !== root2; ) {
                  if (!onlyLegacy)
                    if (0 !== syncTransitionLanes) {
                      var pendingLanes = root2.pendingLanes;
                      if (0 === pendingLanes) var nextLanes = 0;
                      else {
                        var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                        nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                        nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                        nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                      }
                      0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                    } else
                      nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                        root2,
                        root2 === workInProgressRoot ? nextLanes : 0,
                        null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                      ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  root2 = root2.next;
                }
              } while (didPerformSomeWork);
              isFlushingWork = false;
            }
          }
          function processRootScheduleInImmediateTask() {
            processRootScheduleInMicrotask();
          }
          function processRootScheduleInMicrotask() {
            mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
            var syncTransitionLanes = 0;
            0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
            for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
              var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
              if (0 === nextLanes)
                root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
              else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
                mightHavePendingSyncWork = true;
              root2 = next;
            }
            flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
          }
          function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
            for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
              if (-1 === expirationTime) {
                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                  expirationTimes[index] = computeExpirationTime(lane, currentTime);
              } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
              lanes &= ~lane;
            }
            currentTime = workInProgressRoot;
            suspendedLanes = workInProgressRootRenderLanes;
            suspendedLanes = getNextLanes(
              root2,
              root2 === currentTime ? suspendedLanes : 0,
              null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
            );
            pingedLanes = root2.callbackNode;
            if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
              return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
            if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
              currentTime = suspendedLanes & -suspendedLanes;
              if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
                cancelCallback(pingedLanes);
              else return currentTime;
              switch (lanesToEventPriority(suspendedLanes)) {
                case DiscreteEventPriority:
                case ContinuousEventPriority:
                  suspendedLanes = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  suspendedLanes = NormalPriority$1;
                  break;
                case IdleEventPriority:
                  suspendedLanes = IdlePriority;
                  break;
                default:
                  suspendedLanes = NormalPriority$1;
              }
              pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
              null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
              root2.callbackPriority = currentTime;
              root2.callbackNode = suspendedLanes;
              return currentTime;
            }
            null !== pingedLanes && cancelCallback(pingedLanes);
            root2.callbackPriority = 2;
            root2.callbackNode = null;
            return 2;
          }
          function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
            nestedUpdateScheduled = currentUpdateIsNested = false;
            if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
              return root2.callbackNode = null, root2.callbackPriority = 0, null;
            var originalCallbackNode = root2.callbackNode;
            if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
              return null;
            var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
            workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
              root2,
              root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
              null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
            );
            if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
            performWorkOnRoot(
              root2,
              workInProgressRootRenderLanes$jscomp$0,
              didTimeout
            );
            scheduleTaskForRootDuringMicrotask(root2, now$1());
            return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
          }
          function performSyncWorkOnRoot(root2, lanes) {
            if (flushPendingEffects()) return null;
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
            performWorkOnRoot(root2, lanes, true);
          }
          function cancelCallback(callbackNode) {
            callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
          }
          function scheduleImmediateRootScheduleTask() {
            null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
              processRootScheduleInMicrotask();
              return null;
            });
            scheduleMicrotask(function() {
              (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
                ImmediatePriority,
                processRootScheduleInImmediateTask
              ) : processRootScheduleInMicrotask();
            });
          }
          function requestTransitionLane() {
            0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
            return currentEventTransitionLane;
          }
          function coerceFormActionProp(actionProp) {
            if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
              return null;
            if ("function" === typeof actionProp) return actionProp;
            checkAttributeStringCoercion(actionProp, "action");
            return sanitizeURL("" + actionProp);
          }
          function createFormDataWithSubmitter(form, submitter) {
            var temp = submitter.ownerDocument.createElement("input");
            temp.name = submitter.name;
            temp.value = submitter.value;
            form.id && temp.setAttribute("form", form.id);
            submitter.parentNode.insertBefore(temp, submitter);
            form = new FormData(form);
            temp.parentNode.removeChild(temp);
            return form;
          }
          function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
            if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
              var action = coerceFormActionProp(
                (nativeEventTarget[internalPropsKey] || null).action
              ), submitter = nativeEvent.submitter;
              submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
              var event = new SyntheticEvent(
                "action",
                "action",
                null,
                nativeEvent,
                nativeEventTarget
              );
              dispatchQueue.push({
                event,
                listeners: [
                  {
                    instance: null,
                    listener: function() {
                      if (nativeEvent.defaultPrevented) {
                        if (0 !== currentEventTransitionLane) {
                          var formData = submitter ? createFormDataWithSubmitter(
                            nativeEventTarget,
                            submitter
                          ) : new FormData(nativeEventTarget), pendingState = {
                            pending: true,
                            data: formData,
                            method: nativeEventTarget.method,
                            action
                          };
                          Object.freeze(pendingState);
                          startHostTransition(
                            maybeTargetInst,
                            pendingState,
                            null,
                            formData
                          );
                        }
                      } else
                        "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        }, Object.freeze(pendingState), startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          action,
                          formData
                        ));
                    },
                    currentTarget: nativeEventTarget
                  }
                ]
              });
            }
          }
          function executeDispatch(event, listener, currentTarget) {
            event.currentTarget = currentTarget;
            try {
              listener(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            eventSystemFlags = 0 !== (eventSystemFlags & 4);
            for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
              var _dispatchQueue$i = dispatchQueue[i2];
              a: {
                var previousInstance = void 0, event = _dispatchQueue$i.event;
                _dispatchQueue$i = _dispatchQueue$i.listeners;
                if (eventSystemFlags)
                  for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                    var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                    _dispatchListeners$i = _dispatchListeners$i.listener;
                    if (instance !== previousInstance && event.isPropagationStopped())
                      break a;
                    null !== instance ? runWithFiberInDEV(
                      instance,
                      executeDispatch,
                      event,
                      _dispatchListeners$i,
                      currentTarget
                    ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                    previousInstance = instance;
                  }
                else
                  for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                    _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                    instance = _dispatchListeners$i.instance;
                    currentTarget = _dispatchListeners$i.currentTarget;
                    _dispatchListeners$i = _dispatchListeners$i.listener;
                    if (instance !== previousInstance && event.isPropagationStopped())
                      break a;
                    null !== instance ? runWithFiberInDEV(
                      instance,
                      executeDispatch,
                      event,
                      _dispatchListeners$i,
                      currentTarget
                    ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                    previousInstance = instance;
                  }
              }
            }
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            nonDelegatedEvents.has(domEventName) || console.error(
              'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
              domEventName
            );
            var listenerSet = targetElement[internalEventHandlersKey];
            void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
            var listenerSetKey = domEventName + "__bubble";
            listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
              'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
              domEventName
            );
            var eventSystemFlags = 0;
            isCapturePhaseListener && (eventSystemFlags |= 4);
            addTrappedEventListener(
              target,
              domEventName,
              eventSystemFlags,
              isCapturePhaseListener
            );
          }
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
              });
              var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
              null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
            switch (getEventPriority(domEventName)) {
              case DiscreteEventPriority:
                var listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              default:
                listenerWrapper = dispatchEvent2;
            }
            eventSystemFlags = listenerWrapper.bind(
              null,
              domEventName,
              eventSystemFlags,
              targetContainer
            );
            listenerWrapper = void 0;
            !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
            isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              capture: true,
              passive: listenerWrapper
            }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
              passive: listenerWrapper
            }) : targetContainer.addEventListener(
              domEventName,
              eventSystemFlags,
              false
            );
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
            var ancestorInst = targetInst$jscomp$0;
            if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
              a: for (; ; ) {
                if (null === targetInst$jscomp$0) return;
                var nodeTag = targetInst$jscomp$0.tag;
                if (3 === nodeTag || 4 === nodeTag) {
                  var container = targetInst$jscomp$0.stateNode.containerInfo;
                  if (container === targetContainer) break;
                  if (4 === nodeTag)
                    for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                      var grandTag = nodeTag.tag;
                      if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                        return;
                      nodeTag = nodeTag.return;
                    }
                  for (; null !== container; ) {
                    nodeTag = getClosestInstanceFromNode(container);
                    if (null === nodeTag) return;
                    grandTag = nodeTag.tag;
                    if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                      targetInst$jscomp$0 = ancestorInst = nodeTag;
                      continue a;
                    }
                    container = container.parentNode;
                  }
                }
                targetInst$jscomp$0 = targetInst$jscomp$0.return;
              }
            batchedUpdates$1(function() {
              var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
              a: {
                var reactName = topLevelEventsToReactNames.get(domEventName);
                if (void 0 !== reactName) {
                  var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                  switch (domEventName) {
                    case "keypress":
                      if (0 === getEventCharCode(nativeEvent)) break a;
                    case "keydown":
                    case "keyup":
                      SyntheticEventCtor = SyntheticKeyboardEvent;
                      break;
                    case "focusin":
                      reactEventType = "focus";
                      SyntheticEventCtor = SyntheticFocusEvent;
                      break;
                    case "focusout":
                      reactEventType = "blur";
                      SyntheticEventCtor = SyntheticFocusEvent;
                      break;
                    case "beforeblur":
                    case "afterblur":
                      SyntheticEventCtor = SyntheticFocusEvent;
                      break;
                    case "click":
                      if (2 === nativeEvent.button) break a;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                      SyntheticEventCtor = SyntheticMouseEvent;
                      break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                      SyntheticEventCtor = SyntheticDragEvent;
                      break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                      SyntheticEventCtor = SyntheticTouchEvent;
                      break;
                    case ANIMATION_END:
                    case ANIMATION_ITERATION:
                    case ANIMATION_START:
                      SyntheticEventCtor = SyntheticAnimationEvent;
                      break;
                    case TRANSITION_END:
                      SyntheticEventCtor = SyntheticTransitionEvent;
                      break;
                    case "scroll":
                    case "scrollend":
                      SyntheticEventCtor = SyntheticUIEvent;
                      break;
                    case "wheel":
                      SyntheticEventCtor = SyntheticWheelEvent;
                      break;
                    case "copy":
                    case "cut":
                    case "paste":
                      SyntheticEventCtor = SyntheticClipboardEvent;
                      break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                      SyntheticEventCtor = SyntheticPointerEvent;
                      break;
                    case "toggle":
                    case "beforetoggle":
                      SyntheticEventCtor = SyntheticToggleEvent;
                  }
                  var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                  inCapturePhase = [];
                  for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                    var _instance2 = instance;
                    lastHostComponent = _instance2.stateNode;
                    _instance2 = _instance2.tag;
                    5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                      createDispatchListener(
                        instance,
                        _instance2,
                        lastHostComponent
                      )
                    ));
                    if (accumulateTargetOnly) break;
                    instance = instance.return;
                  }
                  0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                    reactName,
                    reactEventType,
                    null,
                    nativeEvent,
                    nativeEventTarget
                  ), dispatchQueue.push({
                    event: reactName,
                    listeners: inCapturePhase
                  }));
                }
              }
              if (0 === (eventSystemFlags & 7)) {
                a: {
                  reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                  SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                  if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                    break a;
                  if (SyntheticEventCtor || reactName) {
                    reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                    if (SyntheticEventCtor) {
                      if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                        reactEventType = null;
                    } else SyntheticEventCtor = null, reactEventType = targetInst;
                    if (SyntheticEventCtor !== reactEventType) {
                      inCapturePhase = SyntheticMouseEvent;
                      _instance2 = "onMouseLeave";
                      reactEventName = "onMouseEnter";
                      instance = "mouse";
                      if ("pointerout" === domEventName || "pointerover" === domEventName)
                        inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                      accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                      lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                      reactName = new inCapturePhase(
                        _instance2,
                        instance + "leave",
                        SyntheticEventCtor,
                        nativeEvent,
                        nativeEventTarget
                      );
                      reactName.target = accumulateTargetOnly;
                      reactName.relatedTarget = lastHostComponent;
                      _instance2 = null;
                      getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                        reactEventName,
                        instance + "enter",
                        reactEventType,
                        nativeEvent,
                        nativeEventTarget
                      ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                      accumulateTargetOnly = _instance2;
                      if (SyntheticEventCtor && reactEventType)
                        b: {
                          inCapturePhase = SyntheticEventCtor;
                          reactEventName = reactEventType;
                          instance = 0;
                          for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                            instance++;
                          lastHostComponent = 0;
                          for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
                            lastHostComponent++;
                          for (; 0 < instance - lastHostComponent; )
                            inCapturePhase = getParent(inCapturePhase), instance--;
                          for (; 0 < lastHostComponent - instance; )
                            reactEventName = getParent(reactEventName), lastHostComponent--;
                          for (; instance--; ) {
                            if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                              break b;
                            inCapturePhase = getParent(inCapturePhase);
                            reactEventName = getParent(reactEventName);
                          }
                          inCapturePhase = null;
                        }
                      else inCapturePhase = null;
                      null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                        dispatchQueue,
                        reactName,
                        SyntheticEventCtor,
                        inCapturePhase,
                        false
                      );
                      null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                        dispatchQueue,
                        accumulateTargetOnly,
                        reactEventType,
                        inCapturePhase,
                        true
                      );
                    }
                  }
                }
                a: {
                  reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                  SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                  if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                    var getTargetInstFunc = getTargetInstForChangeEvent;
                  else if (isTextInputElement(reactName))
                    if (isInputEventSupported)
                      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                    else {
                      getTargetInstFunc = getTargetInstForInputEventPolyfill;
                      var handleEventFunc = handleEventsForInputEventPolyfill;
                    }
                  else
                    SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                  if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                    createAndAccumulateChangeEvent(
                      dispatchQueue,
                      getTargetInstFunc,
                      nativeEvent,
                      nativeEventTarget
                    );
                    break a;
                  }
                  handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                  "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
                }
                handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
                switch (domEventName) {
                  case "focusin":
                    if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                      activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                    break;
                  case "focusout":
                    lastSelection = activeElementInst = activeElement = null;
                    break;
                  case "mousedown":
                    mouseDown = true;
                    break;
                  case "contextmenu":
                  case "mouseup":
                  case "dragend":
                    mouseDown = false;
                    constructSelectEvent(
                      dispatchQueue,
                      nativeEvent,
                      nativeEventTarget
                    );
                    break;
                  case "selectionchange":
                    if (skipSelectionChangeEvent) break;
                  case "keydown":
                  case "keyup":
                    constructSelectEvent(
                      dispatchQueue,
                      nativeEvent,
                      nativeEventTarget
                    );
                }
                var fallbackData;
                if (canUseCompositionEvent)
                  b: {
                    switch (domEventName) {
                      case "compositionstart":
                        var eventType = "onCompositionStart";
                        break b;
                      case "compositionend":
                        eventType = "onCompositionEnd";
                        break b;
                      case "compositionupdate":
                        eventType = "onCompositionUpdate";
                        break b;
                    }
                    eventType = void 0;
                  }
                else
                  isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
                eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                  targetInst,
                  eventType
                ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                  eventType,
                  domEventName,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: eventType,
                  listeners: handleEventFunc
                }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
                if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                  eventType = accumulateTwoPhaseListeners(
                    targetInst,
                    "onBeforeInput"
                  ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                    "onBeforeInput",
                    "beforeinput",
                    null,
                    nativeEvent,
                    nativeEventTarget
                  ), dispatchQueue.push({
                    event: handleEventFunc,
                    listeners: eventType
                  }), handleEventFunc.data = fallbackData);
                extractEvents$1(
                  dispatchQueue,
                  domEventName,
                  targetInst,
                  nativeEvent,
                  nativeEventTarget
                );
              }
              processDispatchQueue(dispatchQueue, eventSystemFlags);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
              var _instance3 = targetFiber, stateNode = _instance3.stateNode;
              _instance3 = _instance3.tag;
              5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
                createDispatchListener(targetFiber, _instance3, stateNode)
              ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
                createDispatchListener(targetFiber, _instance3, stateNode)
              ));
              if (3 === targetFiber.tag) return listeners;
              targetFiber = targetFiber.return;
            }
            return [];
          }
          function getParent(inst) {
            if (null === inst) return null;
            do
              inst = inst.return;
            while (inst && 5 !== inst.tag && 27 !== inst.tag);
            return inst ? inst : null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
              var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
              _instance4 = _instance4.tag;
              if (null !== alternate && alternate === common) break;
              5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
                createDispatchListener(target, stateNode, alternate)
              )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
                createDispatchListener(target, stateNode, alternate)
              )));
              target = target.return;
            }
            0 !== listeners.length && dispatchQueue.push({ event, listeners });
          }
          function validatePropertiesInDevelopment(type, props) {
            validateProperties$2(type, props);
            "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
              "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
              type
            ) : console.error(
              "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
              type
            ));
            var eventRegistry = {
              registrationNameDependencies,
              possibleRegistrationNames
            };
            isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
            props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
              "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
            );
          }
          function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
            serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
          }
          function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
            attributeNames.forEach(function(attributeName) {
              serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
            });
          }
          function warnForInvalidEventListener(registrationName, listener) {
            false === listener ? console.error(
              "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
              registrationName,
              registrationName,
              registrationName
            ) : console.error(
              "Expected `%s` listener to be a function, instead got a value of `%s` type.",
              registrationName,
              typeof listener
            );
          }
          function normalizeHTML(parent, html) {
            parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
              parent.namespaceURI,
              parent.tagName
            ) : parent.ownerDocument.createElement(parent.tagName);
            parent.innerHTML = html;
            return parent.innerHTML;
          }
          function normalizeMarkupForTextOrAttribute(markup) {
            willCoercionThrow(markup) && (console.error(
              "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
              typeName(markup)
            ), testStringCoercion(markup));
            return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText) {
            clientText = normalizeMarkupForTextOrAttribute(clientText);
            return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
          }
          function noop$1() {
          }
          function setProp(domElement, tag, key, value, props, prevValue) {
            switch (key) {
              case "children":
                if ("string" === typeof value)
                  validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
                else if ("number" === typeof value || "bigint" === typeof value)
                  validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
                break;
              case "className":
                setValueForKnownAttribute(domElement, "class", value);
                break;
              case "tabIndex":
                setValueForKnownAttribute(domElement, "tabindex", value);
                break;
              case "dir":
              case "role":
              case "viewBox":
              case "width":
              case "height":
                setValueForKnownAttribute(domElement, key, value);
                break;
              case "style":
                setValueForStyles(domElement, value, prevValue);
                break;
              case "data":
                if ("object" !== tag) {
                  setValueForKnownAttribute(domElement, "data", value);
                  break;
                }
              case "src":
              case "href":
                if ("" === value && ("a" !== tag || "href" !== key)) {
                  "src" === key ? console.error(
                    'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                    key,
                    key
                  ) : console.error(
                    'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                    key,
                    key
                  );
                  domElement.removeAttribute(key);
                  break;
                }
                if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                  domElement.removeAttribute(key);
                  break;
                }
                checkAttributeStringCoercion(value, key);
                value = sanitizeURL("" + value);
                domElement.setAttribute(key, value);
                break;
              case "action":
              case "formAction":
                null != value && ("form" === tag ? "formAction" === key ? console.error(
                  "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
                ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                  "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
                )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                  "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
                ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                  "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
                ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                  'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
                )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                  "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
                )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                  "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
                ))) : (didWarnFormActionType = true, console.error(
                  'A button can only specify a formAction along with type="submit" or no type.'
                )) : (didWarnFormActionType = true, console.error(
                  'An input can only specify a formAction along with type="submit" or type="image".'
                )) : "action" === key ? console.error(
                  "You can only pass the action prop to <form>."
                ) : console.error(
                  "You can only pass the formAction prop to <input> or <button>."
                ));
                if ("function" === typeof value) {
                  domElement.setAttribute(
                    key,
                    "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                  );
                  break;
                } else
                  "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                    domElement,
                    tag,
                    "formEncType",
                    props.formEncType,
                    props,
                    null
                  ), setProp(
                    domElement,
                    tag,
                    "formMethod",
                    props.formMethod,
                    props,
                    null
                  ), setProp(
                    domElement,
                    tag,
                    "formTarget",
                    props.formTarget,
                    props,
                    null
                  )) : (setProp(
                    domElement,
                    tag,
                    "encType",
                    props.encType,
                    props,
                    null
                  ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                    domElement,
                    tag,
                    "target",
                    props.target,
                    props,
                    null
                  )));
                if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                  domElement.removeAttribute(key);
                  break;
                }
                checkAttributeStringCoercion(value, key);
                value = sanitizeURL("" + value);
                domElement.setAttribute(key, value);
                break;
              case "onClick":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
                break;
              case "onScroll":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
                break;
              case "onScrollEnd":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
                break;
              case "dangerouslySetInnerHTML":
                if (null != value) {
                  if ("object" !== typeof value || !("__html" in value))
                    throw Error(
                      "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                    );
                  key = value.__html;
                  if (null != key) {
                    if (null != props.children)
                      throw Error(
                        "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                      );
                    domElement.innerHTML = key;
                  }
                }
                break;
              case "multiple":
                domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
                break;
              case "muted":
                domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "ref":
                break;
              case "autoFocus":
                break;
              case "xlinkHref":
                if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                  domElement.removeAttribute("xlink:href");
                  break;
                }
                checkAttributeStringCoercion(value, key);
                key = sanitizeURL("" + value);
                domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
                break;
              case "contentEditable":
              case "spellCheck":
              case "draggable":
              case "value":
              case "autoReverse":
              case "externalResourcesRequired":
              case "focusable":
              case "preserveAlpha":
                null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
                break;
              case "inert":
                "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                  "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                  key
                ));
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
                value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
                break;
              case "capture":
              case "download":
                true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
                break;
              case "cols":
              case "rows":
              case "size":
              case "span":
                null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
                break;
              case "rowSpan":
              case "start":
                null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
                break;
              case "popover":
                listenToNonDelegatedEvent("beforetoggle", domElement);
                listenToNonDelegatedEvent("toggle", domElement);
                setValueForAttribute(domElement, "popover", value);
                break;
              case "xlinkActuate":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:actuate",
                  value
                );
                break;
              case "xlinkArcrole":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:arcrole",
                  value
                );
                break;
              case "xlinkRole":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:role",
                  value
                );
                break;
              case "xlinkShow":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:show",
                  value
                );
                break;
              case "xlinkTitle":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:title",
                  value
                );
                break;
              case "xlinkType":
                setValueForNamespacedAttribute(
                  domElement,
                  xlinkNamespace,
                  "xlink:type",
                  value
                );
                break;
              case "xmlBase":
                setValueForNamespacedAttribute(
                  domElement,
                  xmlNamespace,
                  "xml:base",
                  value
                );
                break;
              case "xmlLang":
                setValueForNamespacedAttribute(
                  domElement,
                  xmlNamespace,
                  "xml:lang",
                  value
                );
                break;
              case "xmlSpace":
                setValueForNamespacedAttribute(
                  domElement,
                  xmlNamespace,
                  "xml:space",
                  value
                );
                break;
              case "is":
                null != prevValue && console.error(
                  'Cannot update the "is" prop after it has been initialized.'
                );
                setValueForAttribute(domElement, "is", value);
                break;
              case "innerText":
              case "textContent":
                break;
              case "popoverTarget":
                didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                  "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                  value
                ));
              default:
                !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
            }
          }
          function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
            switch (key) {
              case "style":
                setValueForStyles(domElement, value, prevValue);
                break;
              case "dangerouslySetInnerHTML":
                if (null != value) {
                  if ("object" !== typeof value || !("__html" in value))
                    throw Error(
                      "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                    );
                  key = value.__html;
                  if (null != key) {
                    if (null != props.children)
                      throw Error(
                        "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                      );
                    domElement.innerHTML = key;
                  }
                }
                break;
              case "children":
                "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
                break;
              case "onScroll":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
                break;
              case "onScrollEnd":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
                break;
              case "onClick":
                null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
              case "innerHTML":
              case "ref":
                break;
              case "innerText":
              case "textContent":
                break;
              default:
                if (registrationNameDependencies.hasOwnProperty(key))
                  null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
                else
                  a: {
                    if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                      "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                      domElement.addEventListener(tag, value, props);
                      break a;
                    }
                    key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                  }
            }
          }
          function setInitialProperties(domElement, tag, props) {
            validatePropertiesInDevelopment(tag, props);
            switch (tag) {
              case "div":
              case "span":
              case "svg":
              case "path":
              case "a":
              case "g":
              case "p":
              case "li":
                break;
              case "img":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                var hasSrc = false, hasSrcSet = false, propKey;
                for (propKey in props)
                  if (props.hasOwnProperty(propKey)) {
                    var propValue = props[propKey];
                    if (null != propValue)
                      switch (propKey) {
                        case "src":
                          hasSrc = true;
                          break;
                        case "srcSet":
                          hasSrcSet = true;
                          break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        default:
                          setProp(domElement, tag, propKey, propValue, props, null);
                      }
                  }
                hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
                hasSrc && setProp(domElement, tag, "src", props.src, props, null);
                return;
              case "input":
                checkControlledValueProps("input", props);
                listenToNonDelegatedEvent("invalid", domElement);
                var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
                for (hasSrc in props)
                  if (props.hasOwnProperty(hasSrc)) {
                    var _propValue = props[hasSrc];
                    if (null != _propValue)
                      switch (hasSrc) {
                        case "name":
                          hasSrcSet = _propValue;
                          break;
                        case "type":
                          propValue = _propValue;
                          break;
                        case "checked":
                          checked = _propValue;
                          break;
                        case "defaultChecked":
                          defaultChecked = _propValue;
                          break;
                        case "value":
                          propKey = _propValue;
                          break;
                        case "defaultValue":
                          defaultValue = _propValue;
                          break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                          if (null != _propValue)
                            throw Error(
                              tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                            );
                          break;
                        default:
                          setProp(domElement, tag, hasSrc, _propValue, props, null);
                      }
                  }
                validateInputProps(domElement, props);
                initInput2(
                  domElement,
                  propKey,
                  defaultValue,
                  checked,
                  defaultChecked,
                  propValue,
                  hasSrcSet,
                  false
                );
                track(domElement);
                return;
              case "select":
                checkControlledValueProps("select", props);
                listenToNonDelegatedEvent("invalid", domElement);
                hasSrc = propValue = propKey = null;
                for (hasSrcSet in props)
                  if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                    switch (hasSrcSet) {
                      case "value":
                        propKey = defaultValue;
                        break;
                      case "defaultValue":
                        propValue = defaultValue;
                        break;
                      case "multiple":
                        hasSrc = defaultValue;
                      default:
                        setProp(
                          domElement,
                          tag,
                          hasSrcSet,
                          defaultValue,
                          props,
                          null
                        );
                    }
                validateSelectProps(domElement, props);
                tag = propKey;
                props = propValue;
                domElement.multiple = !!hasSrc;
                null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
                return;
              case "textarea":
                checkControlledValueProps("textarea", props);
                listenToNonDelegatedEvent("invalid", domElement);
                propKey = hasSrcSet = hasSrc = null;
                for (propValue in props)
                  if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                    switch (propValue) {
                      case "value":
                        hasSrc = defaultValue;
                        break;
                      case "defaultValue":
                        hasSrcSet = defaultValue;
                        break;
                      case "children":
                        propKey = defaultValue;
                        break;
                      case "dangerouslySetInnerHTML":
                        if (null != defaultValue)
                          throw Error(
                            "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                          );
                        break;
                      default:
                        setProp(
                          domElement,
                          tag,
                          propValue,
                          defaultValue,
                          props,
                          null
                        );
                    }
                validateTextareaProps(domElement, props);
                initTextarea(domElement, hasSrc, hasSrcSet, propKey);
                track(domElement);
                return;
              case "option":
                validateOptionProps(domElement, props);
                for (checked in props)
                  if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                    switch (checked) {
                      case "selected":
                        domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                        break;
                      default:
                        setProp(domElement, tag, checked, hasSrc, props, null);
                    }
                return;
              case "dialog":
                listenToNonDelegatedEvent("beforetoggle", domElement);
                listenToNonDelegatedEvent("toggle", domElement);
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                  listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
                break;
              case "image":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "embed":
              case "source":
              case "link":
                listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
              case "area":
              case "base":
              case "br":
              case "col":
              case "hr":
              case "keygen":
              case "meta":
              case "param":
              case "track":
              case "wbr":
              case "menuitem":
                for (defaultChecked in props)
                  if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                    switch (defaultChecked) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                    }
                return;
              default:
                if (isCustomElement(tag)) {
                  for (_propValue in props)
                    props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                      domElement,
                      tag,
                      _propValue,
                      hasSrc,
                      props,
                      void 0
                    ));
                  return;
                }
            }
            for (defaultValue in props)
              props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
          }
          function updateProperties(domElement, tag, lastProps, nextProps) {
            validatePropertiesInDevelopment(tag, nextProps);
            switch (tag) {
              case "div":
              case "span":
              case "svg":
              case "path":
              case "a":
              case "g":
              case "p":
              case "li":
                break;
              case "input":
                var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
                for (propKey in lastProps) {
                  var lastProp = lastProps[propKey];
                  if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                    switch (propKey) {
                      case "checked":
                        break;
                      case "value":
                        break;
                      case "defaultValue":
                        lastDefaultValue = lastProp;
                      default:
                        nextProps.hasOwnProperty(propKey) || setProp(
                          domElement,
                          tag,
                          propKey,
                          null,
                          nextProps,
                          lastProp
                        );
                    }
                }
                for (var _propKey8 in nextProps) {
                  var propKey = nextProps[_propKey8];
                  lastProp = lastProps[_propKey8];
                  if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                    switch (_propKey8) {
                      case "type":
                        type = propKey;
                        break;
                      case "name":
                        name = propKey;
                        break;
                      case "checked":
                        checked = propKey;
                        break;
                      case "defaultChecked":
                        defaultChecked = propKey;
                        break;
                      case "value":
                        value = propKey;
                        break;
                      case "defaultValue":
                        defaultValue = propKey;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != propKey)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        propKey !== lastProp && setProp(
                          domElement,
                          tag,
                          _propKey8,
                          propKey,
                          nextProps,
                          lastProp
                        );
                    }
                }
                tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
                nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
                tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                  "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
                ), didWarnUncontrolledToControlled = true);
                !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                  "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
                ), didWarnControlledToUncontrolled = true);
                updateInput(
                  domElement,
                  value,
                  defaultValue,
                  lastDefaultValue,
                  checked,
                  defaultChecked,
                  type,
                  name
                );
                return;
              case "select":
                propKey = value = defaultValue = _propKey8 = null;
                for (type in lastProps)
                  if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                    switch (type) {
                      case "value":
                        break;
                      case "multiple":
                        propKey = lastDefaultValue;
                      default:
                        nextProps.hasOwnProperty(type) || setProp(
                          domElement,
                          tag,
                          type,
                          null,
                          nextProps,
                          lastDefaultValue
                        );
                    }
                for (name in nextProps)
                  if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                    switch (name) {
                      case "value":
                        _propKey8 = type;
                        break;
                      case "defaultValue":
                        defaultValue = type;
                        break;
                      case "multiple":
                        value = type;
                      default:
                        type !== lastDefaultValue && setProp(
                          domElement,
                          tag,
                          name,
                          type,
                          nextProps,
                          lastDefaultValue
                        );
                    }
                nextProps = defaultValue;
                tag = value;
                lastProps = propKey;
                null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
                return;
              case "textarea":
                propKey = _propKey8 = null;
                for (defaultValue in lastProps)
                  if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                    switch (defaultValue) {
                      case "value":
                        break;
                      case "children":
                        break;
                      default:
                        setProp(domElement, tag, defaultValue, null, nextProps, name);
                    }
                for (value in nextProps)
                  if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                    switch (value) {
                      case "value":
                        _propKey8 = name;
                        break;
                      case "defaultValue":
                        propKey = name;
                        break;
                      case "children":
                        break;
                      case "dangerouslySetInnerHTML":
                        if (null != name)
                          throw Error(
                            "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                          );
                        break;
                      default:
                        name !== type && setProp(domElement, tag, value, name, nextProps, type);
                    }
                updateTextarea(domElement, _propKey8, propKey);
                return;
              case "option":
                for (var _propKey13 in lastProps)
                  if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                    switch (_propKey13) {
                      case "selected":
                        domElement.selected = false;
                        break;
                      default:
                        setProp(
                          domElement,
                          tag,
                          _propKey13,
                          null,
                          nextProps,
                          _propKey8
                        );
                    }
                for (lastDefaultValue in nextProps)
                  if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                    switch (lastDefaultValue) {
                      case "selected":
                        domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                        break;
                      default:
                        setProp(
                          domElement,
                          tag,
                          lastDefaultValue,
                          _propKey8,
                          nextProps,
                          propKey
                        );
                    }
                return;
              case "img":
              case "link":
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "keygen":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr":
              case "menuitem":
                for (var _propKey15 in lastProps)
                  _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                    domElement,
                    tag,
                    _propKey15,
                    null,
                    nextProps,
                    _propKey8
                  );
                for (checked in nextProps)
                  if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                    switch (checked) {
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propKey8)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(
                          domElement,
                          tag,
                          checked,
                          _propKey8,
                          nextProps,
                          propKey
                        );
                    }
                return;
              default:
                if (isCustomElement(tag)) {
                  for (var _propKey17 in lastProps)
                    _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                      domElement,
                      tag,
                      _propKey17,
                      void 0,
                      nextProps,
                      _propKey8
                    );
                  for (defaultChecked in nextProps)
                    _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                      domElement,
                      tag,
                      defaultChecked,
                      _propKey8,
                      nextProps,
                      propKey
                    );
                  return;
                }
            }
            for (var _propKey19 in lastProps)
              _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
            for (lastProp in nextProps)
              _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
          }
          function getPropNameFromAttributeName(attrName) {
            switch (attrName) {
              case "class":
                return "className";
              case "for":
                return "htmlFor";
              default:
                return attrName;
            }
          }
          function getStylesObjectFromElement(domElement) {
            var serverValueInObjectForm = {};
            domElement = domElement.style;
            for (var i2 = 0; i2 < domElement.length; i2++) {
              var styleName = domElement[i2];
              serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
            }
            return serverValueInObjectForm;
          }
          function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
            if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
              console.error(
                "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
              );
            else {
              var clientValue;
              var delimiter = clientValue = "", styleName;
              for (styleName in value$jscomp$0)
                if (value$jscomp$0.hasOwnProperty(styleName)) {
                  var value = value$jscomp$0[styleName];
                  null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
                }
              clientValue = clientValue || null;
              value$jscomp$0 = domElement.getAttribute("style");
              value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
            }
          }
          function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
            extraAttributes.delete(attributeName);
            domElement = domElement.getAttribute(attributeName);
            if (null === domElement)
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                  return;
              }
            else if (null != value)
              switch (typeof value) {
                case "function":
                case "symbol":
                case "boolean":
                  break;
                default:
                  if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                    return;
              }
            warnForPropDifference(propKey, domElement, value, serverDifferences);
          }
          function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
            extraAttributes.delete(attributeName);
            domElement = domElement.getAttribute(attributeName);
            if (null === domElement) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
              }
              if (!value) return;
            } else
              switch (typeof value) {
                case "function":
                case "symbol":
                  break;
                default:
                  if (value) return;
              }
            warnForPropDifference(propKey, domElement, value, serverDifferences);
          }
          function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
            extraAttributes.delete(attributeName);
            domElement = domElement.getAttribute(attributeName);
            if (null === domElement)
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  return;
              }
            else if (null != value)
              switch (typeof value) {
                case "function":
                case "symbol":
                  break;
                default:
                  if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                    return;
              }
            warnForPropDifference(propKey, domElement, value, serverDifferences);
          }
          function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
            extraAttributes.delete(attributeName);
            domElement = domElement.getAttribute(attributeName);
            if (null === domElement)
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                  return;
                default:
                  if (isNaN(value)) return;
              }
            else if (null != value)
              switch (typeof value) {
                case "function":
                case "symbol":
                case "boolean":
                  break;
                default:
                  if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                    return;
              }
            warnForPropDifference(propKey, domElement, value, serverDifferences);
          }
          function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
            extraAttributes.delete(attributeName);
            domElement = domElement.getAttribute(attributeName);
            if (null === domElement)
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                case "boolean":
                  return;
              }
            else if (null != value)
              switch (typeof value) {
                case "function":
                case "symbol":
                case "boolean":
                  break;
                default:
                  if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                    return;
              }
            warnForPropDifference(propKey, domElement, value, serverDifferences);
          }
          function diffHydratedProperties(domElement, tag, props, hostContext) {
            for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i2 = 0; i2 < attributes.length; i2++)
              switch (attributes[i2].name.toLowerCase()) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributes.add(attributes[i2].name);
              }
            if (isCustomElement(tag))
              for (var propKey in props) {
                if (props.hasOwnProperty(propKey)) {
                  var value = props[propKey];
                  if (null != value) {
                    if (registrationNameDependencies.hasOwnProperty(propKey))
                      "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                    else if (true !== props.suppressHydrationWarning)
                      switch (propKey) {
                        case "children":
                          "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                            "children",
                            domElement.textContent,
                            value,
                            serverDifferences
                          );
                          continue;
                        case "suppressContentEditableWarning":
                        case "suppressHydrationWarning":
                        case "defaultValue":
                        case "defaultChecked":
                        case "innerHTML":
                        case "ref":
                          continue;
                        case "dangerouslySetInnerHTML":
                          attributes = domElement.innerHTML;
                          value = value ? value.__html : void 0;
                          null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                            propKey,
                            attributes,
                            value,
                            serverDifferences
                          ));
                          continue;
                        case "style":
                          extraAttributes.delete(propKey);
                          diffHydratedStyles(domElement, value, serverDifferences);
                          continue;
                        case "offsetParent":
                        case "offsetTop":
                        case "offsetLeft":
                        case "offsetWidth":
                        case "offsetHeight":
                        case "isContentEditable":
                        case "outerText":
                        case "outerHTML":
                          extraAttributes.delete(propKey.toLowerCase());
                          console.error(
                            "Assignment to read-only property will result in a no-op: `%s`",
                            propKey
                          );
                          continue;
                        case "className":
                          extraAttributes.delete("class");
                          attributes = getValueForAttributeOnCustomComponent(
                            domElement,
                            "class",
                            value
                          );
                          warnForPropDifference(
                            "className",
                            attributes,
                            value,
                            serverDifferences
                          );
                          continue;
                        default:
                          hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                            domElement,
                            propKey,
                            value
                          ), warnForPropDifference(
                            propKey,
                            attributes,
                            value,
                            serverDifferences
                          );
                      }
                  }
                }
              }
            else
              for (value in props)
                if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                  if (registrationNameDependencies.hasOwnProperty(value))
                    "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                  else if (true !== props.suppressHydrationWarning)
                    switch (value) {
                      case "children":
                        "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "value":
                      case "checked":
                      case "selected":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        propKey = propKey ? propKey.__html : void 0;
                        null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                        continue;
                      case "className":
                        hydrateAttribute(
                          domElement,
                          value,
                          "class",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "tabIndex":
                        hydrateAttribute(
                          domElement,
                          value,
                          "tabindex",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "style":
                        extraAttributes.delete(value);
                        diffHydratedStyles(domElement, propKey, serverDifferences);
                        continue;
                      case "multiple":
                        extraAttributes.delete(value);
                        warnForPropDifference(
                          value,
                          domElement.multiple,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      case "muted":
                        extraAttributes.delete(value);
                        warnForPropDifference(
                          value,
                          domElement.muted,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      case "autoFocus":
                        extraAttributes.delete("autofocus");
                        warnForPropDifference(
                          value,
                          domElement.autofocus,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      case "data":
                        if ("object" !== tag) {
                          extraAttributes.delete(value);
                          attributes = domElement.getAttribute("data");
                          warnForPropDifference(
                            value,
                            attributes,
                            propKey,
                            serverDifferences
                          );
                          continue;
                        }
                      case "src":
                      case "href":
                        if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                          "src" === value ? console.error(
                            'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                            value,
                            value
                          ) : console.error(
                            'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                            value,
                            value
                          );
                          continue;
                        }
                        hydrateSanitizedAttribute(
                          domElement,
                          value,
                          value,
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "action":
                      case "formAction":
                        attributes = domElement.getAttribute(value);
                        if ("function" === typeof propKey) {
                          extraAttributes.delete(value.toLowerCase());
                          "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                          continue;
                        } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                          extraAttributes.delete(value.toLowerCase());
                          warnForPropDifference(
                            value,
                            "function",
                            propKey,
                            serverDifferences
                          );
                          continue;
                        }
                        hydrateSanitizedAttribute(
                          domElement,
                          value,
                          value.toLowerCase(),
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkHref":
                        hydrateSanitizedAttribute(
                          domElement,
                          value,
                          "xlink:href",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "contentEditable":
                        hydrateBooleanishAttribute(
                          domElement,
                          value,
                          "contenteditable",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "spellCheck":
                        hydrateBooleanishAttribute(
                          domElement,
                          value,
                          "spellcheck",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "draggable":
                      case "autoReverse":
                      case "externalResourcesRequired":
                      case "focusable":
                      case "preserveAlpha":
                        hydrateBooleanishAttribute(
                          domElement,
                          value,
                          value,
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "allowFullScreen":
                      case "async":
                      case "autoPlay":
                      case "controls":
                      case "default":
                      case "defer":
                      case "disabled":
                      case "disablePictureInPicture":
                      case "disableRemotePlayback":
                      case "formNoValidate":
                      case "hidden":
                      case "loop":
                      case "noModule":
                      case "noValidate":
                      case "open":
                      case "playsInline":
                      case "readOnly":
                      case "required":
                      case "reversed":
                      case "scoped":
                      case "seamless":
                      case "itemScope":
                        hydrateBooleanAttribute(
                          domElement,
                          value,
                          value.toLowerCase(),
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "capture":
                      case "download":
                        a: {
                          i2 = domElement;
                          var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                          extraAttributes.delete(attributeName);
                          i2 = i2.getAttribute(attributeName);
                          if (null === i2)
                            switch (typeof propKey) {
                              case "undefined":
                              case "function":
                              case "symbol":
                                break a;
                              default:
                                if (false === propKey) break a;
                            }
                          else if (null != propKey)
                            switch (typeof propKey) {
                              case "function":
                              case "symbol":
                                break;
                              case "boolean":
                                if (true === propKey && "" === i2) break a;
                                break;
                              default:
                                if (checkAttributeStringCoercion(propKey, attributes), i2 === "" + propKey)
                                  break a;
                            }
                          warnForPropDifference(
                            attributes,
                            i2,
                            propKey,
                            serverDifferences$jscomp$0
                          );
                        }
                        continue;
                      case "cols":
                      case "rows":
                      case "size":
                      case "span":
                        a: {
                          i2 = domElement;
                          attributeName = attributes = value;
                          serverDifferences$jscomp$0 = serverDifferences;
                          extraAttributes.delete(attributeName);
                          i2 = i2.getAttribute(attributeName);
                          if (null === i2)
                            switch (typeof propKey) {
                              case "undefined":
                              case "function":
                              case "symbol":
                              case "boolean":
                                break a;
                              default:
                                if (isNaN(propKey) || 1 > propKey) break a;
                            }
                          else if (null != propKey)
                            switch (typeof propKey) {
                              case "function":
                              case "symbol":
                              case "boolean":
                                break;
                              default:
                                if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i2 === "" + propKey))
                                  break a;
                            }
                          warnForPropDifference(
                            attributes,
                            i2,
                            propKey,
                            serverDifferences$jscomp$0
                          );
                        }
                        continue;
                      case "rowSpan":
                        hydrateNumericAttribute(
                          domElement,
                          value,
                          "rowspan",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "start":
                        hydrateNumericAttribute(
                          domElement,
                          value,
                          value,
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xHeight":
                        hydrateAttribute(
                          domElement,
                          value,
                          "x-height",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkActuate":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:actuate",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkArcrole":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:arcrole",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkRole":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:role",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkShow":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:show",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkTitle":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:title",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xlinkType":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xlink:type",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xmlBase":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xml:base",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xmlLang":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xml:lang",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "xmlSpace":
                        hydrateAttribute(
                          domElement,
                          value,
                          "xml:space",
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      case "inert":
                        "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                          "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                          value
                        ));
                        hydrateBooleanAttribute(
                          domElement,
                          value,
                          value,
                          propKey,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      default:
                        if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                          i2 = getAttributeAlias(value);
                          attributes = false;
                          hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i2.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                            attributeName
                          ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i2));
                          a: if (attributeName = domElement, serverDifferences$jscomp$0 = i2, i2 = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                            if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                              attributeName = attributeName.getAttribute(
                                serverDifferences$jscomp$0
                              ), checkAttributeStringCoercion(
                                i2,
                                serverDifferences$jscomp$0
                              ), i2 = attributeName === "" + i2 ? i2 : attributeName;
                            else {
                              switch (typeof i2) {
                                case "function":
                                case "symbol":
                                  break a;
                                case "boolean":
                                  if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                    break a;
                              }
                              i2 = void 0 === i2 ? void 0 : null;
                            }
                          else i2 = void 0;
                          attributes || warnForPropDifference(
                            value,
                            i2,
                            propKey,
                            serverDifferences
                          );
                        }
                    }
                }
            0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
            return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
          }
          function propNamesListJoin(list, combinator) {
            switch (list.length) {
              case 0:
                return "";
              case 1:
                return list[0];
              case 2:
                return list[0] + " " + combinator + " " + list[1];
              default:
                return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function getOwnHostContext(namespaceURI) {
            switch (namespaceURI) {
              case SVG_NAMESPACE:
                return HostContextNamespaceSvg;
              case MATH_NAMESPACE:
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          }
          function getChildHostContextProd(parentNamespace, type) {
            if (parentNamespace === HostContextNamespaceNone)
              switch (type) {
                case "svg":
                  return HostContextNamespaceSvg;
                case "math":
                  return HostContextNamespaceMath;
                default:
                  return HostContextNamespaceNone;
              }
            return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
          }
          function shouldSetTextContent(type, props) {
            return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
          }
          function shouldAttemptEagerTransition() {
            var event = window.event;
            if (event && "popstate" === event.type) {
              if (event === currentPopstateTransitionEvent) return false;
              currentPopstateTransitionEvent = event;
              return true;
            }
            currentPopstateTransitionEvent = null;
            return false;
          }
          function handleErrorInNextTick(error) {
            setTimeout(function() {
              throw error;
            });
          }
          function commitMount(domElement, type, newProps) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                newProps.autoFocus && domElement.focus();
                break;
              case "img":
                newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
            }
          }
          function commitUpdate(domElement, type, oldProps, newProps) {
            updateProperties(domElement, type, oldProps, newProps);
            domElement[internalPropsKey] = newProps;
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function isSingletonScope(type) {
            return "head" === type;
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && 8 === nextNode.nodeType)
                if (node = nextNode.data, node === SUSPENSE_END_DATA) {
                  if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                    node = possiblePreambleContribution;
                    var ownerDocument = parentInstance.ownerDocument;
                    node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
                    node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
                    if (node & PREAMBLE_CONTRIBUTION_HEAD)
                      for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                        var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                        ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                        ownerDocument = nextNode$jscomp$0;
                      }
                  }
                  if (0 === depth) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  }
                  depth--;
                } else
                  node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
              else possiblePreambleContribution = 0;
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function hideInstance(instance) {
            instance = instance.style;
            "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            props = props[STYLE];
            props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
            instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainerSparingly(container) {
            var nextNode = container.firstChild;
            nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
            for (; nextNode; ) {
              var node = nextNode;
              nextNode = nextNode.nextSibling;
              switch (node.nodeName) {
                case "HTML":
                case "HEAD":
                case "BODY":
                  clearContainerSparingly(node);
                  detachDeletedInstance(node);
                  continue;
                case "SCRIPT":
                case "STYLE":
                  continue;
                case "LINK":
                  if ("stylesheet" === node.rel.toLowerCase()) continue;
              }
              container.removeChild(node);
            }
          }
          function canHydrateInstance(instance, type, props, inRootOrSingleton) {
            for (; 1 === instance.nodeType; ) {
              var anyProps = props;
              if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
                if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                  break;
              } else if (!inRootOrSingleton)
                if ("input" === type && "hidden" === instance.type) {
                  checkAttributeStringCoercion(anyProps.name, "name");
                  var name = null == anyProps.name ? null : "" + anyProps.name;
                  if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                    return instance;
                } else return instance;
              else if (!instance[internalHoistableMarker])
                switch (type) {
                  case "meta":
                    if (!instance.hasAttribute("itemprop")) break;
                    return instance;
                  case "link":
                    name = instance.getAttribute("rel");
                    if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                      break;
                    else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                      break;
                    return instance;
                  case "style":
                    if (instance.hasAttribute("data-precedence")) break;
                    return instance;
                  case "script":
                    name = instance.getAttribute("src");
                    if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                      break;
                    return instance;
                  default:
                    return instance;
                }
              instance = getNextHydratable(instance.nextSibling);
              if (null === instance) break;
            }
            return null;
          }
          function canHydrateTextInstance(instance, text, inRootOrSingleton) {
            if ("" === text) return null;
            for (; 3 !== instance.nodeType; ) {
              if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
                return null;
              instance = getNextHydratable(instance.nextSibling);
              if (null === instance) return null;
            }
            return instance;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            var ownerDocument = instance.ownerDocument;
            if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
              callback();
            else {
              var listener = function() {
                callback();
                ownerDocument.removeEventListener("DOMContentLoaded", listener);
              };
              ownerDocument.addEventListener("DOMContentLoaded", listener);
              instance._reactRetry = listener;
            }
          }
          function getNextHydratable(node) {
            for (; null != node; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (1 === nodeType || 3 === nodeType) break;
              if (8 === nodeType) {
                nodeType = node.data;
                if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                  break;
                if (nodeType === SUSPENSE_END_DATA) return null;
              }
            }
            return node;
          }
          function describeHydratableInstanceForDevWarnings(instance) {
            if (1 === instance.nodeType) {
              for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i2 = 0; i2 < attributes.length; i2++) {
                var attr = attributes[i2];
                serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
              }
              return { type: JSCompiler_temp_const, props: serverDifferences };
            }
            return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
          }
          function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
            return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            suspenseInstance = suspenseInstance.nextSibling;
            for (var depth = 0; suspenseInstance; ) {
              if (8 === suspenseInstance.nodeType) {
                var data = suspenseInstance.data;
                if (data === SUSPENSE_END_DATA) {
                  if (0 === depth)
                    return getNextHydratable(suspenseInstance.nextSibling);
                  depth--;
                } else
                  data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
              }
              suspenseInstance = suspenseInstance.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            targetInstance = targetInstance.previousSibling;
            for (var depth = 0; targetInstance; ) {
              if (8 === targetInstance.nodeType) {
                var data = targetInstance.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (0 === depth) return targetInstance;
                  depth--;
                } else data === SUSPENSE_END_DATA && depth++;
              }
              targetInstance = targetInstance.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
            validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
            props = getOwnerDocumentFromRootContainer(rootContainerInstance);
            switch (type) {
              case "html":
                type = props.documentElement;
                if (!type)
                  throw Error(
                    "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                  );
                return type;
              case "head":
                type = props.head;
                if (!type)
                  throw Error(
                    "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                  );
                return type;
              case "body":
                type = props.body;
                if (!type)
                  throw Error(
                    "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                  );
                return type;
              default:
                throw Error(
                  "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
                );
            }
          }
          function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
            if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
              var tagName = instance.tagName.toLowerCase();
              console.error(
                "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
                tagName,
                tagName,
                tagName
              );
            }
            switch (type) {
              case "html":
              case "head":
              case "body":
                break;
              default:
                console.error(
                  "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
                );
            }
            for (tagName = instance.attributes; tagName.length; )
              instance.removeAttributeNode(tagName[0]);
            setInitialProperties(instance, type, props);
            instance[internalInstanceKey] = internalInstanceHandle;
            instance[internalPropsKey] = props;
          }
          function releaseSingletonInstance(instance) {
            for (var attributes = instance.attributes; attributes.length; )
              instance.removeAttributeNode(attributes[0]);
            detachDeletedInstance(instance);
          }
          function getHoistableRoot(container) {
            return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
          }
          function preconnectAs(rel, href, crossOrigin) {
            var ownerDocument = globalDocument;
            if (ownerDocument && "string" === typeof href && href) {
              var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
              limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
              "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
              preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
            }
          }
          function getResource(type, currentProps, pendingProps, currentResource) {
            var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
            if (!resourceRoot)
              throw Error(
                '"resourceRoot" was expected to exist. This is a bug in React.'
              );
            switch (type) {
              case "meta":
              case "title":
                return null;
              case "style":
                return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                  type: "style",
                  instance: null,
                  count: 0,
                  state: null
                }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
              case "link":
                if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                  type = getStyleKey(pendingProps.href);
                  var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                  if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: { loading: NotLoaded, preload: null }
                  }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                    getStylesheetSelectorFromKey(type)
                  )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                    var preloadProps = {
                      rel: "preload",
                      as: "style",
                      href: pendingProps.href,
                      crossOrigin: pendingProps.crossOrigin,
                      integrity: pendingProps.integrity,
                      media: pendingProps.media,
                      hrefLang: pendingProps.hrefLang,
                      referrerPolicy: pendingProps.referrerPolicy
                    };
                    preloadPropsMap.set(type, preloadProps);
                    _styles || preloadStylesheet(
                      resourceRoot,
                      type,
                      preloadProps,
                      _resource.state
                    );
                  }
                  if (currentProps && null === currentResource)
                    throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                      "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                    );
                  return _resource;
                }
                if (currentProps && null !== currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return null;
              case "script":
                return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                  type: "script",
                  instance: null,
                  count: 0,
                  state: null
                }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
              default:
                throw Error(
                  'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
                );
            }
          }
          function describeLinkForResourceErrorDEV(props) {
            var describedProps = 0, description = "<link";
            "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
            "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
            "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
            Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
            return description + " />";
          }
          function getStyleKey(href) {
            return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
          }
          function getStylesheetSelectorFromKey(key) {
            return 'link[rel="stylesheet"][' + key + "]";
          }
          function stylesheetPropsFromRawProps(rawProps) {
            return assign({}, rawProps, {
              "data-precedence": rawProps.precedence,
              precedence: null
            });
          }
          function preloadStylesheet(ownerDocument, key, preloadProps, state) {
            ownerDocument.querySelector(
              'link[rel="preload"][as="style"][' + key + "]"
            ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
              return state.loading |= Loaded;
            }), key.addEventListener("error", function() {
              return state.loading |= Errored;
            }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
          }
          function getScriptKey(src) {
            return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
          }
          function getScriptSelectorFromKey(key) {
            return "script[async]" + key;
          }
          function acquireResource(hoistableRoot, resource, props) {
            resource.count++;
            if (null === resource.instance)
              switch (resource.type) {
                case "style":
                  var instance = hoistableRoot.querySelector(
                    'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                  );
                  if (instance)
                    return resource.instance = instance, markNodeAsHoistable(instance), instance;
                  var styleProps = assign({}, props, {
                    "data-href": props.href,
                    "data-precedence": props.precedence,
                    href: null,
                    precedence: null
                  });
                  instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                  markNodeAsHoistable(instance);
                  setInitialProperties(instance, "style", styleProps);
                  insertStylesheet(instance, props.precedence, hoistableRoot);
                  return resource.instance = instance;
                case "stylesheet":
                  styleProps = getStyleKey(props.href);
                  var _instance = hoistableRoot.querySelector(
                    getStylesheetSelectorFromKey(styleProps)
                  );
                  if (_instance)
                    return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                  instance = stylesheetPropsFromRawProps(props);
                  (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                  _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                  markNodeAsHoistable(_instance);
                  var linkInstance = _instance;
                  linkInstance._p = new Promise(function(resolve, reject) {
                    linkInstance.onload = resolve;
                    linkInstance.onerror = reject;
                  });
                  setInitialProperties(_instance, "link", instance);
                  resource.state.loading |= Inserted;
                  insertStylesheet(_instance, props.precedence, hoistableRoot);
                  return resource.instance = _instance;
                case "script":
                  _instance = getScriptKey(props.src);
                  if (styleProps = hoistableRoot.querySelector(
                    getScriptSelectorFromKey(_instance)
                  ))
                    return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                  instance = props;
                  if (styleProps = preloadPropsMap.get(_instance))
                    instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                  styleProps = hoistableRoot.createElement("script");
                  markNodeAsHoistable(styleProps);
                  setInitialProperties(styleProps, "link", instance);
                  hoistableRoot.head.appendChild(styleProps);
                  return resource.instance = styleProps;
                case "void":
                  return null;
                default:
                  throw Error(
                    'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                  );
              }
            else
              "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
            return resource.instance;
          }
          function insertStylesheet(instance, precedence, root2) {
            for (var nodes = root2.querySelectorAll(
              'link[rel="stylesheet"][data-precedence],style[data-precedence]'
            ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
              var node = nodes[i2];
              if (node.dataset.precedence === precedence) prior = node;
              else if (prior !== last) break;
            }
            prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
          }
          function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
            null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
            null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
            null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
          }
          function adoptPreloadPropsForScript(scriptProps, preloadProps) {
            null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
            null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
            null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
          }
          function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
            if (null === tagCaches) {
              var cache = /* @__PURE__ */ new Map();
              var caches = tagCaches = /* @__PURE__ */ new Map();
              caches.set(ownerDocument, cache);
            } else
              caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
            if (cache.has(type)) return cache;
            cache.set(type, null);
            ownerDocument = ownerDocument.getElementsByTagName(type);
            for (caches = 0; caches < ownerDocument.length; caches++) {
              var node = ownerDocument[caches];
              if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
                var nodeKey = node.getAttribute(keyAttribute) || "";
                nodeKey = type + nodeKey;
                var existing = cache.get(nodeKey);
                existing ? existing.push(node) : cache.set(nodeKey, [node]);
              }
            }
            return cache;
          }
          function mountHoistable(hoistableRoot, type, instance) {
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            hoistableRoot.head.insertBefore(
              instance,
              "title" === type ? hoistableRoot.querySelector("head > title") : null
            );
          }
          function isHostHoistableType(type, props, hostContext) {
            var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
            if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
              return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
                "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
                type,
                type
              ), false;
            switch (type) {
              case "meta":
              case "title":
                return true;
              case "style":
                if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                  outsideHostContainerContext && console.error(
                    'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                  );
                  break;
                }
                return true;
              case "link":
                if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                  if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                    type = props.href;
                    var onError = props.onError, disabled = props.disabled;
                    hostContext = [];
                    props.onLoad && hostContext.push("`onLoad`");
                    onError && hostContext.push("`onError`");
                    null != disabled && hostContext.push("`disabled`");
                    onError = propNamesListJoin(hostContext, "and");
                    onError += 1 === hostContext.length ? " prop" : " props";
                    disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                    hostContext.length && console.error(
                      'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                      type,
                      disabled,
                      onError
                    );
                  }
                  outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                    "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                  ) : (props.onError || props.onLoad) && console.error(
                    "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                  ));
                  break;
                }
                switch (props.rel) {
                  case "stylesheet":
                    return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                      'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                    ), "string" === typeof type && null == props;
                  default:
                    return true;
                }
              case "script":
                type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
                if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                  outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                    "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                  ) : console.error(
                    "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                  ) : console.error(
                    'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                  ));
                  break;
                }
                return true;
              case "noscript":
              case "template":
                outsideHostContainerContext && console.error(
                  "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                  type
                );
            }
            return false;
          }
          function preloadResource(resource) {
            return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
          }
          function noop() {
          }
          function suspendResource(hoistableRoot, resource, props) {
            if (null === suspendedState)
              throw Error(
                "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
              );
            var state = suspendedState;
            if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
              if (null === resource.instance) {
                var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(key)
                );
                if (instance) {
                  hoistableRoot = instance._p;
                  null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                  resource.state.loading |= Inserted;
                  resource.instance = instance;
                  markNodeAsHoistable(instance);
                  return;
                }
                instance = hoistableRoot.ownerDocument || hoistableRoot;
                props = stylesheetPropsFromRawProps(props);
                (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
                instance = instance.createElement("link");
                markNodeAsHoistable(instance);
                var linkInstance = instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(instance, "link", props);
                resource.instance = instance;
              }
              null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
              state.stylesheets.set(resource, hoistableRoot);
              (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
            }
          }
          function waitForCommitToBeReady() {
            if (null === suspendedState)
              throw Error(
                "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
              );
            var state = suspendedState;
            state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
            return 0 < state.count ? function(commit) {
              var stylesheetTimer = setTimeout(function() {
                state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
                if (state.unsuspend) {
                  var unsuspend = state.unsuspend;
                  state.unsuspend = null;
                  unsuspend();
                }
              }, 6e4);
              state.unsuspend = commit;
              return function() {
                state.unsuspend = null;
                clearTimeout(stylesheetTimer);
              };
            } : null;
          }
          function onUnsuspend() {
            this.count--;
            if (0 === this.count) {
              if (this.stylesheets)
                insertSuspendedStylesheets(this, this.stylesheets);
              else if (this.unsuspend) {
                var unsuspend = this.unsuspend;
                this.unsuspend = null;
                unsuspend();
              }
            }
          }
          function insertSuspendedStylesheets(state, resources) {
            state.stylesheets = null;
            null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
          }
          function insertStylesheetIntoRoot(root2, resource) {
            if (!(resource.state.loading & Inserted)) {
              var precedences = precedencesByRoot.get(root2);
              if (precedences) var last = precedences.get(LAST_PRECEDENCE);
              else {
                precedences = /* @__PURE__ */ new Map();
                precedencesByRoot.set(root2, precedences);
                for (var nodes = root2.querySelectorAll(
                  "link[data-precedence],style[data-precedence]"
                ), i2 = 0; i2 < nodes.length; i2++) {
                  var node = nodes[i2];
                  if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                    precedences.set(node.dataset.precedence, node), last = node;
                }
                last && precedences.set(LAST_PRECEDENCE, last);
              }
              nodes = resource.instance;
              node = nodes.getAttribute("data-precedence");
              i2 = precedences.get(node) || last;
              i2 === last && precedences.set(LAST_PRECEDENCE, nodes);
              precedences.set(node, nodes);
              this.count++;
              last = onUnsuspend.bind(this);
              nodes.addEventListener("load", last);
              nodes.addEventListener("error", last);
              i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
              resource.state.loading |= Inserted;
            }
          }
          function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
            this.tag = 1;
            this.containerInfo = containerInfo;
            this.pingCache = this.current = this.pendingChildren = null;
            this.timeoutHandle = noTimeout;
            this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
            this.callbackPriority = 0;
            this.expirationTimes = createLaneMap(-1);
            this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
            this.entanglements = createLaneMap(0);
            this.hiddenUpdates = createLaneMap(null);
            this.identifierPrefix = identifierPrefix;
            this.onUncaughtError = onUncaughtError;
            this.onCaughtError = onCaughtError;
            this.onRecoverableError = onRecoverableError;
            this.pooledCache = null;
            this.pooledCacheLanes = 0;
            this.formState = formState;
            this.incompleteTransitions = /* @__PURE__ */ new Map();
            this.passiveEffectDuration = this.effectDuration = -0;
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            containerInfo = this.pendingUpdatersLaneMap = [];
            for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
            this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
          }
          function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
            containerInfo = new FiberRootNode(
              containerInfo,
              tag,
              hydrate,
              identifierPrefix,
              onUncaughtError,
              onCaughtError,
              onRecoverableError,
              formState
            );
            tag = ConcurrentMode;
            true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
            isDevToolsPresent && (tag |= ProfileMode);
            isStrictMode = createFiber(3, null, null, tag);
            containerInfo.current = isStrictMode;
            isStrictMode.stateNode = containerInfo;
            tag = createCache();
            retainCache(tag);
            containerInfo.pooledCache = tag;
            retainCache(tag);
            isStrictMode.memoizedState = {
              element: initialChildren,
              isDehydrated: hydrate,
              cache: tag
            };
            initializeUpdateQueue(isStrictMode);
            return containerInfo;
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) return emptyContextObject;
            parentComponent = emptyContextObject;
            return parentComponent;
          }
          function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
            if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
              try {
                injectedHook.onScheduleFiberRoot(rendererID, container, element);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
            parentComponent = getContextForSubtree(parentComponent);
            null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
            isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
              "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
              getComponentNameFromFiber(current) || "Unknown"
            ));
            container = createUpdate(lane);
            container.payload = { element };
            callback = void 0 === callback ? null : callback;
            null !== callback && ("function" !== typeof callback && console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ), container.callback = callback);
            element = enqueueUpdate(rootFiber, container, lane);
            null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
          }
          function markRetryLaneImpl(fiber, retryLane) {
            fiber = fiber.memoizedState;
            if (null !== fiber && null !== fiber.dehydrated) {
              var a = fiber.retryLane;
              fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
          }
          function attemptContinuousHydration(fiber) {
            if (13 === fiber.tag) {
              var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
              null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
              markRetryLaneIfNotHydrated(fiber, 67108864);
            }
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function getLaneLabelMap() {
            for (var map2 = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
              var label = getLabelForLane(lane);
              map2.set(lane, label);
              lane *= 2;
            }
            return map2;
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var prevTransition = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
              ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var prevTransition = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
              ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
            }
          }
          function dispatchEvent2(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (_enabled) {
              var blockedOn = findInstanceBlockingEvent(nativeEvent);
              if (null === blockedOn)
                dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                ), clearIfContinuousEvent(domEventName, nativeEvent);
              else if (queueIfContinuousEvent(
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ))
                nativeEvent.stopPropagation();
              else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
                for (; null !== blockedOn; ) {
                  var fiber = getInstanceFromNode(blockedOn);
                  if (null !== fiber)
                    switch (fiber.tag) {
                      case 3:
                        fiber = fiber.stateNode;
                        if (fiber.current.memoizedState.isDehydrated) {
                          var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                          if (0 !== lanes) {
                            var root2 = fiber;
                            root2.pendingLanes |= 2;
                            for (root2.entangledLanes |= 2; lanes; ) {
                              var lane = 1 << 31 - clz32(lanes);
                              root2.entanglements[1] |= lane;
                              lanes &= ~lane;
                            }
                            ensureRootIsScheduled(fiber);
                            (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                          }
                        }
                        break;
                      case 13:
                        root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                    }
                  fiber = findInstanceBlockingEvent(nativeEvent);
                  null === fiber && dispatchEventForPluginEventSystem(
                    domEventName,
                    eventSystemFlags,
                    nativeEvent,
                    return_targetInst,
                    targetContainer
                  );
                  if (fiber === blockedOn) break;
                  blockedOn = fiber;
                }
                null !== blockedOn && nativeEvent.stopPropagation();
              } else
                dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  null,
                  targetContainer
                );
            }
          }
          function findInstanceBlockingEvent(nativeEvent) {
            nativeEvent = getEventTarget(nativeEvent);
            return findInstanceBlockingTarget(nativeEvent);
          }
          function findInstanceBlockingTarget(targetNode) {
            return_targetInst = null;
            targetNode = getClosestInstanceFromNode(targetNode);
            if (null !== targetNode) {
              var nearestMounted = getNearestMountedFiber(targetNode);
              if (null === nearestMounted) targetNode = null;
              else {
                var tag = nearestMounted.tag;
                if (13 === tag) {
                  targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                  if (null !== targetNode) return targetNode;
                  targetNode = null;
                } else if (3 === tag) {
                  if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                    return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                  targetNode = null;
                } else nearestMounted !== targetNode && (targetNode = null);
              }
            }
            return_targetInst = targetNode;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "beforetoggle":
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "toggle":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message":
                switch (getCurrentPriorityLevel()) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority$1:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              default:
                return DefaultEventPriority;
            }
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout":
                queuedPointers.delete(nativeEvent.pointerId);
                break;
              case "gotpointercapture":
              case "lostpointercapture":
                queuedPointerCaptures.delete(nativeEvent.pointerId);
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
              return existingQueuedEvent = {
                blockedOn,
                domEventName,
                eventSystemFlags,
                nativeEvent,
                targetContainers: [targetContainer]
              }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            blockedOn = existingQueuedEvent.targetContainers;
            null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin":
                return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedFocus,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                ), true;
              case "dragenter":
                return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedDrag,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                ), true;
              case "mouseover":
                return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedMouse,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                ), true;
              case "pointerover":
                var pointerId = nativeEvent.pointerId;
                queuedPointers.set(
                  pointerId,
                  accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedPointers.get(pointerId) || null,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent
                  )
                );
                return true;
              case "gotpointercapture":
                return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                  pointerId,
                  accumulateOrCreateContinuousQueuedReplayableEvent(
                    queuedPointerCaptures.get(pointerId) || null,
                    blockedOn,
                    domEventName,
                    eventSystemFlags,
                    targetContainer,
                    nativeEvent
                  )
                ), true;
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (null !== targetInst) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (null !== nearestMounted) {
                if (targetInst = nearestMounted.tag, 13 === targetInst) {
                  if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                    queuedTarget.blockedOn = targetInst;
                    runWithPriority(queuedTarget.priority, function() {
                      if (13 === nearestMounted.tag) {
                        var lane = requestUpdateLane(nearestMounted);
                        lane = getBumpedLaneForHydrationByLane(lane);
                        var root2 = enqueueConcurrentRenderForLane(
                          nearestMounted,
                          lane
                        );
                        null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                        markRetryLaneIfNotHydrated(nearestMounted, lane);
                      }
                    });
                    return;
                  }
                } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                  queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                  return;
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (null !== queuedEvent.blockedOn) return false;
            for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
              if (null === nextBlockedOn) {
                nextBlockedOn = queuedEvent.nativeEvent;
                var nativeEventClone = new nextBlockedOn.constructor(
                  nextBlockedOn.type,
                  nextBlockedOn
                ), event = nativeEventClone;
                null !== currentReplayingEvent && console.error(
                  "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
                );
                currentReplayingEvent = event;
                nextBlockedOn.target.dispatchEvent(nativeEventClone);
                null === currentReplayingEvent && console.error(
                  "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
                );
                currentReplayingEvent = null;
              } else
                return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
            attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
            null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
            null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
              Scheduler.unstable_NormalPriority,
              replayUnblockedEvents
            )));
          }
          function scheduleReplayQueueIfNeeded(formReplayingQueue) {
            lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
              Scheduler.unstable_NormalPriority,
              function() {
                lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
                for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
                  var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
                  if ("function" !== typeof submitterOrAction)
                    if (null === findInstanceBlockingTarget(submitterOrAction || form))
                      continue;
                    else break;
                  var formInst = getInstanceFromNode(form);
                  null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, form = {
                    pending: true,
                    data: formData,
                    method: form.method,
                    action: submitterOrAction
                  }, Object.freeze(form), startHostTransition(
                    formInst,
                    form,
                    submitterOrAction,
                    formData
                  ));
                }
              }
            ));
          }
          function retryIfBlockedOn(unblocked) {
            function unblock(queuedEvent) {
              return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
            }
            null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
              var queuedTarget = queuedExplicitHydrationTargets[i2];
              queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
            }
            for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
              attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
            i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
            if (null != i2)
              for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
                var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
                if ("function" === typeof submitterOrAction)
                  formProps || scheduleReplayQueueIfNeeded(i2);
                else if (formProps) {
                  var action = null;
                  if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                    if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                      action = formProps.formAction;
                    else {
                      if (null !== findInstanceBlockingTarget(form)) continue;
                    }
                  else action = formProps.action;
                  "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
                  scheduleReplayQueueIfNeeded(i2);
                }
              }
          }
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function warnIfReactDOMContainerInDEV(container) {
            container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
              "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
            ) : console.error(
              "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
            ));
          }
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
          var Scheduler = require_scheduler(), React4 = require_react(), ReactDOM2 = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
          Symbol.for("react.scope");
          var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
          Symbol.for("react.legacy_hidden");
          Symbol.for("react.tracing_marker");
          var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
          Symbol.for("react.view_transition");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
            pending: false,
            data: null,
            method: null,
            action: null
          }), valueStack = [];
          var fiberStack = [];
          var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
            "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
          ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
          disabledLog.__reactDisabledLog = true;
          var prefix, suffix, reentry = false;
          var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
          var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
          var didWarnValueDefaultValue = false;
          var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
            " "
          ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
            " "
          ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null,
            containerTagInScope: null,
            implicitRootScope: false
          }, didWarn = {}, shorthandToLonghand = {
            animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
              " "
            ),
            background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
              " "
            ),
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
              " "
            ),
            borderBlockEnd: [
              "borderBlockEndColor",
              "borderBlockEndStyle",
              "borderBlockEndWidth"
            ],
            borderBlockStart: [
              "borderBlockStartColor",
              "borderBlockStartStyle",
              "borderBlockStartWidth"
            ],
            borderBottom: [
              "borderBottomColor",
              "borderBottomStyle",
              "borderBottomWidth"
            ],
            borderColor: [
              "borderBottomColor",
              "borderLeftColor",
              "borderRightColor",
              "borderTopColor"
            ],
            borderImage: [
              "borderImageOutset",
              "borderImageRepeat",
              "borderImageSlice",
              "borderImageSource",
              "borderImageWidth"
            ],
            borderInlineEnd: [
              "borderInlineEndColor",
              "borderInlineEndStyle",
              "borderInlineEndWidth"
            ],
            borderInlineStart: [
              "borderInlineStartColor",
              "borderInlineStartStyle",
              "borderInlineStartWidth"
            ],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: [
              "borderBottomLeftRadius",
              "borderBottomRightRadius",
              "borderTopLeftRadius",
              "borderTopRightRadius"
            ],
            borderRight: [
              "borderRightColor",
              "borderRightStyle",
              "borderRightWidth"
            ],
            borderStyle: [
              "borderBottomStyle",
              "borderLeftStyle",
              "borderRightStyle",
              "borderTopStyle"
            ],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: [
              "borderBottomWidth",
              "borderLeftWidth",
              "borderRightWidth",
              "borderTopWidth"
            ],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
              " "
            ),
            fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
              " "
            ),
            gap: ["columnGap", "rowGap"],
            grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
              " "
            ),
            gridArea: [
              "gridColumnEnd",
              "gridColumnStart",
              "gridRowEnd",
              "gridRowStart"
            ],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: [
              "gridTemplateAreas",
              "gridTemplateColumns",
              "gridTemplateRows"
            ],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
              " "
            ),
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: [
              "textDecorationColor",
              "textDecorationLine",
              "textDecorationStyle"
            ],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: [
              "transitionDelay",
              "transitionDuration",
              "transitionProperty",
              "transitionTimingFunction"
            ],
            wordWrap: ["overflowWrap"]
          }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
            "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
              " "
            )
          ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
            ["acceptCharset", "accept-charset"],
            ["htmlFor", "for"],
            ["httpEquiv", "http-equiv"],
            ["crossOrigin", "crossorigin"],
            ["accentHeight", "accent-height"],
            ["alignmentBaseline", "alignment-baseline"],
            ["arabicForm", "arabic-form"],
            ["baselineShift", "baseline-shift"],
            ["capHeight", "cap-height"],
            ["clipPath", "clip-path"],
            ["clipRule", "clip-rule"],
            ["colorInterpolation", "color-interpolation"],
            ["colorInterpolationFilters", "color-interpolation-filters"],
            ["colorProfile", "color-profile"],
            ["colorRendering", "color-rendering"],
            ["dominantBaseline", "dominant-baseline"],
            ["enableBackground", "enable-background"],
            ["fillOpacity", "fill-opacity"],
            ["fillRule", "fill-rule"],
            ["floodColor", "flood-color"],
            ["floodOpacity", "flood-opacity"],
            ["fontFamily", "font-family"],
            ["fontSize", "font-size"],
            ["fontSizeAdjust", "font-size-adjust"],
            ["fontStretch", "font-stretch"],
            ["fontStyle", "font-style"],
            ["fontVariant", "font-variant"],
            ["fontWeight", "font-weight"],
            ["glyphName", "glyph-name"],
            ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
            ["glyphOrientationVertical", "glyph-orientation-vertical"],
            ["horizAdvX", "horiz-adv-x"],
            ["horizOriginX", "horiz-origin-x"],
            ["imageRendering", "image-rendering"],
            ["letterSpacing", "letter-spacing"],
            ["lightingColor", "lighting-color"],
            ["markerEnd", "marker-end"],
            ["markerMid", "marker-mid"],
            ["markerStart", "marker-start"],
            ["overlinePosition", "overline-position"],
            ["overlineThickness", "overline-thickness"],
            ["paintOrder", "paint-order"],
            ["panose-1", "panose-1"],
            ["pointerEvents", "pointer-events"],
            ["renderingIntent", "rendering-intent"],
            ["shapeRendering", "shape-rendering"],
            ["stopColor", "stop-color"],
            ["stopOpacity", "stop-opacity"],
            ["strikethroughPosition", "strikethrough-position"],
            ["strikethroughThickness", "strikethrough-thickness"],
            ["strokeDasharray", "stroke-dasharray"],
            ["strokeDashoffset", "stroke-dashoffset"],
            ["strokeLinecap", "stroke-linecap"],
            ["strokeLinejoin", "stroke-linejoin"],
            ["strokeMiterlimit", "stroke-miterlimit"],
            ["strokeOpacity", "stroke-opacity"],
            ["strokeWidth", "stroke-width"],
            ["textAnchor", "text-anchor"],
            ["textDecoration", "text-decoration"],
            ["textRendering", "text-rendering"],
            ["transformOrigin", "transform-origin"],
            ["underlinePosition", "underline-position"],
            ["underlineThickness", "underline-thickness"],
            ["unicodeBidi", "unicode-bidi"],
            ["unicodeRange", "unicode-range"],
            ["unitsPerEm", "units-per-em"],
            ["vAlphabetic", "v-alphabetic"],
            ["vHanging", "v-hanging"],
            ["vIdeographic", "v-ideographic"],
            ["vMathematical", "v-mathematical"],
            ["vectorEffect", "vector-effect"],
            ["vertAdvY", "vert-adv-y"],
            ["vertOriginX", "vert-origin-x"],
            ["vertOriginY", "vert-origin-y"],
            ["wordSpacing", "word-spacing"],
            ["writingMode", "writing-mode"],
            ["xmlnsXlink", "xmlns:xlink"],
            ["xHeight", "x-height"]
          ]), possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            fetchpriority: "fetchPriority",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            inert: "inert",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            popover: "popover",
            popovertarget: "popoverTarget",
            popovertargetaction: "popoverTargetAction",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            transformorigin: "transformOrigin",
            "transform-origin": "transformOrigin",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          }, ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          }, warnedProperties$1 = {}, rARIA$1 = RegExp(
            "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
          ), rARIACamel$1 = RegExp(
            "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
          ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
            "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
          ), rARIACamel = RegExp(
            "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
          ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
          if (canUseDOM)
            try {
              var options$jscomp$0 = {};
              Object.defineProperty(options$jscomp$0, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options$jscomp$0, options$jscomp$0);
              window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
            } catch (e) {
              passiveBrowserEventsSupported = false;
            }
          var root = null, startText = null, fallbackText = null, EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) return event.movementX;
              event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
              return lastMovementX;
            },
            movementY: function(event) {
              return "movementY" in event ? event.movementY : lastMovementY;
            }
          }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
            CompositionEventInterface
          ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          }, translateToKey = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
          }, modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          }, KeyboardEventInterface = assign({}, UIEventInterface, {
            key: function(nativeEvent) {
              if (nativeEvent.key) {
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if ("Unidentified" !== key) return key;
              }
              return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              return "keypress" === event.type ? getEventCharCode(event) : 0;
            },
            keyCode: function(event) {
              return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
            },
            which: function(event) {
              return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
            }
          }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
            newState: 0,
            oldState: 0
          }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
          canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
          canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
          var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionrun: makePrefixMap("Transition", "TransitionRun"),
            transitionstart: makePrefixMap("Transition", "TransitionStart"),
            transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          }, prefixedEventNames = {}, style2 = {};
          canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
          var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
            " "
          );
          simpleEventPluginEvents.push("scrollEnd");
          var CapturedStacks = /* @__PURE__ */ new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
          Object.freeze(emptyContextObject);
          var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
          var hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e$3) {
            hasBadMapPolyfill = true;
          }
          var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
            "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
          ), lastResetTime = 0;
          if ("object" === typeof performance && "function" === typeof performance.now) {
            var localPerformance = performance;
            var getCurrentTime = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            getCurrentTime = function() {
              return localDate.now();
            };
          }
          var valueCursor = createCursor(null);
          var rendererCursorDEV = createCursor(null);
          var rendererSigil = {};
          var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
            var listeners = [], signal = this.signal = {
              aborted: false,
              addEventListener: function(type, listener) {
                listeners.push(listener);
              }
            };
            this.abort = function() {
              signal.aborted = true;
              listeners.forEach(function(listener) {
                return listener();
              });
            };
          }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0,
            _currentRenderer: null,
            _currentRenderer2: null
          }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
          ReactSharedInternals.S = function(transition, returnValue) {
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
            null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
          };
          var resumedCache = createCursor(null), ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function() {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function() {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
              componentWillMountUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }), pendingComponentWillMountWarnings = []);
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
              UNSAFE_componentWillMountUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }), pendingUNSAFE_ComponentWillMountWarnings = []);
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
              componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }), pendingComponentWillReceivePropsWarnings = []);
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
              function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(
                  getComponentNameFromFiber(fiber) || "Component"
                );
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              }
            ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
              componentWillUpdateUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }), pendingComponentWillUpdateWarnings = []);
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
              UNSAFE_componentWillUpdateUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
            if (0 < UNSAFE_componentWillMountUniqueNames.size) {
              var sortedNames = setToSortedString(
                UNSAFE_componentWillMountUniqueNames
              );
              console.error(
                "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
                sortedNames
              );
            }
            0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
              UNSAFE_componentWillReceivePropsUniqueNames
            ), console.error(
              "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
              sortedNames
            ));
            0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
              UNSAFE_componentWillUpdateUniqueNames
            ), console.error(
              "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
              sortedNames
            ));
            0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
              "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
              sortedNames
            ));
            0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
              componentWillReceivePropsUniqueNames
            ), console.warn(
              "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
              sortedNames
            ));
            0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
              "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
              sortedNames
            ));
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = null;
            for (var node = fiber; null !== node; )
              node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
            null === strictRoot ? console.error(
              "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
            ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray) {
              if (0 !== fiberArray.length) {
                var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                runWithFiberInDEV(firstFiber, function() {
                  console.error(
                    "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                    sortedNames
                  );
                });
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
          var SuspenseException = Error(
            "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
          ), SuspenseyCommitException = Error(
            "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
          ), SuspenseActionException = Error(
            "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
          ), noopSuspenseyCommitThenable = {
            then: function() {
              console.error(
                'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
              );
            }
          }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
          var didWarnUpdateInsideUpdate = false;
          var currentlyProcessingQueue = null;
          var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
          var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
          var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
          var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
          var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
            readContext,
            use,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            useHostTransitionStatus: throwInvalidHookError,
            useFormState: throwInvalidHookError,
            useActionState: throwInvalidHookError,
            useOptimistic: throwInvalidHookError,
            useMemoCache: throwInvalidHookError,
            useCacheRefresh: throwInvalidHookError
          }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          HooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            use,
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(createDeps);
              return mountEffect(create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              mountEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            useFormState: function(action, initialState) {
              currentHookNameInDev = "useFormState";
              mountHookTypesDev();
              warnOnUseFormStateInDev();
              return mountActionState(action, initialState);
            },
            useActionState: function(action, initialState) {
              currentHookNameInDev = "useActionState";
              mountHookTypesDev();
              return mountActionState(action, initialState);
            },
            useOptimistic: function(passthrough) {
              currentHookNameInDev = "useOptimistic";
              mountHookTypesDev();
              return mountOptimistic(passthrough);
            },
            useHostTransitionStatus,
            useMemoCache,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              mountHookTypesDev();
              return mountRefresh();
            }
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            use,
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              mountEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            useActionState: function(action, initialState) {
              currentHookNameInDev = "useActionState";
              updateHookTypesDev();
              return mountActionState(action, initialState);
            },
            useFormState: function(action, initialState) {
              currentHookNameInDev = "useFormState";
              updateHookTypesDev();
              warnOnUseFormStateInDev();
              return mountActionState(action, initialState);
            },
            useOptimistic: function(passthrough) {
              currentHookNameInDev = "useOptimistic";
              updateHookTypesDev();
              return mountOptimistic(passthrough);
            },
            useHostTransitionStatus,
            useMemoCache,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              updateHookTypesDev();
              return mountRefresh();
            }
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            use,
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              updateEffectImpl(2048, Passive, create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateEffectImpl(4, Layout, create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function() {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useState: function() {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(basicStateReducer);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useFormState: function(action) {
              currentHookNameInDev = "useFormState";
              updateHookTypesDev();
              warnOnUseFormStateInDev();
              return updateActionState(action);
            },
            useActionState: function(action) {
              currentHookNameInDev = "useActionState";
              updateHookTypesDev();
              return updateActionState(action);
            },
            useOptimistic: function(passthrough, reducer) {
              currentHookNameInDev = "useOptimistic";
              updateHookTypesDev();
              return updateOptimistic(passthrough, reducer);
            },
            useHostTransitionStatus,
            useMemoCache,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            }
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            use,
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              updateEffectImpl(2048, Passive, create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateEffectImpl(4, Layout, create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function() {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useState: function() {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(basicStateReducer);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useFormState: function(action) {
              currentHookNameInDev = "useFormState";
              updateHookTypesDev();
              warnOnUseFormStateInDev();
              return rerenderActionState(action);
            },
            useActionState: function(action) {
              currentHookNameInDev = "useActionState";
              updateHookTypesDev();
              return rerenderActionState(action);
            },
            useOptimistic: function(passthrough, reducer) {
              currentHookNameInDev = "useOptimistic";
              updateHookTypesDev();
              return rerenderOptimistic(passthrough, reducer);
            },
            useHostTransitionStatus,
            useMemoCache,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            }
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            use: function(usable) {
              warnInvalidHookAccess();
              return use(usable);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              mountEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            useFormState: function(action, initialState) {
              currentHookNameInDev = "useFormState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountActionState(action, initialState);
            },
            useActionState: function(action, initialState) {
              currentHookNameInDev = "useActionState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountActionState(action, initialState);
            },
            useOptimistic: function(passthrough) {
              currentHookNameInDev = "useOptimistic";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountOptimistic(passthrough);
            },
            useMemoCache: function(size) {
              warnInvalidHookAccess();
              return useMemoCache(size);
            },
            useHostTransitionStatus,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              mountHookTypesDev();
              return mountRefresh();
            }
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            use: function(usable) {
              warnInvalidHookAccess();
              return use(usable);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              updateEffectImpl(2048, Passive, create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffectImpl(4, Layout, create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function() {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useState: function() {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(basicStateReducer);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useFormState: function(action) {
              currentHookNameInDev = "useFormState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateActionState(action);
            },
            useActionState: function(action) {
              currentHookNameInDev = "useActionState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateActionState(action);
            },
            useOptimistic: function(passthrough, reducer) {
              currentHookNameInDev = "useOptimistic";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateOptimistic(passthrough, reducer);
            },
            useMemoCache: function(size) {
              warnInvalidHookAccess();
              return useMemoCache(size);
            },
            useHostTransitionStatus,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            }
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            use: function(usable) {
              warnInvalidHookAccess();
              return use(usable);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create, createDeps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              updateEffectImpl(2048, Passive, create, createDeps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useInsertionEffect: function(create, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffectImpl(4, Insertion, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffectImpl(4, Layout, create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useRef: function() {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useState: function() {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(basicStateReducer);
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            },
            useDebugValue: function() {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
            },
            useDeferredValue: function(value, initialValue) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value, initialValue);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(
                subscribe,
                getSnapshot,
                getServerSnapshot
              );
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            },
            useFormState: function(action) {
              currentHookNameInDev = "useFormState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderActionState(action);
            },
            useActionState: function(action) {
              currentHookNameInDev = "useActionState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderActionState(action);
            },
            useOptimistic: function(passthrough, reducer) {
              currentHookNameInDev = "useOptimistic";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderOptimistic(passthrough, reducer);
            },
            useMemoCache: function(size) {
              warnInvalidHookAccess();
              return useMemoCache(size);
            },
            useHostTransitionStatus,
            useCacheRefresh: function() {
              currentHookNameInDev = "useCacheRefresh";
              updateHookTypesDev();
              return updateWorkInProgressHook().memoizedState;
            }
          };
          var callComponent = {
            "react-stack-bottom-frame": function(Component, props, secondArg) {
              var wasRendering = isRendering;
              isRendering = true;
              try {
                return Component(props, secondArg);
              } finally {
                isRendering = wasRendering;
              }
            }
          }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
            "react-stack-bottom-frame": function(instance) {
              var wasRendering = isRendering;
              isRendering = true;
              try {
                return instance.render();
              } finally {
                isRendering = wasRendering;
              }
            }
          }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
            "react-stack-bottom-frame": function(finishedWork, instance) {
              try {
                instance.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
            "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
              try {
                instance.componentDidUpdate(prevProps, prevState, snapshot);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
            "react-stack-bottom-frame": function(instance, errorInfo) {
              var stack = errorInfo.stack;
              instance.componentDidCatch(errorInfo.value, {
                componentStack: null !== stack ? stack : ""
              });
            }
          }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
            "react-stack-bottom-frame": function(current2, nearestMountedAncestor, instance) {
              try {
                instance.componentWillUnmount();
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              }
            }
          }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
            "react-stack-bottom-frame": function(effect) {
              null != effect.resourceKind && console.error(
                "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
                effect.resourceKind
              );
              var create = effect.create;
              effect = effect.inst;
              create = create();
              return effect.destroy = create;
            }
          }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
            "react-stack-bottom-frame": function(current2, nearestMountedAncestor, destroy) {
              try {
                destroy();
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              }
            }
          }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
            "react-stack-bottom-frame": function(lazy) {
              var init = lazy._init;
              return init(lazy._payload);
            }
          }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
          var didWarnAboutGenerators = didWarnAboutMaps = false;
          var ownerHasKeyUseWarning = {};
          var ownerHasFunctionTypeWarning = {};
          var ownerHasSymbolTypeWarning = {};
          warnForMissingKey = function(returnFiber, workInProgress2, child) {
            if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
              if ("object" !== typeof child._store)
                throw Error(
                  "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
                );
              child._store.validated = 1;
              var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
              if (!ownerHasKeyUseWarning[componentKey]) {
                ownerHasKeyUseWarning[componentKey] = true;
                child = child._owner;
                returnFiber = returnFiber._debugOwner;
                var currentComponentErrorInfo = "";
                returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
                currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
                var childOwnerAppendix = "";
                null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                    currentComponentErrorInfo,
                    childOwnerAppendix
                  );
                });
              }
            }
          };
          var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
          var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
          var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
          var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          Object.freeze(fakeInternalInstance);
          var classComponentUpdater = {
            enqueueSetState: function(inst, payload, callback) {
              inst = inst._reactInternals;
              var lane = requestUpdateLane(inst), update = createUpdate(lane);
              update.payload = payload;
              void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
              payload = enqueueUpdate(inst, update, lane);
              null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
              markStateUpdateScheduled(inst, lane);
            },
            enqueueReplaceState: function(inst, payload, callback) {
              inst = inst._reactInternals;
              var lane = requestUpdateLane(inst), update = createUpdate(lane);
              update.tag = ReplaceState;
              update.payload = payload;
              void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
              payload = enqueueUpdate(inst, update, lane);
              null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
              markStateUpdateScheduled(inst, lane);
            },
            enqueueForceUpdate: function(inst, callback) {
              inst = inst._reactInternals;
              var lane = requestUpdateLane(inst), update = createUpdate(lane);
              update.tag = ForceUpdate;
              void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
              callback = enqueueUpdate(inst, update, lane);
              null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
              null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
            }
          }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
              var event = new window.ErrorEvent("error", {
                bubbles: true,
                cancelable: true,
                message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                error
              });
              if (!window.dispatchEvent(event)) return;
            } else if ("object" === typeof process && "function" === typeof process.emit) {
              process.emit("uncaughtException", error);
              return;
            }
            console.error(error);
          }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
            "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
          ), didReceiveUpdate = false;
          var didWarnAboutBadClass = {};
          var didWarnAboutContextTypeOnFunctionComponent = {};
          var didWarnAboutContextTypes = {};
          var didWarnAboutGetDerivedStateOnFunctionComponent = {};
          var didWarnAboutReassigningProps = false;
          var didWarnAboutRevealOrder = {};
          var didWarnAboutTailOptions = {};
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0,
            hydrationErrors: null
          }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
            getCacheForType: function(resourceType) {
              var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
              void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
              return cacheForType;
            },
            getOwner: function() {
              return current;
            }
          };
          if ("function" === typeof Symbol && Symbol.for) {
            var symbolFor = Symbol.for;
            symbolFor("selector.component");
            symbolFor("selector.has_pseudo_class");
            symbolFor("selector.role");
            symbolFor("selector.test_id");
            symbolFor("selector.text");
          }
          var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
          (function() {
            for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
              var eventName = simpleEventPluginEvents[i2], domEventName = eventName.toLowerCase();
              eventName = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + eventName);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
            registerSimpleEvent(TRANSITION_START, "onTransitionStart");
            registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          })();
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          registerTwoPhaseEvent(
            "onChange",
            "change click focusin focusout input keydown keyup selectionchange".split(
              " "
            )
          );
          registerTwoPhaseEvent(
            "onSelect",
            "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
              " "
            )
          );
          registerTwoPhaseEvent("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
          ]);
          registerTwoPhaseEvent(
            "onCompositionEnd",
            "compositionend focusout keydown keypress keyup mousedown".split(" ")
          );
          registerTwoPhaseEvent(
            "onCompositionStart",
            "compositionstart focusout keydown keypress keyup mousedown".split(" ")
          );
          registerTwoPhaseEvent(
            "onCompositionUpdate",
            "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
          );
          var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
            " "
          ), nonDelegatedEvents = new Set(
            "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
          ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
          var didWarnForNewBooleanPropsWithEmptyValue = {};
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
          ReactDOMSharedInternals.d = {
            f: function() {
              var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
              return previousWasRendering || wasRendering;
            },
            r: function(form) {
              var formInst = getInstanceFromNode(form);
              null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
            },
            D: function(href) {
              previousDispatcher.D(href);
              preconnectAs("dns-prefetch", href, null);
            },
            C: function(href, crossOrigin) {
              previousDispatcher.C(href, crossOrigin);
              preconnectAs("preconnect", href, crossOrigin);
            },
            L: function(href, as, options) {
              previousDispatcher.L(href, as, options);
              var ownerDocument = globalDocument;
              if (ownerDocument && href && as) {
                var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
                "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  options.imageSrcSet
                ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  options.imageSizes
                ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
                var key = preloadSelector;
                switch (as) {
                  case "style":
                    key = getStyleKey(href);
                    break;
                  case "script":
                    key = getScriptKey(href);
                }
                preloadPropsMap.has(key) || (href = assign(
                  {
                    rel: "preload",
                    href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                    as
                  },
                  options
                ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
              }
            },
            m: function(href, options) {
              previousDispatcher.m(href, options);
              var ownerDocument = globalDocument;
              if (ownerDocument && href) {
                var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    key = getScriptKey(href);
                }
                if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                  switch (as) {
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                      if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                        return;
                  }
                  as = ownerDocument.createElement("link");
                  setInitialProperties(as, "link", href);
                  markNodeAsHoistable(as);
                  ownerDocument.head.appendChild(as);
                }
              }
            },
            X: function(src, options) {
              previousDispatcher.X(src, options);
              var ownerDocument = globalDocument;
              if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(
                  getScriptSelectorFromKey(key)
                ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                  type: "script",
                  instance: resource,
                  count: 1,
                  state: null
                }, scripts.set(key, resource));
              }
            },
            S: function(href, precedence, options) {
              previousDispatcher.S(href, precedence, options);
              var ownerDocument = globalDocument;
              if (ownerDocument && href) {
                var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
                precedence = precedence || "default";
                var resource = styles.get(key);
                if (!resource) {
                  var state = { loading: NotLoaded, preload: null };
                  if (resource = ownerDocument.querySelector(
                    getStylesheetSelectorFromKey(key)
                  ))
                    state.loading = Loaded | Inserted;
                  else {
                    href = assign(
                      {
                        rel: "stylesheet",
                        href,
                        "data-precedence": precedence
                      },
                      options
                    );
                    (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                    var link = resource = ownerDocument.createElement("link");
                    markNodeAsHoistable(link);
                    setInitialProperties(link, "link", href);
                    link._p = new Promise(function(resolve, reject) {
                      link.onload = resolve;
                      link.onerror = reject;
                    });
                    link.addEventListener("load", function() {
                      state.loading |= Loaded;
                    });
                    link.addEventListener("error", function() {
                      state.loading |= Errored;
                    });
                    state.loading |= Inserted;
                    insertStylesheet(resource, precedence, ownerDocument);
                  }
                  resource = {
                    type: "stylesheet",
                    instance: resource,
                    count: 1,
                    state
                  };
                  styles.set(key, resource);
                }
              }
            },
            M: function(src, options) {
              previousDispatcher.M(src, options);
              var ownerDocument = globalDocument;
              if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || (resource = ownerDocument.querySelector(
                  getScriptSelectorFromKey(key)
                ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                  type: "script",
                  instance: resource,
                  count: 1,
                  state: null
                }, scripts.set(key, resource));
              }
            }
          };
          var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            Provider: null,
            Consumer: null,
            _currentValue: NotPendingTransition,
            _currentValue2: NotPendingTransition,
            _threadCount: 0
          }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind2 = Function.prototype.bind;
          var didWarnAboutNestedUpdates = false;
          var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
          overrideHookState = function(fiber, id, path, value) {
            id = findHook(fiber, id);
            null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
          };
          overrideHookStateDeletePath = function(fiber, id, path) {
            id = findHook(fiber, id);
            null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            id = findHook(fiber, id);
            null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
          };
          overrideProps = function(fiber, path, value) {
            fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
            fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
            path = enqueueConcurrentRenderForLane(fiber, 2);
            null !== path && scheduleUpdateOnFiber(path, fiber, 2);
          };
          overridePropsDeletePath = function(fiber, path) {
            fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
            fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
            path = enqueueConcurrentRenderForLane(fiber, 2);
            null !== path && scheduleUpdateOnFiber(path, fiber, 2);
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(
              fiber.memoizedProps,
              oldPath,
              newPath
            );
            fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
            oldPath = enqueueConcurrentRenderForLane(fiber, 2);
            null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
          };
          scheduleUpdate = function(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
          var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
            " "
          ), lastScheduledReplayQueue = null;
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            if (null === root2) throw Error("Cannot update an unmounted root.");
            var args = arguments;
            "function" === typeof args[1] ? console.error(
              "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
            ) : isValidContainer(args[1]) ? console.error(
              "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
            ) : "undefined" !== typeof args[1] && console.error(
              "You passed a second argument to root.render(...) but it only accepts one argument."
            );
            args = children;
            var current2 = root2.current, lane = requestUpdateLane(current2);
            updateContainerImpl(current2, lane, args, root2, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            var args = arguments;
            "function" === typeof args[0] && console.error(
              "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
            );
            args = this._internalRoot;
            if (null !== args) {
              this._internalRoot = null;
              var container = args.containerInfo;
              (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
                "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
              );
              updateContainerImpl(args.current, 2, null, args, null, null);
              flushSyncWork$1();
              container[internalContainerInstanceKey] = null;
            }
          };
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
            if (target) {
              var updatePriority = resolveUpdatePriority();
              target = { blockedOn: null, target, priority: updatePriority };
              for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
              queuedExplicitHydrationTargets.splice(i2, 0, target);
              0 === i2 && attemptExplicitHydrationTarget(target);
            }
          };
          (function() {
            var isomorphicReactPackageVersion = React4.version;
            if ("19.1.0" !== isomorphicReactPackageVersion)
              throw Error(
                'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch")
              );
          })();
          "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
            "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
          );
          ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
            var fiber = componentOrElement._reactInternals;
            if (void 0 === fiber) {
              if ("function" === typeof componentOrElement.render)
                throw Error("Unable to find node on an unmounted component.");
              componentOrElement = Object.keys(componentOrElement).join(",");
              throw Error(
                "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
              );
            }
            componentOrElement = findCurrentFiberUsingSlowPath(fiber);
            componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
            componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
            return componentOrElement;
          };
          if (!function() {
            var internals = {
              bundleType: 1,
              version: "19.1.0",
              rendererPackageName: "react-dom",
              currentDispatcherRef: ReactSharedInternals,
              reconcilerVersion: "19.1.0"
            };
            internals.overrideHookState = overrideHookState;
            internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
            internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
            internals.overrideProps = overrideProps;
            internals.overridePropsDeletePath = overridePropsDeletePath;
            internals.overridePropsRenamePath = overridePropsRenamePath;
            internals.scheduleUpdate = scheduleUpdate;
            internals.setErrorHandler = setErrorHandler;
            internals.setSuspenseHandler = setSuspenseHandler;
            internals.scheduleRefresh = scheduleRefresh;
            internals.scheduleRoot = scheduleRoot;
            internals.setRefreshHandler = setRefreshHandler;
            internals.getCurrentFiber = getCurrentFiberForDevTools;
            internals.getLaneLabelMap = getLaneLabelMap;
            internals.injectProfilingHooks = injectProfilingHooks;
            return injectInternals(internals);
          }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
            var protocol = window.location.protocol;
            /^(https?|file):$/.test(protocol) && console.info(
              "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
              "font-weight:bold"
            );
          }
          exports.createRoot = function(container, options) {
            if (!isValidContainer(container))
              throw Error("Target container is not a DOM element.");
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
            null !== options && void 0 !== options && (options.hydrate ? console.warn(
              "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
            ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
              "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
            ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
            options = createFiberRoot(
              container,
              1,
              false,
              null,
              null,
              isStrictMode,
              identifierPrefix,
              onUncaughtError,
              onCaughtError,
              onRecoverableError,
              transitionCallbacks,
              null
            );
            container[internalContainerInstanceKey] = options.current;
            listenToAllSupportedEvents(container);
            return new ReactDOMRoot(options);
          };
          exports.hydrateRoot = function(container, initialChildren, options) {
            if (!isValidContainer(container))
              throw Error("Target container is not a DOM element.");
            warnIfReactDOMContainerInDEV(container);
            void 0 === initialChildren && console.error(
              "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
            );
            var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
            null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
            initialChildren = createFiberRoot(
              container,
              1,
              true,
              initialChildren,
              null != options ? options : null,
              isStrictMode,
              identifierPrefix,
              onUncaughtError,
              onCaughtError,
              onRecoverableError,
              transitionCallbacks,
              formState
            );
            initialChildren.context = getContextForSubtree(null);
            options = initialChildren.current;
            isStrictMode = requestUpdateLane(options);
            isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
            identifierPrefix = createUpdate(isStrictMode);
            identifierPrefix.callback = null;
            enqueueUpdate(options, identifierPrefix, isStrictMode);
            options = isStrictMode;
            initialChildren.current.lanes = options;
            markRootUpdated$1(initialChildren, options);
            ensureRootIsScheduled(initialChildren);
            container[internalContainerInstanceKey] = initialChildren.current;
            listenToAllSupportedEvents(container);
            return new ReactDOMHydrationRoot(initialChildren);
          };
          exports.version = "19.1.0";
          "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
        })();
      }
    });
    var require_client = __commonJS({
      "node_modules/react-dom/client.js"(exports, module) {
        "use strict";
        if (false) {
          checkDCE();
          module.exports = null;
        } else {
          module.exports = require_react_dom_client_development();
        }
      }
    });
    var import_react4 = __toESM(require_react());
    var import_client = __toESM(require_client());
    var import_react2 = __toESM(require_react());
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i2 = 0; i2 < this.content.length; i2 += 2)
          if (this.content[i2] === key) return i2;
        return -1;
      },
      // :: (string)  ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found2 = this.find(key);
        return found2 == -1 ? void 0 : this.content[found2 + 1];
      },
      // :: (string, any, ?string)  OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self = newKey && newKey != key ? this.remove(newKey) : this;
        var found2 = self.find(key), content = self.content.slice();
        if (found2 == -1) {
          content.push(newKey || key, value);
        } else {
          content[found2 + 1] = value;
          if (newKey) content[found2] = newKey;
        }
        return new OrderedMap(content);
      },
      // :: (string)  OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found2 = this.find(key);
        if (found2 == -1) return this;
        var content = this.content.slice();
        content.splice(found2, 2);
        return new OrderedMap(content);
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any)  OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      // :: (string, string, any)  OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found2 = without.find(place);
        content.splice(found2 == -1 ? content.length : found2, 0, key, value);
        return new OrderedMap(content);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i2 = 0; i2 < this.content.length; i2 += 2)
          f(this.content[i2], this.content[i2 + 1]);
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size) return this;
        return new OrderedMap(map2.content.concat(this.subtract(map2).content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map2) {
        map2 = OrderedMap.from(map2);
        if (!map2.size) return this;
        return new OrderedMap(this.subtract(map2).content.concat(map2.content));
      },
      // :: (union<Object, OrderedMap>)  OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map2) {
        var result = this;
        map2 = OrderedMap.from(map2);
        for (var i2 = 0; i2 < map2.content.length; i2 += 2)
          result = result.remove(map2.content[i2]);
        return result;
      },
      // :: ()  Object
      // Turn ordered map into a plain object.
      toObject: function() {
        var result = {};
        this.forEach(function(key, value) {
          result[key] = value;
        });
        return result;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value;
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    var dist_default = OrderedMap;
    function findDiffStart(a, b, pos) {
      for (let i2 = 0; ; i2++) {
        if (i2 == a.childCount || i2 == b.childCount)
          return a.childCount == b.childCount ? null : pos;
        let childA = a.child(i2), childB = b.child(i2);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return pos;
        if (childA.isText && childA.text != childB.text) {
          for (let j = 0; childA.text[j] == childB.text[j]; j++)
            pos++;
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          let inner = findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null)
            return inner;
        }
        pos += childA.nodeSize;
      }
    }
    function findDiffEnd(a, b, posA, posB) {
      for (let iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0)
          return iA == iB ? null : { a: posA, b: posB };
        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size;
          posB -= size;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return { a: posA, b: posB };
        if (childA.isText && childA.text != childB.text) {
          let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return { a: posA, b: posB };
        }
        if (childA.content.size || childB.content.size) {
          let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner)
            return inner;
        }
        posA -= size;
        posB -= size;
      }
    }
    var Fragment = class _Fragment {
      /**
      @internal
      */
      constructor(content, size) {
        this.content = content;
        this.size = size || 0;
        if (size == null)
          for (let i2 = 0; i2 < content.length; i2++)
            this.size += content[i2].nodeSize;
      }
      /**
      Invoke a callback for all descendant nodes between the given two
      positions (relative to start of this fragment). Doesn't descend
      into a node when the callback returns `false`.
      */
      nodesBetween(from2, to, f, nodeStart = 0, parent) {
        for (let i2 = 0, pos = 0; pos < to; i2++) {
          let child = this.content[i2], end = pos + child.nodeSize;
          if (end > from2 && f(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
            let start = pos + 1;
            child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
          }
          pos = end;
        }
      }
      /**
      Call the given callback for every descendant node. `pos` will be
      relative to the start of the fragment. The callback may return
      `false` to prevent traversal of a given node's children.
      */
      descendants(f) {
        this.nodesBetween(0, this.size, f);
      }
      /**
      Extract the text between `from` and `to`. See the same method on
      [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
      */
      textBetween(from2, to, blockSeparator, leafText) {
        let text = "", first2 = true;
        this.nodesBetween(from2, to, (node, pos) => {
          let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
          if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
            if (first2)
              first2 = false;
            else
              text += blockSeparator;
          }
          text += nodeText;
        }, 0);
        return text;
      }
      /**
      Create a new fragment containing the combined content of this
      fragment and the other.
      */
      append(other) {
        if (!other.size)
          return this;
        if (!this.size)
          return other;
        let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i2 = 0;
        if (last.isText && last.sameMarkup(first2)) {
          content[content.length - 1] = last.withText(last.text + first2.text);
          i2 = 1;
        }
        for (; i2 < other.content.length; i2++)
          content.push(other.content[i2]);
        return new _Fragment(content, this.size + other.size);
      }
      /**
      Cut out the sub-fragment between the two given positions.
      */
      cut(from2, to = this.size) {
        if (from2 == 0 && to == this.size)
          return this;
        let result = [], size = 0;
        if (to > from2)
          for (let i2 = 0, pos = 0; pos < to; i2++) {
            let child = this.content[i2], end = pos + child.nodeSize;
            if (end > from2) {
              if (pos < from2 || end > to) {
                if (child.isText)
                  child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
                else
                  child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
              }
              result.push(child);
              size += child.nodeSize;
            }
            pos = end;
          }
        return new _Fragment(result, size);
      }
      /**
      @internal
      */
      cutByIndex(from2, to) {
        if (from2 == to)
          return _Fragment.empty;
        if (from2 == 0 && to == this.content.length)
          return this;
        return new _Fragment(this.content.slice(from2, to));
      }
      /**
      Create a new fragment in which the node at the given index is
      replaced by the given node.
      */
      replaceChild(index, node) {
        let current = this.content[index];
        if (current == node)
          return this;
        let copy2 = this.content.slice();
        let size = this.size + node.nodeSize - current.nodeSize;
        copy2[index] = node;
        return new _Fragment(copy2, size);
      }
      /**
      Create a new fragment by prepending the given node to this
      fragment.
      */
      addToStart(node) {
        return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
      }
      /**
      Create a new fragment by appending the given node to this
      fragment.
      */
      addToEnd(node) {
        return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
      }
      /**
      Compare this fragment to another one.
      */
      eq(other) {
        if (this.content.length != other.content.length)
          return false;
        for (let i2 = 0; i2 < this.content.length; i2++)
          if (!this.content[i2].eq(other.content[i2]))
            return false;
        return true;
      }
      /**
      The first child of the fragment, or `null` if it is empty.
      */
      get firstChild() {
        return this.content.length ? this.content[0] : null;
      }
      /**
      The last child of the fragment, or `null` if it is empty.
      */
      get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
      /**
      The number of child nodes in this fragment.
      */
      get childCount() {
        return this.content.length;
      }
      /**
      Get the child node at the given index. Raise an error when the
      index is out of range.
      */
      child(index) {
        let found2 = this.content[index];
        if (!found2)
          throw new RangeError("Index " + index + " out of range for " + this);
        return found2;
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content[index] || null;
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        for (let i2 = 0, p = 0; i2 < this.content.length; i2++) {
          let child = this.content[i2];
          f(child, p, i2);
          p += child.nodeSize;
        }
      }
      /**
      Find the first position at which this fragment and another
      fragment differ, or `null` if they are the same.
      */
      findDiffStart(other, pos = 0) {
        return findDiffStart(this, other, pos);
      }
      /**
      Find the first position, searching from the end, at which this
      fragment and the given fragment differ, or `null` if they are
      the same. Since this position will not be the same in both
      nodes, an object with two separate positions is returned.
      */
      findDiffEnd(other, pos = this.size, otherPos = other.size) {
        return findDiffEnd(this, other, pos, otherPos);
      }
      /**
      Find the index and inner offset corresponding to a given relative
      position in this fragment. The result object will be reused
      (overwritten) the next time the function is called. @internal
      */
      findIndex(pos, round = -1) {
        if (pos == 0)
          return retIndex(0, pos);
        if (pos == this.size)
          return retIndex(this.content.length, pos);
        if (pos > this.size || pos < 0)
          throw new RangeError(`Position ${pos} outside of fragment (${this})`);
        for (let i2 = 0, curPos = 0; ; i2++) {
          let cur = this.child(i2), end = curPos + cur.nodeSize;
          if (end >= pos) {
            if (end == pos || round > 0)
              return retIndex(i2 + 1, end);
            return retIndex(i2, curPos);
          }
          curPos = end;
        }
      }
      /**
      Return a debugging string that describes this fragment.
      */
      toString() {
        return "<" + this.toStringInner() + ">";
      }
      /**
      @internal
      */
      toStringInner() {
        return this.content.join(", ");
      }
      /**
      Create a JSON-serializeable representation of this fragment.
      */
      toJSON() {
        return this.content.length ? this.content.map((n) => n.toJSON()) : null;
      }
      /**
      Deserialize a fragment from its JSON representation.
      */
      static fromJSON(schema, value) {
        if (!value)
          return _Fragment.empty;
        if (!Array.isArray(value))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new _Fragment(value.map(schema.nodeFromJSON));
      }
      /**
      Build a fragment from an array of nodes. Ensures that adjacent
      text nodes with the same marks are joined together.
      */
      static fromArray(array) {
        if (!array.length)
          return _Fragment.empty;
        let joined, size = 0;
        for (let i2 = 0; i2 < array.length; i2++) {
          let node = array[i2];
          size += node.nodeSize;
          if (i2 && node.isText && array[i2 - 1].sameMarkup(node)) {
            if (!joined)
              joined = array.slice(0, i2);
            joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
          } else if (joined) {
            joined.push(node);
          }
        }
        return new _Fragment(joined || array, size);
      }
      /**
      Create a fragment from something that can be interpreted as a
      set of nodes. For `null`, it returns the empty fragment. For a
      fragment, the fragment itself. For a node or array of nodes, a
      fragment containing those nodes.
      */
      static from(nodes) {
        if (!nodes)
          return _Fragment.empty;
        if (nodes instanceof _Fragment)
          return nodes;
        if (Array.isArray(nodes))
          return this.fromArray(nodes);
        if (nodes.attrs)
          return new _Fragment([nodes], nodes.nodeSize);
        throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    };
    Fragment.empty = new Fragment([], 0);
    var found = { index: 0, offset: 0 };
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found;
    }
    function compareDeep(a, b) {
      if (a === b)
        return true;
      if (!(a && typeof a == "object") || !(b && typeof b == "object"))
        return false;
      let array = Array.isArray(a);
      if (Array.isArray(b) != array)
        return false;
      if (array) {
        if (a.length != b.length)
          return false;
        for (let i2 = 0; i2 < a.length; i2++)
          if (!compareDeep(a[i2], b[i2]))
            return false;
      } else {
        for (let p in a)
          if (!(p in b) || !compareDeep(a[p], b[p]))
            return false;
        for (let p in b)
          if (!(p in a))
            return false;
      }
      return true;
    }
    var Mark = class _Mark {
      /**
      @internal
      */
      constructor(type, attrs) {
        this.type = type;
        this.attrs = attrs;
      }
      /**
      Given a set of marks, create a new set which contains this one as
      well, in the right position. If this mark is already in the set,
      the set itself is returned. If any marks that are set to be
      [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
      those are replaced by this one.
      */
      addToSet(set) {
        let copy2, placed = false;
        for (let i2 = 0; i2 < set.length; i2++) {
          let other = set[i2];
          if (this.eq(other))
            return set;
          if (this.type.excludes(other.type)) {
            if (!copy2)
              copy2 = set.slice(0, i2);
          } else if (other.type.excludes(this.type)) {
            return set;
          } else {
            if (!placed && other.type.rank > this.type.rank) {
              if (!copy2)
                copy2 = set.slice(0, i2);
              copy2.push(this);
              placed = true;
            }
            if (copy2)
              copy2.push(other);
          }
        }
        if (!copy2)
          copy2 = set.slice();
        if (!placed)
          copy2.push(this);
        return copy2;
      }
      /**
      Remove this mark from the given set, returning a new set. If this
      mark is not in the set, the set itself is returned.
      */
      removeFromSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (this.eq(set[i2]))
            return set.slice(0, i2).concat(set.slice(i2 + 1));
        return set;
      }
      /**
      Test whether this mark is in the given set of marks.
      */
      isInSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (this.eq(set[i2]))
            return true;
        return false;
      }
      /**
      Test whether this mark has the same type and attributes as
      another mark.
      */
      eq(other) {
        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
      }
      /**
      Convert this mark to a JSON-serializeable representation.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        return obj;
      }
      /**
      Deserialize a mark from JSON.
      */
      static fromJSON(schema, json) {
        if (!json)
          throw new RangeError("Invalid input for Mark.fromJSON");
        let type = schema.marks[json.type];
        if (!type)
          throw new RangeError(`There is no mark type ${json.type} in this schema`);
        let mark = type.create(json.attrs);
        type.checkAttrs(mark.attrs);
        return mark;
      }
      /**
      Test whether two sets of marks are identical.
      */
      static sameSet(a, b) {
        if (a == b)
          return true;
        if (a.length != b.length)
          return false;
        for (let i2 = 0; i2 < a.length; i2++)
          if (!a[i2].eq(b[i2]))
            return false;
        return true;
      }
      /**
      Create a properly sorted mark set from null, a single mark, or an
      unsorted array of marks.
      */
      static setFrom(marks) {
        if (!marks || Array.isArray(marks) && marks.length == 0)
          return _Mark.none;
        if (marks instanceof _Mark)
          return [marks];
        let copy2 = marks.slice();
        copy2.sort((a, b) => a.type.rank - b.type.rank);
        return copy2;
      }
    };
    Mark.none = [];
    var ReplaceError = class extends Error {
    };
    var Slice = class _Slice {
      /**
      Create a slice. When specifying a non-zero open depth, you must
      make sure that there are nodes of at least that depth at the
      appropriate side of the fragmenti.e. if the fragment is an
      empty paragraph node, `openStart` and `openEnd` can't be greater
      than 1.
      
      It is not necessary for the content of open nodes to conform to
      the schema's content constraints, though it should be a valid
      start/end/middle for such a node, depending on which sides are
      open.
      */
      constructor(content, openStart, openEnd) {
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      /**
      The size this slice would add when inserted into a document.
      */
      get size() {
        return this.content.size - this.openStart - this.openEnd;
      }
      /**
      @internal
      */
      insertAt(pos, fragment) {
        let content = insertInto(this.content, pos + this.openStart, fragment);
        return content && new _Slice(content, this.openStart, this.openEnd);
      }
      /**
      @internal
      */
      removeBetween(from2, to) {
        return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
      }
      /**
      Tests whether this slice is equal to another slice.
      */
      eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
      }
      /**
      @internal
      */
      toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
      /**
      Convert a slice to a JSON-serializable representation.
      */
      toJSON() {
        if (!this.content.size)
          return null;
        let json = { content: this.content.toJSON() };
        if (this.openStart > 0)
          json.openStart = this.openStart;
        if (this.openEnd > 0)
          json.openEnd = this.openEnd;
        return json;
      }
      /**
      Deserialize a slice from its JSON representation.
      */
      static fromJSON(schema, json) {
        if (!json)
          return _Slice.empty;
        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
      }
      /**
      Create a slice from a fragment by taking the maximum possible
      open value on both side of the fragment.
      */
      static maxOpen(fragment, openIsolating = true) {
        let openStart = 0, openEnd = 0;
        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
          openStart++;
        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
          openEnd++;
        return new _Slice(fragment, openStart, openEnd);
      }
    };
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    function removeRange(content, from2, to) {
      let { index, offset } = content.findIndex(from2), child = content.maybeChild(index);
      let { index: indexTo, offset: offsetTo } = content.findIndex(to);
      if (offset == from2 || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText)
          throw new RangeError("Removing non-flat range");
        return content.cut(0, from2).append(content.cut(to));
      }
      if (index != indexTo)
        throw new RangeError("Removing non-flat range");
      return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset - 1, to - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert))
          return null;
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      let inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index, child.copy(inner));
    }
    function replace($from, $to, slice2) {
      if (slice2.openStart > $from.depth)
        throw new ReplaceError("Inserted content deeper than insertion position");
      if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
        throw new ReplaceError("Inconsistent open depths");
      return replaceOuter($from, $to, slice2, 0);
    }
    function replaceOuter($from, $to, slice2, depth) {
      let index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
        let inner = replaceOuter($from, $to, slice2, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
      } else if (!slice2.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
        let parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
      } else {
        let { start, end } = prepareSliceForReplace(slice2, $from);
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type))
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
    }
    function joinable($before, $after, depth) {
      let node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      let last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last]))
        target[last] = child.withText(target[last].text + child.text);
      else
        target.push(child);
    }
    function addRange($start, $end, depth, target) {
      let node = ($end || $start).node(depth);
      let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (let i2 = startIndex; i2 < endIndex; i2++)
        addNode(node.child(i2), target);
      if ($end && $end.depth == depth && $end.textOffset)
        addNode($end.nodeBefore, target);
    }
    function close(node, content) {
      node.type.checkContent(content);
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
      let content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart)
          addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        addRange($start, $end, depth, content);
        if (openEnd)
          addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function replaceTwoWay($from, $to, depth) {
      let content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        let type = joinable($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function prepareSliceForReplace(slice2, $along) {
      let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
      let node = parent.copy(slice2.content);
      for (let i2 = extra - 1; i2 >= 0; i2--)
        node = $along.node(i2).copy(Fragment.from(node));
      return {
        start: node.resolveNoCache(slice2.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
      };
    }
    var ResolvedPos = class _ResolvedPos {
      /**
      @internal
      */
      constructor(pos, path, parentOffset) {
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      /**
      @internal
      */
      resolveDepth(val) {
        if (val == null)
          return this.depth;
        if (val < 0)
          return this.depth + val;
        return val;
      }
      /**
      The parent node that the position points into. Note that even if
      a position points into a text node, that node is not considered
      the parenttext nodes are flat in this model, and have no content.
      */
      get parent() {
        return this.node(this.depth);
      }
      /**
      The root node in which the position was resolved.
      */
      get doc() {
        return this.node(0);
      }
      /**
      The ancestor node at the given level. `p.node(p.depth)` is the
      same as `p.parent`.
      */
      node(depth) {
        return this.path[this.resolveDepth(depth) * 3];
      }
      /**
      The index into the ancestor at the given level. If this points
      at the 3rd node in the 2nd paragraph on the top level, for
      example, `p.index(0)` is 1 and `p.index(1)` is 2.
      */
      index(depth) {
        return this.path[this.resolveDepth(depth) * 3 + 1];
      }
      /**
      The index pointing after this position into the ancestor at the
      given level.
      */
      indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
      }
      /**
      The (absolute) position at the start of the node at the given
      level.
      */
      start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      }
      /**
      The (absolute) position at the end of the node at the given
      level.
      */
      end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
      }
      /**
      The (absolute) position directly before the wrapping node at the
      given level, or, when `depth` is `this.depth + 1`, the original
      position.
      */
      before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position before the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
      }
      /**
      The (absolute) position directly after the wrapping node at the
      given level, or the original position when `depth` is `this.depth + 1`.
      */
      after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth)
          throw new RangeError("There is no position after the top-level node");
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
      }
      /**
      When this position points into a text node, this returns the
      distance between the position and the start of the text node.
      Will be zero for positions that point between nodes.
      */
      get textOffset() {
        return this.pos - this.path[this.path.length - 1];
      }
      /**
      Get the node directly after the position, if any. If the position
      points into a text node, only the part of that node after the
      position is returned.
      */
      get nodeAfter() {
        let parent = this.parent, index = this.index(this.depth);
        if (index == parent.childCount)
          return null;
        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
      }
      /**
      Get the node directly before the position, if any. If the
      position points into a text node, only the part of that node
      before the position is returned.
      */
      get nodeBefore() {
        let index = this.index(this.depth);
        let dOff = this.pos - this.path[this.path.length - 1];
        if (dOff)
          return this.parent.child(index).cut(0, dOff);
        return index == 0 ? null : this.parent.child(index - 1);
      }
      /**
      Get the position at the given index in the parent node at the
      given depth (which defaults to `this.depth`).
      */
      posAtIndex(index, depth) {
        depth = this.resolveDepth(depth);
        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        for (let i2 = 0; i2 < index; i2++)
          pos += node.child(i2).nodeSize;
        return pos;
      }
      /**
      Get the marks at this position, factoring in the surrounding
      marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
      position is at the start of a non-empty node, the marks of the
      node after it (if any) are returned.
      */
      marks() {
        let parent = this.parent, index = this.index();
        if (parent.content.size == 0)
          return Mark.none;
        if (this.textOffset)
          return parent.child(index).marks;
        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
        if (!main) {
          let tmp = main;
          main = other;
          other = tmp;
        }
        let marks = main.marks;
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      Get the marks after the current position, if any, except those
      that are non-inclusive and not present at position `$end`. This
      is mostly useful for getting the set of marks to preserve after a
      deletion. Will return `null` if this position is at the end of
      its parent node or its parent node isn't a textblock (in which
      case no marks should be preserved).
      */
      marksAcross($end) {
        let after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline)
          return null;
        let marks = after.marks, next = $end.parent.maybeChild($end.index());
        for (var i2 = 0; i2 < marks.length; i2++)
          if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
            marks = marks[i2--].removeFromSet(marks);
        return marks;
      }
      /**
      The depth up to which this position and the given (non-resolved)
      position share the same parent nodes.
      */
      sharedDepth(pos) {
        for (let depth = this.depth; depth > 0; depth--)
          if (this.start(depth) <= pos && this.end(depth) >= pos)
            return depth;
        return 0;
      }
      /**
      Returns a range based on the place where this position and the
      given position diverge around block content. If both point into
      the same textblock, for example, a range around that textblock
      will be returned. If they point into different blocks, the range
      around those blocks in their shared ancestor is returned. You can
      pass in an optional predicate that will be called with a parent
      node to see if a range into that parent is acceptable.
      */
      blockRange(other = this, pred) {
        if (other.pos < this.pos)
          return other.blockRange(this);
        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
          if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
            return new NodeRange(this, other, d);
        return null;
      }
      /**
      Query whether the given position shares the same parent node.
      */
      sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
      }
      /**
      Return the greater of this and the given position.
      */
      max(other) {
        return other.pos > this.pos ? other : this;
      }
      /**
      Return the smaller of this and the given position.
      */
      min(other) {
        return other.pos < this.pos ? other : this;
      }
      /**
      @internal
      */
      toString() {
        let str = "";
        for (let i2 = 1; i2 <= this.depth; i2++)
          str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
        return str + ":" + this.parentOffset;
      }
      /**
      @internal
      */
      static resolve(doc3, pos) {
        if (!(pos >= 0 && pos <= doc3.content.size))
          throw new RangeError("Position " + pos + " out of range");
        let path = [];
        let start = 0, parentOffset = pos;
        for (let node = doc3; ; ) {
          let { index, offset } = node.content.findIndex(parentOffset);
          let rem = parentOffset - offset;
          path.push(node, index, start + offset);
          if (!rem)
            break;
          node = node.child(index);
          if (node.isText)
            break;
          parentOffset = rem - 1;
          start += offset + 1;
        }
        return new _ResolvedPos(pos, path, parentOffset);
      }
      /**
      @internal
      */
      static resolveCached(doc3, pos) {
        let cache = resolveCache.get(doc3);
        if (cache) {
          for (let i2 = 0; i2 < cache.elts.length; i2++) {
            let elt = cache.elts[i2];
            if (elt.pos == pos)
              return elt;
          }
        } else {
          resolveCache.set(doc3, cache = new ResolveCache());
        }
        let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
        cache.i = (cache.i + 1) % resolveCacheSize;
        return result;
      }
    };
    var ResolveCache = class {
      constructor() {
        this.elts = [];
        this.i = 0;
      }
    };
    var resolveCacheSize = 12;
    var resolveCache = /* @__PURE__ */ new WeakMap();
    var NodeRange = class {
      /**
      Construct a node range. `$from` and `$to` should point into the
      same node until at least the given `depth`, since a node range
      denotes an adjacent set of nodes in a single parent node.
      */
      constructor($from, $to, depth) {
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      /**
      The position at the start of the range.
      */
      get start() {
        return this.$from.before(this.depth + 1);
      }
      /**
      The position at the end of the range.
      */
      get end() {
        return this.$to.after(this.depth + 1);
      }
      /**
      The parent node that the range points into.
      */
      get parent() {
        return this.$from.node(this.depth);
      }
      /**
      The start index of the range in the parent node.
      */
      get startIndex() {
        return this.$from.index(this.depth);
      }
      /**
      The end index of the range in the parent node.
      */
      get endIndex() {
        return this.$to.indexAfter(this.depth);
      }
    };
    var emptyAttrs = /* @__PURE__ */ Object.create(null);
    var Node = class _Node {
      /**
      @internal
      */
      constructor(type, attrs, content, marks = Mark.none) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment.empty;
      }
      /**
      The array of this node's child nodes.
      */
      get children() {
        return this.content.content;
      }
      /**
      The size of this node, as defined by the integer-based [indexing
      scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
      amount of characters. For other leaf nodes, it is one. For
      non-leaf nodes, it is the size of the content plus two (the
      start and end token).
      */
      get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
      /**
      The number of children that the node has.
      */
      get childCount() {
        return this.content.childCount;
      }
      /**
      Get the child node at the given index. Raises an error when the
      index is out of range.
      */
      child(index) {
        return this.content.child(index);
      }
      /**
      Get the child node at the given index, if it exists.
      */
      maybeChild(index) {
        return this.content.maybeChild(index);
      }
      /**
      Call `f` for every child node, passing the node, its offset
      into this parent node, and its index.
      */
      forEach(f) {
        this.content.forEach(f);
      }
      /**
      Invoke a callback for all descendant nodes recursively between
      the given two positions that are relative to start of this
      node's content. The callback is invoked with the node, its
      position relative to the original node (method receiver),
      its parent node, and its child index. When the callback returns
      false for a given node, that node's children will not be
      recursed over. The last parameter can be used to specify a
      starting position to count from.
      */
      nodesBetween(from2, to, f, startPos = 0) {
        this.content.nodesBetween(from2, to, f, startPos, this);
      }
      /**
      Call the given callback for every descendant node. Doesn't
      descend into a node when the callback returns `false`.
      */
      descendants(f) {
        this.nodesBetween(0, this.content.size, f);
      }
      /**
      Concatenates all the text nodes found in this fragment and its
      children.
      */
      get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
      /**
      Get all text between positions `from` and `to`. When
      `blockSeparator` is given, it will be inserted to separate text
      from different block nodes. If `leafText` is given, it'll be
      inserted for every non-text leaf node encountered, otherwise
      [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
      */
      textBetween(from2, to, blockSeparator, leafText) {
        return this.content.textBetween(from2, to, blockSeparator, leafText);
      }
      /**
      Returns this node's first child, or `null` if there are no
      children.
      */
      get firstChild() {
        return this.content.firstChild;
      }
      /**
      Returns this node's last child, or `null` if there are no
      children.
      */
      get lastChild() {
        return this.content.lastChild;
      }
      /**
      Test whether two nodes represent the same piece of document.
      */
      eq(other) {
        return this == other || this.sameMarkup(other) && this.content.eq(other.content);
      }
      /**
      Compare the markup (type, attributes, and marks) of this node to
      those of another. Returns `true` if both have the same markup.
      */
      sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
      }
      /**
      Check whether this node's markup correspond to the given type,
      attributes, and marks.
      */
      hasMarkup(type, attrs, marks) {
        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
      }
      /**
      Create a new node with the same markup as this node, containing
      the given content (or empty, if no content is given).
      */
      copy(content = null) {
        if (content == this.content)
          return this;
        return new _Node(this.type, this.attrs, content, this.marks);
      }
      /**
      Create a copy of this node, with the given set of marks instead
      of the node's own marks.
      */
      mark(marks) {
        return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
      }
      /**
      Create a copy of this node with only the content between the
      given positions. If `to` is not given, it defaults to the end of
      the node.
      */
      cut(from2, to = this.content.size) {
        if (from2 == 0 && to == this.content.size)
          return this;
        return this.copy(this.content.cut(from2, to));
      }
      /**
      Cut out the part of the document between the given positions, and
      return it as a `Slice` object.
      */
      slice(from2, to = this.content.size, includeParents = false) {
        if (from2 == to)
          return Slice.empty;
        let $from = this.resolve(from2), $to = this.resolve(to);
        let depth = includeParents ? 0 : $from.sharedDepth(to);
        let start = $from.start(depth), node = $from.node(depth);
        let content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
      }
      /**
      Replace the part of the document between the given positions with
      the given slice. The slice must 'fit', meaning its open sides
      must be able to connect to the surrounding content, and its
      content nodes must be valid children for the node they are placed
      into. If any of this is violated, an error of type
      [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
      */
      replace(from2, to, slice2) {
        return replace(this.resolve(from2), this.resolve(to), slice2);
      }
      /**
      Find the node directly after the given position.
      */
      nodeAt(pos) {
        for (let node = this; ; ) {
          let { index, offset } = node.content.findIndex(pos);
          node = node.maybeChild(index);
          if (!node)
            return null;
          if (offset == pos || node.isText)
            return node;
          pos -= offset + 1;
        }
      }
      /**
      Find the (direct) child node after the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childAfter(pos) {
        let { index, offset } = this.content.findIndex(pos);
        return { node: this.content.maybeChild(index), index, offset };
      }
      /**
      Find the (direct) child node before the given offset, if any,
      and return it along with its index and offset relative to this
      node.
      */
      childBefore(pos) {
        if (pos == 0)
          return { node: null, index: 0, offset: 0 };
        let { index, offset } = this.content.findIndex(pos);
        if (offset < pos)
          return { node: this.content.child(index), index, offset };
        let node = this.content.child(index - 1);
        return { node, index: index - 1, offset: offset - node.nodeSize };
      }
      /**
      Resolve the given position in the document, returning an
      [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
      */
      resolve(pos) {
        return ResolvedPos.resolveCached(this, pos);
      }
      /**
      @internal
      */
      resolveNoCache(pos) {
        return ResolvedPos.resolve(this, pos);
      }
      /**
      Test whether a given mark or mark type occurs in this document
      between the two given positions.
      */
      rangeHasMark(from2, to, type) {
        let found2 = false;
        if (to > from2)
          this.nodesBetween(from2, to, (node) => {
            if (type.isInSet(node.marks))
              found2 = true;
            return !found2;
          });
        return found2;
      }
      /**
      True when this is a block (non-inline node)
      */
      get isBlock() {
        return this.type.isBlock;
      }
      /**
      True when this is a textblock node, a block node with inline
      content.
      */
      get isTextblock() {
        return this.type.isTextblock;
      }
      /**
      True when this node allows inline content.
      */
      get inlineContent() {
        return this.type.inlineContent;
      }
      /**
      True when this is an inline node (a text node or a node that can
      appear among text).
      */
      get isInline() {
        return this.type.isInline;
      }
      /**
      True when this is a text node.
      */
      get isText() {
        return this.type.isText;
      }
      /**
      True when this is a leaf node.
      */
      get isLeaf() {
        return this.type.isLeaf;
      }
      /**
      True when this is an atom, i.e. when it does not have directly
      editable content. This is usually the same as `isLeaf`, but can
      be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
      on a node's spec (typically used when the node is displayed as
      an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
      */
      get isAtom() {
        return this.type.isAtom;
      }
      /**
      Return a string representation of this node for debugging
      purposes.
      */
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        let name = this.type.name;
        if (this.content.size)
          name += "(" + this.content.toStringInner() + ")";
        return wrapMarks(this.marks, name);
      }
      /**
      Get the content match in this node at the given index.
      */
      contentMatchAt(index) {
        let match = this.type.contentMatch.matchFragment(this.content, 0, index);
        if (!match)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return match;
      }
      /**
      Test whether replacing the range between `from` and `to` (by
      child index) with the given replacement fragment (which defaults
      to the empty fragment) would leave the node's content valid. You
      can optionally pass `start` and `end` indices into the
      replacement fragment.
      */
      canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
        let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
        let two = one && one.matchFragment(this.content, to);
        if (!two || !two.validEnd)
          return false;
        for (let i2 = start; i2 < end; i2++)
          if (!this.type.allowsMarks(replacement.child(i2).marks))
            return false;
        return true;
      }
      /**
      Test whether replacing the range `from` to `to` (by index) with
      a node of the given type would leave the node's content valid.
      */
      canReplaceWith(from2, to, type, marks) {
        if (marks && !this.type.allowsMarks(marks))
          return false;
        let start = this.contentMatchAt(from2).matchType(type);
        let end = start && start.matchFragment(this.content, to);
        return end ? end.validEnd : false;
      }
      /**
      Test whether the given node's content could be appended to this
      node. If that node is empty, this will only return true if there
      is at least one node type that can appear in both nodes (to avoid
      merging completely incompatible nodes).
      */
      canAppend(other) {
        if (other.content.size)
          return this.canReplace(this.childCount, this.childCount, other.content);
        else
          return this.type.compatibleContent(other.type);
      }
      /**
      Check whether this node and its descendants conform to the
      schema, and raise an exception when they do not.
      */
      check() {
        this.type.checkContent(this.content);
        this.type.checkAttrs(this.attrs);
        let copy2 = Mark.none;
        for (let i2 = 0; i2 < this.marks.length; i2++) {
          let mark = this.marks[i2];
          mark.type.checkAttrs(mark.attrs);
          copy2 = mark.addToSet(copy2);
        }
        if (!Mark.sameSet(copy2, this.marks))
          throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
        this.content.forEach((node) => node.check());
      }
      /**
      Return a JSON-serializeable representation of this node.
      */
      toJSON() {
        let obj = { type: this.type.name };
        for (let _ in this.attrs) {
          obj.attrs = this.attrs;
          break;
        }
        if (this.content.size)
          obj.content = this.content.toJSON();
        if (this.marks.length)
          obj.marks = this.marks.map((n) => n.toJSON());
        return obj;
      }
      /**
      Deserialize a node from its JSON representation.
      */
      static fromJSON(schema, json) {
        if (!json)
          throw new RangeError("Invalid input for Node.fromJSON");
        let marks = void 0;
        if (json.marks) {
          if (!Array.isArray(json.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          marks = json.marks.map(schema.markFromJSON);
        }
        if (json.type == "text") {
          if (typeof json.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return schema.text(json.text, marks);
        }
        let content = Fragment.fromJSON(schema, json.content);
        let node = schema.nodeType(json.type).create(json.attrs, content, marks);
        node.type.checkAttrs(node.attrs);
        return node;
      }
    };
    Node.prototype.text = void 0;
    var TextNode = class _TextNode extends Node {
      /**
      @internal
      */
      constructor(type, attrs, content, marks) {
        super(type, attrs, null, marks);
        if (!content)
          throw new RangeError("Empty text nodes are not allowed");
        this.text = content;
      }
      toString() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        return wrapMarks(this.marks, JSON.stringify(this.text));
      }
      get textContent() {
        return this.text;
      }
      textBetween(from2, to) {
        return this.text.slice(from2, to);
      }
      get nodeSize() {
        return this.text.length;
      }
      mark(marks) {
        return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
      }
      withText(text) {
        if (text == this.text)
          return this;
        return new _TextNode(this.type, this.attrs, text, this.marks);
      }
      cut(from2 = 0, to = this.text.length) {
        if (from2 == 0 && to == this.text.length)
          return this;
        return this.withText(this.text.slice(from2, to));
      }
      eq(other) {
        return this.sameMarkup(other) && this.text == other.text;
      }
      toJSON() {
        let base2 = super.toJSON();
        base2.text = this.text;
        return base2;
      }
    };
    function wrapMarks(marks, str) {
      for (let i2 = marks.length - 1; i2 >= 0; i2--)
        str = marks[i2].type.name + "(" + str + ")";
      return str;
    }
    var ContentMatch = class _ContentMatch {
      /**
      @internal
      */
      constructor(validEnd) {
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      /**
      @internal
      */
      static parse(string, nodeTypes) {
        let stream = new TokenStream(string, nodeTypes);
        if (stream.next == null)
          return _ContentMatch.empty;
        let expr = parseExpr(stream);
        if (stream.next)
          stream.err("Unexpected trailing text");
        let match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
      }
      /**
      Match a node type, returning a match after that node if
      successful.
      */
      matchType(type) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          if (this.next[i2].type == type)
            return this.next[i2].next;
        return null;
      }
      /**
      Try to match a fragment. Returns the resulting match when
      successful.
      */
      matchFragment(frag, start = 0, end = frag.childCount) {
        let cur = this;
        for (let i2 = start; cur && i2 < end; i2++)
          cur = cur.matchType(frag.child(i2).type);
        return cur;
      }
      /**
      @internal
      */
      get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
      /**
      Get the first matching node type at this match position that can
      be generated.
      */
      get defaultType() {
        for (let i2 = 0; i2 < this.next.length; i2++) {
          let { type } = this.next[i2];
          if (!(type.isText || type.hasRequiredAttrs()))
            return type;
        }
        return null;
      }
      /**
      @internal
      */
      compatible(other) {
        for (let i2 = 0; i2 < this.next.length; i2++)
          for (let j = 0; j < other.next.length; j++)
            if (this.next[i2].type == other.next[j].type)
              return true;
        return false;
      }
      /**
      Try to match the given fragment, and if that fails, see if it can
      be made to match by inserting nodes in front of it. When
      successful, return a fragment of inserted nodes (which may be
      empty if nothing had to be inserted). When `toEnd` is true, only
      return a fragment if the resulting match goes to the end of the
      content expression.
      */
      fillBefore(after, toEnd = false, startIndex = 0) {
        let seen = [this];
        function search(match, types) {
          let finished = match.matchFragment(after, startIndex);
          if (finished && (!toEnd || finished.validEnd))
            return Fragment.from(types.map((tp) => tp.createAndFill()));
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
              seen.push(next);
              let found2 = search(next, types.concat(type));
              if (found2)
                return found2;
            }
          }
          return null;
        }
        return search(this, []);
      }
      /**
      Find a set of wrapping node types that would allow a node of the
      given type to appear at this position. The result may be empty
      (when it fits directly) and will be null when no such wrapping
      exists.
      */
      findWrapping(target) {
        for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
          if (this.wrapCache[i2] == target)
            return this.wrapCache[i2 + 1];
        let computed = this.computeWrapping(target);
        this.wrapCache.push(target, computed);
        return computed;
      }
      /**
      @internal
      */
      computeWrapping(target) {
        let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
        while (active.length) {
          let current = active.shift(), match = current.match;
          if (match.matchType(target)) {
            let result = [];
            for (let obj = current; obj.type; obj = obj.via)
              result.push(obj.type);
            return result.reverse();
          }
          for (let i2 = 0; i2 < match.next.length; i2++) {
            let { type, next } = match.next[i2];
            if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
              active.push({ match: type.contentMatch, type, via: current });
              seen[type.name] = true;
            }
          }
        }
        return null;
      }
      /**
      The number of outgoing edges this node has in the finite
      automaton that describes the content expression.
      */
      get edgeCount() {
        return this.next.length;
      }
      /**
      Get the _n_th outgoing edge from this node in the finite
      automaton that describes the content expression.
      */
      edge(n) {
        if (n >= this.next.length)
          throw new RangeError(`There's no ${n}th edge in this content match`);
        return this.next[n];
      }
      /**
      @internal
      */
      toString() {
        let seen = [];
        function scan(m) {
          seen.push(m);
          for (let i2 = 0; i2 < m.next.length; i2++)
            if (seen.indexOf(m.next[i2].next) == -1)
              scan(m.next[i2].next);
        }
        scan(this);
        return seen.map((m, i2) => {
          let out = i2 + (m.validEnd ? "*" : " ") + " ";
          for (let i22 = 0; i22 < m.next.length; i22++)
            out += (i22 ? ", " : "") + m.next[i22].type.name + "->" + seen.indexOf(m.next[i22].next);
          return out;
        }).join("\n");
      }
    };
    ContentMatch.empty = new ContentMatch(true);
    var TokenStream = class {
      constructor(string, nodeTypes) {
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
          this.tokens.pop();
        if (this.tokens[0] == "")
          this.tokens.shift();
      }
      get next() {
        return this.tokens[this.pos];
      }
      eat(tok) {
        return this.next == tok && (this.pos++ || true);
      }
      err(str) {
        throw new SyntaxError(str + " (in content expression '" + this.string + "')");
      }
    };
    function parseExpr(stream) {
      let exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    }
    function parseExprSeq(stream) {
      let exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
    }
    function parseExprSubscript(stream) {
      let expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+"))
          expr = { type: "plus", expr };
        else if (stream.eat("*"))
          expr = { type: "star", expr };
        else if (stream.eat("?"))
          expr = { type: "opt", expr };
        else if (stream.eat("{"))
          expr = parseExprRange(stream, expr);
        else
          break;
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next))
        stream.err("Expected number, got '" + stream.next + "'");
      let result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      let min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}")
          max = parseNum(stream);
        else
          max = -1;
      }
      if (!stream.eat("}"))
        stream.err("Unclosed braced range");
      return { type: "range", min, max, expr };
    }
    function resolveName(stream, name) {
      let types = stream.nodeTypes, type = types[name];
      if (type)
        return [type];
      let result = [];
      for (let typeName in types) {
        let type2 = types[typeName];
        if (type2.isInGroup(name))
          result.push(type2);
      }
      if (result.length == 0)
        stream.err("No node type or group '" + name + "' found");
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        let expr = parseExpr(stream);
        if (!stream.eat(")"))
          stream.err("Missing closing paren");
        return expr;
      } else if (!/\W/.test(stream.next)) {
        let exprs = resolveName(stream, stream.next).map((type) => {
          if (stream.inline == null)
            stream.inline = type.isInline;
          else if (stream.inline != type.isInline)
            stream.err("Mixing inline and block content");
          return { type: "name", value: type };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      let nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from2, to, term) {
        let edge2 = { term, to };
        nfa2[from2].push(edge2);
        return edge2;
      }
      function connect(edges, to) {
        edges.forEach((edge2) => edge2.to = to);
      }
      function compile(expr2, from2) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
        } else if (expr2.type == "seq") {
          for (let i2 = 0; ; i2++) {
            let next = compile(expr2.exprs[i2], from2);
            if (i2 == expr2.exprs.length - 1)
              return next;
            connect(next, from2 = node());
          }
        } else if (expr2.type == "star") {
          let loop = node();
          edge(from2, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          let loop = node();
          connect(compile(expr2.expr, from2), loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "opt") {
          return [edge(from2)].concat(compile(expr2.expr, from2));
        } else if (expr2.type == "range") {
          let cur = from2;
          for (let i2 = 0; i2 < expr2.min; i2++) {
            let next = node();
            connect(compile(expr2.expr, cur), next);
            cur = next;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (let i2 = expr2.min; i2 < expr2.max; i2++) {
              let next = node();
              edge(cur, next);
              connect(compile(expr2.expr, cur), next);
              cur = next;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from2, void 0, expr2.value)];
        } else {
          throw new Error("Unknown expr type");
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      let result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        let edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term)
          return scan(edges[0].to);
        result.push(node2);
        for (let i2 = 0; i2 < edges.length; i2++) {
          let { term, to } = edges[i2];
          if (!term && result.indexOf(to) == -1)
            scan(to);
        }
      }
    }
    function dfa(nfa2) {
      let labeled = /* @__PURE__ */ Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        let out = [];
        states.forEach((node) => {
          nfa2[node].forEach(({ term, to }) => {
            if (!term)
              return;
            let set;
            for (let i2 = 0; i2 < out.length; i2++)
              if (out[i2][0] == term)
                set = out[i2][1];
            nullFrom(nfa2, to).forEach((node2) => {
              if (!set)
                out.push([term, set = []]);
              if (set.indexOf(node2) == -1)
                set.push(node2);
            });
          });
        });
        let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (let i2 = 0; i2 < out.length; i2++) {
          let states2 = out[i2][1].sort(cmp);
          state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
        }
        return state;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
        let state = work[i2], dead = !state.validEnd, nodes = [];
        for (let j = 0; j < state.next.length; j++) {
          let { type, next } = state.next[j];
          nodes.push(type.name);
          if (dead && !(type.isText || type.hasRequiredAttrs()))
            dead = false;
          if (work.indexOf(next) == -1)
            work.push(next);
        }
        if (dead)
          stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function defaultAttrs(attrs) {
      let defaults = /* @__PURE__ */ Object.create(null);
      for (let attrName in attrs) {
        let attr = attrs[attrName];
        if (!attr.hasDefault)
          return null;
        defaults[attrName] = attr.default;
      }
      return defaults;
    }
    function computeAttrs(attrs, value) {
      let built = /* @__PURE__ */ Object.create(null);
      for (let name in attrs) {
        let given = value && value[name];
        if (given === void 0) {
          let attr = attrs[name];
          if (attr.hasDefault)
            given = attr.default;
          else
            throw new RangeError("No value supplied for attribute " + name);
        }
        built[name] = given;
      }
      return built;
    }
    function checkAttrs(attrs, values, type, name) {
      for (let name2 in values)
        if (!(name2 in attrs))
          throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
      for (let name2 in attrs) {
        let attr = attrs[name2];
        if (attr.validate)
          attr.validate(values[name2]);
      }
    }
    function initAttrs(typeName, attrs) {
      let result = /* @__PURE__ */ Object.create(null);
      if (attrs)
        for (let name in attrs)
          result[name] = new Attribute(typeName, name, attrs[name]);
      return result;
    }
    var NodeType = class _NodeType {
      /**
      @internal
      */
      constructor(name, schema, spec) {
        this.name = name;
        this.schema = schema;
        this.spec = spec;
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(name, spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
      }
      /**
      True if this is an inline type.
      */
      get isInline() {
        return !this.isBlock;
      }
      /**
      True if this is a textblock type, a block that contains inline
      content.
      */
      get isTextblock() {
        return this.isBlock && this.inlineContent;
      }
      /**
      True for node types that allow no content.
      */
      get isLeaf() {
        return this.contentMatch == ContentMatch.empty;
      }
      /**
      True when this node is an atom, i.e. when it does not have
      directly editable content.
      */
      get isAtom() {
        return this.isLeaf || !!this.spec.atom;
      }
      /**
      Return true when this node type is part of the given
      [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
      */
      isInGroup(group) {
        return this.groups.indexOf(group) > -1;
      }
      /**
      The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
      */
      get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
      /**
      Tells you whether this node type has any required attributes.
      */
      hasRequiredAttrs() {
        for (let n in this.attrs)
          if (this.attrs[n].isRequired)
            return true;
        return false;
      }
      /**
      Indicates whether this node allows some of the same content as
      the given node type.
      */
      compatibleContent(other) {
        return this == other || this.contentMatch.compatible(other.contentMatch);
      }
      /**
      @internal
      */
      computeAttrs(attrs) {
        if (!attrs && this.defaultAttrs)
          return this.defaultAttrs;
        else
          return computeAttrs(this.attrs, attrs);
      }
      /**
      Create a `Node` of this type. The given attributes are
      checked and defaulted (you can pass `null` to use the type's
      defaults entirely, if no required attributes exist). `content`
      may be a `Fragment`, a node, an array of nodes, or
      `null`. Similarly `marks` may be `null` to default to the empty
      set of marks.
      */
      create(attrs = null, content, marks) {
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
      against the node type's content restrictions, and throw an error
      if it doesn't match.
      */
      createChecked(attrs = null, content, marks) {
        content = Fragment.from(content);
        this.checkContent(content);
        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
      }
      /**
      Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
      necessary to add nodes to the start or end of the given fragment
      to make it fit the node. If no fitting wrapping can be found,
      return null. Note that, due to the fact that required nodes can
      always be created, this will always succeed if you pass null or
      `Fragment.empty` as content.
      */
      createAndFill(attrs = null, content, marks) {
        attrs = this.computeAttrs(attrs);
        content = Fragment.from(content);
        if (content.size) {
          let before = this.contentMatch.fillBefore(content);
          if (!before)
            return null;
          content = before.append(content);
        }
        let matched = this.contentMatch.matchFragment(content);
        let after = matched && matched.fillBefore(Fragment.empty, true);
        if (!after)
          return null;
        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
      }
      /**
      Returns true if the given fragment is valid content for this node
      type.
      */
      validContent(content) {
        let result = this.contentMatch.matchFragment(content);
        if (!result || !result.validEnd)
          return false;
        for (let i2 = 0; i2 < content.childCount; i2++)
          if (!this.allowsMarks(content.child(i2).marks))
            return false;
        return true;
      }
      /**
      Throws a RangeError if the given fragment is not valid content for this
      node type.
      @internal
      */
      checkContent(content) {
        if (!this.validContent(content))
          throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "node", this.name);
      }
      /**
      Check whether the given mark type is allowed in this node.
      */
      allowsMarkType(markType) {
        return this.markSet == null || this.markSet.indexOf(markType) > -1;
      }
      /**
      Test whether the given set of marks are allowed in this node.
      */
      allowsMarks(marks) {
        if (this.markSet == null)
          return true;
        for (let i2 = 0; i2 < marks.length; i2++)
          if (!this.allowsMarkType(marks[i2].type))
            return false;
        return true;
      }
      /**
      Removes the marks that are not allowed in this node from the given set.
      */
      allowedMarks(marks) {
        if (this.markSet == null)
          return marks;
        let copy2;
        for (let i2 = 0; i2 < marks.length; i2++) {
          if (!this.allowsMarkType(marks[i2].type)) {
            if (!copy2)
              copy2 = marks.slice(0, i2);
          } else if (copy2) {
            copy2.push(marks[i2]);
          }
        }
        return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
      }
      /**
      @internal
      */
      static compile(nodes, schema) {
        let result = /* @__PURE__ */ Object.create(null);
        nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
        let topType = schema.spec.topNode || "doc";
        if (!result[topType])
          throw new RangeError("Schema is missing its top node type ('" + topType + "')");
        if (!result.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (let _ in result.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return result;
      }
    };
    function validateType(typeName, attrName, type) {
      let types = type.split("|");
      return (value) => {
        let name = value === null ? "null" : typeof value;
        if (types.indexOf(name) < 0)
          throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
      };
    }
    var Attribute = class {
      constructor(typeName, attrName, options) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this.default = options.default;
        this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
      }
      get isRequired() {
        return !this.hasDefault;
      }
    };
    var MarkType = class _MarkType {
      /**
      @internal
      */
      constructor(name, rank, schema, spec) {
        this.name = name;
        this.rank = rank;
        this.schema = schema;
        this.spec = spec;
        this.attrs = initAttrs(name, spec.attrs);
        this.excluded = null;
        let defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark(this, defaults) : null;
      }
      /**
      Create a mark of this type. `attrs` may be `null` or an object
      containing only some of the mark's attributes. The others, if
      they have defaults, will be added.
      */
      create(attrs = null) {
        if (!attrs && this.instance)
          return this.instance;
        return new Mark(this, computeAttrs(this.attrs, attrs));
      }
      /**
      @internal
      */
      static compile(marks, schema) {
        let result = /* @__PURE__ */ Object.create(null), rank = 0;
        marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
        return result;
      }
      /**
      When there is a mark of this type in the given set, a new set
      without it is returned. Otherwise, the input set is returned.
      */
      removeFromSet(set) {
        for (var i2 = 0; i2 < set.length; i2++)
          if (set[i2].type == this) {
            set = set.slice(0, i2).concat(set.slice(i2 + 1));
            i2--;
          }
        return set;
      }
      /**
      Tests whether there is a mark of this type in the given set.
      */
      isInSet(set) {
        for (let i2 = 0; i2 < set.length; i2++)
          if (set[i2].type == this)
            return set[i2];
      }
      /**
      @internal
      */
      checkAttrs(attrs) {
        checkAttrs(this.attrs, attrs, "mark", this.name);
      }
      /**
      Queries whether a given mark type is
      [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
      */
      excludes(other) {
        return this.excluded.indexOf(other) > -1;
      }
    };
    var Schema = class {
      /**
      Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
      */
      constructor(spec) {
        this.linebreakReplacement = null;
        this.cached = /* @__PURE__ */ Object.create(null);
        let instanceSpec = this.spec = {};
        for (let prop in spec)
          instanceSpec[prop] = spec[prop];
        instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        let contentExprCache = /* @__PURE__ */ Object.create(null);
        for (let prop in this.nodes) {
          if (prop in this.marks)
            throw new RangeError(prop + " can not be both a node and a mark");
          let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
          type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
          type.inlineContent = type.contentMatch.inlineContent;
          if (type.spec.linebreakReplacement) {
            if (this.linebreakReplacement)
              throw new RangeError("Multiple linebreak nodes defined");
            if (!type.isInline || !type.isLeaf)
              throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
            this.linebreakReplacement = type;
          }
          type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (let prop in this.marks) {
          let type = this.marks[prop], excl = type.spec.excludes;
          type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this);
        this.markFromJSON = this.markFromJSON.bind(this);
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      /**
      Create a node in this schema. The `type` may be a string or a
      `NodeType` instance. Attributes will be extended with defaults,
      `content` may be a `Fragment`, `null`, a `Node`, or an array of
      nodes.
      */
      node(type, attrs = null, content, marks) {
        if (typeof type == "string")
          type = this.nodeType(type);
        else if (!(type instanceof NodeType))
          throw new RangeError("Invalid node type: " + type);
        else if (type.schema != this)
          throw new RangeError("Node type from different schema used (" + type.name + ")");
        return type.createChecked(attrs, content, marks);
      }
      /**
      Create a text node in the schema. Empty text nodes are not
      allowed.
      */
      text(text, marks) {
        let type = this.nodes.text;
        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
      }
      /**
      Create a mark with the given type and attributes.
      */
      mark(type, attrs) {
        if (typeof type == "string")
          type = this.marks[type];
        return type.create(attrs);
      }
      /**
      Deserialize a node from its JSON representation. This method is
      bound.
      */
      nodeFromJSON(json) {
        return Node.fromJSON(this, json);
      }
      /**
      Deserialize a mark from its JSON representation. This method is
      bound.
      */
      markFromJSON(json) {
        return Mark.fromJSON(this, json);
      }
      /**
      @internal
      */
      nodeType(name) {
        let found2 = this.nodes[name];
        if (!found2)
          throw new RangeError("Unknown node type: " + name);
        return found2;
      }
    };
    function gatherMarks(schema, marks) {
      let found2 = [];
      for (let i2 = 0; i2 < marks.length; i2++) {
        let name = marks[i2], mark = schema.marks[name], ok = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (let prop in schema.marks) {
            let mark2 = schema.marks[prop];
            if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
              found2.push(ok = mark2);
          }
        }
        if (!ok)
          throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
      }
      return found2;
    }
    function isTagRule(rule) {
      return rule.tag != null;
    }
    function isStyleRule(rule) {
      return rule.style != null;
    }
    var DOMParser = class _DOMParser {
      /**
      Create a parser that targets the given schema, using the given
      parsing rules.
      */
      constructor(schema, rules) {
        this.schema = schema;
        this.rules = rules;
        this.tags = [];
        this.styles = [];
        let matchedStyles = this.matchedStyles = [];
        rules.forEach((rule) => {
          if (isTagRule(rule)) {
            this.tags.push(rule);
          } else if (isStyleRule(rule)) {
            let prop = /[^=]*/.exec(rule.style)[0];
            if (matchedStyles.indexOf(prop) < 0)
              matchedStyles.push(prop);
            this.styles.push(rule);
          }
        });
        this.normalizeLists = !this.tags.some((r) => {
          if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
            return false;
          let node = schema.nodes[r.node];
          return node.contentMatch.matchType(node);
        });
      }
      /**
      Parse a document from the content of a DOM node.
      */
      parse(dom, options = {}) {
        let context = new ParseContext(this, options, false);
        context.addAll(dom, Mark.none, options.from, options.to);
        return context.finish();
      }
      /**
      Parses the content of the given DOM node, like
      [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
      options. But unlike that method, which produces a whole node,
      this one returns a slice that is open at the sides, meaning that
      the schema constraints aren't applied to the start of nodes to
      the left of the input and the end of nodes at the end.
      */
      parseSlice(dom, options = {}) {
        let context = new ParseContext(this, options, true);
        context.addAll(dom, Mark.none, options.from, options.to);
        return Slice.maxOpen(context.finish());
      }
      /**
      @internal
      */
      matchTag(dom, context, after) {
        for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
          let rule = this.tags[i2];
          if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
            if (rule.getAttrs) {
              let result = rule.getAttrs(dom);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }
      /**
      @internal
      */
      matchStyle(prop, value, context, after) {
        for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
          let rule = this.styles[i2], style2 = rule.style;
          if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
            continue;
          if (rule.getAttrs) {
            let result = rule.getAttrs(value);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
      /**
      @internal
      */
      static schemaRules(schema) {
        let result = [];
        function insert(rule) {
          let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
          for (; i2 < result.length; i2++) {
            let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
            if (nextPriority < priority)
              break;
          }
          result.splice(i2, 0, rule);
        }
        for (let name in schema.marks) {
          let rules = schema.marks[name].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.mark || rule.ignore || rule.clearMark))
                rule.mark = name;
            });
        }
        for (let name in schema.nodes) {
          let rules = schema.nodes[name].spec.parseDOM;
          if (rules)
            rules.forEach((rule) => {
              insert(rule = copy(rule));
              if (!(rule.node || rule.ignore || rule.mark))
                rule.node = name;
            });
        }
        return result;
      }
      /**
      Construct a DOM parser using the parsing rules listed in a
      schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
      [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
      */
      static fromSchema(schema) {
        return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
      }
    };
    var blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    var ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    var listTags = { ol: true, ul: true };
    var OPT_PRESERVE_WS = 1;
    var OPT_PRESERVE_WS_FULL = 2;
    var OPT_OPEN_LEFT = 4;
    function wsOptionsFor(type, preserveWhitespace, base2) {
      if (preserveWhitespace != null)
        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
      return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
    }
    var NodeContext = class {
      constructor(type, attrs, marks, solid, match, options) {
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.solid = solid;
        this.options = options;
        this.content = [];
        this.activeMarks = Mark.none;
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      }
      findWrapping(node) {
        if (!this.match) {
          if (!this.type)
            return [];
          let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
          if (fill) {
            this.match = this.type.contentMatch.matchFragment(fill);
          } else {
            let start = this.type.contentMatch, wrap2;
            if (wrap2 = start.findWrapping(node.type)) {
              this.match = start;
              return wrap2;
            } else {
              return null;
            }
          }
        }
        return this.match.findWrapping(node.type);
      }
      finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) {
          let last = this.content[this.content.length - 1], m;
          if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
            let text = last;
            if (last.text.length == m[0].length)
              this.content.pop();
            else
              this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
          }
        }
        let content = Fragment.from(this.content);
        if (!openEnd && this.match)
          content = content.append(this.match.fillBefore(Fragment.empty, true));
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
      }
      inlineContext(node) {
        if (this.type)
          return this.type.inlineContent;
        if (this.content.length)
          return this.content[0].isInline;
        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
      }
    };
    var ParseContext = class {
      constructor(parser, options, isOpen) {
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        this.localPreserveWS = false;
        let topNode = options.topNode, topContext;
        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
          topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
        else
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
      }
      get top() {
        return this.nodes[this.open];
      }
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      addDOM(dom, marks) {
        if (dom.nodeType == 3)
          this.addTextNode(dom, marks);
        else if (dom.nodeType == 1)
          this.addElement(dom, marks);
      }
      addTextNode(dom, marks) {
        let value = dom.nodeValue;
        let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
        if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
          if (!preserveWS) {
            value = value.replace(/[ \t\r\n\u000c]+/g, " ");
            if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
              let nodeBefore = top.content[top.content.length - 1];
              let domNodeBefore = dom.previousSibling;
              if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                value = value.slice(1);
            }
          } else if (preserveWS !== "full") {
            value = value.replace(/\r?\n|\r/g, " ");
          } else {
            value = value.replace(/\r\n?/g, "\n");
          }
          if (value)
            this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
          this.findInText(dom);
        } else {
          this.findInside(dom);
        }
      }
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      addElement(dom, marks, matchAfter) {
        let outerWS = this.localPreserveWS, top = this.top;
        if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
          this.localPreserveWS = true;
        let name = dom.nodeName.toLowerCase(), ruleID;
        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
          normalizeList(dom);
        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
          this.findInside(dom);
          this.ignoreFallback(dom, marks);
        } else if (!rule || rule.skip || rule.closeParent) {
          if (rule && rule.closeParent)
            this.open = Math.max(0, this.open - 1);
          else if (rule && rule.skip.nodeType)
            dom = rule.skip;
          let sync, oldNeedsBlock = this.needsBlock;
          if (blockTags.hasOwnProperty(name)) {
            if (top.content.length && top.content[0].isInline && this.open) {
              this.open--;
              top = this.top;
            }
            sync = true;
            if (!top.type)
              this.needsBlock = true;
          } else if (!dom.firstChild) {
            this.leafFallback(dom, marks);
            break out;
          }
          let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
          if (innerMarks)
            this.addAll(dom, innerMarks);
          if (sync)
            this.sync(top);
          this.needsBlock = oldNeedsBlock;
        } else {
          let innerMarks = this.readStyles(dom, marks);
          if (innerMarks)
            this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
        }
        this.localPreserveWS = outerWS;
      }
      // Called for leaf DOM nodes that would otherwise be ignored
      leafFallback(dom, marks) {
        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
          this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
      }
      // Called for ignored nodes
      ignoreFallback(dom, marks) {
        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
          this.findPlace(this.parser.schema.text("-"), marks, true);
      }
      // Run any style parser associated with the node's styles. Either
      // return an updated array of marks, or null to indicate some of the
      // styles had a rule with `ignore` set.
      readStyles(dom, marks) {
        let styles = dom.style;
        if (styles && styles.length)
          for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
            let name = this.parser.matchedStyles[i2], value = styles.getPropertyValue(name);
            if (value)
              for (let after = void 0; ; ) {
                let rule = this.parser.matchStyle(name, value, this, after);
                if (!rule)
                  break;
                if (rule.ignore)
                  return null;
                if (rule.clearMark)
                  marks = marks.filter((m) => !rule.clearMark(m));
                else
                  marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
                if (rule.consuming === false)
                  after = rule;
                else
                  break;
              }
          }
        return marks;
      }
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      addElementByRule(dom, rule, marks, continueAfter) {
        let sync, nodeType;
        if (rule.node) {
          nodeType = this.parser.schema.nodes[rule.node];
          if (!nodeType.isLeaf) {
            let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
            if (inner) {
              sync = true;
              marks = inner;
            }
          } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
            this.leafFallback(dom, marks);
          }
        } else {
          let markType = this.parser.schema.marks[rule.mark];
          marks = marks.concat(markType.create(rule.attrs));
        }
        let startIn = this.top;
        if (nodeType && nodeType.isLeaf) {
          this.findInside(dom);
        } else if (continueAfter) {
          this.addElement(dom, marks, continueAfter);
        } else if (rule.getContent) {
          this.findInside(dom);
          rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
        } else {
          let contentDOM = dom;
          if (typeof rule.contentElement == "string")
            contentDOM = dom.querySelector(rule.contentElement);
          else if (typeof rule.contentElement == "function")
            contentDOM = rule.contentElement(dom);
          else if (rule.contentElement)
            contentDOM = rule.contentElement;
          this.findAround(dom, contentDOM, true);
          this.addAll(contentDOM, marks);
          this.findAround(dom, contentDOM, false);
        }
        if (sync && this.sync(startIn))
          this.open--;
      }
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      addAll(parent, marks, startIndex, endIndex) {
        let index = startIndex || 0;
        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
          this.findAtPoint(parent, index);
          this.addDOM(dom, marks);
        }
        this.findAtPoint(parent, index);
      }
      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      findPlace(node, marks, cautious) {
        let route, sync;
        for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
          let cx = this.nodes[depth];
          let found2 = cx.findWrapping(node);
          if (found2 && (!route || route.length > found2.length + penalty)) {
            route = found2;
            sync = cx;
            if (!found2.length)
              break;
          }
          if (cx.solid) {
            if (cautious)
              break;
            penalty += 2;
          }
        }
        if (!route)
          return null;
        this.sync(sync);
        for (let i2 = 0; i2 < route.length; i2++)
          marks = this.enterInner(route[i2], null, marks, false);
        return marks;
      }
      // Try to insert the given node, adjusting the context when needed.
      insertNode(node, marks, cautious) {
        if (node.isInline && this.needsBlock && !this.top.type) {
          let block = this.textblockFromContext();
          if (block)
            marks = this.enterInner(block, null, marks);
        }
        let innerMarks = this.findPlace(node, marks, cautious);
        if (innerMarks) {
          this.closeExtra();
          let top = this.top;
          if (top.match)
            top.match = top.match.matchType(node.type);
          let nodeMarks = Mark.none;
          for (let m of innerMarks.concat(node.marks))
            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
              nodeMarks = m.addToSet(nodeMarks);
          top.content.push(node.mark(nodeMarks));
          return true;
        }
        return false;
      }
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      enter(type, attrs, marks, preserveWS) {
        let innerMarks = this.findPlace(type.create(attrs), marks, false);
        if (innerMarks)
          innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
        return innerMarks;
      }
      // Open a node of the given type
      enterInner(type, attrs, marks, solid = false, preserveWS) {
        this.closeExtra();
        let top = this.top;
        top.match = top.match && top.match.matchType(type);
        let options = wsOptionsFor(type, preserveWS, top.options);
        if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
          options |= OPT_OPEN_LEFT;
        let applyMarks = Mark.none;
        marks = marks.filter((m) => {
          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
            applyMarks = m.addToSet(applyMarks);
            return false;
          }
          return true;
        });
        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
        this.open++;
        return marks;
      }
      // Make sure all nodes above this.open are finished and added to
      // their parents
      closeExtra(openEnd = false) {
        let i2 = this.nodes.length - 1;
        if (i2 > this.open) {
          for (; i2 > this.open; i2--)
            this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
          this.nodes.length = this.open + 1;
        }
      }
      finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
      }
      sync(to) {
        for (let i2 = this.open; i2 >= 0; i2--) {
          if (this.nodes[i2] == to) {
            this.open = i2;
            return true;
          } else if (this.localPreserveWS) {
            this.nodes[i2].options |= OPT_PRESERVE_WS;
          }
        }
        return false;
      }
      get currentPos() {
        this.closeExtra();
        let pos = 0;
        for (let i2 = this.open; i2 >= 0; i2--) {
          let content = this.nodes[i2].content;
          for (let j = content.length - 1; j >= 0; j--)
            pos += content[j].nodeSize;
          if (i2)
            pos++;
        }
        return pos;
      }
      findAtPoint(parent, offset) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == parent && this.find[i2].offset == offset)
              this.find[i2].pos = this.currentPos;
          }
      }
      findInside(parent) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
              this.find[i2].pos = this.currentPos;
          }
      }
      findAround(parent, content, before) {
        if (parent != content && this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
              let pos = content.compareDocumentPosition(this.find[i2].node);
              if (pos & (before ? 2 : 4))
                this.find[i2].pos = this.currentPos;
            }
          }
      }
      findInText(textNode) {
        if (this.find)
          for (let i2 = 0; i2 < this.find.length; i2++) {
            if (this.find[i2].node == textNode)
              this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
          }
      }
      // Determines whether the given context string matches this context.
      matchesContext(context) {
        if (context.indexOf("|") > -1)
          return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        let parts = context.split("/");
        let option = this.options.context;
        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        let match = (i2, depth) => {
          for (; i2 >= 0; i2--) {
            let part = parts[i2];
            if (part == "") {
              if (i2 == parts.length - 1 || i2 == 0)
                continue;
              for (; depth >= minDepth; depth--)
                if (match(i2 - 1, depth))
                  return true;
              return false;
            } else {
              let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
              if (!next || next.name != part && !next.isInGroup(part))
                return false;
              depth--;
            }
          }
          return true;
        };
        return match(parts.length - 1, this.open);
      }
      textblockFromContext() {
        let $context = this.options.context;
        if ($context)
          for (let d = $context.depth; d >= 0; d--) {
            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs)
              return deflt;
          }
        for (let name in this.parser.schema.nodes) {
          let type = this.parser.schema.nodes[name];
          if (type.isTextblock && type.defaultAttrs)
            return type;
        }
      }
    };
    function normalizeList(dom) {
      for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function copy(obj) {
      let copy2 = {};
      for (let prop in obj)
        copy2[prop] = obj[prop];
      return copy2;
    }
    function markMayApply(markType, nodeType) {
      let nodes = nodeType.schema.nodes;
      for (let name in nodes) {
        let parent = nodes[name];
        if (!parent.allowsMarkType(markType))
          continue;
        let seen = [], scan = (match) => {
          seen.push(match);
          for (let i2 = 0; i2 < match.edgeCount; i2++) {
            let { type, next } = match.edge(i2);
            if (type == nodeType)
              return true;
            if (seen.indexOf(next) < 0 && scan(next))
              return true;
          }
        };
        if (scan(parent.contentMatch))
          return true;
      }
    }
    var DOMSerializer = class _DOMSerializer {
      /**
      Create a serializer. `nodes` should map node names to functions
      that take a node and return a description of the corresponding
      DOM. `marks` does the same for mark names, but also gets an
      argument that tells it whether the mark's content is block or
      inline content (for typical use, it'll always be inline). A mark
      serializer may be `null` to indicate that marks of that type
      should not be serialized.
      */
      constructor(nodes, marks) {
        this.nodes = nodes;
        this.marks = marks;
      }
      /**
      Serialize the content of this fragment to a DOM fragment. When
      not in the browser, the `document` option, containing a DOM
      document, should be passed so that the serializer can create
      nodes.
      */
      serializeFragment(fragment, options = {}, target) {
        if (!target)
          target = doc(options).createDocumentFragment();
        let top = target, active = [];
        fragment.forEach((node) => {
          if (active.length || node.marks.length) {
            let keep = 0, rendered = 0;
            while (keep < active.length && rendered < node.marks.length) {
              let next = node.marks[rendered];
              if (!this.marks[next.type.name]) {
                rendered++;
                continue;
              }
              if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                break;
              keep++;
              rendered++;
            }
            while (keep < active.length)
              top = active.pop()[1];
            while (rendered < node.marks.length) {
              let add = node.marks[rendered++];
              let markDOM = this.serializeMark(add, node.isInline, options);
              if (markDOM) {
                active.push([add, top]);
                top.appendChild(markDOM.dom);
                top = markDOM.contentDOM || markDOM.dom;
              }
            }
          }
          top.appendChild(this.serializeNodeInner(node, options));
        });
        return target;
      }
      /**
      @internal
      */
      serializeNodeInner(node, options) {
        let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
        if (contentDOM) {
          if (node.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(node.content, options, contentDOM);
        }
        return dom;
      }
      /**
      Serialize this node to a DOM node. This can be useful when you
      need to serialize a part of a document, as opposed to the whole
      document. To serialize a whole document, use
      [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
      its [content](https://prosemirror.net/docs/ref/#model.Node.content).
      */
      serializeNode(node, options = {}) {
        let dom = this.serializeNodeInner(node, options);
        for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
          let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options);
          if (wrap2) {
            (wrap2.contentDOM || wrap2.dom).appendChild(dom);
            dom = wrap2.dom;
          }
        }
        return dom;
      }
      /**
      @internal
      */
      serializeMark(mark, inline, options = {}) {
        let toDOM = this.marks[mark.type.name];
        return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
      }
      static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
        return renderSpec(doc3, structure, xmlNS, blockArraysIn);
      }
      /**
      Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
      properties in a schema's node and mark specs.
      */
      static fromSchema(schema) {
        return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
      }
      /**
      Gather the serializers in a schema's node specs into an object.
      This can be useful as a base to build a custom serializer from.
      */
      static nodesFromSchema(schema) {
        let result = gatherToDOM(schema.nodes);
        if (!result.text)
          result.text = (node) => node.text;
        return result;
      }
      /**
      Gather the serializers in a schema's mark specs into an object.
      */
      static marksFromSchema(schema) {
        return gatherToDOM(schema.marks);
      }
    };
    function gatherToDOM(obj) {
      let result = {};
      for (let name in obj) {
        let toDOM = obj[name].spec.toDOM;
        if (toDOM)
          result[name] = toDOM;
      }
      return result;
    }
    function doc(options) {
      return options.document || window.document;
    }
    var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
    function suspiciousAttributes(attrs) {
      let value = suspiciousAttributeCache.get(attrs);
      if (value === void 0)
        suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
      return value;
    }
    function suspiciousAttributesInner(attrs) {
      let result = null;
      function scan(value) {
        if (value && typeof value == "object") {
          if (Array.isArray(value)) {
            if (typeof value[0] == "string") {
              if (!result)
                result = [];
              result.push(value);
            } else {
              for (let i2 = 0; i2 < value.length; i2++)
                scan(value[i2]);
            }
          } else {
            for (let prop in value)
              scan(value[prop]);
          }
        }
      }
      scan(attrs);
      return result;
    }
    function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
      if (typeof structure == "string")
        return { dom: doc3.createTextNode(structure) };
      if (structure.nodeType != null)
        return { dom: structure };
      if (structure.dom && structure.dom.nodeType != null)
        return structure;
      let tagName = structure[0], suspicious;
      if (typeof tagName != "string")
        throw new RangeError("Invalid array passed to renderSpec");
      if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
      let space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      let contentDOM;
      let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
      let attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (let name in attrs)
          if (attrs[name] != null) {
            let space2 = name.indexOf(" ");
            if (space2 > 0)
              dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
            else
              dom.setAttribute(name, attrs[name]);
          }
      }
      for (let i2 = start; i2 < structure.length; i2++) {
        let child = structure[i2];
        if (child === 0) {
          if (i2 < structure.length - 1 || i2 > start)
            throw new RangeError("Content hole must be the only child of its parent node");
          return { dom, contentDOM: dom };
        } else {
          let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM)
              throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    }
    var lower16 = 65535;
    var factor16 = Math.pow(2, 16);
    function makeRecover(index, offset) {
      return index + offset * factor16;
    }
    function recoverIndex(value) {
      return value & lower16;
    }
    function recoverOffset(value) {
      return (value - (value & lower16)) / factor16;
    }
    var DEL_BEFORE = 1;
    var DEL_AFTER = 2;
    var DEL_ACROSS = 4;
    var DEL_SIDE = 8;
    var MapResult = class {
      /**
      @internal
      */
      constructor(pos, delInfo, recover) {
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      /**
      Tells you whether the position was deleted, that is, whether the
      step removed the token on the side queried (via the `assoc`)
      argument from the document.
      */
      get deleted() {
        return (this.delInfo & DEL_SIDE) > 0;
      }
      /**
      Tells you whether the token before the mapped position was deleted.
      */
      get deletedBefore() {
        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
      }
      /**
      True when the token after the mapped position was deleted.
      */
      get deletedAfter() {
        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
      }
      /**
      Tells whether any of the steps mapped through deletes across the
      position (including both the token before and after the
      position).
      */
      get deletedAcross() {
        return (this.delInfo & DEL_ACROSS) > 0;
      }
    };
    var StepMap = class _StepMap {
      /**
      Create a position map. The modifications to the document are
      represented as an array of numbers, in which each group of three
      represents a modified chunk as `[start, oldSize, newSize]`.
      */
      constructor(ranges, inverted = false) {
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && _StepMap.empty)
          return _StepMap.empty;
      }
      /**
      @internal
      */
      recover(value) {
        let diff = 0, index = recoverIndex(value);
        if (!this.inverted)
          for (let i2 = 0; i2 < index; i2++)
            diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
        return this.ranges[index * 3] + diff + recoverOffset(value);
      }
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      map(pos, assoc = 1) {
        return this._map(pos, assoc, true);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
          if (pos <= end) {
            let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
            let result = start + diff + (side < 0 ? 0 : newSize);
            if (simple)
              return result;
            let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
            let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
            if (assoc < 0 ? pos != start : pos != end)
              del2 |= DEL_SIDE;
            return new MapResult(result, del2, recover);
          }
          diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff, 0, null);
      }
      /**
      @internal
      */
      touches(pos, recover) {
        let diff = 0, index = recoverIndex(recover);
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2] - (this.inverted ? diff : 0);
          if (start > pos)
            break;
          let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
          if (pos <= end && i2 == index * 3)
            return true;
          diff += this.ranges[i2 + newIndex] - oldSize;
        }
        return false;
      }
      /**
      Calls the given function on each of the changed ranges included in
      this map.
      */
      forEach(f) {
        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
        for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
          let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
          let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
          f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
          diff += newSize - oldSize;
        }
      }
      /**
      Create an inverted version of this map. The result can be used to
      map positions in the post-step document to the pre-step document.
      */
      invert() {
        return new _StepMap(this.ranges, !this.inverted);
      }
      /**
      @internal
      */
      toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      }
      /**
      Create a map that moves all positions by offset `n` (which may be
      negative). This can be useful when applying steps meant for a
      sub-document to a larger document, or vice-versa.
      */
      static offset(n) {
        return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
      }
    };
    StepMap.empty = new StepMap([]);
    var Mapping = class _Mapping {
      /**
      Create a new mapping with the given position maps.
      */
      constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
        this.mirror = mirror;
        this.from = from2;
        this.to = to;
        this._maps = maps || [];
        this.ownData = !(maps || mirror);
      }
      /**
      The step maps in this mapping.
      */
      get maps() {
        return this._maps;
      }
      /**
      Create a mapping that maps only through a part of this one.
      */
      slice(from2 = 0, to = this.maps.length) {
        return new _Mapping(this._maps, this.mirror, from2, to);
      }
      /**
      Add a step map to the end of this mapping. If `mirrors` is
      given, it should be the index of the step map that is the mirror
      image of this one.
      */
      appendMap(map2, mirrors) {
        if (!this.ownData) {
          this._maps = this._maps.slice();
          this.mirror = this.mirror && this.mirror.slice();
          this.ownData = true;
        }
        this.to = this._maps.push(map2);
        if (mirrors != null)
          this.setMirror(this._maps.length - 1, mirrors);
      }
      /**
      Add all the step maps in a given mapping to this one (preserving
      mirroring information).
      */
      appendMapping(mapping) {
        for (let i2 = 0, startSize = this._maps.length; i2 < mapping._maps.length; i2++) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping._maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
        }
      }
      /**
      Finds the offset of the step map that mirrors the map at the
      given offset, in this mapping (as per the second argument to
      `appendMap`).
      */
      getMirror(n) {
        if (this.mirror) {
          for (let i2 = 0; i2 < this.mirror.length; i2++)
            if (this.mirror[i2] == n)
              return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
        }
      }
      /**
      @internal
      */
      setMirror(n, m) {
        if (!this.mirror)
          this.mirror = [];
        this.mirror.push(n, m);
      }
      /**
      Append the inverse of the given mapping to this one.
      */
      appendMappingInverted(mapping) {
        for (let i2 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i2 >= 0; i2--) {
          let mirr = mapping.getMirror(i2);
          this.appendMap(mapping._maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
        }
      }
      /**
      Create an inverted version of this mapping.
      */
      invert() {
        let inverse = new _Mapping();
        inverse.appendMappingInverted(this);
        return inverse;
      }
      /**
      Map a position through this mapping.
      */
      map(pos, assoc = 1) {
        if (this.mirror)
          return this._map(pos, assoc, true);
        for (let i2 = this.from; i2 < this.to; i2++)
          pos = this._maps[i2].map(pos, assoc);
        return pos;
      }
      /**
      Map a position through this mapping, returning a mapping
      result.
      */
      mapResult(pos, assoc = 1) {
        return this._map(pos, assoc, false);
      }
      /**
      @internal
      */
      _map(pos, assoc, simple) {
        let delInfo = 0;
        for (let i2 = this.from; i2 < this.to; i2++) {
          let map2 = this._maps[i2], result = map2.mapResult(pos, assoc);
          if (result.recover != null) {
            let corr = this.getMirror(i2);
            if (corr != null && corr > i2 && corr < this.to) {
              i2 = corr;
              pos = this._maps[corr].recover(result.recover);
              continue;
            }
          }
          delInfo |= result.delInfo;
          pos = result.pos;
        }
        return simple ? pos : new MapResult(pos, delInfo, null);
      }
    };
    var stepsByID = /* @__PURE__ */ Object.create(null);
    var Step = class {
      /**
      Get the step map that represents the changes made by this step,
      and which can be used to transform between positions in the old
      and the new document.
      */
      getMap() {
        return StepMap.empty;
      }
      /**
      Try to merge this step with another one, to be applied directly
      after it. Returns the merged step when possible, null if the
      steps can't be merged.
      */
      merge(other) {
        return null;
      }
      /**
      Deserialize a step from its JSON representation. Will call
      through to the step class' own implementation of this method.
      */
      static fromJSON(schema, json) {
        if (!json || !json.stepType)
          throw new RangeError("Invalid input for Step.fromJSON");
        let type = stepsByID[json.stepType];
        if (!type)
          throw new RangeError(`No step type ${json.stepType} defined`);
        return type.fromJSON(schema, json);
      }
      /**
      To be able to serialize steps to JSON, each step needs a string
      ID to attach to its JSON representation. Use this method to
      register an ID for your step classes. Try to pick something
      that's unlikely to clash with steps from other modules.
      */
      static jsonID(id, stepClass) {
        if (id in stepsByID)
          throw new RangeError("Duplicate use of step JSON ID " + id);
        stepsByID[id] = stepClass;
        stepClass.prototype.jsonID = id;
        return stepClass;
      }
    };
    var StepResult = class _StepResult {
      /**
      @internal
      */
      constructor(doc3, failed) {
        this.doc = doc3;
        this.failed = failed;
      }
      /**
      Create a successful step result.
      */
      static ok(doc3) {
        return new _StepResult(doc3, null);
      }
      /**
      Create a failed step result.
      */
      static fail(message) {
        return new _StepResult(null, message);
      }
      /**
      Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
      arguments. Create a successful result if it succeeds, and a
      failed one if it throws a `ReplaceError`.
      */
      static fromReplace(doc3, from2, to, slice2) {
        try {
          return _StepResult.ok(doc3.replace(from2, to, slice2));
        } catch (e) {
          if (e instanceof ReplaceError)
            return _StepResult.fail(e.message);
          throw e;
        }
      }
    };
    function mapFragment(fragment, f, parent) {
      let mapped = [];
      for (let i2 = 0; i2 < fragment.childCount; i2++) {
        let child = fragment.child(i2);
        if (child.content.size)
          child = child.copy(mapFragment(child.content, f, child));
        if (child.isInline)
          child = f(child, parent, i2);
        mapped.push(child);
      }
      return Fragment.fromArray(mapped);
    }
    var AddMarkStep = class _AddMarkStep extends Step {
      /**
      Create a mark step.
      */
      constructor(from2, to, mark) {
        super();
        this.from = from2;
        this.to = to;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
        let parent = $from.node($from.sharedDepth(this.to));
        let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
          if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
            return node;
          return node.mark(this.mark.addToSet(node.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deleted && to.deleted || from2.pos >= to.pos)
          return null;
        return new _AddMarkStep(from2.pos, to.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
      }
    };
    Step.jsonID("addMark", AddMarkStep);
    var RemoveMarkStep = class _RemoveMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(from2, to, mark) {
        super();
        this.from = from2;
        this.to = to;
        this.mark = mark;
      }
      apply(doc3) {
        let oldSlice = doc3.slice(this.from, this.to);
        let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
          return node.mark(this.mark.removeFromSet(node.marks));
        }, doc3), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc3, this.from, this.to, slice2);
      }
      invert() {
        return new AddMarkStep(this.from, this.to, this.mark);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deleted && to.deleted || from2.pos >= to.pos)
          return null;
        return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
      }
      merge(other) {
        if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
          return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
        return null;
      }
      toJSON() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
      }
    };
    Step.jsonID("removeMark", RemoveMarkStep);
    var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
      /**
      Create a node mark step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (node) {
          let newSet = this.mark.addToSet(node.marks);
          if (newSet.length == node.marks.length) {
            for (let i2 = 0; i2 < node.marks.length; i2++)
              if (!node.marks[i2].isInSet(newSet))
                return new _AddNodeMarkStep(this.pos, node.marks[i2]);
            return new _AddNodeMarkStep(this.pos, this.mark);
          }
        }
        return new RemoveNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
      }
    };
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
      /**
      Create a mark-removing step.
      */
      constructor(pos, mark) {
        super();
        this.pos = pos;
        this.mark = mark;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at mark step's position");
        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      invert(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node || !this.mark.isInSet(node.marks))
          return this;
        return new AddNodeMarkStep(this.pos, this.mark);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
      }
      toJSON() {
        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
      }
    };
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    var ReplaceStep = class _ReplaceStep extends Step {
      /**
      The given `slice` should fit the 'gap' between `from` and
      `to`the depths must line up, and the surrounding nodes must be
      able to be joined with the open sides of the slice. When
      `structure` is true, the step will fail if the content between
      from and to is not just a sequence of closing and then opening
      tokens (this is to guard against rebased replace steps
      overwriting something they weren't supposed to).
      */
      constructor(from2, to, slice2, structure = false) {
        super();
        this.from = from2;
        this.to = to;
        this.slice = slice2;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && contentBetween(doc3, this.from, this.to))
          return StepResult.fail("Structure replace would overwrite content");
        return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
      }
      getMap() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      }
      invert(doc3) {
        return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from2.deletedAcross && to.deletedAcross)
          return null;
        return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
      }
      merge(other) {
        if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
          return null;
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new _ReplaceStep(other.from, this.to, slice2, this.structure);
        } else {
          return null;
        }
      }
      toJSON() {
        let json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
      }
    };
    Step.jsonID("replace", ReplaceStep);
    var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
      /**
      Create a replace-around step with the given range and gap.
      `insert` should be the point in the slice into which the content
      of the gap should be moved. `structure` has the same meaning as
      it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
      */
      constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
        super();
        this.from = from2;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice2;
        this.insert = insert;
        this.structure = structure;
      }
      apply(doc3) {
        if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
          return StepResult.fail("Structure gap-replace would overwrite content");
        let gap = doc3.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
          return StepResult.fail("Gap is not a flat range");
        let inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted)
          return StepResult.fail("Content does not fit in gap");
        return StepResult.fromReplace(doc3, this.from, this.to, inserted);
      }
      getMap() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      }
      invert(doc3) {
        let gap = this.gapTo - this.gapFrom;
        return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
      }
      map(mapping) {
        let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
        if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
          return null;
        return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      }
      toJSON() {
        let json = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size)
          json.slice = this.slice.toJSON();
        if (this.structure)
          json.structure = true;
        return json;
      }
      /**
      @internal
      */
      static fromJSON(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
      }
    };
    Step.jsonID("replaceAround", ReplaceAroundStep);
    function contentBetween(doc3, from2, to) {
      let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        let next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf)
            return true;
          next = next.firstChild;
          dist--;
        }
      }
      return false;
    }
    function addMark(tr, from2, to, mark) {
      let removed = [], added = [];
      let removing, adding;
      tr.doc.nodesBetween(from2, to, (node, pos, parent) => {
        if (!node.isInline)
          return;
        let marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
          let newSet = mark.addToSet(marks);
          for (let i2 = 0; i2 < marks.length; i2++) {
            if (!marks[i2].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i2]))
                removing.to = end;
              else
                removed.push(removing = new RemoveMarkStep(start, end, marks[i2]));
            }
          }
          if (adding && adding.to == start)
            adding.to = end;
          else
            added.push(adding = new AddMarkStep(start, end, mark));
        }
      });
      removed.forEach((s) => tr.step(s));
      added.forEach((s) => tr.step(s));
    }
    function removeMark(tr, from2, to, mark) {
      let matched = [], step = 0;
      tr.doc.nodesBetween(from2, to, (node, pos) => {
        if (!node.isInline)
          return;
        step++;
        let toRemove = null;
        if (mark instanceof MarkType) {
          let set = node.marks, found2;
          while (found2 = mark.isInSet(set)) {
            (toRemove || (toRemove = [])).push(found2);
            set = found2.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks))
            toRemove = [mark];
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          let end = Math.min(pos + node.nodeSize, to);
          for (let i2 = 0; i2 < toRemove.length; i2++) {
            let style2 = toRemove[i2], found2;
            for (let j = 0; j < matched.length; j++) {
              let m = matched[j];
              if (m.step == step - 1 && style2.eq(matched[j].style))
                found2 = m;
            }
            if (found2) {
              found2.to = end;
              found2.step = step;
            } else {
              matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
            }
          }
        }
      });
      matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
    }
    function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
      let node = tr.doc.nodeAt(pos);
      let replSteps = [], cur = pos + 1;
      for (let i2 = 0; i2 < node.childCount; i2++) {
        let child = node.child(i2), end = cur + child.nodeSize;
        let allowed = match.matchType(child.type);
        if (!allowed) {
          replSteps.push(new ReplaceStep(cur, end, Slice.empty));
        } else {
          match = allowed;
          for (let j = 0; j < child.marks.length; j++)
            if (!parentType.allowsMarkType(child.marks[j].type))
              tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
          if (clearNewlines && child.isText && parentType.whitespace != "pre") {
            let m, newline = /\r?\n|\r/g, slice2;
            while (m = newline.exec(child.text)) {
              if (!slice2)
                slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
              replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
            }
          }
        }
        cur = end;
      }
      if (!match.validEnd) {
        let fill = match.fillBefore(Fragment.empty, true);
        tr.replace(cur, cur, new Slice(fill, 0, 0));
      }
      for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
        tr.step(replSteps[i2]);
    }
    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
    }
    function liftTarget(range) {
      let parent = range.parent;
      let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
      for (let depth = range.depth; ; --depth) {
        let node = range.$from.node(depth);
        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
        if (depth < range.depth && node.canReplace(index, endIndex, content))
          return depth;
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
          break;
      }
      return null;
    }
    function lift(tr, range, target) {
      let { $from, $to, depth } = range;
      let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      let start = gapStart, end = gapEnd;
      let before = Fragment.empty, openStart = 0;
      for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $from.index(d) > 0) {
          splitting = true;
          before = Fragment.from($from.node(d).copy(before));
          openStart++;
        } else {
          start--;
        }
      let after = Fragment.empty, openEnd = 0;
      for (let d = depth, splitting = false; d > target; d--)
        if (splitting || $to.after(d + 1) < $to.end(d)) {
          splitting = true;
          after = Fragment.from($to.node(d).copy(after));
          openEnd++;
        } else {
          end++;
        }
      tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
    }
    function findWrapping(range, nodeType, attrs = null, innerRange = range) {
      let around = findWrappingOutside(range, nodeType);
      let inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner)
        return null;
      return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
    }
    function withAttrs(type) {
      return { type, attrs: null };
    }
    function findWrappingOutside(range, type) {
      let { parent, startIndex, endIndex } = range;
      let around = parent.contentMatchAt(startIndex).findWrapping(type);
      if (!around)
        return null;
      let outer = around.length ? around[0] : type;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    function findWrappingInside(range, type) {
      let { parent, startIndex, endIndex } = range;
      let inner = parent.child(startIndex);
      let inside = type.contentMatch.findWrapping(inner.type);
      if (!inside)
        return null;
      let lastType = inside.length ? inside[inside.length - 1] : type;
      let innerMatch = lastType.contentMatch;
      for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
        innerMatch = innerMatch.matchType(parent.child(i2).type);
      if (!innerMatch || !innerMatch.validEnd)
        return null;
      return inside;
    }
    function wrap(tr, range, wrappers) {
      let content = Fragment.empty;
      for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
        if (content.size) {
          let match = wrappers[i2].type.contentMatch.matchFragment(content);
          if (!match || !match.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
      }
      let start = range.start, end = range.end;
      tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
    }
    function setBlockType(tr, from2, to, type, attrs) {
      if (!type.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      let mapFrom = tr.steps.length;
      tr.doc.nodesBetween(from2, to, (node, pos) => {
        let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
        if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
          let convertNewlines = null;
          if (type.schema.linebreakReplacement) {
            let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
            if (pre && !supportLinebreak)
              convertNewlines = false;
            else if (!pre && supportLinebreak)
              convertNewlines = true;
          }
          if (convertNewlines === false)
            replaceLinebreaks(tr, node, pos, mapFrom);
          clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
          let mapping = tr.mapping.slice(mapFrom);
          let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
          if (convertNewlines === true)
            replaceNewlines(tr, node, pos, mapFrom);
          return false;
        }
      });
    }
    function replaceNewlines(tr, node, pos, mapFrom) {
      node.forEach((child, offset) => {
        if (child.isText) {
          let m, newline = /\r?\n|\r/g;
          while (m = newline.exec(child.text)) {
            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
            tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
          }
        }
      });
    }
    function replaceLinebreaks(tr, node, pos, mapFrom) {
      node.forEach((child, offset) => {
        if (child.type == child.type.schema.linebreakReplacement) {
          let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
          tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
        }
      });
    }
    function canChangeType(doc3, pos, type) {
      let $pos = doc3.resolve(pos), index = $pos.index();
      return $pos.parent.canReplaceWith(index, index + 1, type);
    }
    function setNodeMarkup(tr, pos, type, attrs, marks) {
      let node = tr.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at given position");
      if (!type)
        type = node.type;
      let newNode = type.create(attrs, null, marks || node.marks);
      if (node.isLeaf)
        return tr.replaceWith(pos, pos + node.nodeSize, newNode);
      if (!type.validContent(node.content))
        throw new RangeError("Invalid content for node type " + type.name);
      tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
    }
    function canSplit(doc3, pos, depth = 1, typesAfter) {
      let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
      let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
      if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
        return false;
      for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
        let node = $pos.node(d), index2 = $pos.index(d);
        if (node.type.spec.isolating)
          return false;
        let rest = node.content.cutByIndex(index2, node.childCount);
        let overrideChild = typesAfter && typesAfter[i2 + 1];
        if (overrideChild)
          rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
        let after = typesAfter && typesAfter[i2] || node;
        if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
          return false;
      }
      let index = $pos.indexAfter(base2);
      let baseType = typesAfter && typesAfter[0];
      return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
    }
    function split(tr, pos, depth = 1, typesAfter) {
      let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
      for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
        before = Fragment.from($pos.node(d).copy(before));
        let typeAfter = typesAfter && typesAfter[i2];
        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
    }
    function canJoin(doc3, pos) {
      let $pos = doc3.resolve(pos), index = $pos.index();
      return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
    }
    function canAppendWithSubstitutedLinebreaks(a, b) {
      if (!b.content.size)
        a.type.compatibleContent(b.type);
      let match = a.contentMatchAt(a.childCount);
      let { linebreakReplacement } = a.type.schema;
      for (let i2 = 0; i2 < b.childCount; i2++) {
        let child = b.child(i2);
        let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
        match = match.matchType(type);
        if (!match)
          return false;
        if (!a.type.allowsMarks(child.marks))
          return false;
      }
      return match.validEnd;
    }
    function joinable2(a, b) {
      return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
    }
    function joinPoint(doc3, pos, dir = -1) {
      let $pos = doc3.resolve(pos);
      for (let d = $pos.depth; ; d--) {
        let before, after, index = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index++;
          after = $pos.node(d).maybeChild(index);
        } else {
          before = $pos.node(d).maybeChild(index - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
          return pos;
        if (d == 0)
          break;
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }
    function join(tr, pos, depth) {
      let convertNewlines = null;
      let { linebreakReplacement } = tr.doc.type.schema;
      let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
      if (linebreakReplacement && beforeType.inlineContent) {
        let pre = beforeType.whitespace == "pre";
        let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      let mapFrom = tr.steps.length;
      if (convertNewlines === false) {
        let $after = tr.doc.resolve(pos + depth);
        replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
      }
      if (beforeType.inlineContent)
        clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
      let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
      tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
      if (convertNewlines === true) {
        let $full = tr.doc.resolve(start);
        replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
      }
      return tr;
    }
    function insertPoint(doc3, pos, nodeType) {
      let $pos = doc3.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
        return pos;
      if ($pos.parentOffset == 0)
        for (let d = $pos.depth - 1; d >= 0; d--) {
          let index = $pos.index(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType))
            return $pos.before(d + 1);
          if (index > 0)
            return null;
        }
      if ($pos.parentOffset == $pos.parent.content.size)
        for (let d = $pos.depth - 1; d >= 0; d--) {
          let index = $pos.indexAfter(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType))
            return $pos.after(d + 1);
          if (index < $pos.node(d).childCount)
            return null;
        }
      return null;
    }
    function dropPoint(doc3, pos, slice2) {
      let $pos = doc3.resolve(pos);
      if (!slice2.content.size)
        return pos;
      let content = slice2.content;
      for (let i2 = 0; i2 < slice2.openStart; i2++)
        content = content.firstChild.content;
      for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
        for (let d = $pos.depth; d >= 0; d--) {
          let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          let parent = $pos.node(d), fits = false;
          if (pass == 1) {
            fits = parent.canReplace(insertPos, insertPos, content);
          } else {
            let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
            fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
          }
          if (fits)
            return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
      }
      return null;
    }
    function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
      if (from2 == to && !slice2.size)
        return null;
      let $from = doc3.resolve(from2), $to = doc3.resolve(to);
      if (fitsTrivially($from, $to, slice2))
        return new ReplaceStep(from2, to, slice2);
      return new Fitter($from, $to, slice2).fit();
    }
    function fitsTrivially($from, $to, slice2) {
      return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
    }
    var Fitter = class {
      constructor($from, $to, unplaced) {
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = Fragment.empty;
        for (let i2 = 0; i2 <= $from.depth; i2++) {
          let node = $from.node(i2);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i2))
          });
        }
        for (let i2 = $from.depth; i2 > 0; i2--)
          this.placed = Fragment.from($from.node(i2).copy(this.placed));
      }
      get depth() {
        return this.frontier.length - 1;
      }
      fit() {
        while (this.unplaced.size) {
          let fit = this.findFittable();
          if (fit)
            this.placeNodes(fit);
          else
            this.openMore() || this.dropNode();
        }
        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
        if (!$to)
          return null;
        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
        while (openStart && openEnd && content.childCount == 1) {
          content = content.firstChild.content;
          openStart--;
          openEnd--;
        }
        let slice2 = new Slice(content, openStart, openEnd);
        if (moveInline > -1)
          return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
        if (slice2.size || $from.pos != this.$to.pos)
          return new ReplaceStep($from.pos, $to.pos, slice2);
        return null;
      }
      // Find a position on the start spine of `this.unplaced` that has
      // content that can be moved somewhere on the frontier. Returns two
      // depths, one for the slice and one for the frontier.
      findFittable() {
        let startDepth = this.unplaced.openStart;
        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
          let node = cur.firstChild;
          if (cur.childCount > 1)
            openEnd = 0;
          if (node.type.spec.isolating && openEnd <= d) {
            startDepth = d;
            break;
          }
          cur = node.content;
        }
        for (let pass = 1; pass <= 2; pass++) {
          for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
            let fragment, parent = null;
            if (sliceDepth) {
              parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
              fragment = parent.content;
            } else {
              fragment = this.unplaced.content;
            }
            let first2 = fragment.firstChild;
            for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
              let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
              if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
                return { sliceDepth, frontierDepth, parent, inject };
              else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
                return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
              if (parent && match.matchType(parent.type))
                break;
            }
          }
        }
      }
      openMore() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (!inner.childCount || inner.firstChild.isLeaf)
          return false;
        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
        return true;
      }
      dropNode() {
        let { content, openStart, openEnd } = this.unplaced;
        let inner = contentAt(content, openStart);
        if (inner.childCount <= 1 && openStart > 0) {
          let openAtEnd = content.size - openStart <= openStart + inner.size;
          this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
        } else {
          this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
        }
      }
      // Move content from the unplaced slice at `sliceDepth` to the
      // frontier node at `frontierDepth`. Close that frontier node when
      // applicable.
      placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
        while (this.depth > frontierDepth)
          this.closeFrontierNode();
        if (wrap2)
          for (let i2 = 0; i2 < wrap2.length; i2++)
            this.openFrontierNode(wrap2[i2]);
        let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
        let openStart = slice2.openStart - sliceDepth;
        let taken = 0, add = [];
        let { match, type } = this.frontier[frontierDepth];
        if (inject) {
          for (let i2 = 0; i2 < inject.childCount; i2++)
            add.push(inject.child(i2));
          match = match.matchFragment(inject);
        }
        let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
        while (taken < fragment.childCount) {
          let next = fragment.child(taken), matches2 = match.matchType(next.type);
          if (!matches2)
            break;
          taken++;
          if (taken > 1 || openStart == 0 || next.content.size) {
            match = matches2;
            add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
          }
        }
        let toEnd = taken == fragment.childCount;
        if (!toEnd)
          openEndCount = -1;
        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
        this.frontier[frontierDepth].match = match;
        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
          this.closeFrontierNode();
        for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
          let node = cur.lastChild;
          this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
          cur = node.content;
        }
        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
      }
      mustMoveInline() {
        if (!this.$to.parent.isTextblock)
          return -1;
        let top = this.frontier[this.depth], level;
        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
          return -1;
        let { depth } = this.$to, after = this.$to.after(depth);
        while (depth > 1 && after == this.$to.end(--depth))
          ++after;
        return after;
      }
      findCloseLevel($to) {
        scan: for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
          let { match, type } = this.frontier[i2];
          let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
          let fit = contentAfterFits($to, i2, type, match, dropInner);
          if (!fit)
            continue;
          for (let d = i2 - 1; d >= 0; d--) {
            let { match: match2, type: type2 } = this.frontier[d];
            let matches2 = contentAfterFits($to, d, type2, match2, true);
            if (!matches2 || matches2.childCount)
              continue scan;
          }
          return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
        }
      }
      close($to) {
        let close2 = this.findCloseLevel($to);
        if (!close2)
          return null;
        while (this.depth > close2.depth)
          this.closeFrontierNode();
        if (close2.fit.childCount)
          this.placed = addToFragment(this.placed, close2.depth, close2.fit);
        $to = close2.move;
        for (let d = close2.depth + 1; d <= $to.depth; d++) {
          let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
          this.openFrontierNode(node.type, node.attrs, add);
        }
        return $to;
      }
      openFrontierNode(type, attrs = null, content) {
        let top = this.frontier[this.depth];
        top.match = top.match.matchType(type);
        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
        this.frontier.push({ type, match: type.contentMatch });
      }
      closeFrontierNode() {
        let open = this.frontier.pop();
        let add = open.match.fillBefore(Fragment.empty, true);
        if (add.childCount)
          this.placed = addToFragment(this.placed, this.frontier.length, add);
      }
    };
    function dropFromFragment(fragment, depth, count) {
      if (depth == 0)
        return fragment.cutByIndex(count, fragment.childCount);
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
    }
    function addToFragment(fragment, depth, content) {
      if (depth == 0)
        return fragment.append(content);
      return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
    }
    function contentAt(fragment, depth) {
      for (let i2 = 0; i2 < depth; i2++)
        fragment = fragment.firstChild.content;
      return fragment;
    }
    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0)
        return node;
      let frag = node.content;
      if (openStart > 1)
        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0)
          frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
      }
      return node.copy(frag);
    }
    function contentAfterFits($to, depth, type, match, open) {
      let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index == node.childCount && !type.compatibleContent(node.type))
        return null;
      let fit = match.fillBefore(node.content, true, index);
      return fit && !invalidMarks(type, node.content, index) ? fit : null;
    }
    function invalidMarks(type, fragment, start) {
      for (let i2 = start; i2 < fragment.childCount; i2++)
        if (!type.allowsMarks(fragment.child(i2).marks))
          return true;
      return false;
    }
    function definesContent(type) {
      return type.spec.defining || type.spec.definingForContent;
    }
    function replaceRange(tr, from2, to, slice2) {
      if (!slice2.size)
        return tr.deleteRange(from2, to);
      let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
      if (fitsTrivially($from, $to, slice2))
        return tr.step(new ReplaceStep(from2, to, slice2));
      let targetDepths = coveredDepths($from, tr.doc.resolve(to));
      if (targetDepths[targetDepths.length - 1] == 0)
        targetDepths.pop();
      let preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        let spec = $from.node(d).type.spec;
        if (spec.defining || spec.definingAsContext || spec.isolating)
          break;
        if (targetDepths.indexOf(d) > -1)
          preferredTarget = d;
        else if ($from.before(d) == pos)
          targetDepths.splice(1, 0, -d);
      }
      let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      let leftNodes = [], preferredDepth = slice2.openStart;
      for (let content = slice2.content, i2 = 0; ; i2++) {
        let node = content.firstChild;
        leftNodes.push(node);
        if (i2 == slice2.openStart)
          break;
        content = node.content;
      }
      for (let d = preferredDepth - 1; d >= 0; d--) {
        let leftNode = leftNodes[d], def = definesContent(leftNode.type);
        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
          preferredDepth = d;
        else if (def || !leftNode.type.isTextblock)
          break;
      }
      for (let j = slice2.openStart; j >= 0; j--) {
        let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
        let insert = leftNodes[openDepth];
        if (!insert)
          continue;
        for (let i2 = 0; i2 < targetDepths.length; i2++) {
          let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index, index, insert.type, insert.marks))
            return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
        }
      }
      let startSteps = tr.steps.length;
      for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
        tr.replace(from2, to, slice2);
        if (tr.steps.length > startSteps)
          break;
        let depth = targetDepths[i2];
        if (depth < 0)
          continue;
        from2 = $from.before(depth);
        to = $to.after(depth);
      }
    }
    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        let first2 = fragment.firstChild;
        fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
      }
      if (depth > newOpen) {
        let match = parent.contentMatchAt(0);
        let start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
      }
      return fragment;
    }
    function replaceRangeWith(tr, from2, to, node) {
      if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
        let point = insertPoint(tr.doc, from2, node.type);
        if (point != null)
          from2 = to = point;
      }
      tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
    }
    function deleteRange(tr, from2, to) {
      let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
      let covered = coveredDepths($from, $to);
      for (let i2 = 0; i2 < covered.length; i2++) {
        let depth = covered[i2], last = i2 == covered.length - 1;
        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
          return tr.delete($from.start(depth), $to.end(depth));
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
          return tr.delete($from.before(depth), $to.after(depth));
      }
      for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
          return tr.delete($from.before(d), to);
      }
      tr.delete(from2, to);
    }
    function coveredDepths($from, $to) {
      let result = [], minDepth = Math.min($from.depth, $to.depth);
      for (let d = minDepth; d >= 0; d--) {
        let start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
          break;
        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
          result.push(d);
      }
      return result;
    }
    var AttrStep = class _AttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(pos, attr, value) {
        super();
        this.pos = pos;
        this.attr = attr;
        this.value = value;
      }
      apply(doc3) {
        let node = doc3.nodeAt(this.pos);
        if (!node)
          return StepResult.fail("No node at attribute step's position");
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in node.attrs)
          attrs[name] = node.attrs[name];
        attrs[this.attr] = this.value;
        let updated = node.type.create(attrs, null, node.marks);
        return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc3) {
        return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
      }
      map(mapping) {
        let pos = mapping.mapResult(this.pos, 1);
        return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
      }
      toJSON() {
        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
      }
      static fromJSON(schema, json) {
        if (typeof json.pos != "number" || typeof json.attr != "string")
          throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new _AttrStep(json.pos, json.attr, json.value);
      }
    };
    Step.jsonID("attr", AttrStep);
    var DocAttrStep = class _DocAttrStep extends Step {
      /**
      Construct an attribute step.
      */
      constructor(attr, value) {
        super();
        this.attr = attr;
        this.value = value;
      }
      apply(doc3) {
        let attrs = /* @__PURE__ */ Object.create(null);
        for (let name in doc3.attrs)
          attrs[name] = doc3.attrs[name];
        attrs[this.attr] = this.value;
        let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
        return StepResult.ok(updated);
      }
      getMap() {
        return StepMap.empty;
      }
      invert(doc3) {
        return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
      }
      map(mapping) {
        return this;
      }
      toJSON() {
        return { stepType: "docAttr", attr: this.attr, value: this.value };
      }
      static fromJSON(schema, json) {
        if (typeof json.attr != "string")
          throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new _DocAttrStep(json.attr, json.value);
      }
    };
    Step.jsonID("docAttr", DocAttrStep);
    var TransformError = class extends Error {
    };
    TransformError = function TransformError2(message) {
      let err = Error.call(this, message);
      err.__proto__ = TransformError2.prototype;
      return err;
    };
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    var Transform = class {
      /**
      Create a transform that starts with the given document.
      */
      constructor(doc3) {
        this.doc = doc3;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      /**
      The starting document.
      */
      get before() {
        return this.docs.length ? this.docs[0] : this.doc;
      }
      /**
      Apply a new step in this transform, saving the result. Throws an
      error when the step fails.
      */
      step(step) {
        let result = this.maybeStep(step);
        if (result.failed)
          throw new TransformError(result.failed);
        return this;
      }
      /**
      Try to apply a step in this transformation, ignoring it if it
      fails. Returns the step result.
      */
      maybeStep(step) {
        let result = step.apply(this.doc);
        if (!result.failed)
          this.addStep(step, result.doc);
        return result;
      }
      /**
      True when the document has been changed (when there are any
      steps).
      */
      get docChanged() {
        return this.steps.length > 0;
      }
      /**
      @internal
      */
      addStep(step, doc3) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc3;
      }
      /**
      Replace the part of the document between `from` and `to` with the
      given `slice`.
      */
      replace(from2, to = from2, slice2 = Slice.empty) {
        let step = replaceStep(this.doc, from2, to, slice2);
        if (step)
          this.step(step);
        return this;
      }
      /**
      Replace the given range with the given content, which may be a
      fragment, node, or array of nodes.
      */
      replaceWith(from2, to, content) {
        return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
      }
      /**
      Delete the content between the given positions.
      */
      delete(from2, to) {
        return this.replace(from2, to, Slice.empty);
      }
      /**
      Insert the given content at the given position.
      */
      insert(pos, content) {
        return this.replaceWith(pos, pos, content);
      }
      /**
      Replace a range of the document with a given slice, using
      `from`, `to`, and the slice's
      [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
      than fixed start and end points. This method may grow the
      replaced area or close open nodes in the slice in order to get a
      fit that is more in line with WYSIWYG expectations, by dropping
      fully covered parent nodes of the replaced region when they are
      marked [non-defining as
      context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
      open parent node from the slice that _is_ marked as [defining
      its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
      
      This is the method, for example, to handle paste. The similar
      [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
      primitive tool which will _not_ move the start and end of its given
      range, and is useful in situations where you need more precise
      control over what happens.
      */
      replaceRange(from2, to, slice2) {
        replaceRange(this, from2, to, slice2);
        return this;
      }
      /**
      Replace the given range with a node, but use `from` and `to` as
      hints, rather than precise positions. When from and to are the same
      and are at the start or end of a parent node in which the given
      node doesn't fit, this method may _move_ them out towards a parent
      that does allow the given node to be placed. When the given range
      completely covers a parent node, this method may completely replace
      that parent node.
      */
      replaceRangeWith(from2, to, node) {
        replaceRangeWith(this, from2, to, node);
        return this;
      }
      /**
      Delete the given range, expanding it to cover fully covered
      parent nodes until a valid replace is found.
      */
      deleteRange(from2, to) {
        deleteRange(this, from2, to);
        return this;
      }
      /**
      Split the content in the given range off from its parent, if there
      is sibling content before or after it, and move it up the tree to
      the depth specified by `target`. You'll probably want to use
      [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
      sure the lift is valid.
      */
      lift(range, target) {
        lift(this, range, target);
        return this;
      }
      /**
      Join the blocks around the given position. If depth is 2, their
      last and first siblings are also joined, and so on.
      */
      join(pos, depth = 1) {
        join(this, pos, depth);
        return this;
      }
      /**
      Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
      The wrappers are assumed to be valid in this position, and should
      probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
      */
      wrap(range, wrappers) {
        wrap(this, range, wrappers);
        return this;
      }
      /**
      Set the type of all textblocks (partly) between `from` and `to` to
      the given node type with the given attributes.
      */
      setBlockType(from2, to = from2, type, attrs = null) {
        setBlockType(this, from2, to, type, attrs);
        return this;
      }
      /**
      Change the type, attributes, and/or marks of the node at `pos`.
      When `type` isn't given, the existing node type is preserved,
      */
      setNodeMarkup(pos, type, attrs = null, marks) {
        setNodeMarkup(this, pos, type, attrs, marks);
        return this;
      }
      /**
      Set a single attribute on a given node to a new value.
      The `pos` addresses the document content. Use `setDocAttribute`
      to set attributes on the document itself.
      */
      setNodeAttribute(pos, attr, value) {
        this.step(new AttrStep(pos, attr, value));
        return this;
      }
      /**
      Set a single attribute on the document to a new value.
      */
      setDocAttribute(attr, value) {
        this.step(new DocAttrStep(attr, value));
        return this;
      }
      /**
      Add a mark to the node at position `pos`.
      */
      addNodeMark(pos, mark) {
        this.step(new AddNodeMarkStep(pos, mark));
        return this;
      }
      /**
      Remove a mark (or all marks of the given type) from the node at
      position `pos`.
      */
      removeNodeMark(pos, mark) {
        let node = this.doc.nodeAt(pos);
        if (!node)
          throw new RangeError("No node at position " + pos);
        if (mark instanceof Mark) {
          if (mark.isInSet(node.marks))
            this.step(new RemoveNodeMarkStep(pos, mark));
        } else {
          let set = node.marks, found2, steps = [];
          while (found2 = mark.isInSet(set)) {
            steps.push(new RemoveNodeMarkStep(pos, found2));
            set = found2.removeFromSet(set);
          }
          for (let i2 = steps.length - 1; i2 >= 0; i2--)
            this.step(steps[i2]);
        }
        return this;
      }
      /**
      Split the node at the given position, and optionally, if `depth` is
      greater than one, any number of nodes above that. By default, the
      parts split off will inherit the node type of the original node.
      This can be changed by passing an array of types and attributes to
      use after the split (with the outermost nodes coming first).
      */
      split(pos, depth = 1, typesAfter) {
        split(this, pos, depth, typesAfter);
        return this;
      }
      /**
      Add the given mark to the inline content between `from` and `to`.
      */
      addMark(from2, to, mark) {
        addMark(this, from2, to, mark);
        return this;
      }
      /**
      Remove marks from inline nodes between `from` and `to`. When
      `mark` is a single mark, remove precisely that mark. When it is
      a mark type, remove all marks of that type. When it is null,
      remove all marks of any type.
      */
      removeMark(from2, to, mark) {
        removeMark(this, from2, to, mark);
        return this;
      }
      /**
      Removes all marks and nodes from the content of the node at
      `pos` that don't match the given new parent node type. Accepts
      an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
      third argument.
      */
      clearIncompatible(pos, parentType, match) {
        clearIncompatible(this, pos, parentType, match);
        return this;
      }
    };
    var classesById = /* @__PURE__ */ Object.create(null);
    var Selection = class {
      /**
      Initialize a selection with the head and anchor and ranges. If no
      ranges are given, constructs a single range across `$anchor` and
      `$head`.
      */
      constructor($anchor, $head, ranges) {
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      /**
      The selection's anchor, as an unresolved position.
      */
      get anchor() {
        return this.$anchor.pos;
      }
      /**
      The selection's head.
      */
      get head() {
        return this.$head.pos;
      }
      /**
      The lower bound of the selection's main range.
      */
      get from() {
        return this.$from.pos;
      }
      /**
      The upper bound of the selection's main range.
      */
      get to() {
        return this.$to.pos;
      }
      /**
      The resolved lower  bound of the selection's main range.
      */
      get $from() {
        return this.ranges[0].$from;
      }
      /**
      The resolved upper bound of the selection's main range.
      */
      get $to() {
        return this.ranges[0].$to;
      }
      /**
      Indicates whether the selection contains any content.
      */
      get empty() {
        let ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++)
          if (ranges[i2].$from.pos != ranges[i2].$to.pos)
            return false;
        return true;
      }
      /**
      Get the content of this selection as a slice.
      */
      content() {
        return this.$from.doc.slice(this.from, this.to, true);
      }
      /**
      Replace the selection with a slice or, if no slice is given,
      delete the selection. Will append to the given transaction.
      */
      replace(tr, content = Slice.empty) {
        let lastNode = content.content.lastChild, lastParent = null;
        for (let i2 = 0; i2 < content.openEnd; i2++) {
          lastParent = lastNode;
          lastNode = lastNode.lastChild;
        }
        let mapFrom = tr.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
          tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
          if (i2 == 0)
            selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
      /**
      Replace the selection with the given node, appending the changes
      to the given transaction.
      */
      replaceWith(tr, node) {
        let mapFrom = tr.steps.length, ranges = this.ranges;
        for (let i2 = 0; i2 < ranges.length; i2++) {
          let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
          let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
          if (i2) {
            tr.deleteRange(from2, to);
          } else {
            tr.replaceRangeWith(from2, to, node);
            selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
          }
        }
      }
      /**
      Find a valid cursor or leaf node selection starting at the given
      position and searching back if `dir` is negative, and forward if
      positive. When `textOnly` is true, only consider cursor
      selections. Will return null when no valid selection position is
      found.
      */
      static findFrom($pos, dir, textOnly = false) {
        let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner)
          return inner;
        for (let depth = $pos.depth - 1; depth >= 0; depth--) {
          let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
          if (found2)
            return found2;
        }
        return null;
      }
      /**
      Find a valid cursor or leaf node selection near the given
      position. Searches forward first by default, but if `bias` is
      negative, it will search backwards first.
      */
      static near($pos, bias = 1) {
        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
      }
      /**
      Find the cursor or leaf node selection closest to the start of
      the given document. Will return an
      [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
      exists.
      */
      static atStart(doc3) {
        return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
      }
      /**
      Find the cursor or leaf node selection closest to the end of the
      given document.
      */
      static atEnd(doc3) {
        return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
      }
      /**
      Deserialize the JSON representation of a selection. Must be
      implemented for custom classes (as a static class method).
      */
      static fromJSON(doc3, json) {
        if (!json || !json.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        let cls = classesById[json.type];
        if (!cls)
          throw new RangeError(`No selection type ${json.type} defined`);
        return cls.fromJSON(doc3, json);
      }
      /**
      To be able to deserialize selections from JSON, custom selection
      classes must register themselves with an ID string, so that they
      can be disambiguated. Try to pick something that's unlikely to
      clash with classes from other modules.
      */
      static jsonID(id, selectionClass) {
        if (id in classesById)
          throw new RangeError("Duplicate use of selection JSON ID " + id);
        classesById[id] = selectionClass;
        selectionClass.prototype.jsonID = id;
        return selectionClass;
      }
      /**
      Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
      which is a value that can be mapped without having access to a
      current document, and later resolved to a real selection for a
      given document again. (This is used mostly by the history to
      track and restore old selections.) The default implementation of
      this method just converts the selection to a text selection and
      returns the bookmark for that.
      */
      getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
      }
    };
    Selection.prototype.visible = true;
    var SelectionRange = class {
      /**
      Create a range.
      */
      constructor($from, $to) {
        this.$from = $from;
        this.$to = $to;
      }
    };
    var warnedAboutTextSelection = false;
    function checkTextSelection($pos) {
      if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
        warnedAboutTextSelection = true;
        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
      }
    }
    var TextSelection = class _TextSelection extends Selection {
      /**
      Construct a text selection between the given points.
      */
      constructor($anchor, $head = $anchor) {
        checkTextSelection($anchor);
        checkTextSelection($head);
        super($anchor, $head);
      }
      /**
      Returns a resolved position if this is a cursor selection (an
      empty text selection), and null otherwise.
      */
      get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
      map(doc3, mapping) {
        let $head = doc3.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent)
          return Selection.near($head);
        let $anchor = doc3.resolve(mapping.map(this.anchor));
        return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
      }
      replace(tr, content = Slice.empty) {
        super.replace(tr, content);
        if (content == Slice.empty) {
          let marks = this.$from.marksAcross(this.$to);
          if (marks)
            tr.ensureMarks(marks);
        }
      }
      eq(other) {
        return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
      }
      getBookmark() {
        return new TextBookmark(this.anchor, this.head);
      }
      toJSON() {
        return { type: "text", anchor: this.anchor, head: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
      }
      /**
      Create a text selection from non-resolved positions.
      */
      static create(doc3, anchor, head = anchor) {
        let $anchor = doc3.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
      }
      /**
      Return a text selection that spans the given positions or, if
      they aren't text positions, find a text selection near them.
      `bias` determines whether the method searches forward (default)
      or backwards (negative number) first. Will fall back to calling
      [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
      doesn't contain a valid text position.
      */
      static between($anchor, $head, bias) {
        let dPos = $anchor.pos - $head.pos;
        if (!bias || dPos)
          bias = dPos >= 0 ? 1 : -1;
        if (!$head.parent.inlineContent) {
          let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
          if (found2)
            $head = found2.$head;
          else
            return Selection.near($head, bias);
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0)
              $anchor = $head;
          }
        }
        return new _TextSelection($anchor, $head);
      }
    };
    Selection.jsonID("text", TextSelection);
    var TextBookmark = class _TextBookmark {
      constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      map(mapping) {
        return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
      }
      resolve(doc3) {
        return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
      }
    };
    var NodeSelection = class _NodeSelection extends Selection {
      /**
      Create a node selection. Does not verify the validity of its
      argument.
      */
      constructor($pos) {
        let node = $pos.nodeAfter;
        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        super($pos, $end);
        this.node = node;
      }
      map(doc3, mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        let $pos = doc3.resolve(pos);
        if (deleted)
          return Selection.near($pos);
        return new _NodeSelection($pos);
      }
      content() {
        return new Slice(Fragment.from(this.node), 0, 0);
      }
      eq(other) {
        return other instanceof _NodeSelection && other.anchor == this.anchor;
      }
      toJSON() {
        return { type: "node", anchor: this.anchor };
      }
      getBookmark() {
        return new NodeBookmark(this.anchor);
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new _NodeSelection(doc3.resolve(json.anchor));
      }
      /**
      Create a node selection from non-resolved positions.
      */
      static create(doc3, from2) {
        return new _NodeSelection(doc3.resolve(from2));
      }
      /**
      Determines whether the given node may be selected as a node
      selection.
      */
      static isSelectable(node) {
        return !node.isText && node.type.spec.selectable !== false;
      }
    };
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    var NodeBookmark = class _NodeBookmark {
      constructor(anchor) {
        this.anchor = anchor;
      }
      map(mapping) {
        let { deleted, pos } = mapping.mapResult(this.anchor);
        return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node))
          return new NodeSelection($pos);
        return Selection.near($pos);
      }
    };
    var AllSelection = class _AllSelection extends Selection {
      /**
      Create an all-selection over the given document.
      */
      constructor(doc3) {
        super(doc3.resolve(0), doc3.resolve(doc3.content.size));
      }
      replace(tr, content = Slice.empty) {
        if (content == Slice.empty) {
          tr.delete(0, tr.doc.content.size);
          let sel = Selection.atStart(tr.doc);
          if (!sel.eq(tr.selection))
            tr.setSelection(sel);
        } else {
          super.replace(tr, content);
        }
      }
      toJSON() {
        return { type: "all" };
      }
      /**
      @internal
      */
      static fromJSON(doc3) {
        return new _AllSelection(doc3);
      }
      map(doc3) {
        return new _AllSelection(doc3);
      }
      eq(other) {
        return other instanceof _AllSelection;
      }
      getBookmark() {
        return AllBookmark;
      }
    };
    Selection.jsonID("all", AllSelection);
    var AllBookmark = {
      map() {
        return this;
      },
      resolve(doc3) {
        return new AllSelection(doc3);
      }
    };
    function findSelectionIn(doc3, node, pos, index, dir, text = false) {
      if (node.inlineContent)
        return TextSelection.create(doc3, pos);
      for (let i2 = index - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
        let child = node.child(i2);
        if (!child.isAtom) {
          let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner)
            return inner;
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
      }
      return null;
    }
    function selectionToInsertionEnd(tr, startLen, bias) {
      let last = tr.steps.length - 1;
      if (last < startLen)
        return;
      let step = tr.steps[last];
      if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
        return;
      let map2 = tr.mapping.maps[last], end;
      map2.forEach((_from, _to, _newFrom, newTo) => {
        if (end == null)
          end = newTo;
      });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }
    var UPDATED_SEL = 1;
    var UPDATED_MARKS = 2;
    var UPDATED_SCROLL = 4;
    var Transaction = class extends Transform {
      /**
      @internal
      */
      constructor(state) {
        super(state.doc);
        this.curSelectionFor = 0;
        this.updated = 0;
        this.meta = /* @__PURE__ */ Object.create(null);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.storedMarks = state.storedMarks;
      }
      /**
      The transaction's current selection. This defaults to the editor
      selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
      transaction, but can be overwritten with
      [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
      */
      get selection() {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      }
      /**
      Update the transaction's current selection. Will determine the
      selection that the editor gets when the transaction is applied.
      */
      setSelection(selection) {
        if (selection.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this;
      }
      /**
      Whether the selection was explicitly updated by this transaction.
      */
      get selectionSet() {
        return (this.updated & UPDATED_SEL) > 0;
      }
      /**
      Set the current stored marks.
      */
      setStoredMarks(marks) {
        this.storedMarks = marks;
        this.updated |= UPDATED_MARKS;
        return this;
      }
      /**
      Make sure the current stored marks or, if that is null, the marks
      at the selection, match the given set of marks. Does nothing if
      this is already the case.
      */
      ensureMarks(marks) {
        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
          this.setStoredMarks(marks);
        return this;
      }
      /**
      Add a mark to the set of stored marks.
      */
      addStoredMark(mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Remove a mark or mark type from the set of stored marks.
      */
      removeStoredMark(mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
      /**
      Whether the stored marks were explicitly set for this transaction.
      */
      get storedMarksSet() {
        return (this.updated & UPDATED_MARKS) > 0;
      }
      /**
      @internal
      */
      addStep(step, doc3) {
        super.addStep(step, doc3);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
      }
      /**
      Update the timestamp for the transaction.
      */
      setTime(time) {
        this.time = time;
        return this;
      }
      /**
      Replace the current selection with the given slice.
      */
      replaceSelection(slice2) {
        this.selection.replace(this, slice2);
        return this;
      }
      /**
      Replace the selection with the given node. When `inheritMarks` is
      true and the content is inline, it inherits the marks from the
      place where it is inserted.
      */
      replaceSelectionWith(node, inheritMarks = true) {
        let selection = this.selection;
        if (inheritMarks)
          node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
        selection.replaceWith(this, node);
        return this;
      }
      /**
      Delete the selection.
      */
      deleteSelection() {
        this.selection.replace(this);
        return this;
      }
      /**
      Replace the given range, or the selection if no range is given,
      with a text node containing the given string.
      */
      insertText(text, from2, to) {
        let schema = this.doc.type.schema;
        if (from2 == null) {
          if (!text)
            return this.deleteSelection();
          return this.replaceSelectionWith(schema.text(text), true);
        } else {
          if (to == null)
            to = from2;
          to = to == null ? from2 : to;
          if (!text)
            return this.deleteRange(from2, to);
          let marks = this.storedMarks;
          if (!marks) {
            let $from = this.doc.resolve(from2);
            marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
          }
          this.replaceRangeWith(from2, to, schema.text(text, marks));
          if (!this.selection.empty)
            this.setSelection(Selection.near(this.selection.$to));
          return this;
        }
      }
      /**
      Store a metadata property in this transaction, keyed either by
      name or by plugin.
      */
      setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
      }
      /**
      Retrieve a metadata property for a given name or plugin.
      */
      getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
      }
      /**
      Returns true if this transaction doesn't contain any metadata,
      and can thus safely be extended.
      */
      get isGeneric() {
        for (let _ in this.meta)
          return false;
        return true;
      }
      /**
      Indicate that the editor should scroll the selection into view
      when updated to the state produced by this transaction.
      */
      scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
      }
      /**
      True when this transaction has had `scrollIntoView` called on it.
      */
      get scrolledIntoView() {
        return (this.updated & UPDATED_SCROLL) > 0;
      }
    };
    function bind(f, self) {
      return !self || !f ? f : f.bind(self);
    }
    var FieldDesc = class {
      constructor(name, desc, self) {
        this.name = name;
        this.init = bind(desc.init, self);
        this.apply = bind(desc.apply, self);
      }
    };
    var baseFields = [
      new FieldDesc("doc", {
        init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply(tr) {
          return tr.doc;
        }
      }),
      new FieldDesc("selection", {
        init(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply(tr) {
          return tr.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init(config) {
          return config.storedMarks || null;
        },
        apply(tr, _marks, _old, state) {
          return state.selection.$cursor ? tr.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init() {
          return 0;
        },
        apply(tr, prev) {
          return tr.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    var Configuration = class {
      constructor(schema, plugins) {
        this.schema = schema;
        this.plugins = [];
        this.pluginsByKey = /* @__PURE__ */ Object.create(null);
        this.fields = baseFields.slice();
        if (plugins)
          plugins.forEach((plugin) => {
            if (this.pluginsByKey[plugin.key])
              throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
            this.plugins.push(plugin);
            this.pluginsByKey[plugin.key] = plugin;
            if (plugin.spec.state)
              this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
          });
      }
    };
    var EditorState = class _EditorState {
      /**
      @internal
      */
      constructor(config) {
        this.config = config;
      }
      /**
      The schema of the state's document.
      */
      get schema() {
        return this.config.schema;
      }
      /**
      The plugins that are active in this state.
      */
      get plugins() {
        return this.config.plugins;
      }
      /**
      Apply the given transaction to produce a new state.
      */
      apply(tr) {
        return this.applyTransaction(tr).state;
      }
      /**
      @internal
      */
      filterTransaction(tr, ignore = -1) {
        for (let i2 = 0; i2 < this.config.plugins.length; i2++)
          if (i2 != ignore) {
            let plugin = this.config.plugins[i2];
            if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
              return false;
          }
        return true;
      }
      /**
      Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
      returns the precise transactions that were applied (which might
      be influenced by the [transaction
      hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
      plugins) along with the new state.
      */
      applyTransaction(rootTr) {
        if (!this.filterTransaction(rootTr))
          return { state: this, transactions: [] };
        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
        for (; ; ) {
          let haveNew = false;
          for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
            let plugin = this.config.plugins[i2];
            if (plugin.spec.appendTransaction) {
              let n = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
              let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
              if (tr && newState.filterTransaction(tr, i2)) {
                tr.setMeta("appendedTransaction", rootTr);
                if (!seen) {
                  seen = [];
                  for (let j = 0; j < this.config.plugins.length; j++)
                    seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
                }
                trs.push(tr);
                newState = newState.applyInner(tr);
                haveNew = true;
              }
              if (seen)
                seen[i2] = { state: newState, n: trs.length };
            }
          }
          if (!haveNew)
            return { state: newState, transactions: trs };
        }
      }
      /**
      @internal
      */
      applyInner(tr) {
        if (!tr.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        let newInstance = new _EditorState(this.config), fields = this.config.fields;
        for (let i2 = 0; i2 < fields.length; i2++) {
          let field = fields[i2];
          newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
        }
        return newInstance;
      }
      /**
      Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
      */
      get tr() {
        return new Transaction(this);
      }
      /**
      Create a new state.
      */
      static create(config) {
        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
        let instance = new _EditorState($config);
        for (let i2 = 0; i2 < $config.fields.length; i2++)
          instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
        return instance;
      }
      /**
      Create a new state based on this one, but with an adjusted set
      of active plugins. State fields that exist in both sets of
      plugins are kept unchanged. Those that no longer exist are
      dropped, and those that are new are initialized using their
      [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
      configuration object..
      */
      reconfigure(config) {
        let $config = new Configuration(this.schema, config.plugins);
        let fields = $config.fields, instance = new _EditorState($config);
        for (let i2 = 0; i2 < fields.length; i2++) {
          let name = fields[i2].name;
          instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
        }
        return instance;
      }
      /**
      Serialize this state to JSON. If you want to serialize the state
      of plugins, pass an object mapping property names to use in the
      resulting JSON object to plugin objects. The argument may also be
      a string or number, in which case it is ignored, to support the
      way `JSON.stringify` calls `toString` methods.
      */
      toJSON(pluginFields) {
        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks)
          result.storedMarks = this.storedMarks.map((m) => m.toJSON());
        if (pluginFields && typeof pluginFields == "object")
          for (let prop in pluginFields) {
            if (prop == "doc" || prop == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (state && state.toJSON)
              result[prop] = state.toJSON.call(plugin, this[plugin.key]);
          }
        return result;
      }
      /**
      Deserialize a JSON representation of a state. `config` should
      have at least a `schema` field, and should contain array of
      plugins to initialize the state with. `pluginFields` can be used
      to deserialize the state of plugins, by associating plugin
      instances with the property names they use in the JSON object.
      */
      static fromJSON(config, json, pluginFields) {
        if (!json)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!config.schema)
          throw new RangeError("Required config field 'schema' missing");
        let $config = new Configuration(config.schema, config.plugins);
        let instance = new _EditorState($config);
        $config.fields.forEach((field) => {
          if (field.name == "doc") {
            instance.doc = Node.fromJSON(config.schema, json.doc);
          } else if (field.name == "selection") {
            instance.selection = Selection.fromJSON(instance.doc, json.selection);
          } else if (field.name == "storedMarks") {
            if (json.storedMarks)
              instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
          } else {
            if (pluginFields)
              for (let prop in pluginFields) {
                let plugin = pluginFields[prop], state = plugin.spec.state;
                if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                  instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                  return;
                }
              }
            instance[field.name] = field.init(config, instance);
          }
        });
        return instance;
      }
    };
    function bindProps(obj, self, target) {
      for (let prop in obj) {
        let val = obj[prop];
        if (val instanceof Function)
          val = val.bind(self);
        else if (prop == "handleDOMEvents")
          val = bindProps(val, self, {});
        target[prop] = val;
      }
      return target;
    }
    var Plugin = class {
      /**
      Create a plugin.
      */
      constructor(spec) {
        this.spec = spec;
        this.props = {};
        if (spec.props)
          bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      /**
      Extract the plugin's state field from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
    var keys = /* @__PURE__ */ Object.create(null);
    function createKey(name) {
      if (name in keys)
        return name + "$" + ++keys[name];
      keys[name] = 0;
      return name + "$";
    }
    var PluginKey = class {
      /**
      Create a plugin key.
      */
      constructor(name = "key") {
        this.key = createKey(name);
      }
      /**
      Get the active plugin with this key, if any, from an editor
      state.
      */
      get(state) {
        return state.config.pluginsByKey[this.key];
      }
      /**
      Get the plugin's state from an editor state.
      */
      getState(state) {
        return state[this.key];
      }
    };
    var domIndex = function(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling;
        if (!node)
          return index;
      }
    };
    var parentNode = function(node) {
      let parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    var reusedRange = null;
    var textRange = function(node, from2, to) {
      let range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node, to == null ? node.nodeValue.length : to);
      range.setStart(node, from2 || 0);
      return range;
    };
    var clearReusedRange = function() {
      reusedRange = null;
    };
    var isEquivalentPosition = function(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    var atomElements = /^(img|br|input|textarea|hr)$/i;
    function scanFor(node, off, targetNode, targetOff, dir) {
      for (; ; ) {
        if (node == targetNode && off == targetOff)
          return true;
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
          let parent = node.parentNode;
          if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
            return false;
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (node.contentEditable == "false")
            return false;
          off = dir < 0 ? nodeSize(node) : 0;
        } else {
          return false;
        }
      }
    }
    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function textNodeBefore$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset)
          return node;
        if (node.nodeType == 1 && offset > 0) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node);
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function textNodeAfter$1(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3 && offset < node.nodeValue.length)
          return node;
        if (node.nodeType == 1 && offset < node.childNodes.length) {
          if (node.contentEditable == "false")
            return null;
          node = node.childNodes[offset];
          offset = 0;
        } else if (node.parentNode && !hasBlockDesc(node)) {
          offset = domIndex(node) + 1;
          node = node.parentNode;
        } else {
          return null;
        }
      }
    }
    function isOnEdge(node, offset, parent) {
      for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
        if (node == parent)
          return true;
        let index = domIndex(node);
        node = node.parentNode;
        if (!node)
          return false;
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
      }
    }
    function hasBlockDesc(dom) {
      let desc;
      for (let cur = dom; cur; cur = cur.parentNode)
        if (desc = cur.pmViewDesc)
          break;
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
    }
    var selectionCollapsed = function(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    function keyEvent(keyCode, key) {
      let event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event;
    }
    function deepActiveElement(doc3) {
      let elt = doc3.activeElement;
      while (elt && elt.shadowRoot)
        elt = elt.shadowRoot.activeElement;
      return elt;
    }
    function caretFromPoint(doc3, x, y) {
      if (doc3.caretPositionFromPoint) {
        try {
          let pos = doc3.caretPositionFromPoint(x, y);
          if (pos)
            return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
        } catch (_) {
        }
      }
      if (doc3.caretRangeFromPoint) {
        let range = doc3.caretRangeFromPoint(x, y);
        if (range)
          return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
      }
    }
    var nav = typeof navigator != "undefined" ? navigator : null;
    var doc2 = typeof document != "undefined" ? document : null;
    var agent = nav && nav.userAgent || "";
    var ie_edge = /Edge\/(\d+)/.exec(agent);
    var ie_upto10 = /MSIE \d/.exec(agent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    var ie = !!(ie_upto10 || ie_11up || ie_edge);
    var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    var gecko = !ie && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
    var chrome = !!_chrome;
    var chrome_version = _chrome ? +_chrome[1] : 0;
    var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
    var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
    var windows = nav ? /Win/.test(nav.platform) : false;
    var android = /Android \d/.test(agent);
    var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
    var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function windowRect(doc3) {
      let vp = doc3.defaultView && doc3.defaultView.visualViewport;
      if (vp)
        return {
          left: 0,
          right: vp.width,
          top: 0,
          bottom: vp.height
        };
      return {
        left: 0,
        right: doc3.documentElement.clientWidth,
        top: 0,
        bottom: doc3.documentElement.clientHeight
      };
    }
    function getSide(value, side) {
      return typeof value == "number" ? value : value[side];
    }
    function clientRect(node) {
      let rect = node.getBoundingClientRect();
      let scaleX = rect.width / node.offsetWidth || 1;
      let scaleY = rect.height / node.offsetHeight || 1;
      return {
        left: rect.left,
        right: rect.left + node.clientWidth * scaleX,
        top: rect.top,
        bottom: rect.top + node.clientHeight * scaleY
      };
    }
    function scrollRectIntoView(view, rect, startDOM) {
      let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      let doc3 = view.dom.ownerDocument;
      for (let parent = startDOM || view.dom; ; ) {
        if (!parent)
          break;
        if (parent.nodeType != 1) {
          parent = parentNode(parent);
          continue;
        }
        let elt = parent;
        let atTop = elt == doc3.body;
        let bounding = atTop ? windowRect(doc3) : clientRect(elt);
        let moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
          moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
          moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
          moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
          moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        if (moveX || moveY) {
          if (atTop) {
            doc3.defaultView.scrollBy(moveX, moveY);
          } else {
            let startX = elt.scrollLeft, startY = elt.scrollTop;
            if (moveY)
              elt.scrollTop += moveY;
            if (moveX)
              elt.scrollLeft += moveX;
            let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
            rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
          }
        }
        let pos = atTop ? "fixed" : getComputedStyle(parent).position;
        if (/^(fixed|sticky)$/.test(pos))
          break;
        parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
      }
    }
    function storeScrollPos(view) {
      let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      let refDOM, refTop;
      for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        let dom = view.root.elementFromPoint(x, y);
        if (!dom || dom == view.dom || !view.dom.contains(dom))
          continue;
        let localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break;
        }
      }
      return { refDOM, refTop, stack: scrollStack(view.dom) };
    }
    function scrollStack(dom) {
      let stack = [], doc3 = dom.ownerDocument;
      for (let cur = dom; cur; cur = parentNode(cur)) {
        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
        if (dom == doc3)
          break;
      }
      return stack;
    }
    function resetScrollPos({ refDOM, refTop, stack }) {
      let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
    }
    function restoreScrollStack(stack, dTop) {
      for (let i2 = 0; i2 < stack.length; i2++) {
        let { dom, top, left } = stack[i2];
        if (dom.scrollTop != top + dTop)
          dom.scrollTop = top + dTop;
        if (dom.scrollLeft != left)
          dom.scrollLeft = left;
      }
    }
    var preventScrollSupported = null;
    function focusPreventScroll(dom) {
      if (dom.setActive)
        return dom.setActive();
      if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
      let stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = { preventScroll: true };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }
    function findOffsetInNode(node, coords) {
      let closest, dxClosest = 2e8, coordsClosest, offset = 0;
      let rowBot = coords.top, rowTop = coords.top;
      let firstBelow, coordsBelow;
      for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        let rects;
        if (child.nodeType == 1)
          rects = child.getClientRects();
        else if (child.nodeType == 3)
          rects = textRange(child).getClientRects();
        else
          continue;
        for (let i2 = 0; i2 < rects.length; i2++) {
          let rect = rects[i2];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? {
                left: rect.right < coords.left ? rect.right : rect.left,
                top: coords.top
              } : coords;
              if (child.nodeType == 1 && dx)
                offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
              continue;
            }
          } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
            firstBelow = child;
            coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
            offset = childIndex + 1;
        }
      }
      if (!closest && firstBelow) {
        closest = firstBelow;
        coordsClosest = coordsBelow;
        dxClosest = 0;
      }
      if (closest && closest.nodeType == 3)
        return findOffsetInText(closest, coordsClosest);
      if (!closest || dxClosest && closest.nodeType == 1)
        return { node, offset };
      return findOffsetInNode(closest, coordsClosest);
    }
    function findOffsetInText(node, coords) {
      let len = node.nodeValue.length;
      let range = document.createRange();
      for (let i2 = 0; i2 < len; i2++) {
        range.setEnd(node, i2 + 1);
        range.setStart(node, i2);
        let rect = singleRect(range, 1);
        if (rect.top == rect.bottom)
          continue;
        if (inRect(coords, rect))
          return { node, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      }
      return { node, offset: 0 };
    }
    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
    }
    function targetKludge(dom, coords) {
      let parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
        return parent;
      return dom;
    }
    function posFromElement(view, elt, coords) {
      let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        let rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias);
    }
    function posFromCaret(view, node, offset, coords) {
      let outsideBlock = -1;
      for (let cur = node, sawBlock = false; ; ) {
        if (cur == view.dom)
          break;
        let desc = view.docView.nearestDesc(cur, true), rect;
        if (!desc)
          return null;
        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
        ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
          if (desc.node.isBlock && desc.parent) {
            if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
              outsideBlock = desc.posBefore;
            else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
              outsideBlock = desc.posAfter;
            sawBlock = true;
          }
          if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
            let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
            return before ? desc.posBefore : desc.posAfter;
          }
        }
        cur = desc.dom.parentNode;
      }
      return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
    }
    function elementFromPoint(element, coords, box) {
      let len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
          let child = element.childNodes[i2];
          if (child.nodeType == 1) {
            let rects = child.getClientRects();
            for (let j = 0; j < rects.length; j++) {
              let rect = rects[j];
              if (inRect(coords, rect))
                return elementFromPoint(child, coords, rect);
            }
          }
          if ((i2 = (i2 + 1) % len) == startI)
            break;
        }
      }
      return element;
    }
    function posAtCoords(view, coords) {
      let doc3 = view.dom.ownerDocument, node, offset = 0;
      let caret = caretFromPoint(doc3, coords.left, coords.top);
      if (caret)
        ({ node, offset } = caret);
      let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
      let pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        let box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box))
          return null;
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt)
          return null;
      }
      if (safari) {
        for (let p = elt; node && p; p = parentNode(p))
          if (p.draggable)
            node = void 0;
      }
      elt = targetKludge(elt, coords);
      if (node) {
        if (gecko && node.nodeType == 1) {
          offset = Math.min(offset, node.childNodes.length);
          if (offset < node.childNodes.length) {
            let next = node.childNodes[offset], box;
            if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
              offset++;
          }
        }
        let prev;
        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
          offset--;
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
          pos = view.state.doc.content.size;
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
          pos = posFromCaret(view, node, offset, coords);
      }
      if (pos == null)
        pos = posFromElement(view, elt, coords);
      let desc = view.docView.nearestDesc(elt, true);
      return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
    }
    function nonZero(rect) {
      return rect.top < rect.bottom || rect.left < rect.right;
    }
    function singleRect(target, bias) {
      let rects = target.getClientRects();
      if (rects.length) {
        let first2 = rects[bias < 0 ? 0 : rects.length - 1];
        if (nonZero(first2))
          return first2;
      }
      return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
    }
    var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function coordsAtPos(view, pos, side) {
      let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
      let supportEmptyRange = webkit || gecko;
      if (node.nodeType == 3) {
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          let rect = singleRect(textRange(node, offset, offset), side);
          if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top)
                return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
          return rect;
        } else {
          let from2 = offset, to = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) {
            to++;
            takeSide = -1;
          } else if (side >= 0 && offset == node.nodeValue.length) {
            from2--;
            takeSide = 1;
          } else if (side < 0) {
            from2--;
          } else {
            to++;
          }
          return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
        }
      }
      let $dom = view.state.doc.resolve(pos - (atom || 0));
      if (!$dom.parent.inlineContent) {
        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
          let before = node.childNodes[offset - 1];
          if (before.nodeType == 1)
            return flattenH(before.getBoundingClientRect(), false);
        }
        if (atom == null && offset < nodeSize(node)) {
          let after = node.childNodes[offset];
          if (after.nodeType == 1)
            return flattenH(after.getBoundingClientRect(), true);
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
      }
      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
        let before = node.childNodes[offset - 1];
        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
        if (target)
          return flattenV(singleRect(target, 1), false);
      }
      if (atom == null && offset < nodeSize(node)) {
        let after = node.childNodes[offset];
        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
          after = after.nextSibling;
        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
        if (target)
          return flattenV(singleRect(target, -1), true);
      }
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
    }
    function flattenV(rect, left) {
      if (rect.width == 0)
        return rect;
      let x = left ? rect.left : rect.right;
      return { top: rect.top, bottom: rect.bottom, left: x, right: x };
    }
    function flattenH(rect, top) {
      if (rect.height == 0)
        return rect;
      let y = top ? rect.top : rect.bottom;
      return { top: y, bottom: y, left: rect.left, right: rect.right };
    }
    function withFlushedState(view, state, f) {
      let viewState = view.state, active = view.root.activeElement;
      if (viewState != state)
        view.updateState(state);
      if (active != view.dom)
        view.focus();
      try {
        return f();
      } finally {
        if (viewState != state)
          view.updateState(viewState);
        if (active != view.dom && active)
          active.focus();
      }
    }
    function endOfTextblockVertical(view, state, dir) {
      let sel = state.selection;
      let $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state, () => {
        let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
        for (; ; ) {
          let nearest = view.docView.nearestDesc(dom, true);
          if (!nearest)
            break;
          if (nearest.node.isBlock) {
            dom = nearest.contentDOM || nearest.dom;
            break;
          }
          dom = nearest.dom.parentNode;
        }
        let coords = coordsAtPos(view, $pos.pos, 1);
        for (let child = dom.firstChild; child; child = child.nextSibling) {
          let boxes;
          if (child.nodeType == 1)
            boxes = child.getClientRects();
          else if (child.nodeType == 3)
            boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
          else
            continue;
          for (let i2 = 0; i2 < boxes.length; i2++) {
            let box = boxes[i2];
            if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    var maybeRTL = /[\u0590-\u08ac]/;
    function endOfTextblockHorizontal(view, state, dir) {
      let { $head } = state.selection;
      if (!$head.parent.isTextblock)
        return false;
      let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      let sel = view.domSelection();
      if (!sel)
        return $head.pos == $head.start() || $head.pos == $head.end();
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
        return dir == "left" || dir == "backward" ? atStart : atEnd;
      return withFlushedState(view, state, () => {
        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
        let oldBidiLevel = sel.caretBidiLevel;
        sel.modify("move", dir, "character");
        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
        try {
          sel.collapse(anchorNode, anchorOffset);
          if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
            sel.extend(oldNode, oldOff);
        } catch (_) {
        }
        if (oldBidiLevel != null)
          sel.caretBidiLevel = oldBidiLevel;
        return result;
      });
    }
    var cachedState = null;
    var cachedDir = null;
    var cachedResult = false;
    function endOfTextblock(view, state, dir) {
      if (cachedState == state && cachedDir == dir)
        return cachedResult;
      cachedState = state;
      cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
    }
    var NOT_DIRTY = 0;
    var CHILD_DIRTY = 1;
    var CONTENT_DIRTY = 2;
    var NODE_DIRTY = 3;
    var ViewDesc = class {
      constructor(parent, children, dom, contentDOM) {
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        dom.pmViewDesc = this;
      }
      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      matchesWidget(widget) {
        return false;
      }
      matchesMark(mark) {
        return false;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return false;
      }
      matchesHack(nodeName) {
        return false;
      }
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      parseRule() {
        return null;
      }
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      stopEvent(event) {
        return false;
      }
      // The size of the content represented by this desc.
      get size() {
        let size = 0;
        for (let i2 = 0; i2 < this.children.length; i2++)
          size += this.children[i2].size;
        return size;
      }
      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      get border() {
        return 0;
      }
      destroy() {
        this.parent = void 0;
        if (this.dom.pmViewDesc == this)
          this.dom.pmViewDesc = void 0;
        for (let i2 = 0; i2 < this.children.length; i2++)
          this.children[i2].destroy();
      }
      posBeforeChild(child) {
        for (let i2 = 0, pos = this.posAtStart; ; i2++) {
          let cur = this.children[i2];
          if (cur == child)
            return pos;
          pos += cur.size;
        }
      }
      get posBefore() {
        return this.parent.posBeforeChild(this);
      }
      get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
      get posAfter() {
        return this.posBefore + this.size;
      }
      get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border;
      }
      localPosFromDOM(dom, offset, bias) {
        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
          if (bias < 0) {
            let domBefore, desc;
            if (dom == this.contentDOM) {
              domBefore = dom.childNodes[offset - 1];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domBefore = dom.previousSibling;
            }
            while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
              domBefore = domBefore.previousSibling;
            return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
          } else {
            let domAfter, desc;
            if (dom == this.contentDOM) {
              domAfter = dom.childNodes[offset];
            } else {
              while (dom.parentNode != this.contentDOM)
                dom = dom.parentNode;
              domAfter = dom.nextSibling;
            }
            while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
              domAfter = domAfter.nextSibling;
            return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
          }
        }
        let atEnd;
        if (dom == this.dom && this.contentDOM) {
          atEnd = offset > domIndex(this.contentDOM);
        } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
          atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
        } else if (this.dom.firstChild) {
          if (offset == 0)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = false;
                break;
              }
              if (search.previousSibling)
                break;
            }
          if (atEnd == null && offset == dom.childNodes.length)
            for (let search = dom; ; search = search.parentNode) {
              if (search == this.dom) {
                atEnd = true;
                break;
              }
              if (search.nextSibling)
                break;
            }
        }
        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
      }
      nearestDesc(dom, onlyNodes = false) {
        for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
          let desc = this.getDesc(cur), nodeDOM;
          if (desc && (!onlyNodes || desc.node)) {
            if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
              first2 = false;
            else
              return desc;
          }
        }
      }
      getDesc(dom) {
        let desc = dom.pmViewDesc;
        for (let cur = desc; cur; cur = cur.parent)
          if (cur == this)
            return desc;
      }
      posFromDOM(dom, offset, bias) {
        for (let scan = dom; scan; scan = scan.parentNode) {
          let desc = this.getDesc(scan);
          if (desc)
            return desc.localPosFromDOM(dom, offset, bias);
        }
        return -1;
      }
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      descAt(pos) {
        for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (offset == pos && end != offset) {
            while (!child.border && child.children.length) {
              for (let i22 = 0; i22 < child.children.length; i22++) {
                let inner = child.children[i22];
                if (inner.size) {
                  child = inner;
                  break;
                }
              }
            }
            return child;
          }
          if (pos < end)
            return child.descAt(pos - offset - child.border);
          offset = end;
        }
      }
      domFromPos(pos, side) {
        if (!this.contentDOM)
          return { node: this.dom, offset: 0, atom: pos + 1 };
        let i2 = 0, offset = 0;
        for (let curPos = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = curPos + child.size;
          if (end > pos || child instanceof TrailingHackViewDesc) {
            offset = pos - curPos;
            break;
          }
          curPos = end;
        }
        if (offset)
          return this.children[i2].domFromPos(offset - this.children[i2].border, side);
        for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
        }
        if (side <= 0) {
          let prev, enter2 = true;
          for (; ; i2--, enter2 = false) {
            prev = i2 ? this.children[i2 - 1] : null;
            if (!prev || prev.dom.parentNode == this.contentDOM)
              break;
          }
          if (prev && side && enter2 && !prev.border && !prev.domAtom)
            return prev.domFromPos(prev.size, side);
          return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
        } else {
          let next, enter2 = true;
          for (; ; i2++, enter2 = false) {
            next = i2 < this.children.length ? this.children[i2] : null;
            if (!next || next.dom.parentNode == this.contentDOM)
              break;
          }
          if (next && enter2 && !next.border && !next.domAtom)
            return next.domFromPos(0, side);
          return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
        }
      }
      // Used to find a DOM range in a single parent for a given changed
      // range.
      parseRange(from2, to, base2 = 0) {
        if (this.children.length == 0)
          return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        let fromOffset = -1, toOffset = -1;
        for (let offset = base2, i2 = 0; ; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (fromOffset == -1 && from2 <= end) {
            let childBase = offset + child.border;
            if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
              return child.parseRange(from2, to, childBase);
            from2 = offset;
            for (let j = i2; j > 0; j--) {
              let prev = this.children[j - 1];
              if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                fromOffset = domIndex(prev.dom) + 1;
                break;
              }
              from2 -= prev.size;
            }
            if (fromOffset == -1)
              fromOffset = 0;
          }
          if (fromOffset > -1 && (end > to || i2 == this.children.length - 1)) {
            to = end;
            for (let j = i2 + 1; j < this.children.length; j++) {
              let next = this.children[j];
              if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                toOffset = domIndex(next.dom);
                break;
              }
              to += next.size;
            }
            if (toOffset == -1)
              toOffset = this.contentDOM.childNodes.length;
            break;
          }
          offset = end;
        }
        return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
      }
      emptyChildAt(side) {
        if (this.border || !this.contentDOM || !this.children.length)
          return false;
        let child = this.children[side < 0 ? 0 : this.children.length - 1];
        return child.size == 0 || child.emptyChildAt(side);
      }
      domAfterPos(pos) {
        let { node, offset } = this.domFromPos(pos, 0);
        if (node.nodeType != 1 || offset == node.childNodes.length)
          throw new RangeError("No node after pos " + pos);
        return node.childNodes[offset];
      }
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      setSelection(anchor, head, view, force = false) {
        let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
        for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (from2 > offset && to < end)
            return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);
          offset = end;
        }
        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
        let domSel = view.root.getSelection();
        let selRange = view.domSelectionRange();
        let brKludge = false;
        if ((gecko || safari) && anchor == head) {
          let { node, offset } = anchorDOM;
          if (node.nodeType == 3) {
            brKludge = !!(offset && node.nodeValue[offset - 1] == "\n");
            if (brKludge && offset == node.nodeValue.length) {
              for (let scan = node, after; scan; scan = scan.parentNode) {
                if (after = scan.nextSibling) {
                  if (after.nodeName == "BR")
                    anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                  break;
                }
                let desc = scan.pmViewDesc;
                if (desc && desc.node && desc.node.isBlock)
                  break;
              }
            }
          } else {
            let prev = node.childNodes[offset - 1];
            brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
          }
        }
        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
          let after = selRange.focusNode.childNodes[selRange.focusOffset];
          if (after && after.contentEditable == "false")
            force = true;
        }
        if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
          return;
        let domSelExtended = false;
        if ((domSel.extend || anchor == head) && !brKludge) {
          domSel.collapse(anchorDOM.node, anchorDOM.offset);
          try {
            if (anchor != head)
              domSel.extend(headDOM.node, headDOM.offset);
            domSelExtended = true;
          } catch (_) {
          }
        }
        if (!domSelExtended) {
          if (anchor > head) {
            let tmp = anchorDOM;
            anchorDOM = headDOM;
            headDOM = tmp;
          }
          let range = document.createRange();
          range.setEnd(headDOM.node, headDOM.offset);
          range.setStart(anchorDOM.node, anchorDOM.offset);
          domSel.removeAllRanges();
          domSel.addRange(range);
        }
      }
      ignoreMutation(mutation) {
        return !this.contentDOM && mutation.type != "selection";
      }
      get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      markDirty(from2, to) {
        for (let offset = 0, i2 = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = offset + child.size;
          if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {
            let startInside = offset + child.border, endInside = end - child.border;
            if (from2 >= startInside && to <= endInside) {
              this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
              if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
                child.dirty = NODE_DIRTY;
              else
                child.markDirty(from2 - startInside, to - startInside);
              return;
            } else {
              child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
            }
          }
          offset = end;
        }
        this.dirty = CONTENT_DIRTY;
      }
      markParentsDirty() {
        let level = 1;
        for (let node = this.parent; node; node = node.parent, level++) {
          let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (node.dirty < dirty)
            node.dirty = dirty;
        }
      }
      get domAtom() {
        return false;
      }
      get ignoreForCoords() {
        return false;
      }
      isText(text) {
        return false;
      }
    };
    var WidgetViewDesc = class extends ViewDesc {
      constructor(parent, widget, view, pos) {
        let self, dom = widget.type.toDOM;
        if (typeof dom == "function")
          dom = dom(view, () => {
            if (!self)
              return pos;
            if (self.parent)
              return self.parent.posBeforeChild(self);
          });
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            let wrap2 = document.createElement("span");
            wrap2.appendChild(dom);
            dom = wrap2;
          }
          dom.contentEditable = "false";
          dom.classList.add("ProseMirror-widget");
        }
        super(parent, [], dom, null);
        this.widget = widget;
        this.widget = widget;
        self = this;
      }
      matchesWidget(widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
      }
      parseRule() {
        return { ignore: true };
      }
      stopEvent(event) {
        let stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false;
      }
      ignoreMutation(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      }
      destroy() {
        this.widget.type.destroy(this.dom);
        super.destroy();
      }
      get domAtom() {
        return true;
      }
      get side() {
        return this.widget.type.side;
      }
    };
    var CompositionViewDesc = class extends ViewDesc {
      constructor(parent, dom, textDOM, text) {
        super(parent, [], dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }
      get size() {
        return this.text.length;
      }
      localPosFromDOM(dom, offset) {
        if (dom != this.textDOM)
          return this.posAtStart + (offset ? this.size : 0);
        return this.posAtStart + offset;
      }
      domFromPos(pos) {
        return { node: this.textDOM, offset: pos };
      }
      ignoreMutation(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      }
    };
    var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
      constructor(parent, mark, dom, contentDOM, spec) {
        super(parent, [], dom, contentDOM);
        this.mark = mark;
        this.spec = spec;
      }
      static create(parent, mark, inline, view) {
        let custom = view.nodeViews[mark.type.name];
        let spec = custom && custom(mark, view, inline);
        if (!spec || !spec.dom)
          spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
        return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
      }
      parseRule() {
        if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
          return null;
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      }
      matchesMark(mark) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark);
      }
      markDirty(from2, to) {
        super.markDirty(from2, to);
        if (this.dirty != NOT_DIRTY) {
          let parent = this.parent;
          while (!parent.node)
            parent = parent.parent;
          if (parent.dirty < this.dirty)
            parent.dirty = this.dirty;
          this.dirty = NOT_DIRTY;
        }
      }
      slice(from2, to, view) {
        let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
        let nodes = this.children, size = this.size;
        if (to < size)
          nodes = replaceNodes(nodes, to, size, view);
        if (from2 > 0)
          nodes = replaceNodes(nodes, 0, from2, view);
        for (let i2 = 0; i2 < nodes.length; i2++)
          nodes[i2].parent = copy2;
        copy2.children = nodes;
        return copy2;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
    };
    var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        super(parent, [], dom, contentDOM);
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        this.nodeDOM = nodeDOM;
      }
      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finicky
      // implementation details to the user code that they probably will
      // never need.)
      static create(parent, node, outerDeco, innerDeco, view, pos) {
        let custom = view.nodeViews[node.type.name], descObj;
        let spec = custom && custom(node, view, () => {
          if (!descObj)
            return pos;
          if (descObj.parent)
            return descObj.parent.posBeforeChild(descObj);
        }, outerDeco, innerDeco);
        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
          if (!dom)
            dom = document.createTextNode(node.text);
          else if (dom.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!dom) {
          let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
          ({ dom, contentDOM } = spec2);
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable"))
            dom.contentEditable = "false";
          if (node.type.spec.draggable)
            dom.draggable = true;
        }
        let nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);
        if (spec)
          return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
        else if (node.isText)
          return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
        else
          return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
      }
      parseRule() {
        if (this.node.type.spec.reparseInView)
          return null;
        let rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.whitespace == "pre")
          rule.preserveWhitespace = "full";
        if (!this.contentDOM) {
          rule.getContent = () => this.node.content;
        } else if (!this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
            let child = this.children[i2];
            if (this.dom.contains(child.dom.parentNode)) {
              rule.contentElement = child.dom.parentNode;
              break;
            }
          }
          if (!rule.contentElement)
            rule.getContent = () => Fragment.empty;
        }
        return rule;
      }
      matchesNode(node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      }
      get size() {
        return this.node.nodeSize;
      }
      get border() {
        return this.node.isLeaf ? 0 : 1;
      }
      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      updateChildren(view, pos) {
        let inline = this.node.inlineContent, off = pos;
        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
        let localComposition = composition && composition.pos > -1 ? composition : null;
        let compositionInChild = composition && composition.pos < 0;
        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
        iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
          if (widget.spec.marks)
            updater.syncToMarks(widget.spec.marks, inline, view);
          else if (widget.type.side >= 0 && !insideNode)
            updater.syncToMarks(i2 == this.node.childCount ? Mark.none : this.node.child(i2).marks, inline, view);
          updater.placeWidget(widget, view, off);
        }, (child, outerDeco, innerDeco, i2) => {
          updater.syncToMarks(child.marks, inline, view);
          let compIndex;
          if (updater.findNodeMatch(child, outerDeco, innerDeco, i2)) ;
          else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
          else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off)) ;
          else {
            updater.addNode(child, outerDeco, innerDeco, view, off);
          }
          off += child.nodeSize;
        });
        updater.syncToMarks([], inline, view);
        if (this.node.isTextblock)
          updater.addTextblockHacks();
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (localComposition)
            this.protectLocalComposition(view, localComposition);
          renderDescs(this.contentDOM, this.children, view);
          if (ios)
            iosHacks(this.dom);
        }
      }
      localCompositionInfo(view, pos) {
        let { from: from2, to } = view.state.selection;
        if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
          return null;
        let textNode = view.input.compositionNode;
        if (!textNode || !this.dom.contains(textNode.parentNode))
          return null;
        if (this.node.inlineContent) {
          let text = textNode.nodeValue;
          let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
          return textPos < 0 ? null : { node: textNode, pos: textPos, text };
        } else {
          return { node: textNode, pos: -1, text: "" };
        }
      }
      protectLocalComposition(view, { node, pos, text }) {
        if (this.getDesc(node))
          return;
        let topNode = node;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM)
            break;
          while (topNode.previousSibling)
            topNode.parentNode.removeChild(topNode.previousSibling);
          while (topNode.nextSibling)
            topNode.parentNode.removeChild(topNode.nextSibling);
          if (topNode.pmViewDesc)
            topNode.pmViewDesc = void 0;
        }
        let desc = new CompositionViewDesc(this, topNode, node, text);
        view.input.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      }
      // If this desc must be updated to match the given node decoration,
      // do so and return true.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
          return false;
        this.updateInner(node, outerDeco, innerDeco, view);
        return true;
      }
      updateInner(node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM)
          this.updateChildren(view, this.posAtStart);
        this.dirty = NOT_DIRTY;
      }
      updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco))
          return;
        let needsWrap = this.nodeDOM.nodeType != 1;
        let oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = void 0;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      }
      // Mark this node as being the selected node.
      selectNode() {
        if (this.nodeDOM.nodeType == 1)
          this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
          this.dom.draggable = true;
      }
      // Remove selected node marking from this node.
      deselectNode() {
        if (this.nodeDOM.nodeType == 1) {
          this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.removeAttribute("draggable");
        }
      }
      get domAtom() {
        return this.node.isAtom;
      }
    };
    function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc3);
      let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
      if (docView.contentDOM)
        docView.updateChildren(view, 0);
      return docView;
    }
    var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
      }
      parseRule() {
        let skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco)
          skip = skip.parentNode;
        return { skip: skip || true };
      }
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
          return false;
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node.text;
          if (view.trackWrites == this.nodeDOM)
            view.trackWrites = null;
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true;
      }
      inParent() {
        let parentDOM = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
          if (n == parentDOM)
            return true;
        return false;
      }
      domFromPos(pos) {
        return { node: this.nodeDOM, offset: pos };
      }
      localPosFromDOM(dom, offset, bias) {
        if (dom == this.nodeDOM)
          return this.posAtStart + Math.min(offset, this.node.text.length);
        return super.localPosFromDOM(dom, offset, bias);
      }
      ignoreMutation(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      }
      slice(from2, to, view) {
        let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
        return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
      }
      markDirty(from2, to) {
        super.markDirty(from2, to);
        if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
          this.dirty = NODE_DIRTY;
      }
      get domAtom() {
        return false;
      }
      isText(text) {
        return this.node.text == text;
      }
    };
    var TrailingHackViewDesc = class extends ViewDesc {
      parseRule() {
        return { ignore: true };
      }
      matchesHack(nodeName) {
        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
      }
      get domAtom() {
        return true;
      }
      get ignoreForCoords() {
        return this.dom.nodeName == "IMG";
      }
    };
    var CustomNodeViewDesc = class extends NodeViewDesc {
      constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
      }
      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      update(node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY)
          return false;
        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
          let result = this.spec.update(node, outerDeco, innerDeco);
          if (result)
            this.updateInner(node, outerDeco, innerDeco, view);
          return result;
        } else if (!this.contentDOM && !node.isLeaf) {
          return false;
        } else {
          return super.update(node, outerDeco, innerDeco, view);
        }
      }
      selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
      }
      deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
      }
      setSelection(anchor, head, view, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
      }
      destroy() {
        if (this.spec.destroy)
          this.spec.destroy();
        super.destroy();
      }
      stopEvent(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      }
      ignoreMutation(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
      }
    };
    function renderDescs(parentDOM, descs, view) {
      let dom = parentDOM.firstChild, written = false;
      for (let i2 = 0; i2 < descs.length; i2++) {
        let desc = descs[i2], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) {
            dom = rm(dom);
            written = true;
          }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          let pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) {
        dom = rm(dom);
        written = true;
      }
      if (written && view.trackWrites == parentDOM)
        view.trackWrites = null;
    }
    var OuterDecoLevel = function(nodeName) {
      if (nodeName)
        this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    var noDeco = [new OuterDecoLevel()];
    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0)
        return noDeco;
      let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
      for (let i2 = 0; i2 < outerDeco.length; i2++) {
        let attrs = outerDeco[i2].type.attrs;
        if (!attrs)
          continue;
        if (attrs.nodeName)
          result.push(top = new OuterDecoLevel(attrs.nodeName));
        for (let name in attrs) {
          let val = attrs[name];
          if (val == null)
            continue;
          if (needsWrap && result.length == 1)
            result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
          if (name == "class")
            top.class = (top.class ? top.class + " " : "") + val;
          else if (name == "style")
            top.style = (top.style ? top.style + ";" : "") + val;
          else if (name != "nodeName")
            top[name] = val;
        }
      }
      return result;
    }
    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      if (prevComputed == noDeco && curComputed == noDeco)
        return nodeDOM;
      let curDOM = nodeDOM;
      for (let i2 = 0; i2 < curComputed.length; i2++) {
        let deco = curComputed[i2], prev = prevComputed[i2];
        if (i2) {
          let parent;
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM;
    }
    function patchAttributes(dom, prev, cur) {
      for (let name in prev)
        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
          dom.removeAttribute(name);
      for (let name in cur)
        if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
          dom.setAttribute(name, cur[name]);
      if (prev.class != cur.class) {
        let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
        let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
        for (let i2 = 0; i2 < prevList.length; i2++)
          if (curList.indexOf(prevList[i2]) == -1)
            dom.classList.remove(prevList[i2]);
        for (let i2 = 0; i2 < curList.length; i2++)
          if (prevList.indexOf(curList[i2]) == -1)
            dom.classList.add(curList[i2]);
        if (dom.classList.length == 0)
          dom.removeAttribute("class");
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop.exec(prev.style))
            dom.style.removeProperty(m[1]);
        }
        if (cur.style)
          dom.style.cssText += cur.style;
      }
    }
    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
    }
    function sameOuterDeco(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++)
        if (!a[i2].type.eq(b[i2].type))
          return false;
      return true;
    }
    function rm(dom) {
      let next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    var ViewTreeUpdater = class {
      constructor(top, lock, view) {
        this.lock = lock;
        this.view = view;
        this.index = 0;
        this.stack = [];
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
      }
      // Destroy and remove the children between the given indices in
      // `this.top`.
      destroyBetween(start, end) {
        if (start == end)
          return;
        for (let i2 = start; i2 < end; i2++)
          this.top.children[i2].destroy();
        this.top.children.splice(start, end - start);
        this.changed = true;
      }
      // Destroy all remaining children in `this.top`.
      destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      }
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      syncToMarks(marks, inline, view) {
        let keep = 0, depth = this.stack.length >> 1;
        let maxKeep = Math.min(depth, marks.length);
        while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
          keep++;
        while (keep < depth) {
          this.destroyRest();
          this.top.dirty = NOT_DIRTY;
          this.index = this.stack.pop();
          this.top = this.stack.pop();
          depth--;
        }
        while (depth < marks.length) {
          this.stack.push(this.top, this.index + 1);
          let found2 = -1;
          for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
            let next = this.top.children[i2];
            if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
              found2 = i2;
              break;
            }
          }
          if (found2 > -1) {
            if (found2 > this.index) {
              this.changed = true;
              this.destroyBetween(this.index, found2);
            }
            this.top = this.top.children[this.index];
          } else {
            let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
            this.top.children.splice(this.index, 0, markDesc);
            this.top = markDesc;
            this.changed = true;
          }
          this.index = 0;
          depth++;
        }
      }
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      findNodeMatch(node, outerDeco, innerDeco, index) {
        let found2 = -1, targetDesc;
        if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
          found2 = this.top.children.indexOf(targetDesc, this.index);
        } else {
          for (let i2 = this.index, e = Math.min(this.top.children.length, i2 + 5); i2 < e; i2++) {
            let child = this.top.children[i2];
            if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
              found2 = i2;
              break;
            }
          }
        }
        if (found2 < 0)
          return false;
        this.destroyBetween(this.index, found2);
        this.index++;
        return true;
      }
      updateNodeAt(node, outerDeco, innerDeco, index, view) {
        let child = this.top.children[index];
        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
          child.dirty = CONTENT_DIRTY;
        if (!child.update(node, outerDeco, innerDeco, view))
          return false;
        this.destroyBetween(this.index, index);
        this.index++;
        return true;
      }
      findIndexWithChild(domNode) {
        for (; ; ) {
          let parent = domNode.parentNode;
          if (!parent)
            return -1;
          if (parent == this.top.contentDOM) {
            let desc = domNode.pmViewDesc;
            if (desc)
              for (let i2 = this.index; i2 < this.top.children.length; i2++) {
                if (this.top.children[i2] == desc)
                  return i2;
              }
            return -1;
          }
          domNode = parent;
        }
      }
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
        for (let i2 = this.index; i2 < this.top.children.length; i2++) {
          let next = this.top.children[i2];
          if (next instanceof NodeViewDesc) {
            let preMatch2 = this.preMatch.matched.get(next);
            if (preMatch2 != null && preMatch2 != index)
              return false;
            let nextDOM = next.dom, updated;
            let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
            if (!locked && next.update(node, outerDeco, innerDeco, view)) {
              this.destroyBetween(this.index, i2);
              if (next.dom != nextDOM)
                this.changed = true;
              this.index++;
              return true;
            } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
              this.destroyBetween(this.index, i2);
              this.top.children[this.index] = updated;
              if (updated.contentDOM) {
                updated.dirty = CONTENT_DIRTY;
                updated.updateChildren(view, pos + 1);
                updated.dirty = NOT_DIRTY;
              }
              this.changed = true;
              this.index++;
              return true;
            }
            break;
          }
        }
        return false;
      }
      // When a node with content is replaced by a different node with
      // identical content, move over its children.
      recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
        if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
          return null;
        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (wrapper.contentDOM) {
          wrapper.children = next.children;
          next.children = [];
          for (let ch of wrapper.children)
            ch.parent = wrapper;
        }
        next.destroy();
        return wrapper;
      }
      // Insert the node as a newly created node desc.
      addNode(node, outerDeco, innerDeco, view, pos) {
        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
        if (desc.contentDOM)
          desc.updateChildren(view, pos + 1);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
      placeWidget(widget, view, pos) {
        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
          this.index++;
        } else {
          let desc = new WidgetViewDesc(this.top, widget, view, pos);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
      }
      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      addTextblockHacks() {
        let lastChild = this.top.children[this.index - 1], parent = this.top;
        while (lastChild instanceof MarkViewDesc) {
          parent = lastChild;
          lastChild = parent.children[parent.children.length - 1];
        }
        if (!lastChild || // Empty textblock
        !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
          if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
            this.addHackNode("IMG", parent);
          this.addHackNode("BR", this.top);
        }
      }
      addHackNode(nodeName, parent) {
        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
          this.index++;
        } else {
          let dom = document.createElement(nodeName);
          if (nodeName == "IMG") {
            dom.className = "ProseMirror-separator";
            dom.alt = "";
          }
          if (nodeName == "BR")
            dom.className = "ProseMirror-trailingBreak";
          let hack = new TrailingHackViewDesc(this.top, [], dom, null);
          if (parent != this.top)
            parent.children.push(hack);
          else
            parent.children.splice(this.index++, 0, hack);
          this.changed = true;
        }
      }
      isLocked(node) {
        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
      }
    };
    function preMatch(frag, parentDesc) {
      let curDesc = parentDesc, descI = curDesc.children.length;
      let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
      outer: while (fI > 0) {
        let desc;
        for (; ; ) {
          if (descI) {
            let next = curDesc.children[descI - 1];
            if (next instanceof MarkViewDesc) {
              curDesc = next;
              descI = next.children.length;
            } else {
              desc = next;
              descI--;
              break;
            }
          } else if (curDesc == parentDesc) {
            break outer;
          } else {
            descI = curDesc.parent.children.indexOf(curDesc);
            curDesc = curDesc.parent;
          }
        }
        let node = desc.node;
        if (!node)
          continue;
        if (node != frag.child(fI - 1))
          break;
        --fI;
        matched.set(desc, fI);
        matches2.push(desc);
      }
      return { index: fI, matched, matches: matches2.reverse() };
    }
    function compareSide(a, b) {
      return a.type.side - b.type.side;
    }
    function iterDeco(parent, deco, onWidget, onNode) {
      let locals = deco.locals(parent), offset = 0;
      if (locals.length == 0) {
        for (let i2 = 0; i2 < parent.childCount; i2++) {
          let child = parent.child(i2);
          onNode(child, locals, deco.forChild(offset, child), i2);
          offset += child.nodeSize;
        }
        return;
      }
      let decoIndex = 0, active = [], restNode = null;
      for (let parentIndex = 0; ; ) {
        let widget, widgets;
        while (decoIndex < locals.length && locals[decoIndex].to == offset) {
          let next = locals[decoIndex++];
          if (next.widget) {
            if (!widget)
              widget = next;
            else
              (widgets || (widgets = [widget])).push(next);
          }
        }
        if (widget) {
          if (widgets) {
            widgets.sort(compareSide);
            for (let i2 = 0; i2 < widgets.length; i2++)
              onWidget(widgets[i2], parentIndex, !!restNode);
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }
        let child, index;
        if (restNode) {
          index = -1;
          child = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index = parentIndex;
          child = parent.child(parentIndex++);
        } else {
          break;
        }
        for (let i2 = 0; i2 < active.length; i2++)
          if (active[i2].to <= offset)
            active.splice(i2--, 1);
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
          active.push(locals[decoIndex++]);
        let end = offset + child.nodeSize;
        if (child.isText) {
          let cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
            cutAt = locals[decoIndex].from;
          for (let i2 = 0; i2 < active.length; i2++)
            if (active[i2].to < cutAt)
              cutAt = active[i2].to;
          if (cutAt < end) {
            restNode = child.cut(cutAt - offset);
            child = child.cut(0, cutAt - offset);
            end = cutAt;
            index = -1;
          }
        } else {
          while (decoIndex < locals.length && locals[decoIndex].to < end)
            decoIndex++;
        }
        let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
        onNode(child, outerDeco, deco.forChild(offset, child), index);
        offset = end;
      }
    }
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        let oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }
    function findTextInFragment(frag, text, from2, to) {
      for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
        let child = frag.child(i2++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText)
          continue;
        let str = child.text;
        while (i2 < frag.childCount) {
          let next = frag.child(i2++);
          pos += next.nodeSize;
          if (!next.isText)
            break;
          str += next.text;
        }
        if (pos >= from2) {
          if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
            return to - text.length;
          let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
          if (found2 >= 0 && found2 + text.length + childStart >= from2)
            return childStart + found2;
          if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
            return to;
        }
      }
      return -1;
    }
    function replaceNodes(nodes, from2, to, view, replacement) {
      let result = [];
      for (let i2 = 0, off = 0; i2 < nodes.length; i2++) {
        let child = nodes[i2], start = off, end = off += child.size;
        if (start >= to || end <= from2) {
          result.push(child);
        } else {
          if (start < from2)
            result.push(child.slice(0, from2 - start, view));
          if (replacement) {
            result.push(replacement);
            replacement = void 0;
          }
          if (end > to)
            result.push(child.slice(to - start, child.size, view));
        }
      }
      return result;
    }
    function selectionFromDOM(view, origin = null) {
      let domSel = view.domSelectionRange(), doc3 = view.state.doc;
      if (!domSel.focusNode)
        return null;
      let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
      if (head < 0)
        return null;
      let $head = doc3.resolve(head), anchor, selection;
      if (selectionCollapsed(domSel)) {
        anchor = head;
        while (nearestDesc && !nearestDesc.node)
          nearestDesc = nearestDesc.parent;
        let nearestDescNode = nearestDesc.node;
        if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          let pos = nearestDesc.posBefore;
          selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
        }
      } else {
        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
          let min = head, max = head;
          for (let i2 = 0; i2 < domSel.rangeCount; i2++) {
            let range = domSel.getRangeAt(i2);
            min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
            max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
          }
          if (min < 0)
            return null;
          [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];
          $head = doc3.resolve(head);
        } else {
          anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
        }
        if (anchor < 0)
          return null;
      }
      let $anchor = doc3.resolve(anchor);
      if (!selection) {
        let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection;
    }
    function editorOwnsSelection(view) {
      return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
    }
    function selectionToDOM(view, force = false) {
      let sel = view.state.selection;
      syncNodeSelection(view, sel);
      if (!editorOwnsSelection(view))
        return;
      if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
          view.input.mouseDown.delayedSelectionSync = true;
          view.domObserver.setCurSelection();
          return;
        }
      }
      view.domObserver.disconnectSelection();
      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
          if (!sel.$from.parent.inlineContent)
            resetEditableFrom = temporarilyEditableNear(view, sel.from);
          if (!sel.empty && !sel.$from.parent.inlineContent)
            resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
        view.docView.setSelection(anchor, head, view, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom)
            resetEditable(resetEditableFrom);
          if (resetEditableTo)
            resetEditable(resetEditableTo);
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document)
            removeClassOnSelectionChange(view);
        }
      }
      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }
    var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    function temporarilyEditableNear(view, pos) {
      let { node, offset } = view.docView.domFromPos(pos, 0);
      let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      let before = offset ? node.childNodes[offset - 1] : null;
      if (safari && after && after.contentEditable == "false")
        return setEditable(after);
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after)
          return setEditable(after);
        else if (before)
          return setEditable(before);
      }
    }
    function setEditable(element) {
      element.contentEditable = "true";
      if (safari && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
      }
      return element;
    }
    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
      }
    }
    function removeClassOnSelectionChange(view) {
      let doc3 = view.dom.ownerDocument;
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      let domSel = view.domSelectionRange();
      let node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
          setTimeout(() => {
            if (!editorOwnsSelection(view) || view.state.selection.visible)
              view.dom.classList.remove("ProseMirror-hideselection");
          }, 20);
        }
      });
    }
    function selectCursorWrapper(view) {
      let domSel = view.domSelection(), range = document.createRange();
      if (!domSel)
        return;
      let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img)
        range.setStart(node.parentNode, domIndex(node) + 1);
      else
        range.setStart(node, 0);
      range.collapse(true);
      domSel.removeAllRanges();
      domSel.addRange(range);
      if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }
    function syncNodeSelection(view, sel) {
      if (sel instanceof NodeSelection) {
        let desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc)
            desc.selectNode();
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent)
          view.lastSelectedViewDesc.deselectNode();
        view.lastSelectedViewDesc = void 0;
      }
    }
    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
    }
    function hasFocusAndSelection(view) {
      if (view.editable && !view.hasFocus())
        return false;
      return hasSelection(view);
    }
    function hasSelection(view) {
      let sel = view.domSelectionRange();
      if (!sel.anchorNode)
        return false;
      try {
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
      } catch (_) {
        return false;
      }
    }
    function anchorInRightPlace(view) {
      let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      let domSel = view.domSelectionRange();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
    }
    function moveSelectionBlock(state, dir) {
      let { $anchor, $head } = state.selection;
      let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && Selection.findFrom($start, dir);
    }
    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true;
    }
    function selectHorizontally(view, dir, mods) {
      let sel = view.state.selection;
      if (sel instanceof TextSelection) {
        if (mods.indexOf("s") > -1) {
          let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
          if (!node || node.isText || !node.isLeaf)
            return false;
          let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
          return apply(view, new TextSelection(sel.$anchor, $newHead));
        } else if (!sel.empty) {
          return false;
        } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
          let next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof NodeSelection)
            return apply(view, next);
          return false;
        } else if (!(mac && mods.indexOf("m") > -1)) {
          let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
          if (!node || node.isText)
            return false;
          let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
          if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
            return false;
          if (NodeSelection.isSelectable(node)) {
            return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
          } else if (webkit) {
            return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
          } else {
            return false;
          }
        }
      } else if (sel instanceof NodeSelection && sel.node.isInline) {
        return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
      } else {
        let next = moveSelectionBlock(view.state, dir);
        if (next)
          return apply(view, next);
        return false;
      }
    }
    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isIgnorable(dom, dir) {
      let desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
    }
    function skipIgnoredNodes(view, dir) {
      return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
    }
    function skipIgnoredNodesBefore(view) {
      let sel = view.domSelectionRange();
      let node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      let moveNode, moveOffset, force = false;
      if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))
        force = true;
      for (; ; ) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break;
          } else {
            let before = node.childNodes[offset - 1];
            if (isIgnorable(before, -1)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else
              break;
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          let prev = node.previousSibling;
          while (prev && isIgnorable(prev, -1)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force)
        setSelFocus(view, node, offset);
      else if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function skipIgnoredNodesAfter(view) {
      let sel = view.domSelectionRange();
      let node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      let len = nodeLen(node);
      let moveNode, moveOffset;
      for (; ; ) {
        if (offset < len) {
          if (node.nodeType != 1)
            break;
          let after = node.childNodes[offset];
          if (isIgnorable(after, 1)) {
            moveNode = node;
            moveOffset = ++offset;
          } else
            break;
        } else if (isBlockNode(node)) {
          break;
        } else {
          let next = node.nextSibling;
          while (next && isIgnorable(next, 1)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function isBlockNode(dom) {
      let desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock;
    }
    function textNodeAfter(node, offset) {
      while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      }
      while (node && offset < node.childNodes.length) {
        let next = node.childNodes[offset];
        if (next.nodeType == 3)
          return next;
        if (next.nodeType == 1 && next.contentEditable == "false")
          break;
        node = next;
        offset = 0;
      }
    }
    function textNodeBefore(node, offset) {
      while (node && !offset && !hasBlockDesc(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      }
      while (node && offset) {
        let next = node.childNodes[offset - 1];
        if (next.nodeType == 3)
          return next;
        if (next.nodeType == 1 && next.contentEditable == "false")
          break;
        node = next;
        offset = node.childNodes.length;
      }
    }
    function setSelFocus(view, node, offset) {
      if (node.nodeType != 3) {
        let before, after;
        if (after = textNodeAfter(node, offset)) {
          node = after;
          offset = 0;
        } else if (before = textNodeBefore(node, offset)) {
          node = before;
          offset = before.nodeValue.length;
        }
      }
      let sel = view.domSelection();
      if (!sel)
        return;
      if (selectionCollapsed(sel)) {
        let range = document.createRange();
        range.setEnd(node, offset);
        range.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      let { state } = view;
      setTimeout(() => {
        if (view.state == state)
          selectionToDOM(view);
      }, 50);
    }
    function findDirection(view, pos) {
      let $pos = view.state.doc.resolve(pos);
      if (!(chrome || windows) && $pos.parent.inlineContent) {
        let coords = view.coordsAtPos(pos);
        if (pos > $pos.start()) {
          let before = view.coordsAtPos(pos - 1);
          let mid = (before.top + before.bottom) / 2;
          if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
            return before.left < coords.left ? "ltr" : "rtl";
        }
        if (pos < $pos.end()) {
          let after = view.coordsAtPos(pos + 1);
          let mid = (after.top + after.bottom) / 2;
          if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
            return after.left > coords.left ? "ltr" : "rtl";
        }
      }
      let computed = getComputedStyle(view.dom).direction;
      return computed == "rtl" ? "rtl" : "ltr";
    }
    function selectVertically(view, dir, mods) {
      let sel = view.state.selection;
      if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
        return false;
      if (mac && mods.indexOf("m") > -1)
        return false;
      let { $from, $to } = sel;
      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        let next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof NodeSelection)
          return apply(view, next);
      }
      if (!$from.parent.inlineContent) {
        let side = dir < 0 ? $from : $to;
        let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
      }
      return false;
    }
    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof TextSelection))
        return true;
      let { $head, $anchor, empty: empty2 } = view.state.selection;
      if (!$head.sameParent($anchor))
        return true;
      if (!empty2)
        return false;
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
        return true;
      let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        let tr = view.state.tr;
        if (dir < 0)
          tr.delete($head.pos - nextNode.nodeSize, $head.pos);
        else
          tr.delete($head.pos, $head.pos + nextNode.nodeSize);
        view.dispatch(tr);
        return true;
      }
      return false;
    }
    function switchEditable(view, node, state) {
      view.domObserver.stop();
      node.contentEditable = state;
      view.domObserver.start();
    }
    function safariDownArrowBug(view) {
      if (!safari || view.state.selection.$head.parentOffset > 0)
        return false;
      let { focusNode, focusOffset } = view.domSelectionRange();
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        let child = focusNode.firstChild;
        switchEditable(view, child, "true");
        setTimeout(() => switchEditable(view, child, "false"), 20);
      }
      return false;
    }
    function getMods(event) {
      let result = "";
      if (event.ctrlKey)
        result += "c";
      if (event.metaKey)
        result += "m";
      if (event.altKey)
        result += "a";
      if (event.shiftKey)
        result += "s";
      return result;
    }
    function captureKeyDown(view, event) {
      let code2 = event.keyCode, mods = getMods(event);
      if (code2 == 8 || mac && code2 == 72 && mods == "c") {
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
      } else if (code2 == 46 && !event.shiftKey || mac && code2 == 68 && mods == "c") {
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
      } else if (code2 == 13 || code2 == 27) {
        return true;
      } else if (code2 == 37 || mac && code2 == 66 && mods == "c") {
        let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
      } else if (code2 == 39 || mac && code2 == 70 && mods == "c") {
        let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
      } else if (code2 == 38 || mac && code2 == 80 && mods == "c") {
        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
      } else if (code2 == 40 || mac && code2 == 78 && mods == "c") {
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
      } else if (mods == (mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
        return true;
      }
      return false;
    }
    function serializeForClipboard(view, slice2) {
      view.someProp("transformCopied", (f) => {
        slice2 = f(slice2, view);
      });
      let context = [], { content, openStart, openEnd } = slice2;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        let node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }
      let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
      let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
      wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
      let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
          let wrapper = doc3.createElement(needsWrap[i2]);
          while (wrap2.firstChild)
            wrapper.appendChild(wrap2.firstChild);
          wrap2.appendChild(wrapper);
          wrappers++;
        }
        firstChild = wrap2.firstChild;
      }
      if (firstChild && firstChild.nodeType == 1)
        firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
      let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
      return { dom: wrap2, text, slice: slice2 };
    }
    function parseFromClipboard(view, text, html, plainText, $context) {
      let inCode = $context.parent.type.spec.code;
      let dom, slice2;
      if (!html && !text)
        return null;
      let asText = text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", (f) => {
          text = f(text, inCode || plainText, view);
        });
        if (inCode)
          return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
        let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
        if (parsed) {
          slice2 = parsed;
        } else {
          let marks = $context.marks();
          let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
          dom = document.createElement("div");
          text.split(/(?:\r\n?|\n)+/).forEach((block) => {
            let p = dom.appendChild(document.createElement("p"));
            if (block)
              p.appendChild(serializer.serializeNode(schema.text(block, marks)));
          });
        }
      } else {
        view.someProp("transformPastedHTML", (f) => {
          html = f(html, view);
        });
        dom = readHTML(html);
        if (webkit)
          restoreReplacedSpaces(dom);
      }
      let contextNode = dom && dom.querySelector("[data-pm-slice]");
      let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
      if (sliceData && sliceData[3])
        for (let i2 = +sliceData[3]; i2 > 0; i2--) {
          let child = dom.firstChild;
          while (child && child.nodeType != 1)
            child = child.nextSibling;
          if (!child)
            break;
          dom = child;
        }
      if (!slice2) {
        let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
        slice2 = parser.parseSlice(dom, {
          preserveWhitespace: !!(asText || sliceData),
          context: $context,
          ruleFromNode(dom2) {
            if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
              return { ignore: true };
            return null;
          }
        });
      }
      if (sliceData) {
        slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
      } else {
        slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
        if (slice2.openStart || slice2.openEnd) {
          let openStart = 0, openEnd = 0;
          for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
          }
          for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
          }
          slice2 = closeSlice(slice2, openStart, openEnd);
        }
      }
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view);
      });
      return slice2;
    }
    var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2)
        return fragment;
      for (let d = $context.depth; d >= 0; d--) {
        let parent = $context.node(d);
        let match = parent.contentMatchAt($context.index(d));
        let lastWrap, result = [];
        fragment.forEach((node) => {
          if (!result)
            return;
          let wrap2 = match.findWrapping(node.type), inLast;
          if (!wrap2)
            return result = null;
          if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length)
              result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
            let wrapped = withWrappers(node, wrap2);
            result.push(wrapped);
            match = match.matchType(wrapped.type);
            lastWrap = wrap2;
          }
        });
        if (result)
          return Fragment.from(result);
      }
      return fragment;
    }
    function withWrappers(node, wrap2, from2 = 0) {
      for (let i2 = wrap2.length - 1; i2 >= from2; i2--)
        node = wrap2[i2].create(null, Fragment.from(node));
      return node;
    }
    function addToSibling(wrap2, lastWrap, node, sibling, depth) {
      if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
        let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner)
          return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        let match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
          return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
      }
    }
    function closeRight(node, depth) {
      if (depth == 0)
        return node;
      let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
      return node.copy(fragment.append(fill));
    }
    function closeRange(fragment, side, from2, to, depth, openEnd) {
      let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (fragment.childCount > 1)
        openEnd = 0;
      if (depth < to - 1)
        inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
      if (depth >= from2)
        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
    }
    function closeSlice(slice2, openStart, openEnd) {
      if (openStart < slice2.openStart)
        slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
      if (openEnd < slice2.openEnd)
        slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
      return slice2;
    }
    var wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    var _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
    }
    var _policy = null;
    function maybeWrapTrusted(html) {
      let trustedTypes = window.trustedTypes;
      if (!trustedTypes)
        return html;
      if (!_policy)
        _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
      return _policy.createHTML(html);
    }
    function readHTML(html) {
      let metas = /^(\s*<meta [^>]*>)*/.exec(html);
      if (metas)
        html = html.slice(metas[0].length);
      let elt = detachedDoc().createElement("div");
      let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
      if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
        html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
      elt.innerHTML = maybeWrapTrusted(html);
      if (wrap2)
        for (let i2 = 0; i2 < wrap2.length; i2++)
          elt = elt.querySelector(wrap2[i2]) || elt;
      return elt;
    }
    function restoreReplacedSpaces(dom) {
      let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (let i2 = 0; i2 < nodes.length; i2++) {
        let node = nodes[i2];
        if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
          node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
      }
    }
    function addContext(slice2, context) {
      if (!slice2.size)
        return slice2;
      let schema = slice2.content.firstChild.type.schema, array;
      try {
        array = JSON.parse(context);
      } catch (e) {
        return slice2;
      }
      let { content, openStart, openEnd } = slice2;
      for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
        let type = schema.nodes[array[i2]];
        if (!type || type.hasRequiredAttrs())
          break;
        content = Fragment.from(type.create(array[i2 + 1], content));
        openStart++;
        openEnd++;
      }
      return new Slice(content, openStart, openEnd);
    }
    var handlers = {};
    var editHandlers = {};
    var passiveHandlers = { touchstart: true, touchmove: true };
    var InputState = class {
      constructor() {
        this.shiftKey = false;
        this.mouseDown = null;
        this.lastKeyCode = null;
        this.lastKeyCodeTime = 0;
        this.lastClick = { time: 0, x: 0, y: 0, type: "" };
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastIOSEnter = 0;
        this.lastIOSEnterFallbackTimeout = -1;
        this.lastFocus = 0;
        this.lastTouch = 0;
        this.lastChromeDelete = 0;
        this.composing = false;
        this.compositionNode = null;
        this.composingTimeout = -1;
        this.compositionNodes = [];
        this.compositionEndedAt = -2e8;
        this.compositionID = 1;
        this.compositionPendingChanges = 0;
        this.domChangeCount = 0;
        this.eventHandlers = /* @__PURE__ */ Object.create(null);
        this.hideSelectionGuard = null;
      }
    };
    function initInput(view) {
      for (let event in handlers) {
        let handler = handlers[event];
        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
          if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
            handler(view, event2);
        }, passiveHandlers[event] ? { passive: true } : void 0);
      }
      if (safari)
        view.dom.addEventListener("input", () => null);
      ensureListeners(view);
    }
    function setSelectionOrigin(view, origin) {
      view.input.lastSelectionOrigin = origin;
      view.input.lastSelectionTime = Date.now();
    }
    function destroyInput(view) {
      view.domObserver.stop();
      for (let type in view.input.eventHandlers)
        view.dom.removeEventListener(type, view.input.eventHandlers[type]);
      clearTimeout(view.input.composingTimeout);
      clearTimeout(view.input.lastIOSEnterFallbackTimeout);
    }
    function ensureListeners(view) {
      view.someProp("handleDOMEvents", (currentHandlers) => {
        for (let type in currentHandlers)
          if (!view.input.eventHandlers[type])
            view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
      });
    }
    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", (handlers2) => {
        let handler = handlers2[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false;
      });
    }
    function eventBelongsToView(view, event) {
      if (!event.bubbles)
        return true;
      if (event.defaultPrevented)
        return false;
      for (let node = event.target; node != view.dom; node = node.parentNode)
        if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
          return false;
      return true;
    }
    function dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
        handlers[event.type](view, event);
    }
    editHandlers.keydown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event))
        return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13)
        return;
      if (event.keyCode != 229)
        view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        let now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = (view, event) => {
      if (event.keyCode == 16)
        view.input.shiftKey = false;
    };
    editHandlers.keypress = (view, _event) => {
      let event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
        return;
      if (view.someProp("handleKeyPress", (f) => f(view, event))) {
        event.preventDefault();
        return;
      }
      let sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        let text = String.fromCharCode(event.charCode);
        if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))
          view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        event.preventDefault();
      }
    };
    function eventCoords(event) {
      return { left: event.clientX, top: event.clientY };
    }
    function isNear(event, click) {
      let dx = click.x - event.clientX, dy = click.y - event.clientY;
      return dx * dx + dy * dy < 100;
    }
    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1)
        return false;
      let $pos = view.state.doc.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        if (view.someProp(propName, (f) => i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
          return true;
      }
      return false;
    }
    function updateSelection(view, selection, origin) {
      if (!view.focused)
        view.focus();
      if (view.state.selection.eq(selection))
        return;
      let tr = view.state.tr.setSelection(selection);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      view.dispatch(tr);
    }
    function selectClickedLeaf(view, inside) {
      if (inside == -1)
        return false;
      let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && NodeSelection.isSelectable(node)) {
        updateSelection(view, new NodeSelection($pos), "pointer");
        return true;
      }
      return false;
    }
    function selectClickedNode(view, inside) {
      if (inside == -1)
        return false;
      let sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof NodeSelection)
        selectedNode = sel.node;
      let $pos = view.state.doc.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
        if (NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
            selectAt = $pos.before(sel.$from.depth);
          else
            selectAt = $pos.before(i2);
          break;
        }
      }
      if (selectAt != null) {
        updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true;
      } else {
        return false;
      }
    }
    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
    }
    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
    }
    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
    }
    function defaultTripleClick(view, inside, event) {
      if (event.button != 0)
        return false;
      let doc3 = view.state.doc;
      if (inside == -1) {
        if (doc3.inlineContent) {
          updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
          return true;
        }
        return false;
      }
      let $pos = doc3.resolve(inside);
      for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
        let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
        let nodePos = $pos.before(i2);
        if (node.inlineContent)
          updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
        else if (NodeSelection.isSelectable(node))
          updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
        else
          continue;
        return true;
      }
    }
    function forceDOMFlush(view) {
      return endComposition(view);
    }
    var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = (view, _event) => {
      let event = _event;
      view.input.shiftKey = event.shiftKey;
      let flushed = forceDOMFlush(view);
      let now = Date.now(), type = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
        if (view.input.lastClick.type == "singleClick")
          type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
          type = "tripleClick";
      }
      view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      let pos = view.posAtCoords(eventCoords(event));
      if (!pos)
        return;
      if (type == "singleClick") {
        if (view.input.mouseDown)
          view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    var MouseDown = class {
      constructor(view, pos, event, flushed) {
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        let targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          let $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        const target = flushed ? null : event.target;
        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
        let { selection } = view.state;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
          this.mightDrag = {
            node: targetNode,
            pos: targetPos,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
          };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.draggable = true;
          if (this.mightDrag.setUneditable)
            setTimeout(() => {
              if (this.view.input.mouseDown == this)
                this.target.setAttribute("contentEditable", "false");
            }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.removeAttribute("draggable");
          if (this.mightDrag.setUneditable)
            this.target.removeAttribute("contentEditable");
          this.view.domObserver.start();
        }
        if (this.delayedSelectionSync)
          setTimeout(() => selectionToDOM(this.view));
        this.view.input.mouseDown = null;
      }
      up(event) {
        this.done();
        if (!this.view.dom.contains(event.target))
          return;
        let pos = this.pos;
        if (this.view.state.doc != this.startDoc)
          pos = this.view.posAtCoords(eventCoords(event));
        this.updateAllowDefault(event);
        if (this.allowDefault || !pos) {
          setSelectionOrigin(this.view, "pointer");
        } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
          event.preventDefault();
        } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
        safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
          updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
          event.preventDefault();
        } else {
          setSelectionOrigin(this.view, "pointer");
        }
      }
      move(event) {
        this.updateAllowDefault(event);
        setSelectionOrigin(this.view, "pointer");
        if (event.buttons == 0)
          this.done();
      }
      updateAllowDefault(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
          this.allowDefault = true;
      }
    };
    handlers.touchstart = (view) => {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = (view) => {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = (view) => forceDOMFlush(view);
    function inOrNearComposition(view, event) {
      if (view.composing)
        return true;
      if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
        view.input.compositionEndedAt = -2e8;
        return true;
      }
      return false;
    }
    var timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
      if (!view.composing) {
        view.domObserver.flush();
        let { state } = view, $pos = state.selection.$to;
        if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view, !state.selection.empty);
          if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            let sel = view.domSelectionRange();
            for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
              let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before)
                break;
              if (before.nodeType == 3) {
                let sel2 = view.domSelection();
                if (sel2)
                  sel2.collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = (view, event) => {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
        view.input.compositionNode = null;
        if (view.input.compositionPendingChanges)
          Promise.resolve().then(() => view.domObserver.flush());
        view.input.compositionID++;
        scheduleComposeEnd(view, 20);
      }
    };
    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.input.composingTimeout);
      if (delay > -1)
        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
    }
    function clearComposition(view) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = timestampFromCustomEvent();
      }
      while (view.input.compositionNodes.length > 0)
        view.input.compositionNodes.pop().markParentsDirty();
    }
    function findCompositionNode(view) {
      let sel = view.domSelectionRange();
      if (!sel.focusNode)
        return null;
      let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
      let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
      if (textBefore && textAfter && textBefore != textAfter) {
        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
        if (textBefore == lastChanged || textAfter == lastChanged)
          return lastChanged;
        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
          return textAfter;
        } else if (view.input.compositionNode == textAfter) {
          let descBefore = textBefore.pmViewDesc;
          if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
            return textAfter;
        }
      }
      return textBefore || textAfter;
    }
    function timestampFromCustomEvent() {
      let event = document.createEvent("Event");
      event.initEvent("event", true, true);
      return event.timeStamp;
    }
    function endComposition(view, restarting = false) {
      if (android && view.domObserver.flushingSoon >= 0)
        return;
      view.domObserver.forceFlush();
      clearComposition(view);
      if (restarting || view.docView && view.docView.dirty) {
        let sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection))
          view.dispatch(view.state.tr.setSelection(sel));
        else if ((view.markCursor || restarting) && !view.state.selection.empty)
          view.dispatch(view.state.tr.deleteSelection());
        else
          view.updateState(view.state);
        return true;
      }
      return false;
    }
    function captureCopy(view, dom) {
      if (!view.dom.parentNode)
        return;
      let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap2.appendChild(dom);
      wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
      let sel = getSelection(), range = document.createRange();
      range.selectNodeContents(dom);
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range);
      setTimeout(() => {
        if (wrap2.parentNode)
          wrap2.parentNode.removeChild(wrap2);
        view.focus();
      }, 50);
    }
    var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = (view, _event) => {
      let event = _event;
      let sel = view.state.selection, cut2 = event.type == "cut";
      if (sel.empty)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut2)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function sliceSingleNode(slice2) {
      return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
    }
    function capturePaste(view, event) {
      if (!view.dom.parentNode)
        return;
      let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
      let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText)
        target.contentEditable = "true";
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      setTimeout(() => {
        view.focus();
        if (target.parentNode)
          target.parentNode.removeChild(target);
        if (plainText)
          doPaste(view, target.value, null, plain, event);
        else
          doPaste(view, target.textContent, target.innerHTML, plain, event);
      }, 50);
    }
    function doPaste(view, text, html, preferPlain, event) {
      let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
      if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
        return true;
      if (!slice2)
        return false;
      let singleNode = sliceSingleNode(slice2);
      let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
      view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true;
    }
    function getText(clipboardData) {
      let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
      if (text)
        return text;
      let uris = clipboardData.getData("text/uri-list");
      return uris ? uris.replace(/\r?\n/g, " ") : "";
    }
    editHandlers.paste = (view, _event) => {
      let event = _event;
      if (view.composing && !android)
        return;
      let data = brokenClipboardAPI ? null : event.clipboardData;
      let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
      if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
        event.preventDefault();
      else
        capturePaste(view, event);
    };
    var Dragging = class {
      constructor(slice2, move, node) {
        this.slice = slice2;
        this.move = move;
        this.node = node;
      }
    };
    var dragCopyModifier = mac ? "altKey" : "ctrlKey";
    function dragMoves(view, event) {
      let moves = view.someProp("dragCopies", (test) => !test(event));
      return moves != null ? moves : !event[dragCopyModifier];
    }
    handlers.dragstart = (view, _event) => {
      let event = _event;
      let mouseDown = view.input.mouseDown;
      if (mouseDown)
        mouseDown.done();
      if (!event.dataTransfer)
        return;
      let sel = view.state.selection;
      let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      let node;
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
      else if (mouseDown && mouseDown.mightDrag) {
        node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
      } else if (event.target && event.target.nodeType == 1) {
        let desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView)
          node = NodeSelection.create(view.state.doc, desc.posBefore);
      }
      let draggedSlice = (node || view.state.selection).content();
      let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
      if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
        event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text);
      view.dragging = new Dragging(slice2, dragMoves(view, event), node);
    };
    handlers.dragend = (view) => {
      let dragging = view.dragging;
      window.setTimeout(() => {
        if (view.dragging == dragging)
          view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
    editHandlers.drop = (view, _event) => {
      let event = _event;
      let dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer)
        return;
      let eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos)
        return;
      let $mouse = view.state.doc.resolve(eventPos.pos);
      let slice2 = dragging && dragging.slice;
      if (slice2) {
        view.someProp("transformPasted", (f) => {
          slice2 = f(slice2, view);
        });
      } else {
        slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      let move = !!(dragging && dragMoves(view, event));
      if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
        event.preventDefault();
        return;
      }
      if (!slice2)
        return;
      event.preventDefault();
      let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
      if (insertPos == null)
        insertPos = $mouse.pos;
      let tr = view.state.tr;
      if (move) {
        let { node } = dragging;
        if (node)
          node.replace(tr);
        else
          tr.deleteSelection();
      }
      let pos = tr.mapping.map(insertPos);
      let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
      let beforeInsert = tr.doc;
      if (isNode)
        tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
      else
        tr.replaceRange(pos, pos, slice2);
      if (tr.doc.eq(beforeInsert))
        return;
      let $pos = tr.doc.resolve(pos);
      if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
        tr.setSelection(new NodeSelection($pos));
      } else {
        let end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = (view) => {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(() => {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
            selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = (view, _event) => {
      let event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
          view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = (view, _event) => {
      let event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        let { domChangeCount } = view.input;
        setTimeout(() => {
          if (view.input.domChangeCount != domChangeCount)
            return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
            return;
          let { $cursor } = view.state.selection;
          if ($cursor && $cursor.pos > 0)
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (let prop in editHandlers)
      handlers[prop] = editHandlers[prop];
    function compareObjs(a, b) {
      if (a == b)
        return true;
      for (let p in a)
        if (a[p] !== b[p])
          return false;
      for (let p in b)
        if (!(p in a))
          return false;
      return true;
    }
    var WidgetType = class _WidgetType {
      constructor(toDOM, spec) {
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      map(mapping, span, offset, oldOffset) {
        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        return deleted ? null : new Decoration(pos - offset, pos - offset, this);
      }
      valid() {
        return true;
      }
      eq(other) {
        return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
      }
      destroy(node) {
        if (this.spec.destroy)
          this.spec.destroy(node);
      }
    };
    var InlineType = class _InlineType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset, oldOffset) {
        let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
        return from2 >= to ? null : new Decoration(from2, to, this);
      }
      valid(_, span) {
        return span.from < span.to;
      }
      eq(other) {
        return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      static is(span) {
        return span.type instanceof _InlineType;
      }
      destroy() {
      }
    };
    var NodeType2 = class _NodeType {
      constructor(attrs, spec) {
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      map(mapping, span, offset, oldOffset) {
        let from2 = mapping.mapResult(span.from + oldOffset, 1);
        if (from2.deleted)
          return null;
        let to = mapping.mapResult(span.to + oldOffset, -1);
        if (to.deleted || to.pos <= from2.pos)
          return null;
        return new Decoration(from2.pos - offset, to.pos - offset, this);
      }
      valid(node, span) {
        let { index, offset } = node.content.findIndex(span.from), child;
        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
      }
      eq(other) {
        return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      }
      destroy() {
      }
    };
    var Decoration = class _Decoration {
      /**
      @internal
      */
      constructor(from2, to, type) {
        this.from = from2;
        this.to = to;
        this.type = type;
      }
      /**
      @internal
      */
      copy(from2, to) {
        return new _Decoration(from2, to, this.type);
      }
      /**
      @internal
      */
      eq(other, offset = 0) {
        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
      }
      /**
      @internal
      */
      map(mapping, offset, oldOffset) {
        return this.type.map(mapping, this, offset, oldOffset);
      }
      /**
      Creates a widget decoration, which is a DOM node that's shown in
      the document at the given position. It is recommended that you
      delay rendering the widget by passing a function that will be
      called when the widget is actually drawn in a view, but you can
      also directly pass a DOM node. `getPos` can be used to find the
      widget's current document position.
      */
      static widget(pos, toDOM, spec) {
        return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
      }
      /**
      Creates an inline decoration, which adds the given attributes to
      each inline node between `from` and `to`.
      */
      static inline(from2, to, attrs, spec) {
        return new _Decoration(from2, to, new InlineType(attrs, spec));
      }
      /**
      Creates a node decoration. `from` and `to` should point precisely
      before and after a node in the document. That node, and only that
      node, will receive the given attributes.
      */
      static node(from2, to, attrs, spec) {
        return new _Decoration(from2, to, new NodeType2(attrs, spec));
      }
      /**
      The spec provided when creating this decoration. Can be useful
      if you've stored extra information in that object.
      */
      get spec() {
        return this.type.spec;
      }
      /**
      @internal
      */
      get inline() {
        return this.type instanceof InlineType;
      }
      /**
      @internal
      */
      get widget() {
        return this.type instanceof WidgetType;
      }
    };
    var none = [];
    var noSpec = {};
    var DecorationSet = class _DecorationSet {
      /**
      @internal
      */
      constructor(local, children) {
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      /**
      Create a set of decorations, using the structure of the given
      document. This will consume (modify) the `decorations` array, so
      you must make a copy if you want need to preserve that.
      */
      static create(doc3, decorations) {
        return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
      }
      /**
      Find all decorations in this set which touch the given range
      (including decorations that start or end directly at the
      boundaries) and match the given predicate on their spec. When
      `start` and `end` are omitted, all decorations in the set are
      considered. When `predicate` isn't given, all decorations are
      assumed to match.
      */
      find(start, end, predicate) {
        let result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
      }
      findInner(start, end, result, offset, predicate) {
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let span = this.local[i2];
          if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
            result.push(span.copy(span.from + offset, span.to + offset));
        }
        for (let i2 = 0; i2 < this.children.length; i2 += 3) {
          if (this.children[i2] < end && this.children[i2 + 1] > start) {
            let childOff = this.children[i2] + 1;
            this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
          }
        }
      }
      /**
      Map the set of decorations in response to a change in the
      document.
      */
      map(mapping, doc3, options) {
        if (this == empty || mapping.maps.length == 0)
          return this;
        return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
      }
      /**
      @internal
      */
      mapInner(mapping, node, offset, oldOffset, options) {
        let newLocal;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let mapped = this.local[i2].map(mapping, offset, oldOffset);
          if (mapped && mapped.type.valid(node, mapped))
            (newLocal || (newLocal = [])).push(mapped);
          else if (options.onRemove)
            options.onRemove(this.local[i2].spec);
        }
        if (this.children.length)
          return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
        else
          return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
      }
      /**
      Add the given array of decorations to the ones in the set,
      producing a new set. Consumes the `decorations` array. Needs
      access to the current document to create the appropriate tree
      structure.
      */
      add(doc3, decorations) {
        if (!decorations.length)
          return this;
        if (this == empty)
          return _DecorationSet.create(doc3, decorations);
        return this.addInner(doc3, decorations, 0);
      }
      addInner(doc3, decorations, offset) {
        let children, childIndex = 0;
        doc3.forEach((childNode, childOffset) => {
          let baseOffset = childOffset + offset, found2;
          if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
            return;
          if (!children)
            children = this.children.slice();
          while (childIndex < children.length && children[childIndex] < childOffset)
            childIndex += 3;
          if (children[childIndex] == childOffset)
            children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
          else
            children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
          childIndex += 3;
        });
        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
        for (let i2 = 0; i2 < local.length; i2++)
          if (!local[i2].type.valid(doc3, local[i2]))
            local.splice(i2--, 1);
        return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
      }
      /**
      Create a new set that contains the decorations in this set, minus
      the ones in the given array.
      */
      remove(decorations) {
        if (decorations.length == 0 || this == empty)
          return this;
        return this.removeInner(decorations, 0);
      }
      removeInner(decorations, offset) {
        let children = this.children, local = this.local;
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let found2;
          let from2 = children[i2] + offset, to = children[i2 + 1] + offset;
          for (let j = 0, span; j < decorations.length; j++)
            if (span = decorations[j]) {
              if (span.from > from2 && span.to < to) {
                decorations[j] = null;
                (found2 || (found2 = [])).push(span);
              }
            }
          if (!found2)
            continue;
          if (children == this.children)
            children = this.children.slice();
          let removed = children[i2 + 2].removeInner(found2, from2 + 1);
          if (removed != empty) {
            children[i2 + 2] = removed;
          } else {
            children.splice(i2, 3);
            i2 -= 3;
          }
        }
        if (local.length) {
          for (let i2 = 0, span; i2 < decorations.length; i2++)
            if (span = decorations[i2]) {
              for (let j = 0; j < local.length; j++)
                if (local[j].eq(span, offset)) {
                  if (local == this.local)
                    local = this.local.slice();
                  local.splice(j--, 1);
                }
            }
        }
        if (children == this.children && local == this.local)
          return this;
        return local.length || children.length ? new _DecorationSet(local, children) : empty;
      }
      forChild(offset, node) {
        if (this == empty)
          return this;
        if (node.isLeaf)
          return _DecorationSet.empty;
        let child, local;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] >= offset) {
            if (this.children[i2] == offset)
              child = this.children[i2 + 2];
            break;
          }
        let start = offset + 1, end = start + node.content.size;
        for (let i2 = 0; i2 < this.local.length; i2++) {
          let dec = this.local[i2];
          if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
            let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
            if (from2 < to)
              (local || (local = [])).push(dec.copy(from2, to));
          }
        }
        if (local) {
          let localSet = new _DecorationSet(local.sort(byPos), none);
          return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
      }
      /**
      @internal
      */
      eq(other) {
        if (this == other)
          return true;
        if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
          return false;
        for (let i2 = 0; i2 < this.local.length; i2++)
          if (!this.local[i2].eq(other.local[i2]))
            return false;
        for (let i2 = 0; i2 < this.children.length; i2 += 3)
          if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
            return false;
        return true;
      }
      /**
      @internal
      */
      locals(node) {
        return removeOverlap(this.localsInner(node));
      }
      /**
      @internal
      */
      localsInner(node) {
        if (this == empty)
          return none;
        if (node.inlineContent || !this.local.some(InlineType.is))
          return this.local;
        let result = [];
        for (let i2 = 0; i2 < this.local.length; i2++) {
          if (!(this.local[i2].type instanceof InlineType))
            result.push(this.local[i2]);
        }
        return result;
      }
      forEachSet(f) {
        f(this);
      }
    };
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    var empty = DecorationSet.empty;
    var DecorationGroup = class _DecorationGroup {
      constructor(members) {
        this.members = members;
      }
      map(mapping, doc3) {
        const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
        return _DecorationGroup.from(mappedDecos);
      }
      forChild(offset, child) {
        if (child.isLeaf)
          return DecorationSet.empty;
        let found2 = [];
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let result = this.members[i2].forChild(offset, child);
          if (result == empty)
            continue;
          if (result instanceof _DecorationGroup)
            found2 = found2.concat(result.members);
          else
            found2.push(result);
        }
        return _DecorationGroup.from(found2);
      }
      eq(other) {
        if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
          return false;
        for (let i2 = 0; i2 < this.members.length; i2++)
          if (!this.members[i2].eq(other.members[i2]))
            return false;
        return true;
      }
      locals(node) {
        let result, sorted = true;
        for (let i2 = 0; i2 < this.members.length; i2++) {
          let locals = this.members[i2].localsInner(node);
          if (!locals.length)
            continue;
          if (!result) {
            result = locals;
          } else {
            if (sorted) {
              result = result.slice();
              sorted = false;
            }
            for (let j = 0; j < locals.length; j++)
              result.push(locals[j]);
          }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
      }
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      static from(members) {
        switch (members.length) {
          case 0:
            return empty;
          case 1:
            return members[0];
          default:
            return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
        }
      }
      forEachSet(f) {
        for (let i2 = 0; i2 < this.members.length; i2++)
          this.members[i2].forEachSet(f);
      }
    };
    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
      let children = oldChildren.slice();
      for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
        let moved = 0;
        mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
          let dSize = newEnd - newStart - (oldEnd - oldStart);
          for (let i22 = 0; i22 < children.length; i22 += 3) {
            let end = children[i22 + 1];
            if (end < 0 || oldStart > end + baseOffset - moved)
              continue;
            let start = children[i22] + baseOffset - moved;
            if (oldEnd >= start) {
              children[i22 + 1] = oldStart <= start ? -2 : -1;
            } else if (oldStart >= baseOffset && dSize) {
              children[i22] += dSize;
              children[i22 + 1] += dSize;
            }
          }
          moved += dSize;
        });
        baseOffset = mapping.maps[i2].map(baseOffset, -1);
      }
      let mustRebuild = false;
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] < 0) {
          if (children[i2 + 1] == -2) {
            mustRebuild = true;
            children[i2 + 1] = -1;
            continue;
          }
          let from2 = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from2 - offset;
          if (fromLocal < 0 || fromLocal >= node.content.size) {
            mustRebuild = true;
            continue;
          }
          let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset;
          let { index, offset: childOffset } = node.content.findIndex(fromLocal);
          let childNode = node.maybeChild(index);
          if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
            let mapped = children[i2 + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i2] + oldOffset + 1, options);
            if (mapped != empty) {
              children[i2] = fromLocal;
              children[i2 + 1] = toLocal;
              children[i2 + 2] = mapped;
            } else {
              children[i2 + 1] = -2;
              mustRebuild = true;
            }
          } else {
            mustRebuild = true;
          }
        }
      if (mustRebuild) {
        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
        let built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (let i2 = 0; i2 < children.length; i2 += 3)
          if (children[i2 + 1] < 0) {
            children.splice(i2, 3);
            i2 -= 3;
          }
        for (let i2 = 0, j = 0; i2 < built.children.length; i2 += 3) {
          let from2 = built.children[i2];
          while (j < children.length && children[j] < from2)
            j += 3;
          children.splice(j, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
        }
      }
      return new DecorationSet(newLocal.sort(byPos), children);
    }
    function moveSpans(spans, offset) {
      if (!offset || !spans.length)
        return spans;
      let result = [];
      for (let i2 = 0; i2 < spans.length; i2++) {
        let span = spans[i2];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result;
    }
    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
      function gather(set, oldOffset2) {
        for (let i2 = 0; i2 < set.local.length; i2++) {
          let mapped = set.local[i2].map(mapping, offset, oldOffset2);
          if (mapped)
            decorations.push(mapped);
          else if (options.onRemove)
            options.onRemove(set.local[i2].spec);
        }
        for (let i2 = 0; i2 < set.children.length; i2 += 3)
          gather(set.children[i2 + 2], set.children[i2] + oldOffset2 + 1);
      }
      for (let i2 = 0; i2 < children.length; i2 += 3)
        if (children[i2 + 1] == -1)
          gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
      return decorations;
    }
    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf)
        return null;
      let end = offset + node.nodeSize, found2 = null;
      for (let i2 = 0, span; i2 < spans.length; i2++) {
        if ((span = spans[i2]) && span.from > offset && span.to < end) {
          (found2 || (found2 = [])).push(span);
          spans[i2] = null;
        }
      }
      return found2;
    }
    function withoutNulls(array) {
      let result = [];
      for (let i2 = 0; i2 < array.length; i2++)
        if (array[i2] != null)
          result.push(array[i2]);
      return result;
    }
    function buildTree(spans, node, offset, options) {
      let children = [], hasNulls = false;
      node.forEach((childNode, localStart) => {
        let found2 = takeSpansForNode(spans, childNode, localStart + offset);
        if (found2) {
          hasNulls = true;
          let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
          if (subtree != empty)
            children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
      });
      let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (let i2 = 0; i2 < locals.length; i2++)
        if (!locals[i2].type.valid(node, locals[i2])) {
          if (options.onRemove)
            options.onRemove(locals[i2].spec);
          locals.splice(i2--, 1);
        }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty;
    }
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to;
    }
    function removeOverlap(spans) {
      let working = spans;
      for (let i2 = 0; i2 < working.length - 1; i2++) {
        let span = working[i2];
        if (span.from != span.to)
          for (let j = i2 + 1; j < working.length; j++) {
            let next = working[j];
            if (next.from == span.from) {
              if (next.to != span.to) {
                if (working == spans)
                  working = spans.slice();
                working[j] = next.copy(next.from, span.to);
                insertAhead(working, j + 1, next.copy(span.to, next.to));
              }
              continue;
            } else {
              if (next.from < span.to) {
                if (working == spans)
                  working = spans.slice();
                working[i2] = span.copy(span.from, next.from);
                insertAhead(working, j, span.copy(next.from, span.to));
              }
              break;
            }
          }
      }
      return working;
    }
    function insertAhead(array, i2, deco) {
      while (i2 < array.length && byPos(deco, array[i2]) > 0)
        i2++;
      array.splice(i2, 0, deco);
    }
    function viewDecorations(view) {
      let found2 = [];
      view.someProp("decorations", (f) => {
        let result = f(view.state);
        if (result && result != empty)
          found2.push(result);
      });
      if (view.cursorWrapper)
        found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
      return DecorationGroup.from(found2);
    }
    var observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    var useCharData = ie && ie_version <= 11;
    var SelectionState = class {
      constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      set(sel) {
        this.anchorNode = sel.anchorNode;
        this.anchorOffset = sel.anchorOffset;
        this.focusNode = sel.focusNode;
        this.focusOffset = sel.focusOffset;
      }
      clear() {
        this.anchorNode = this.focusNode = null;
      }
      eq(sel) {
        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
      }
    };
    var DOMObserver = class {
      constructor(view, handleDOMChange) {
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState();
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.lastChangedTextNode = null;
        this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
          for (let i2 = 0; i2 < mutations.length; i2++)
            this.queue.push(mutations[i2]);
          if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
            this.flushSoon();
          else
            this.flush();
        });
        if (useCharData) {
          this.onCharData = (e) => {
            this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
            this.flushSoon();
          };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      flushSoon() {
        if (this.flushingSoon < 0)
          this.flushingSoon = window.setTimeout(() => {
            this.flushingSoon = -1;
            this.flush();
          }, 20);
      }
      forceFlush() {
        if (this.flushingSoon > -1) {
          window.clearTimeout(this.flushingSoon);
          this.flushingSoon = -1;
          this.flush();
        }
      }
      start() {
        if (this.observer) {
          this.observer.takeRecords();
          this.observer.observe(this.view.dom, observeOptions);
        }
        if (this.onCharData)
          this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.connectSelection();
      }
      stop() {
        if (this.observer) {
          let take = this.observer.takeRecords();
          if (take.length) {
            for (let i2 = 0; i2 < take.length; i2++)
              this.queue.push(take[i2]);
            window.setTimeout(() => this.flush(), 20);
          }
          this.observer.disconnect();
        }
        if (this.onCharData)
          this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        this.disconnectSelection();
      }
      connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
      disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
      suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = true;
        setTimeout(() => this.suppressingSelectionUpdates = false, 50);
      }
      onSelectionChange() {
        if (!hasFocusAndSelection(this.view))
          return;
        if (this.suppressingSelectionUpdates)
          return selectionToDOM(this.view);
        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
          let sel = this.view.domSelectionRange();
          if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            return this.flushSoon();
        }
        this.flush();
      }
      setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
      ignoreSelectionChange(sel) {
        if (!sel.focusNode)
          return true;
        let ancestors = /* @__PURE__ */ new Set(), container;
        for (let scan = sel.focusNode; scan; scan = parentNode(scan))
          ancestors.add(scan);
        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
          if (ancestors.has(scan)) {
            container = scan;
            break;
          }
        let desc = container && this.view.docView.nearestDesc(container);
        if (desc && desc.ignoreMutation({
          type: "selection",
          target: container.nodeType == 3 ? container.parentNode : container
        })) {
          this.setCurSelection();
          return true;
        }
      }
      pendingRecords() {
        if (this.observer)
          for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
      }
      flush() {
        let { view } = this;
        if (!view.docView || this.flushingSoon > -1)
          return;
        let mutations = this.pendingRecords();
        if (mutations.length)
          this.queue = [];
        let sel = view.domSelectionRange();
        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
        let from2 = -1, to = -1, typeOver = false, added = [];
        if (view.editable) {
          for (let i2 = 0; i2 < mutations.length; i2++) {
            let result = this.registerMutation(mutations[i2], added);
            if (result) {
              from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
              to = to < 0 ? result.to : Math.max(result.to, to);
              if (result.typeOver)
                typeOver = true;
            }
          }
        }
        if (gecko && added.length) {
          let brs = added.filter((n) => n.nodeName == "BR");
          if (brs.length == 2) {
            let [a, b] = brs;
            if (a.parentNode && a.parentNode.parentNode == b.parentNode)
              b.remove();
            else
              a.remove();
          } else {
            let { focusNode } = this.currentSelection;
            for (let br of brs) {
              let parent = br.parentNode;
              if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
                br.remove();
            }
          }
        }
        let readSel = null;
        if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
          view.input.lastFocus = 0;
          selectionToDOM(view);
          this.currentSelection.set(sel);
          view.scrollToSelection();
        } else if (from2 > -1 || newSel) {
          if (from2 > -1) {
            view.docView.markDirty(from2, to);
            checkCSS(view);
          }
          this.handleDOMChange(from2, to, typeOver, added);
          if (view.docView && view.docView.dirty)
            view.updateState(view.state);
          else if (!this.currentSelection.eq(sel))
            selectionToDOM(view);
          this.currentSelection.set(sel);
        }
      }
      registerMutation(mut, added) {
        if (added.indexOf(mut.target) > -1)
          return null;
        let desc = this.view.docView.nearestDesc(mut.target);
        if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
        mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
          return null;
        if (!desc || desc.ignoreMutation(mut))
          return null;
        if (mut.type == "childList") {
          for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
            let node = mut.addedNodes[i2];
            added.push(node);
            if (node.nodeType == 3)
              this.lastChangedTextNode = node;
          }
          if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
            return { from: desc.posBefore, to: desc.posAfter };
          let prev = mut.previousSibling, next = mut.nextSibling;
          if (ie && ie_version <= 11 && mut.addedNodes.length) {
            for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
              let { previousSibling, nextSibling } = mut.addedNodes[i2];
              if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
                prev = previousSibling;
              if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
                next = nextSibling;
            }
          }
          let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
          let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
          let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
          let to = desc.localPosFromDOM(mut.target, toOffset, 1);
          return { from: from2, to };
        } else if (mut.type == "attributes") {
          return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
        } else {
          this.lastChangedTextNode = mut.target;
          return {
            from: desc.posAtStart,
            to: desc.posAtEnd,
            // An event was generated for a text change that didn't change
            // any text. Mark the dom change to fall back to assuming the
            // selection was typed over with an identical value if it can't
            // find another change.
            typeOver: mut.target.nodeValue == mut.oldValue
          };
        }
      }
    };
    var cssChecked = /* @__PURE__ */ new WeakMap();
    var cssCheckWarned = false;
    function checkCSS(view) {
      if (cssChecked.has(view))
        return;
      cssChecked.set(view, null);
      if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
        view.requiresGeckoHackNode = gecko;
        if (cssCheckWarned)
          return;
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
        cssCheckWarned = true;
      }
    }
    function rangeToSelectionRange(view, range) {
      let anchorNode = range.startContainer, anchorOffset = range.startOffset;
      let focusNode = range.endContainer, focusOffset = range.endOffset;
      let currentAnchor = view.domAtPos(view.state.selection.anchor);
      if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
      return { anchorNode, anchorOffset, focusNode, focusOffset };
    }
    function safariShadowSelectionRange(view, selection) {
      if (selection.getComposedRanges) {
        let range = selection.getComposedRanges(view.root)[0];
        if (range)
          return rangeToSelectionRange(view, range);
      }
      let found2;
      function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found2 = event.getTargetRanges()[0];
      }
      view.dom.addEventListener("beforeinput", read, true);
      document.execCommand("indent");
      view.dom.removeEventListener("beforeinput", read, true);
      return found2 ? rangeToSelectionRange(view, found2) : null;
    }
    function blockParent(view, node) {
      for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
        let desc = view.docView.nearestDesc(p, true);
        if (desc && desc.node.isBlock)
          return p;
      }
      return null;
    }
    function parseBetween(view, from_, to_) {
      let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
      let domSel = view.domSelectionRange();
      let find;
      let anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{ node: anchor, offset: domSel.anchorOffset }];
        if (!selectionCollapsed(domSel))
          find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
      }
      if (chrome && view.input.lastKeyCode === 8) {
        for (let off = toOffset; off > fromOffset; off--) {
          let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
          if (node.nodeName == "BR" && !desc) {
            toOffset = off;
            break;
          }
          if (!desc || desc.size)
            break;
        }
      }
      let startDoc = view.state.doc;
      let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
      let $from = startDoc.resolve(from2);
      let sel = null, doc3 = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find,
        ruleFromNode,
        context: $from
      });
      if (find && find[0].pos != null) {
        let anchor2 = find[0].pos, head = find[1] && find[1].pos;
        if (head == null)
          head = anchor2;
        sel = { anchor: anchor2 + from2, head: head + from2 };
      }
      return { doc: doc3, sel, from: from2, to };
    }
    function ruleFromNode(dom) {
      let desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule();
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          let skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return { skip };
        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return { ignore: true };
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return { ignore: true };
      }
      return null;
    }
    var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
    function readDOMChange(view, from2, to, typeOver, addedNodes) {
      let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
      view.input.compositionPendingChanges = 0;
      if (from2 < 0) {
        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
        let newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
            return;
          let tr2 = view.state.tr.setSelection(newSel);
          if (origin == "pointer")
            tr2.setMeta("pointer", true);
          else if (origin == "key")
            tr2.scrollIntoView();
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
        return;
      }
      let $before = view.state.doc.resolve(from2);
      let shared = $before.sharedDepth(to);
      from2 = $before.before(shared + 1);
      to = view.state.doc.resolve(to).after(shared + 1);
      let sel = view.state.selection;
      let parse = parseBetween(view, from2, to);
      let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
      let preferredPos, preferredSide;
      if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.input.lastKeyCode = null;
      let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if (change)
        view.input.domChangeCount++;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (!change) {
        if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = { start: sel.from, endA: sel.to, endB: sel.to };
        } else {
          if (parse.sel) {
            let sel2 = resolveSelection(view, view.state.doc, parse.sel);
            if (sel2 && !sel2.eq(view.state.selection)) {
              let tr2 = view.state.tr.setSelection(sel2);
              if (compositionID)
                tr2.setMeta("composition", compositionID);
              view.dispatch(tr2);
            }
          }
          return;
        }
      }
      if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
          change.endB += view.state.selection.to - change.endA;
          change.endA = view.state.selection.to;
        }
      }
      if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
        change.start--;
        change.endA--;
        change.endB--;
      }
      let $from = parse.doc.resolveNoCache(change.start - parse.from);
      let $to = parse.doc.resolveNoCache(change.endB - parse.from);
      let $fromA = doc3.resolve(change.start);
      let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
      let nextSel;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
        if (android && chrome)
          view.domObserver.suppressSelectionUpdates();
        return;
      }
      if (chrome && change.endB == change.start)
        view.input.lastChromeDelete = Date.now();
      if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(() => {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
        }, 20);
      }
      let chFrom = change.start, chTo = change.endA;
      let tr, storedMarks, markChange;
      if (inlineChange) {
        if ($from.pos == $to.pos) {
          if (ie && ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(() => selectionToDOM(view), 20);
          }
          tr = view.state.tr.delete(chFrom, chTo);
          storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
        } else if (
          // Adding or removing a mark
          change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
        ) {
          tr = view.state.tr;
          if (markChange.type == "add")
            tr.addMark(chFrom, chTo, markChange.mark);
          else
            tr.removeMark(chFrom, chTo, markChange.mark);
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          if (view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text)))
            return;
          tr = view.state.tr.insertText(text, chFrom, chTo);
        }
      }
      if (!tr)
        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
      if (parse.sel) {
        let sel2 = resolveSelection(view, tr.doc, parse.sel);
        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
          tr.setSelection(sel2);
      }
      if (storedMarks)
        tr.ensureMarks(storedMarks);
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr.scrollIntoView());
    }
    function resolveSelection(view, doc3, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
        return null;
      return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
    }
    function isMarkChange(cur, prev) {
      let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      let added = curMarks, removed = prevMarks, type, mark, update;
      for (let i2 = 0; i2 < prevMarks.length; i2++)
        added = prevMarks[i2].removeFromSet(added);
      for (let i2 = 0; i2 < curMarks.length; i2++)
        removed = curMarks[i2].removeFromSet(removed);
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = (node) => node.mark(mark.addToSet(node.marks));
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = (node) => node.mark(mark.removeFromSet(node.marks));
      } else {
        return null;
      }
      let updated = [];
      for (let i2 = 0; i2 < prev.childCount; i2++)
        updated.push(update(prev.child(i2)));
      if (Fragment.from(updated).eq(cur))
        return { mark, type };
    }
    function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
      if (
        // The content must have shrunk
        end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
        skipClosingAndOpening($newStart, true, false) < $newEnd.pos
      )
        return false;
      let $start = old.resolve(start);
      if (!$newStart.parent.isTextblock) {
        let after = $start.nodeAfter;
        return after != null && end == start + after.nodeSize;
      }
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
        return false;
      let $next = old.resolve(skipClosingAndOpening($start, true, true));
      if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
        return false;
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
    }
    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end;
    }
    function findDiff(a, b, pos, preferredPos, preferredSide) {
      let start = a.findDiffStart(b, pos);
      if (start == null)
        return null;
      let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
      if (preferredSide == "end") {
        let adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
          start += move ? 1 : -1;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= move;
        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
          start += move ? 1 : -1;
        endA = start + (endA - endB);
        endB = start;
      }
      return { start, endA, endB };
    }
    function isSurrogatePair(str) {
      if (str.length != 2)
        return false;
      let a = str.charCodeAt(0), b = str.charCodeAt(1);
      return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
    }
    var EditorView = class {
      /**
      Create a view. `place` may be a DOM node that the editor should
      be appended to, a function that will place it into the document,
      or an object whose `mount` property holds the node to use as the
      document container. If it is `null`, the editor will not be
      added to the document.
      */
      constructor(place, props) {
        this._root = null;
        this.focused = false;
        this.trackWrites = null;
        this.mounted = false;
        this.markCursor = null;
        this.cursorWrapper = null;
        this.lastSelectedViewDesc = void 0;
        this.input = new InputState();
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        this.requiresGeckoHackNode = false;
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild)
            place.appendChild(this.dom);
          else if (typeof place == "function")
            place(this.dom);
          else if (place.mount)
            this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
      }
      /**
      Holds `true` when a
      [composition](https://w3c.github.io/uievents/#events-compositionevents)
      is active.
      */
      get composing() {
        return this.input.composing;
      }
      /**
      The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
      */
      get props() {
        if (this._props.state != this.state) {
          let prev = this._props;
          this._props = {};
          for (let name in prev)
            this._props[name] = prev[name];
          this._props.state = this.state;
        }
        return this._props;
      }
      /**
      Update the view's props. Will immediately cause an update to
      the DOM.
      */
      update(props) {
        if (props.handleDOMEvents != this._props.handleDOMEvents)
          ensureListeners(this);
        let prevProps = this._props;
        this._props = props;
        if (props.plugins) {
          props.plugins.forEach(checkStateComponent);
          this.directPlugins = props.plugins;
        }
        this.updateStateInner(props.state, prevProps);
      }
      /**
      Update the view by updating existing props object with the object
      given as argument. Equivalent to `view.update(Object.assign({},
      view.props, props))`.
      */
      setProps(props) {
        let updated = {};
        for (let name in this._props)
          updated[name] = this._props[name];
        updated.state = this.state;
        for (let name in props)
          updated[name] = props[name];
        this.update(updated);
      }
      /**
      Update the editor's `state` prop, without touching any of the
      other props.
      */
      updateState(state) {
        this.updateStateInner(state, this._props);
      }
      updateStateInner(state, prevProps) {
        var _a;
        let prev = this.state, redraw = false, updateSel = false;
        if (state.storedMarks && this.composing) {
          clearComposition(this);
          updateSel = true;
        }
        this.state = state;
        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
          let nodeViews = buildNodeViews(this);
          if (changedNodeViews(nodeViews, this.nodeViews)) {
            this.nodeViews = nodeViews;
            redraw = true;
          }
        }
        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
          ensureListeners(this);
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
        if (updateDoc || !state.selection.eq(prev.selection))
          updateSel = true;
        let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
        if (updateSel) {
          this.domObserver.stop();
          let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
          if (updateDoc) {
            let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
            if (this.composing)
              this.input.compositionNode = findCompositionNode(this);
            if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
              this.docView.updateOuterDeco(outerDeco);
              this.docView.destroy();
              this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
            }
            if (chromeKludge && !this.trackWrites)
              forceSelUpdate = true;
          }
          if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
            selectionToDOM(this, forceSelUpdate);
          } else {
            syncNodeSelection(this, state.selection);
            this.domObserver.setCurSelection();
          }
          this.domObserver.start();
        }
        this.updatePluginViews(prev);
        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
          this.updateDraggedNode(this.dragging, prev);
        if (scroll == "reset") {
          this.dom.scrollTop = 0;
        } else if (scroll == "to selection") {
          this.scrollToSelection();
        } else if (oldScrollPos) {
          resetScrollPos(oldScrollPos);
        }
      }
      /**
      @internal
      */
      scrollToSelection() {
        let startDOM = this.domSelectionRange().focusNode;
        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
        else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
        else if (this.state.selection instanceof NodeSelection) {
          let target = this.docView.domAfterPos(this.state.selection.from);
          if (target.nodeType == 1)
            scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
        }
      }
      destroyPluginViews() {
        let view;
        while (view = this.pluginViews.pop())
          if (view.destroy)
            view.destroy();
      }
      updatePluginViews(prevState) {
        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins;
          this.destroyPluginViews();
          for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
            let plugin = this.directPlugins[i2];
            if (plugin.spec.view)
              this.pluginViews.push(plugin.spec.view(this));
          }
          for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
            let plugin = this.state.plugins[i2];
            if (plugin.spec.view)
              this.pluginViews.push(plugin.spec.view(this));
          }
        } else {
          for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
            let pluginView = this.pluginViews[i2];
            if (pluginView.update)
              pluginView.update(this, prevState);
          }
        }
      }
      updateDraggedNode(dragging, prev) {
        let sel = dragging.node, found2 = -1;
        if (this.state.doc.nodeAt(sel.from) == sel.node) {
          found2 = sel.from;
        } else {
          let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
          let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
          if (moved == sel.node)
            found2 = movedPos;
        }
        this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
      }
      someProp(propName, f) {
        let prop = this._props && this._props[propName], value;
        if (prop != null && (value = f ? f(prop) : prop))
          return value;
        for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
          let prop2 = this.directPlugins[i2].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
        let plugins = this.state.plugins;
        if (plugins)
          for (let i2 = 0; i2 < plugins.length; i2++) {
            let prop2 = plugins[i2].props[propName];
            if (prop2 != null && (value = f ? f(prop2) : prop2))
              return value;
          }
      }
      /**
      Query whether the view has focus.
      */
      hasFocus() {
        if (ie) {
          let node = this.root.activeElement;
          if (node == this.dom)
            return true;
          if (!node || !this.dom.contains(node))
            return false;
          while (node && this.dom != node && this.dom.contains(node)) {
            if (node.contentEditable == "false")
              return false;
            node = node.parentElement;
          }
          return true;
        }
        return this.root.activeElement == this.dom;
      }
      /**
      Focus the editor.
      */
      focus() {
        this.domObserver.stop();
        if (this.editable)
          focusPreventScroll(this.dom);
        selectionToDOM(this);
        this.domObserver.start();
      }
      /**
      Get the document root in which the editor exists. This will
      usually be the top-level `document`, but might be a [shadow
      DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      root if the editor is inside one.
      */
      get root() {
        let cached = this._root;
        if (cached == null)
          for (let search = this.dom.parentNode; search; search = search.parentNode) {
            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
              if (!search.getSelection)
                Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
              return this._root = search;
            }
          }
        return cached || document;
      }
      /**
      When an existing editor view is moved to a new document or
      shadow tree, call this to make it recompute its root.
      */
      updateRoot() {
        this._root = null;
      }
      /**
      Given a pair of viewport coordinates, return the document
      position that corresponds to them. May return null if the given
      coordinates aren't inside of the editor. When an object is
      returned, its `pos` property is the position nearest to the
      coordinates, and its `inside` property holds the position of the
      inner node that the position falls inside of, or -1 if it is at
      the top level, not in any node.
      */
      posAtCoords(coords) {
        return posAtCoords(this, coords);
      }
      /**
      Returns the viewport rectangle at a given document position.
      `left` and `right` will be the same number, as this returns a
      flat cursor-ish rectangle. If the position is between two things
      that aren't directly adjacent, `side` determines which element
      is used. When < 0, the element before the position is used,
      otherwise the element after.
      */
      coordsAtPos(pos, side = 1) {
        return coordsAtPos(this, pos, side);
      }
      /**
      Find the DOM position that corresponds to the given document
      position. When `side` is negative, find the position as close as
      possible to the content before the position. When positive,
      prefer positions close to the content after the position. When
      zero, prefer as shallow a position as possible.
      
      Note that you should **not** mutate the editor's internal DOM,
      only inspect it (and even that is usually not necessary).
      */
      domAtPos(pos, side = 0) {
        return this.docView.domFromPos(pos, side);
      }
      /**
      Find the DOM node that represents the document node after the
      given position. May return `null` when the position doesn't point
      in front of a node or if the node is inside an opaque node view.
      
      This is intended to be able to call things like
      `getBoundingClientRect` on that DOM node. Do **not** mutate the
      editor DOM directly, or add styling this way, since that will be
      immediately overriden by the editor as it redraws the node.
      */
      nodeDOM(pos) {
        let desc = this.docView.descAt(pos);
        return desc ? desc.nodeDOM : null;
      }
      /**
      Find the document position that corresponds to a given DOM
      position. (Whenever possible, it is preferable to inspect the
      document structure directly, rather than poking around in the
      DOM, but sometimesfor example when interpreting an event
      targetyou don't have a choice.)
      
      The `bias` parameter can be used to influence which side of a DOM
      node to use when the position is inside a leaf node.
      */
      posAtDOM(node, offset, bias = -1) {
        let pos = this.docView.posFromDOM(node, offset, bias);
        if (pos == null)
          throw new RangeError("DOM position not inside the editor");
        return pos;
      }
      /**
      Find out whether the selection is at the end of a textblock when
      moving in a given direction. When, for example, given `"left"`,
      it will return true if moving left from the current cursor
      position would leave that position's parent textblock. Will apply
      to the view's current state by default, but it is possible to
      pass a different state.
      */
      endOfTextblock(dir, state) {
        return endOfTextblock(this, state || this.state, dir);
      }
      /**
      Run the editor's paste logic with the given HTML string. The
      `event`, if given, will be passed to the
      [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
      */
      pasteHTML(html, event) {
        return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
      }
      /**
      Run the editor's paste logic with the given plain-text input.
      */
      pasteText(text, event) {
        return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
      }
      /**
      Serialize the given slice as it would be if it was copied from
      this editor. Returns a DOM element that contains a
      representation of the slice as its children, a textual
      representation, and the transformed slice (which can be
      different from the given input due to hooks like
      [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
      */
      serializeForClipboard(slice2) {
        return serializeForClipboard(this, slice2);
      }
      /**
      Removes the editor from the DOM and destroys all [node
      views](https://prosemirror.net/docs/ref/#view.NodeView).
      */
      destroy() {
        if (!this.docView)
          return;
        destroyInput(this);
        this.destroyPluginViews();
        if (this.mounted) {
          this.docView.update(this.state.doc, [], viewDecorations(this), this);
          this.dom.textContent = "";
        } else if (this.dom.parentNode) {
          this.dom.parentNode.removeChild(this.dom);
        }
        this.docView.destroy();
        this.docView = null;
        clearReusedRange();
      }
      /**
      This is true when the view has been
      [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
      used anymore).
      */
      get isDestroyed() {
        return this.docView == null;
      }
      /**
      Used for testing.
      */
      dispatchEvent(event) {
        return dispatchEvent(this, event);
      }
      /**
      Dispatch a transaction. Will call
      [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
      when given, and otherwise defaults to applying the transaction to
      the current state and calling
      [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
      This method is bound to the view instance, so that it can be
      easily passed around.
      */
      dispatch(tr) {
        let dispatchTransaction = this._props.dispatchTransaction;
        if (dispatchTransaction)
          dispatchTransaction.call(this, tr);
        else
          this.updateState(this.state.apply(tr));
      }
      /**
      @internal
      */
      domSelectionRange() {
        let sel = this.domSelection();
        if (!sel)
          return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
      }
      /**
      @internal
      */
      domSelection() {
        return this.root.getSelection();
      }
    };
    function computeDocDeco(view) {
      let attrs = /* @__PURE__ */ Object.create(null);
      attrs.class = "ProseMirror";
      attrs.contenteditable = String(view.editable);
      view.someProp("attributes", (value) => {
        if (typeof value == "function")
          value = value(view.state);
        if (value)
          for (let attr in value) {
            if (attr == "class")
              attrs.class += " " + value[attr];
            else if (attr == "style")
              attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
            else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
              attrs[attr] = String(value[attr]);
          }
      });
      if (!attrs.translate)
        attrs.translate = "no";
      return [Decoration.node(0, view.state.doc.content.size, attrs)];
    }
    function updateCursorWrapper(view) {
      if (view.markCursor) {
        let dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        dom.setAttribute("alt", "");
        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
      } else {
        view.cursorWrapper = null;
      }
    }
    function getEditable(view) {
      return !view.someProp("editable", (value) => value(view.state) === false);
    }
    function selectionContextChanged(sel1, sel2) {
      let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
    }
    function buildNodeViews(view) {
      let result = /* @__PURE__ */ Object.create(null);
      function add(obj) {
        for (let prop in obj)
          if (!Object.prototype.hasOwnProperty.call(result, prop))
            result[prop] = obj[prop];
      }
      view.someProp("nodeViews", add);
      view.someProp("markViews", add);
      return result;
    }
    function changedNodeViews(a, b) {
      let nA = 0, nB = 0;
      for (let prop in a) {
        if (a[prop] != b[prop])
          return true;
        nA++;
      }
      for (let _ in b)
        nB++;
      return nA != nB;
    }
    function checkStateComponent(plugin) {
      if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
    var i;
    for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
    var i;
    for (i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    var i;
    for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
    var code;
    function keyName(event) {
      var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      if (name == "Esc") name = "Escape";
      if (name == "Del") name = "Delete";
      if (name == "Left") name = "ArrowLeft";
      if (name == "Up") name = "ArrowUp";
      if (name == "Right") name = "ArrowRight";
      if (name == "Down") name = "ArrowDown";
      return name;
    }
    var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function normalizeKeyName(name) {
      let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space")
        result = " ";
      let alt, ctrl, shift2, meta;
      for (let i2 = 0; i2 < parts.length - 1; i2++) {
        let mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod))
          meta = true;
        else if (/^a(lt)?$/i.test(mod))
          alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
          ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
          shift2 = true;
        else if (/^mod$/i.test(mod)) {
          if (mac3)
            meta = true;
          else
            ctrl = true;
        } else
          throw new Error("Unrecognized modifier name: " + mod);
      }
      if (alt)
        result = "Alt-" + result;
      if (ctrl)
        result = "Ctrl-" + result;
      if (meta)
        result = "Meta-" + result;
      if (shift2)
        result = "Shift-" + result;
      return result;
    }
    function normalize(map2) {
      let copy2 = /* @__PURE__ */ Object.create(null);
      for (let prop in map2)
        copy2[normalizeKeyName(prop)] = map2[prop];
      return copy2;
    }
    function modifiers(name, event, shift2 = true) {
      if (event.altKey)
        name = "Alt-" + name;
      if (event.ctrlKey)
        name = "Ctrl-" + name;
      if (event.metaKey)
        name = "Meta-" + name;
      if (shift2 && event.shiftKey)
        name = "Shift-" + name;
      return name;
    }
    function keymap(bindings) {
      return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
    }
    function keydownHandler(bindings) {
      let map2 = normalize(bindings);
      return function(view, event) {
        let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
        if (direct && direct(view.state, view.dispatch, view))
          return true;
        if (name.length == 1 && name != " ") {
          if (event.shiftKey) {
            let noShift = map2[modifiers(name, event, false)];
            if (noShift && noShift(view.state, view.dispatch, view))
              return true;
          }
          if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
            let fromCode = map2[modifiers(baseName, event)];
            if (fromCode && fromCode(view.state, view.dispatch, view))
              return true;
          }
        }
        return false;
      };
    }
    var deleteSelection = (state, dispatch) => {
      if (state.selection.empty)
        return false;
      if (dispatch)
        dispatch(state.tr.deleteSelection().scrollIntoView());
      return true;
    };
    function atBlockStart(state, view) {
      let { $cursor } = state.selection;
      if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
        return null;
      return $cursor;
    }
    var joinBackward = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      if (!$cut) {
        let range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null)
          return false;
        if (dispatch)
          dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
      }
      let before = $cut.nodeBefore;
      if (deleteBarrier(state, $cut, dispatch, -1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        for (let depth = $cursor.depth; ; depth--) {
          let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
          if (delStep && delStep.slice.size < delStep.to - delStep.from) {
            if (dispatch) {
              let tr = state.tr.step(delStep);
              tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
              dispatch(tr.scrollIntoView());
            }
            return true;
          }
          if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
            break;
        }
      }
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
        return true;
      }
      return false;
    };
    var joinTextblockBackward = (state, dispatch, view) => {
      let $cursor = atBlockStart(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutBefore($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    var joinTextblockForward = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
    };
    function joinTextblocksAround(state, $cut, dispatch) {
      let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
      for (; !beforeText.isTextblock; beforePos--) {
        if (beforeText.type.spec.isolating)
          return false;
        let child = beforeText.lastChild;
        if (!child)
          return false;
        beforeText = child;
      }
      let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
      for (; !afterText.isTextblock; afterPos++) {
        if (afterText.type.spec.isolating)
          return false;
        let child = afterText.firstChild;
        if (!child)
          return false;
        afterText = child;
      }
      let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
      if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
        return false;
      if (dispatch) {
        let tr = state.tr.step(step);
        tr.setSelection(TextSelection.create(tr.doc, beforePos));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
    function textblockAt(node, side, only = false) {
      for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
        if (scan.isTextblock)
          return true;
        if (only && scan.childCount != 1)
          return false;
      }
      return false;
    }
    var selectNodeBackward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
          return false;
        $cut = findCutBefore($head);
      }
      let node = $cut && $cut.nodeBefore;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
      return true;
    };
    function findCutBefore($pos) {
      if (!$pos.parent.type.spec.isolating)
        for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
          if ($pos.index(i2) > 0)
            return $pos.doc.resolve($pos.before(i2 + 1));
          if ($pos.node(i2).type.spec.isolating)
            break;
        }
      return null;
    }
    function atBlockEnd(state, view) {
      let { $cursor } = state.selection;
      if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
        return null;
      return $cursor;
    }
    var joinForward = (state, dispatch, view) => {
      let $cursor = atBlockEnd(state, view);
      if (!$cursor)
        return false;
      let $cut = findCutAfter($cursor);
      if (!$cut)
        return false;
      let after = $cut.nodeAfter;
      if (deleteBarrier(state, $cut, dispatch, 1))
        return true;
      if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr = state.tr.step(delStep);
            tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }
      }
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch)
          dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
        return true;
      }
      return false;
    };
    var selectNodeForward = (state, dispatch, view) => {
      let { $head, empty: empty2 } = state.selection, $cut = $head;
      if (!empty2)
        return false;
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
          return false;
        $cut = findCutAfter($head);
      }
      let node = $cut && $cut.nodeAfter;
      if (!node || !NodeSelection.isSelectable(node))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
      return true;
    };
    function findCutAfter($pos) {
      if (!$pos.parent.type.spec.isolating)
        for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
          let parent = $pos.node(i2);
          if ($pos.index(i2) + 1 < parent.childCount)
            return $pos.doc.resolve($pos.after(i2 + 1));
          if (parent.type.spec.isolating)
            break;
        }
      return null;
    }
    var joinUp = (state, dispatch) => {
      let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
          return false;
        point = sel.from;
      } else {
        point = joinPoint(state.doc, sel.from, -1);
        if (point == null)
          return false;
      }
      if (dispatch) {
        let tr = state.tr.join(point);
        if (nodeSel)
          tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var joinDown = (state, dispatch) => {
      let sel = state.selection, point;
      if (sel instanceof NodeSelection) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
          return false;
        point = sel.to;
      } else {
        point = joinPoint(state.doc, sel.to, 1);
        if (point == null)
          return false;
      }
      if (dispatch)
        dispatch(state.tr.join(point).scrollIntoView());
      return true;
    };
    var lift2 = (state, dispatch) => {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    var newlineInCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      if (dispatch)
        dispatch(state.tr.insertText("\n").scrollIntoView());
      return true;
    };
    function defaultBlockAt(match) {
      for (let i2 = 0; i2 < match.edgeCount; i2++) {
        let { type } = match.edge(i2);
        if (type.isTextblock && !type.hasRequiredAttrs())
          return type;
      }
      return null;
    }
    var exitCode = (state, dispatch) => {
      let { $head, $anchor } = state.selection;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
        return false;
      let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
      if (!type || !above.canReplaceWith(after, after, type))
        return false;
      if (dispatch) {
        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var createParagraphNear = (state, dispatch) => {
      let sel = state.selection, { $from, $to } = sel;
      if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
        return false;
      let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock)
        return false;
      if (dispatch) {
        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        let tr = state.tr.insert(side, type.createAndFill());
        tr.setSelection(TextSelection.create(tr.doc, side + 1));
        dispatch(tr.scrollIntoView());
      }
      return true;
    };
    var liftEmptyBlock = (state, dispatch) => {
      let { $cursor } = state.selection;
      if (!$cursor || $cursor.parent.content.size)
        return false;
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        let before = $cursor.before();
        if (canSplit(state.doc, before)) {
          if (dispatch)
            dispatch(state.tr.split(before).scrollIntoView());
          return true;
        }
      }
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    };
    function splitBlockAs(splitNode) {
      return (state, dispatch) => {
        let { $from, $to } = state.selection;
        if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
          if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
            return false;
          if (dispatch)
            dispatch(state.tr.split($from.pos).scrollIntoView());
          return true;
        }
        if (!$from.depth)
          return false;
        let types = [];
        let splitDepth, deflt, atEnd = false, atStart = false;
        for (let d = $from.depth; ; d--) {
          let node = $from.node(d);
          if (node.isBlock) {
            atEnd = $from.end(d) == $from.pos + ($from.depth - d);
            atStart = $from.start(d) == $from.pos - ($from.depth - d);
            deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
            let splitType = splitNode && splitNode($to.parent, atEnd, $from);
            types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
            splitDepth = d;
            break;
          } else {
            if (d == 1)
              return false;
            types.unshift(null);
          }
        }
        let tr = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
          tr.deleteSelection();
        let splitPos = tr.mapping.map($from.pos);
        let can = canSplit(tr.doc, splitPos, types.length, types);
        if (!can) {
          types[0] = deflt ? { type: deflt } : null;
          can = canSplit(tr.doc, splitPos, types.length, types);
        }
        if (!can)
          return false;
        tr.split(splitPos, types.length, types);
        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
          let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
          if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
            tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
        }
        if (dispatch)
          dispatch(tr.scrollIntoView());
        return true;
      };
    }
    var splitBlock = splitBlockAs();
    var selectParentNode = (state, dispatch) => {
      let { $from, to } = state.selection, pos;
      let same = $from.sharedDepth(to);
      if (same == 0)
        return false;
      pos = $from.before(same);
      if (dispatch)
        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
      return true;
    };
    var selectAll = (state, dispatch) => {
      if (dispatch)
        dispatch(state.tr.setSelection(new AllSelection(state.doc)));
      return true;
    };
    function joinMaybeClear(state, $pos, dispatch) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
      if (!before || !after || !before.type.compatibleContent(after.type))
        return false;
      if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
        if (dispatch)
          dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
        return true;
      }
      if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
        return false;
      if (dispatch)
        dispatch(state.tr.join($pos.pos).scrollIntoView());
      return true;
    }
    function deleteBarrier(state, $cut, dispatch, dir) {
      let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
      let isolated = before.type.spec.isolating || after.type.spec.isolating;
      if (!isolated && joinMaybeClear(state, $cut, dispatch))
        return true;
      let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
      if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
          let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
          for (let i2 = conn.length - 1; i2 >= 0; i2--)
            wrap2 = Fragment.from(conn[i2].create(null, wrap2));
          wrap2 = Fragment.from(before.copy(wrap2));
          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
          let $joinAt = tr.doc.resolve(end + 2 * conn.length);
          if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
            tr.join($joinAt.pos);
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
      let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
      if (target != null && target >= $cut.depth) {
        if (dispatch)
          dispatch(state.tr.lift(range, target).scrollIntoView());
        return true;
      }
      if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
        let at = before, wrap2 = [];
        for (; ; ) {
          wrap2.push(at);
          if (at.isTextblock)
            break;
          at = at.lastChild;
        }
        let afterText = after, afterDepth = 1;
        for (; !afterText.isTextblock; afterText = afterText.firstChild)
          afterDepth++;
        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
          if (dispatch) {
            let end = Fragment.empty;
            for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
              end = Fragment.from(wrap2[i2].copy(end));
            let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }
      }
      return false;
    }
    function selectTextblockSide(side) {
      return function(state, dispatch) {
        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
        let depth = $pos.depth;
        while ($pos.node(depth).isInline) {
          if (!depth)
            return false;
          depth--;
        }
        if (!$pos.node(depth).isTextblock)
          return false;
        if (dispatch)
          dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
        return true;
      };
    }
    var selectTextblockStart = selectTextblockSide(-1);
    var selectTextblockEnd = selectTextblockSide(1);
    function wrapIn(nodeType, attrs = null) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
        if (!wrapping)
          return false;
        if (dispatch)
          dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
        return true;
      };
    }
    function setBlockType2(nodeType, attrs = null) {
      return function(state, dispatch) {
        let applicable = false;
        for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
          let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
          state.doc.nodesBetween(from2, to, (node, pos) => {
            if (applicable)
              return false;
            if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
              return;
            if (node.type == nodeType) {
              applicable = true;
            } else {
              let $pos = state.doc.resolve(pos), index = $pos.index();
              applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
            }
          });
        }
        if (!applicable)
          return false;
        if (dispatch) {
          let tr = state.tr;
          for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
            let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i2];
            tr.setBlockType(from2, to, nodeType, attrs);
          }
          dispatch(tr.scrollIntoView());
        }
        return true;
      };
    }
    function chainCommands(...commands2) {
      return function(state, dispatch, view) {
        for (let i2 = 0; i2 < commands2.length; i2++)
          if (commands2[i2](state, dispatch, view))
            return true;
        return false;
      };
    }
    var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
    var pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Shift-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };
    var macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"],
      "Ctrl-a": selectTextblockStart,
      "Ctrl-e": selectTextblockEnd
    };
    for (let key in pcBaseKeymap)
      macBaseKeymap[key] = pcBaseKeymap[key];
    var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
    function wrapInList(listType, attrs = null) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to);
        if (!range)
          return false;
        let tr = dispatch ? state.tr : null;
        if (!wrapRangeInList(tr, range, listType, attrs))
          return false;
        if (dispatch)
          dispatch(tr.scrollIntoView());
        return true;
      };
    }
    function wrapRangeInList(tr, range, listType, attrs = null) {
      let doJoin = false, outerRange = range, doc3 = range.$from.doc;
      if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
        if (range.$from.index(range.depth - 1) == 0)
          return false;
        let $insert = doc3.resolve(range.start - 2);
        outerRange = new NodeRange($insert, $insert, range.depth);
        if (range.endIndex < range.parent.childCount)
          range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
        doJoin = true;
      }
      let wrap2 = findWrapping(outerRange, listType, attrs, range);
      if (!wrap2)
        return false;
      if (tr)
        doWrapInList(tr, range, wrap2, doJoin, listType);
      return true;
    }
    function doWrapInList(tr, range, wrappers, joinBefore, listType) {
      let content = Fragment.empty;
      for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
        content = Fragment.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
      tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
      let found2 = 0;
      for (let i2 = 0; i2 < wrappers.length; i2++)
        if (wrappers[i2].type == listType)
          found2 = i2 + 1;
      let splitDepth = wrappers.length - found2;
      let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
      for (let i2 = range.startIndex, e = range.endIndex, first2 = true; i2 < e; i2++, first2 = false) {
        if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
          tr.split(splitPos, splitDepth);
          splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(i2).nodeSize;
      }
      return tr;
    }
    function liftListItem(itemType) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range)
          return false;
        if (!dispatch)
          return true;
        if ($from.node(range.depth - 1).type == itemType)
          return liftToOuterList(state, dispatch, itemType, range);
        else
          return liftOutOfList(state, dispatch, range);
      };
    }
    function liftToOuterList(state, dispatch, itemType, range) {
      let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
      if (end < endOfList) {
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
      }
      const target = liftTarget(range);
      if (target == null)
        return false;
      tr.lift(range, target);
      let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
      if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
        tr.join($after.pos);
      dispatch(tr.scrollIntoView());
      return true;
    }
    function liftOutOfList(state, dispatch, range) {
      let tr = state.tr, list = range.parent;
      for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex; i2 > e; i2--) {
        pos -= list.child(i2).nodeSize;
        tr.delete(pos - 1, pos + 1);
      }
      let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
      if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
        return false;
      let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
      let parent = $start.node(-1), indexBefore = $start.index(-1);
      if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
        return false;
      let start = $start.pos, end = start + item.nodeSize;
      tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
      dispatch(tr.scrollIntoView());
      return true;
    }
    function sinkListItem(itemType) {
      return function(state, dispatch) {
        let { $from, $to } = state.selection;
        let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
        if (!range)
          return false;
        let startIndex = range.startIndex;
        if (startIndex == 0)
          return false;
        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType)
          return false;
        if (dispatch) {
          let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
          let inner = Fragment.from(nestedBefore ? itemType.create() : null);
          let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
          let before = range.start, after = range.end;
          dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
        }
        return true;
      };
    }
    function createChainableState(config) {
      const { state, transaction } = config;
      let { selection } = transaction;
      let { doc: doc3 } = transaction;
      let { storedMarks } = transaction;
      return __spreadProps(__spreadValues({}, state), {
        apply: state.apply.bind(state),
        applyTransaction: state.applyTransaction.bind(state),
        plugins: state.plugins,
        schema: state.schema,
        reconfigure: state.reconfigure.bind(state),
        toJSON: state.toJSON.bind(state),
        get storedMarks() {
          return storedMarks;
        },
        get selection() {
          return selection;
        },
        get doc() {
          return doc3;
        },
        get tr() {
          selection = transaction.selection;
          doc3 = transaction.doc;
          storedMarks = transaction.storedMarks;
          return transaction;
        }
      });
    }
    var CommandManager = class {
      constructor(props) {
        this.editor = props.editor;
        this.rawCommands = this.editor.extensionManager.commands;
        this.customState = props.state;
      }
      get hasCustomState() {
        return !!this.customState;
      }
      get state() {
        return this.customState || this.editor.state;
      }
      get commands() {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const { tr } = state;
        const props = this.buildProps(tr);
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const method = (...args) => {
            const callback = command2(...args)(props);
            if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
              view.dispatch(tr);
            }
            return callback;
          };
          return [name, method];
        }));
      }
      get chain() {
        return () => this.createChain();
      }
      get can() {
        return () => this.createCan();
      }
      createChain(startTr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const callbacks = [];
        const hasStartTransaction = !!startTr;
        const tr = startTr || state.tr;
        const run2 = () => {
          if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callbacks.every((callback) => callback === true);
        };
        const chain = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        }))), {
          run: run2
        });
        return chain;
      }
      createCan(startTr) {
        const { rawCommands, state } = this;
        const dispatch = false;
        const tr = startTr || state.tr;
        const props = this.buildProps(tr, dispatch);
        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(__spreadProps(__spreadValues({}, props), { dispatch: void 0 }))];
        }));
        return __spreadProps(__spreadValues({}, formattedCommands), {
          chain: () => this.createChain(tr, dispatch)
        });
      }
      buildProps(tr, shouldDispatch = true) {
        const { rawCommands, editor, state } = this;
        const { view } = editor;
        const props = {
          tr,
          editor,
          view,
          state: createChainableState({
            state,
            transaction: tr
          }),
          dispatch: shouldDispatch ? () => void 0 : void 0,
          chain: () => this.createChain(tr, shouldDispatch),
          can: () => this.createCan(tr),
          get commands() {
            return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
              return [name, (...args) => command2(...args)(props)];
            }));
          }
        };
        return props;
      }
    };
    var EventEmitter = class {
      constructor() {
        this.callbacks = {};
      }
      on(event, fn) {
        if (!this.callbacks[event]) {
          this.callbacks[event] = [];
        }
        this.callbacks[event].push(fn);
        return this;
      }
      emit(event, ...args) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          callbacks.forEach((callback) => callback.apply(this, args));
        }
        return this;
      }
      off(event, fn) {
        const callbacks = this.callbacks[event];
        if (callbacks) {
          if (fn) {
            this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
          } else {
            delete this.callbacks[event];
          }
        }
        return this;
      }
      once(event, fn) {
        const onceFn = (...args) => {
          this.off(event, onceFn);
          fn.apply(this, args);
        };
        return this.on(event, onceFn);
      }
      removeAllListeners() {
        this.callbacks = {};
      }
    };
    function getExtensionField(extension, field, context) {
      if (extension.config[field] === void 0 && extension.parent) {
        return getExtensionField(extension.parent, field, context);
      }
      if (typeof extension.config[field] === "function") {
        const value = extension.config[field].bind(__spreadProps(__spreadValues({}, context), {
          parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
        }));
        return value;
      }
      return extension.config[field];
    }
    function splitExtensions(extensions) {
      const baseExtensions = extensions.filter((extension) => extension.type === "extension");
      const nodeExtensions = extensions.filter((extension) => extension.type === "node");
      const markExtensions = extensions.filter((extension) => extension.type === "mark");
      return {
        baseExtensions,
        nodeExtensions,
        markExtensions
      };
    }
    function getAttributesFromExtensions(extensions) {
      const extensionAttributes = [];
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
      const defaultAttribute = {
        default: null,
        rendered: true,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: true,
        isRequired: false
      };
      extensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          extensions: nodeAndMarkExtensions
        };
        const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
        if (!addGlobalAttributes) {
          return;
        }
        const globalAttributes = addGlobalAttributes();
        globalAttributes.forEach((globalAttribute) => {
          globalAttribute.types.forEach((type) => {
            Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
              extensionAttributes.push({
                type,
                name,
                attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute)
              });
            });
          });
        });
      });
      nodeAndMarkExtensions.forEach((extension) => {
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        const addAttributes = getExtensionField(extension, "addAttributes", context);
        if (!addAttributes) {
          return;
        }
        const attributes = addAttributes();
        Object.entries(attributes).forEach(([name, attribute]) => {
          const mergedAttr = __spreadValues(__spreadValues({}, defaultAttribute), attribute);
          if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
            mergedAttr.default = mergedAttr.default();
          }
          if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
            delete mergedAttr.default;
          }
          extensionAttributes.push({
            type: extension.name,
            name,
            attribute: mergedAttr
          });
        });
      });
      return extensionAttributes;
    }
    function getNodeType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.nodes[nameOrType]) {
          throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.nodes[nameOrType];
      }
      return nameOrType;
    }
    function mergeAttributes(...objects) {
      return objects.filter((item) => !!item).reduce((items, item) => {
        const mergedAttributes = __spreadValues({}, items);
        Object.entries(item).forEach(([key, value]) => {
          const exists = mergedAttributes[key];
          if (!exists) {
            mergedAttributes[key] = value;
            return;
          }
          if (key === "class") {
            const valueClasses = value ? String(value).split(" ") : [];
            const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
            const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
            mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
          } else if (key === "style") {
            const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
            const styleMap = /* @__PURE__ */ new Map();
            existingStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            newStyles.forEach((style2) => {
              const [property, val] = style2.split(":").map((part) => part.trim());
              styleMap.set(property, val);
            });
            mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
          } else {
            mergedAttributes[key] = value;
          }
        });
        return mergedAttributes;
      }, {});
    }
    function getRenderedAttributes(nodeOrMark, extensionAttributes) {
      return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
        if (!item.attribute.renderHTML) {
          return {
            [item.name]: nodeOrMark.attrs[item.name]
          };
        }
        return item.attribute.renderHTML(nodeOrMark.attrs) || {};
      }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function callOrReturn(value, context = void 0, ...props) {
      if (isFunction(value)) {
        if (context) {
          return value.bind(context)(...props);
        }
        return value(...props);
      }
      return value;
    }
    function isEmptyObject(value = {}) {
      return Object.keys(value).length === 0 && value.constructor === Object;
    }
    function fromString(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
        return Number(value);
      }
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
      return value;
    }
    function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
      if ("style" in parseRule) {
        return parseRule;
      }
      return __spreadProps(__spreadValues({}, parseRule), {
        getAttrs: (node) => {
          const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
          if (oldAttributes === false) {
            return false;
          }
          const newAttributes = extensionAttributes.reduce((items, item) => {
            const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
            if (value === null || value === void 0) {
              return items;
            }
            return __spreadProps(__spreadValues({}, items), {
              [item.name]: value
            });
          }, {});
          return __spreadValues(__spreadValues({}, oldAttributes), newAttributes);
        }
      });
    }
    function cleanUpSchemaItem(data) {
      return Object.fromEntries(
        // @ts-ignore
        Object.entries(data).filter(([key, value]) => {
          if (key === "attrs" && isEmptyObject(value)) {
            return false;
          }
          return value !== null && value !== void 0;
        })
      );
    }
    function getSchemaByResolvedExtensions(extensions, editor) {
      var _a;
      const allAttributes = getAttributesFromExtensions(extensions);
      const { nodeExtensions, markExtensions } = splitExtensions(extensions);
      const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
      const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor
        };
        const extraNodeFields = extensions.reduce((fields, e) => {
          const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
          return __spreadValues(__spreadValues({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
        }, {});
        const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraNodeFields), {
          content: callOrReturn(getExtensionField(extension, "content", context)),
          marks: callOrReturn(getExtensionField(extension, "marks", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          inline: callOrReturn(getExtensionField(extension, "inline", context)),
          atom: callOrReturn(getExtensionField(extension, "atom", context)),
          selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
          draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
          linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
          defining: callOrReturn(getExtensionField(extension, "defining", context)),
          isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a2;
            return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
          }))
        }));
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (node) => renderHTML({
            node,
            HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
          });
        }
        const renderText = getExtensionField(extension, "renderText", context);
        if (renderText) {
          schema.toText = renderText;
        }
        return [extension.name, schema];
      }));
      const marks = Object.fromEntries(markExtensions.map((extension) => {
        const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor
        };
        const extraMarkFields = extensions.reduce((fields, e) => {
          const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
          return __spreadValues(__spreadValues({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
        }, {});
        const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraMarkFields), {
          inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
          excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
          group: callOrReturn(getExtensionField(extension, "group", context)),
          spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
          code: callOrReturn(getExtensionField(extension, "code", context)),
          attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
            var _a2;
            return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
          }))
        }));
        const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
        if (parseHTML) {
          schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
        }
        const renderHTML = getExtensionField(extension, "renderHTML", context);
        if (renderHTML) {
          schema.toDOM = (mark) => renderHTML({
            mark,
            HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
          });
        }
        return [extension.name, schema];
      }));
      return new Schema({
        topNode,
        nodes,
        marks
      });
    }
    function getSchemaTypeByName(name, schema) {
      return schema.nodes[name] || schema.marks[name] || null;
    }
    function isExtensionRulesEnabled(extension, enabled) {
      if (Array.isArray(enabled)) {
        return enabled.some((enabledExtension) => {
          const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
          return name === extension.name;
        });
      }
      return enabled;
    }
    function getHTMLFromFragment(fragment, schema) {
      const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
      const temporaryDocument = document.implementation.createHTMLDocument();
      const container = temporaryDocument.createElement("div");
      container.appendChild(documentFragment);
      return container.innerHTML;
    }
    var getTextContentFromNodes = ($from, maxMatch = 500) => {
      let textBefore = "";
      const sliceEndPos = $from.parentOffset;
      $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
        var _a, _b;
        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
          node,
          pos,
          parent,
          index
        })) || node.textContent || "%leaf%";
        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
      });
      return textBefore;
    };
    function isRegExp(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    }
    var InputRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    var inputRuleMatcherHandler = (text, find) => {
      if (isRegExp(find)) {
        return find.exec(text);
      }
      const inputRuleMatch = find(text);
      if (!inputRuleMatch) {
        return null;
      }
      const result = [inputRuleMatch.text];
      result.index = inputRuleMatch.index;
      result.input = text;
      result.data = inputRuleMatch.data;
      if (inputRuleMatch.replaceWith) {
        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
        }
        result.push(inputRuleMatch.replaceWith);
      }
      return result;
    };
    function run$1(config) {
      var _a;
      const { editor, from: from2, to, text, rules, plugin } = config;
      const { view } = editor;
      if (view.composing) {
        return false;
      }
      const $from = view.state.doc.resolve(from2);
      if (
        // check for code node
        $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
      ) {
        return false;
      }
      let matched = false;
      const textBefore = getTextContentFromNodes($from) + text;
      rules.forEach((rule) => {
        if (matched) {
          return;
        }
        const match = inputRuleMatcherHandler(textBefore, rule.find);
        if (!match) {
          return;
        }
        const tr = view.state.tr;
        const state = createChainableState({
          state: view.state,
          transaction: tr
        });
        const range = {
          from: from2 - (match[0].length - text.length),
          to
        };
        const { commands: commands2, chain, can } = new CommandManager({
          editor,
          state
        });
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can
        });
        if (handler === null || !tr.steps.length) {
          return;
        }
        tr.setMeta(plugin, {
          transform: tr,
          from: from2,
          to,
          text
        });
        view.dispatch(tr);
        matched = true;
      });
      return matched;
    }
    function inputRulesPlugin(props) {
      const { editor, rules } = props;
      const plugin = new Plugin({
        state: {
          init() {
            return null;
          },
          apply(tr, prev, state) {
            const stored = tr.getMeta(plugin);
            if (stored) {
              return stored;
            }
            const simulatedInputMeta = tr.getMeta("applyInputRules");
            const isSimulatedInput = !!simulatedInputMeta;
            if (isSimulatedInput) {
              setTimeout(() => {
                let { text } = simulatedInputMeta;
                if (typeof text === "string") {
                  text = text;
                } else {
                  text = getHTMLFromFragment(Fragment.from(text), state.schema);
                }
                const { from: from2 } = simulatedInputMeta;
                const to = from2 + text.length;
                run$1({
                  editor,
                  from: from2,
                  to,
                  text,
                  rules,
                  plugin
                });
              });
            }
            return tr.selectionSet || tr.docChanged ? null : prev;
          }
        },
        props: {
          handleTextInput(view, from2, to, text) {
            return run$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          },
          handleDOMEvents: {
            compositionend: (view) => {
              setTimeout(() => {
                const { $cursor } = view.state.selection;
                if ($cursor) {
                  run$1({
                    editor,
                    from: $cursor.pos,
                    to: $cursor.pos,
                    text: "",
                    rules,
                    plugin
                  });
                }
              });
              return false;
            }
          },
          // add support for input rules to trigger on enter
          // this is useful for example for code blocks
          handleKeyDown(view, event) {
            if (event.key !== "Enter") {
              return false;
            }
            const { $cursor } = view.state.selection;
            if ($cursor) {
              return run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "\n",
                rules,
                plugin
              });
            }
            return false;
          }
        },
        // @ts-ignore
        isInputRules: true
      });
      return plugin;
    }
    function getType(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    function isPlainObject(value) {
      if (getType(value) !== "Object") {
        return false;
      }
      return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
    }
    function mergeDeep(target, source) {
      const output = __spreadValues({}, target);
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (isPlainObject(source[key]) && isPlainObject(target[key])) {
            output[key] = mergeDeep(target[key], source[key]);
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    var Mark2 = class _Mark {
      constructor(config = {}) {
        this.type = "mark";
        this.name = "mark";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = __spreadValues(__spreadValues({}, this.config), config);
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Mark(config);
      }
      configure(options = {}) {
        const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        }));
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Mark(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
      static handleExit({ editor, mark }) {
        const { tr } = editor.state;
        const currentPos = editor.state.selection.$from;
        const isAtEnd = currentPos.pos === currentPos.end();
        if (isAtEnd) {
          const currentMarks = currentPos.marks();
          const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (!isInMark) {
            return false;
          }
          const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
          if (removeMark2) {
            tr.removeStoredMark(removeMark2);
          }
          tr.insertText(" ", currentPos.pos);
          editor.view.dispatch(tr);
          return true;
        }
        return false;
      }
    };
    function isNumber(value) {
      return typeof value === "number";
    }
    var PasteRule = class {
      constructor(config) {
        this.find = config.find;
        this.handler = config.handler;
      }
    };
    var pasteRuleMatcherHandler = (text, find, event) => {
      if (isRegExp(find)) {
        return [...text.matchAll(find)];
      }
      const matches2 = find(text, event);
      if (!matches2) {
        return [];
      }
      return matches2.map((pasteRuleMatch) => {
        const result = [pasteRuleMatch.text];
        result.index = pasteRuleMatch.index;
        result.input = text;
        result.data = pasteRuleMatch.data;
        if (pasteRuleMatch.replaceWith) {
          if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
            console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
          }
          result.push(pasteRuleMatch.replaceWith);
        }
        return result;
      });
    };
    function run(config) {
      const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handlers2 = [];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (!node.isTextblock || node.type.spec.code) {
          return;
        }
        const resolvedFrom = Math.max(from2, pos);
        const resolvedTo = Math.min(to, pos + node.content.size);
        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
        const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
        matches2.forEach((match) => {
          if (match.index === void 0) {
            return;
          }
          const start = resolvedFrom + match.index + 1;
          const end = start + match[0].length;
          const range = {
            from: state.tr.mapping.map(start),
            to: state.tr.mapping.map(end)
          };
          const handler = rule.handler({
            state,
            range,
            match,
            commands: commands2,
            chain,
            can,
            pasteEvent,
            dropEvent
          });
          handlers2.push(handler);
        });
      });
      const success = handlers2.every((handler) => handler !== null);
      return success;
    }
    var tiptapDragFromOtherEditor = null;
    var createClipboardPasteEvent = (text) => {
      var _a;
      const event = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData("text/html", text);
      return event;
    };
    function pasteRulesPlugin(props) {
      const { editor, rules } = props;
      let dragSourceElement = null;
      let isPastedFromProseMirror = false;
      let isDroppedFromProseMirror = false;
      let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      let dropEvent;
      try {
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      } catch (e) {
        dropEvent = null;
      }
      const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
        const tr = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr
        });
        const handler = run({
          editor,
          state: chainableState,
          from: Math.max(from2 - 1, 0),
          to: to.b - 1,
          rule,
          pasteEvent: pasteEvt,
          dropEvent
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        try {
          dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
        } catch (e) {
          dropEvent = null;
        }
        pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
        return tr;
      };
      const plugins = rules.map((rule) => {
        return new Plugin({
          // we register a global drag handler to track the current drag source element
          view(view) {
            const handleDragstart = (event) => {
              var _a;
              dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
              if (dragSourceElement) {
                tiptapDragFromOtherEditor = editor;
              }
            };
            const handleDragend = () => {
              if (tiptapDragFromOtherEditor) {
                tiptapDragFromOtherEditor = null;
              }
            };
            window.addEventListener("dragstart", handleDragstart);
            window.addEventListener("dragend", handleDragend);
            return {
              destroy() {
                window.removeEventListener("dragstart", handleDragstart);
                window.removeEventListener("dragend", handleDragend);
              }
            };
          },
          props: {
            handleDOMEvents: {
              drop: (view, event) => {
                isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
                dropEvent = event;
                if (!isDroppedFromProseMirror) {
                  const dragFromOtherEditor = tiptapDragFromOtherEditor;
                  if (dragFromOtherEditor) {
                    setTimeout(() => {
                      const selection = dragFromOtherEditor.state.selection;
                      if (selection) {
                        dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                      }
                    }, 10);
                  }
                }
                return false;
              },
              paste: (_view, event) => {
                var _a;
                const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
                pasteEvent = event;
                isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
                return false;
              }
            }
          },
          appendTransaction: (transactions, oldState, state) => {
            const transaction = transactions[0];
            const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
            const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
            const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
            const isSimulatedPaste = !!simulatedPasteMeta;
            if (!isPaste && !isDrop && !isSimulatedPaste) {
              return;
            }
            if (isSimulatedPaste) {
              let { text } = simulatedPasteMeta;
              if (typeof text === "string") {
                text = text;
              } else {
                text = getHTMLFromFragment(Fragment.from(text), state.schema);
              }
              const { from: from3 } = simulatedPasteMeta;
              const to2 = from3 + text.length;
              const pasteEvt = createClipboardPasteEvent(text);
              return processEvent({
                rule,
                state,
                from: from3,
                to: { b: to2 },
                pasteEvt
              });
            }
            const from2 = oldState.doc.content.findDiffStart(state.doc.content);
            const to = oldState.doc.content.findDiffEnd(state.doc.content);
            if (!isNumber(from2) || !to || from2 === to.b) {
              return;
            }
            return processEvent({
              rule,
              state,
              from: from2,
              to,
              pasteEvt: pasteEvent
            });
          }
        });
      });
      return plugins;
    }
    function findDuplicates(items) {
      const filtered = items.filter((el, index) => items.indexOf(el) !== index);
      return Array.from(new Set(filtered));
    }
    var ExtensionManager = class _ExtensionManager {
      constructor(extensions, editor) {
        this.splittableMarks = [];
        this.editor = editor;
        this.extensions = _ExtensionManager.resolve(extensions);
        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
        this.setupExtensions();
      }
      /**
       * Returns a flattened and sorted extension list while
       * also checking for duplicated extensions and warns the user.
       * @param extensions An array of Tiptap extensions
       * @returns An flattened and sorted array of Tiptap extensions
       */
      static resolve(extensions) {
        const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
        const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
        if (duplicatedNames.length) {
          console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
        }
        return resolvedExtensions;
      }
      /**
       * Create a flattened array of extensions by traversing the `addExtensions` field.
       * @param extensions An array of Tiptap extensions
       * @returns A flattened array of Tiptap extensions
       */
      static flatten(extensions) {
        return extensions.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage
          };
          const addExtensions = getExtensionField(extension, "addExtensions", context);
          if (addExtensions) {
            return [extension, ...this.flatten(addExtensions())];
          }
          return extension;
        }).flat(10);
      }
      /**
       * Sort extensions by priority.
       * @param extensions An array of Tiptap extensions
       * @returns A sorted array of Tiptap extensions by priority
       */
      static sort(extensions) {
        const defaultPriority = 100;
        return extensions.sort((a, b) => {
          const priorityA = getExtensionField(a, "priority") || defaultPriority;
          const priorityB = getExtensionField(b, "priority") || defaultPriority;
          if (priorityA > priorityB) {
            return -1;
          }
          if (priorityA < priorityB) {
            return 1;
          }
          return 0;
        });
      }
      /**
       * Get all commands from the extensions.
       * @returns An object with all commands where the key is the command name and the value is the command function
       */
      get commands() {
        return this.extensions.reduce((commands2, extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const addCommands = getExtensionField(extension, "addCommands", context);
          if (!addCommands) {
            return commands2;
          }
          return __spreadValues(__spreadValues({}, commands2), addCommands());
        }, {});
      }
      /**
       * Get all registered Prosemirror plugins from the extensions.
       * @returns An array of Prosemirror plugins
       */
      get plugins() {
        const { editor } = this;
        const extensions = _ExtensionManager.sort([...this.extensions].reverse());
        const inputRules = [];
        const pasteRules = [];
        const allPlugins = extensions.map((extension) => {
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          const plugins = [];
          const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
          let defaultBindings = {};
          if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
            defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
          }
          if (addKeyboardShortcuts) {
            const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
              return [shortcut, () => method({ editor })];
            }));
            defaultBindings = __spreadValues(__spreadValues({}, defaultBindings), bindings);
          }
          const keyMapPlugin = keymap(defaultBindings);
          plugins.push(keyMapPlugin);
          const addInputRules = getExtensionField(extension, "addInputRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
            inputRules.push(...addInputRules());
          }
          const addPasteRules = getExtensionField(extension, "addPasteRules", context);
          if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
            pasteRules.push(...addPasteRules());
          }
          const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
          if (addProseMirrorPlugins) {
            const proseMirrorPlugins = addProseMirrorPlugins();
            plugins.push(...proseMirrorPlugins);
          }
          return plugins;
        }).flat();
        return [
          inputRulesPlugin({
            editor,
            rules: inputRules
          }),
          ...pasteRulesPlugin({
            editor,
            rules: pasteRules
          }),
          ...allPlugins
        ];
      }
      /**
       * Get all attributes from the extensions.
       * @returns An array of attributes
       */
      get attributes() {
        return getAttributesFromExtensions(this.extensions);
      }
      /**
       * Get all node views from the extensions.
       * @returns An object with all node views where the key is the node name and the value is the node view function
       */
      get nodeViews() {
        const { editor } = this;
        const { nodeExtensions } = splitExtensions(this.extensions);
        return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
          const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor,
            type: getNodeType(extension.name, this.schema)
          };
          const addNodeView = getExtensionField(extension, "addNodeView", context);
          if (!addNodeView) {
            return [];
          }
          const nodeview = (node, view, getPos, decorations, innerDecorations) => {
            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
            return addNodeView()({
              // pass-through
              node,
              view,
              getPos,
              decorations,
              innerDecorations,
              // tiptap-specific
              editor,
              extension,
              HTMLAttributes
            });
          };
          return [extension.name, nodeview];
        }));
      }
      /**
       * Go through all extensions, create extension storages & setup marks
       * & bind editor event listener.
       */
      setupExtensions() {
        this.extensions.forEach((extension) => {
          var _a;
          this.editor.extensionStorage[extension.name] = extension.storage;
          const context = {
            name: extension.name,
            options: extension.options,
            storage: extension.storage,
            editor: this.editor,
            type: getSchemaTypeByName(extension.name, this.schema)
          };
          if (extension.type === "mark") {
            const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
            if (keepOnSplit) {
              this.splittableMarks.push(extension.name);
            }
          }
          const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
          const onCreate = getExtensionField(extension, "onCreate", context);
          const onUpdate = getExtensionField(extension, "onUpdate", context);
          const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
          const onTransaction = getExtensionField(extension, "onTransaction", context);
          const onFocus = getExtensionField(extension, "onFocus", context);
          const onBlur = getExtensionField(extension, "onBlur", context);
          const onDestroy = getExtensionField(extension, "onDestroy", context);
          if (onBeforeCreate) {
            this.editor.on("beforeCreate", onBeforeCreate);
          }
          if (onCreate) {
            this.editor.on("create", onCreate);
          }
          if (onUpdate) {
            this.editor.on("update", onUpdate);
          }
          if (onSelectionUpdate) {
            this.editor.on("selectionUpdate", onSelectionUpdate);
          }
          if (onTransaction) {
            this.editor.on("transaction", onTransaction);
          }
          if (onFocus) {
            this.editor.on("focus", onFocus);
          }
          if (onBlur) {
            this.editor.on("blur", onBlur);
          }
          if (onDestroy) {
            this.editor.on("destroy", onDestroy);
          }
        });
      }
    };
    var Extension = class _Extension {
      constructor(config = {}) {
        this.type = "extension";
        this.name = "extension";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = __spreadValues(__spreadValues({}, this.config), config);
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Extension(config);
      }
      configure(options = {}) {
        const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        }));
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Extension(__spreadValues(__spreadValues({}, this.config), extendedConfig));
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    };
    function getTextBetween(startNode, range, options) {
      const { from: from2, to } = range;
      const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
      let text = "";
      startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
        var _a;
        if (node.isBlock && pos > from2) {
          text += blockSeparator;
        }
        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
        if (textSerializer) {
          if (parent) {
            text += textSerializer({
              node,
              pos,
              parent,
              index,
              range
            });
          }
          return false;
        }
        if (node.isText) {
          text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
        }
      });
      return text;
    }
    function getTextSerializersFromSchema(schema) {
      return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
    }
    var ClipboardTextSerializer = Extension.create({
      name: "clipboardTextSerializer",
      addOptions() {
        return {
          blockSeparator: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("clipboardTextSerializer"),
            props: {
              clipboardTextSerializer: () => {
                const { editor } = this;
                const { state, schema } = editor;
                const { doc: doc3, selection } = state;
                const { ranges } = selection;
                const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
                const to = Math.max(...ranges.map((range2) => range2.$to.pos));
                const textSerializers = getTextSerializersFromSchema(schema);
                const range = { from: from2, to };
                return getTextBetween(doc3, range, __spreadProps(__spreadValues({}, this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}), {
                  textSerializers
                }));
              }
            }
          })
        ];
      }
    });
    var blur = () => ({ editor, view }) => {
      requestAnimationFrame(() => {
        var _a;
        if (!editor.isDestroyed) {
          view.dom.blur();
          (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
        }
      });
      return true;
    };
    var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
      return commands2.setContent("", emitUpdate);
    };
    var clearNodes = () => ({ state, tr, dispatch }) => {
      const { selection } = tr;
      const { ranges } = selection;
      if (!dispatch) {
        return true;
      }
      ranges.forEach(({ $from, $to }) => {
        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
          if (node.type.isText) {
            return;
          }
          const { doc: doc3, mapping } = tr;
          const $mappedFrom = doc3.resolve(mapping.map(pos));
          const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
          const nodeRange = $mappedFrom.blockRange($mappedTo);
          if (!nodeRange) {
            return;
          }
          const targetLiftDepth = liftTarget(nodeRange);
          if (node.type.isTextblock) {
            const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
            tr.setNodeMarkup(nodeRange.start, defaultType);
          }
          if (targetLiftDepth || targetLiftDepth === 0) {
            tr.lift(nodeRange, targetLiftDepth);
          }
        });
      });
      return true;
    };
    var command = (fn) => (props) => {
      return fn(props);
    };
    var createParagraphNear2 = () => ({ state, dispatch }) => {
      return createParagraphNear(state, dispatch);
    };
    var cut = (originRange, targetPos) => ({ editor, tr }) => {
      const { state } = editor;
      const contentSlice = state.doc.slice(originRange.from, originRange.to);
      tr.deleteRange(originRange.from, originRange.to);
      const newPos = tr.mapping.map(targetPos);
      tr.insert(newPos, contentSlice.content);
      tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
      return true;
    };
    var deleteCurrentNode = () => ({ tr, dispatch }) => {
      const { selection } = tr;
      const currentNode = selection.$anchor.node();
      if (currentNode.content.size > 0) {
        return false;
      }
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === currentNode.type) {
          if (dispatch) {
            const from2 = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from2, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const $pos = tr.selection.$anchor;
      for (let depth = $pos.depth; depth > 0; depth -= 1) {
        const node = $pos.node(depth);
        if (node.type === type) {
          if (dispatch) {
            const from2 = $pos.before(depth);
            const to = $pos.after(depth);
            tr.delete(from2, to).scrollIntoView();
          }
          return true;
        }
      }
      return false;
    };
    var deleteRange2 = (range) => ({ tr, dispatch }) => {
      const { from: from2, to } = range;
      if (dispatch) {
        tr.delete(from2, to);
      }
      return true;
    };
    var deleteSelection2 = () => ({ state, dispatch }) => {
      return deleteSelection(state, dispatch);
    };
    var enter = () => ({ commands: commands2 }) => {
      return commands2.keyboardShortcut("Enter");
    };
    var exitCode2 = () => ({ state, dispatch }) => {
      return exitCode(state, dispatch);
    };
    function objectIncludes(object1, object2, options = { strict: true }) {
      const keys2 = Object.keys(object2);
      if (!keys2.length) {
        return true;
      }
      return keys2.every((key) => {
        if (options.strict) {
          return object2[key] === object1[key];
        }
        if (isRegExp(object2[key])) {
          return object2[key].test(object1[key]);
        }
        return object2[key] === object1[key];
      });
    }
    function findMarkInSet(marks, type, attributes = {}) {
      return marks.find((item) => {
        return item.type === type && objectIncludes(
          // Only check equality for the attributes that are provided
          Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
          attributes
        );
      });
    }
    function isMarkInSet(marks, type, attributes = {}) {
      return !!findMarkInSet(marks, type, attributes);
    }
    function getMarkRange($pos, type, attributes) {
      var _a;
      if (!$pos || !type) {
        return;
      }
      let start = $pos.parent.childAfter($pos.parentOffset);
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
        start = $pos.parent.childBefore($pos.parentOffset);
      }
      if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
        return;
      }
      attributes = attributes || ((_a = start.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);
      const mark = findMarkInSet([...start.node.marks], type, attributes);
      if (!mark) {
        return;
      }
      let startIndex = start.index;
      let startPos = $pos.start() + start.offset;
      let endIndex = startIndex + 1;
      let endPos = startPos + start.node.nodeSize;
      while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
        startIndex -= 1;
        startPos -= $pos.parent.child(startIndex).nodeSize;
      }
      while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
        endPos += $pos.parent.child(endIndex).nodeSize;
        endIndex += 1;
      }
      return {
        from: startPos,
        to: endPos
      };
    }
    function getMarkType(nameOrType, schema) {
      if (typeof nameOrType === "string") {
        if (!schema.marks[nameOrType]) {
          throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
        }
        return schema.marks[nameOrType];
      }
      return nameOrType;
    }
    var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const type = getMarkType(typeOrName, state.schema);
      const { doc: doc3, selection } = tr;
      const { $from, from: from2, to } = selection;
      if (dispatch) {
        const range = getMarkRange($from, type, attributes);
        if (range && range.from <= from2 && range.to >= to) {
          const newSelection = TextSelection.create(doc3, range.from, range.to);
          tr.setSelection(newSelection);
        }
      }
      return true;
    };
    var first = (commands2) => (props) => {
      const items = typeof commands2 === "function" ? commands2(props) : commands2;
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        if (items[i2](props)) {
          return true;
        }
      }
      return false;
    };
    function isTextSelection(value) {
      return value instanceof TextSelection;
    }
    function minMax(value = 0, min = 0, max = 0) {
      return Math.min(Math.max(value, min), max);
    }
    function resolveFocusPosition(doc3, position = null) {
      if (!position) {
        return null;
      }
      const selectionAtStart = Selection.atStart(doc3);
      const selectionAtEnd = Selection.atEnd(doc3);
      if (position === "start" || position === true) {
        return selectionAtStart;
      }
      if (position === "end") {
        return selectionAtEnd;
      }
      const minPos = selectionAtStart.from;
      const maxPos = selectionAtEnd.to;
      if (position === "all") {
        return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
      }
      return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
    }
    function isAndroid() {
      return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
    }
    function isiOS() {
      return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    }
    var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
      options = __spreadValues({
        scrollIntoView: true
      }, options);
      const delayedFocus = () => {
        if (isiOS() || isAndroid()) {
          view.dom.focus();
        }
        requestAnimationFrame(() => {
          if (!editor.isDestroyed) {
            view.focus();
            if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
              editor.commands.scrollIntoView();
            }
          }
        });
      };
      if (view.hasFocus() && position === null || position === false) {
        return true;
      }
      if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
        delayedFocus();
        return true;
      }
      const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
      const isSameSelection = editor.state.selection.eq(selection);
      if (dispatch) {
        if (!isSameSelection) {
          tr.setSelection(selection);
        }
        if (isSameSelection && tr.storedMarks) {
          tr.setStoredMarks(tr.storedMarks);
        }
        delayedFocus();
      }
      return true;
    };
    var forEach = (items, fn) => (props) => {
      return items.every((item, index) => fn(item, __spreadProps(__spreadValues({}, props), { index })));
    };
    var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
      return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
    };
    var removeWhitespaces = (node) => {
      const children = node.childNodes;
      for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
        const child = children[i2];
        if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
          node.removeChild(child);
        } else if (child.nodeType === 1) {
          removeWhitespaces(child);
        }
      }
      return node;
    };
    function elementFromString(value) {
      const wrappedValue = `<body>${value}</body>`;
      const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
      return removeWhitespaces(html);
    }
    function createNodeFromContent(content, schema, options) {
      if (content instanceof Node || content instanceof Fragment) {
        return content;
      }
      options = __spreadValues({
        slice: true,
        parseOptions: {}
      }, options);
      const isJSONContent = typeof content === "object" && content !== null;
      const isTextContent = typeof content === "string";
      if (isJSONContent) {
        try {
          const isArrayContent = Array.isArray(content) && content.length > 0;
          if (isArrayContent) {
            return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
          }
          const node = schema.nodeFromJSON(content);
          if (options.errorOnInvalidContent) {
            node.check();
          }
          return node;
        } catch (error) {
          if (options.errorOnInvalidContent) {
            throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
          }
          console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
          return createNodeFromContent("", schema, options);
        }
      }
      if (isTextContent) {
        if (options.errorOnInvalidContent) {
          let hasInvalidContent = false;
          let invalidContent = "";
          const contentCheckSchema = new Schema({
            topNode: schema.spec.topNode,
            marks: schema.spec.marks,
            // Prosemirror's schemas are executed such that: the last to execute, matches last
            // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
            nodes: schema.spec.nodes.append({
              __tiptap__private__unknown__catch__all__node: {
                content: "inline*",
                group: "block",
                parseDOM: [
                  {
                    tag: "*",
                    getAttrs: (e) => {
                      hasInvalidContent = true;
                      invalidContent = typeof e === "string" ? e : e.outerHTML;
                      return null;
                    }
                  }
                ]
              }
            })
          });
          if (options.slice) {
            DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
          } else {
            DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
          }
          if (options.errorOnInvalidContent && hasInvalidContent) {
            throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
          }
        }
        const parser = DOMParser.fromSchema(schema);
        if (options.slice) {
          return parser.parseSlice(elementFromString(content), options.parseOptions).content;
        }
        return parser.parse(elementFromString(content), options.parseOptions);
      }
      return createNodeFromContent("", schema, options);
    }
    function selectionToInsertionEnd2(tr, startLen, bias) {
      const last = tr.steps.length - 1;
      if (last < startLen) {
        return;
      }
      const step = tr.steps[last];
      if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
        return;
      }
      const map2 = tr.mapping.maps[last];
      let end = 0;
      map2.forEach((_from, _to, _newFrom, newTo) => {
        if (end === 0) {
          end = newTo;
        }
      });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }
    var isFragment = (nodeOrFragment) => {
      return !("type" in nodeOrFragment);
    };
    var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
      var _a;
      if (dispatch) {
        options = __spreadValues({
          parseOptions: editor.options.parseOptions,
          updateSelection: true,
          applyInputRules: false,
          applyPasteRules: false
        }, options);
        let content;
        try {
          content = createNodeFromContent(value, editor.schema, {
            parseOptions: __spreadValues({
              preserveWhitespace: "full"
            }, options.parseOptions),
            errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
          });
        } catch (e) {
          editor.emit("contentError", {
            editor,
            error: e,
            disableCollaboration: () => {
              if (editor.storage.collaboration) {
                editor.storage.collaboration.isDisabled = true;
              }
            }
          });
          return false;
        }
        let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
        let isOnlyTextContent = true;
        let isOnlyBlockContent = true;
        const nodes = isFragment(content) ? content : [content];
        nodes.forEach((node) => {
          node.check();
          isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
          isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
        });
        if (from2 === to && isOnlyBlockContent) {
          const { parent } = tr.doc.resolve(from2);
          const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
          if (isEmptyTextBlock) {
            from2 -= 1;
            to += 1;
          }
        }
        let newContent;
        if (isOnlyTextContent) {
          if (Array.isArray(value)) {
            newContent = value.map((v) => v.text || "").join("");
          } else if (value instanceof Fragment) {
            let text = "";
            value.forEach((node) => {
              if (node.text) {
                text += node.text;
              }
            });
            newContent = text;
          } else if (typeof value === "object" && !!value && !!value.text) {
            newContent = value.text;
          } else {
            newContent = value;
          }
          tr.insertText(newContent, from2, to);
        } else {
          newContent = content;
          tr.replaceWith(from2, to, newContent);
        }
        if (options.updateSelection) {
          selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
        }
        if (options.applyInputRules) {
          tr.setMeta("applyInputRules", { from: from2, text: newContent });
        }
        if (options.applyPasteRules) {
          tr.setMeta("applyPasteRules", { from: from2, text: newContent });
        }
      }
      return true;
    };
    var joinUp2 = () => ({ state, dispatch }) => {
      return joinUp(state, dispatch);
    };
    var joinDown2 = () => ({ state, dispatch }) => {
      return joinDown(state, dispatch);
    };
    var joinBackward2 = () => ({ state, dispatch }) => {
      return joinBackward(state, dispatch);
    };
    var joinForward2 = () => ({ state, dispatch }) => {
      return joinForward(state, dispatch);
    };
    var joinItemBackward = () => ({ state, dispatch, tr }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, -1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
    var joinItemForward = () => ({ state, dispatch, tr }) => {
      try {
        const point = joinPoint(state.doc, state.selection.$from.pos, 1);
        if (point === null || point === void 0) {
          return false;
        }
        tr.join(point, 2);
        if (dispatch) {
          dispatch(tr);
        }
        return true;
      } catch (e) {
        return false;
      }
    };
    var joinTextblockBackward2 = () => ({ state, dispatch }) => {
      return joinTextblockBackward(state, dispatch);
    };
    var joinTextblockForward2 = () => ({ state, dispatch }) => {
      return joinTextblockForward(state, dispatch);
    };
    function isMacOS() {
      return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
    }
    function normalizeKeyName2(name) {
      const parts = name.split(/-(?!$)/);
      let result = parts[parts.length - 1];
      if (result === "Space") {
        result = " ";
      }
      let alt;
      let ctrl;
      let shift2;
      let meta;
      for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
        const mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          meta = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift2 = true;
        } else if (/^mod$/i.test(mod)) {
          if (isiOS() || isMacOS()) {
            meta = true;
          } else {
            ctrl = true;
          }
        } else {
          throw new Error(`Unrecognized modifier name: ${mod}`);
        }
      }
      if (alt) {
        result = `Alt-${result}`;
      }
      if (ctrl) {
        result = `Ctrl-${result}`;
      }
      if (meta) {
        result = `Meta-${result}`;
      }
      if (shift2) {
        result = `Shift-${result}`;
      }
      return result;
    }
    var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
      const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
      const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
      const event = new KeyboardEvent("keydown", {
        key: key === "Space" ? " " : key,
        altKey: keys2.includes("Alt"),
        ctrlKey: keys2.includes("Ctrl"),
        metaKey: keys2.includes("Meta"),
        shiftKey: keys2.includes("Shift"),
        bubbles: true,
        cancelable: true
      });
      const capturedTransaction = editor.captureTransaction(() => {
        view.someProp("handleKeyDown", (f) => f(view, event));
      });
      capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
        const newStep = step.map(tr.mapping);
        if (newStep && dispatch) {
          tr.maybeStep(newStep);
        }
      });
      return true;
    };
    function isNodeActive(state, typeOrName, attributes = {}) {
      const { from: from2, to, empty: empty2 } = state.selection;
      const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
      const nodeRanges = [];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (node.isText) {
          return;
        }
        const relativeFrom = Math.max(from2, pos);
        const relativeTo = Math.min(to, pos + node.nodeSize);
        nodeRanges.push({
          node,
          from: relativeFrom,
          to: relativeTo
        });
      });
      const selectionRange = to - from2;
      const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
        if (!type) {
          return true;
        }
        return type.name === nodeRange.node.type.name;
      }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
      if (empty2) {
        return !!matchedNodeRanges.length;
      }
      const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
      return range >= selectionRange;
    }
    var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (!isActive2) {
        return false;
      }
      return lift2(state, dispatch);
    };
    var liftEmptyBlock2 = () => ({ state, dispatch }) => {
      return liftEmptyBlock(state, dispatch);
    };
    var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return liftListItem(type)(state, dispatch);
    };
    var newlineInCode2 = () => ({ state, dispatch }) => {
      return newlineInCode(state, dispatch);
    };
    function getSchemaTypeNameByName(name, schema) {
      if (schema.nodes[name]) {
        return "node";
      }
      if (schema.marks[name]) {
        return "mark";
      }
      return null;
    }
    function deleteProps(obj, propOrProps) {
      const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
      return Object.keys(obj).reduce((newObj, prop) => {
        if (!props.includes(prop)) {
          newObj[prop] = obj[prop];
        }
        return newObj;
      }, {});
    }
    var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
                }
              });
            }
          });
        });
      }
      return true;
    };
    var scrollIntoView = () => ({ tr, dispatch }) => {
      if (dispatch) {
        tr.scrollIntoView();
      }
      return true;
    };
    var selectAll2 = () => ({ tr, dispatch }) => {
      if (dispatch) {
        const selection = new AllSelection(tr.doc);
        tr.setSelection(selection);
      }
      return true;
    };
    var selectNodeBackward2 = () => ({ state, dispatch }) => {
      return selectNodeBackward(state, dispatch);
    };
    var selectNodeForward2 = () => ({ state, dispatch }) => {
      return selectNodeForward(state, dispatch);
    };
    var selectParentNode2 = () => ({ state, dispatch }) => {
      return selectParentNode(state, dispatch);
    };
    var selectTextblockEnd2 = () => ({ state, dispatch }) => {
      return selectTextblockEnd(state, dispatch);
    };
    var selectTextblockStart2 = () => ({ state, dispatch }) => {
      return selectTextblockStart(state, dispatch);
    };
    function createDocument(content, schema, parseOptions = {}, options = {}) {
      return createNodeFromContent(content, schema, {
        slice: false,
        parseOptions,
        errorOnInvalidContent: options.errorOnInvalidContent
      });
    }
    var setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch, commands: commands2 }) => {
      var _a, _b;
      const { doc: doc3 } = tr;
      if (parseOptions.preserveWhitespace !== "full") {
        const document2 = createDocument(content, editor.schema, parseOptions, {
          errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck
        });
        if (dispatch) {
          tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
        }
        return true;
      }
      if (dispatch) {
        tr.setMeta("preventUpdate", !emitUpdate);
      }
      return commands2.insertContentAt({ from: 0, to: doc3.content.size }, content, {
        parseOptions,
        errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
      });
    };
    function getMarkAttributes(state, typeOrName) {
      const type = getMarkType(typeOrName, state.schema);
      const { from: from2, to, empty: empty2 } = state.selection;
      const marks = [];
      if (empty2) {
        if (state.storedMarks) {
          marks.push(...state.storedMarks);
        }
        marks.push(...state.selection.$head.marks());
      } else {
        state.doc.nodesBetween(from2, to, (node) => {
          marks.push(...node.marks);
        });
      }
      const mark = marks.find((markItem) => markItem.type.name === type.name);
      if (!mark) {
        return {};
      }
      return __spreadValues({}, mark.attrs);
    }
    function defaultBlockAt2(match) {
      for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
        const { type } = match.edge(i2);
        if (type.isTextblock && !type.hasRequiredAttrs()) {
          return type;
        }
      }
      return null;
    }
    function findParentNodeClosestToPos($pos, predicate) {
      for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
        const node = $pos.node(i2);
        if (predicate(node)) {
          return {
            pos: i2 > 0 ? $pos.before(i2) : 0,
            start: $pos.start(i2),
            depth: i2,
            node
          };
        }
      }
    }
    function findParentNode(predicate) {
      return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
    }
    function getText2(node, options) {
      const range = {
        from: 0,
        to: node.content.size
      };
      return getTextBetween(node, range, options);
    }
    function getNodeAttributes(state, typeOrName) {
      const type = getNodeType(typeOrName, state.schema);
      const { from: from2, to } = state.selection;
      const nodes = [];
      state.doc.nodesBetween(from2, to, (node2) => {
        nodes.push(node2);
      });
      const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
      if (!node) {
        return {};
      }
      return __spreadValues({}, node.attrs);
    }
    function getAttributes(state, typeOrName) {
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (schemaType === "node") {
        return getNodeAttributes(state, typeOrName);
      }
      if (schemaType === "mark") {
        return getMarkAttributes(state, typeOrName);
      }
      return {};
    }
    function getMarksBetween(from2, to, doc3) {
      const marks = [];
      if (from2 === to) {
        doc3.resolve(from2).marks().forEach((mark) => {
          const $pos = doc3.resolve(from2);
          const range = getMarkRange($pos, mark.type);
          if (!range) {
            return;
          }
          marks.push(__spreadValues({
            mark
          }, range));
        });
      } else {
        doc3.nodesBetween(from2, to, (node, pos) => {
          if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
            return;
          }
          marks.push(...node.marks.map((mark) => ({
            from: pos,
            to: pos + node.nodeSize,
            mark
          })));
        });
      }
      return marks;
    }
    function getSplittedAttributes(extensionAttributes, typeName, attributes) {
      return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
        const extensionAttribute = extensionAttributes.find((item) => {
          return item.type === typeName && item.name === name;
        });
        if (!extensionAttribute) {
          return false;
        }
        return extensionAttribute.attribute.keepOnSplit;
      }));
    }
    function isMarkActive(state, typeOrName, attributes = {}) {
      const { empty: empty2, ranges } = state.selection;
      const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
      if (empty2) {
        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
          if (!type) {
            return true;
          }
          return type.name === mark.type.name;
        }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
      }
      let selectionRange = 0;
      const markRanges = [];
      ranges.forEach(({ $from, $to }) => {
        const from2 = $from.pos;
        const to = $to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (!node.isText && !node.marks.length) {
            return;
          }
          const relativeFrom = Math.max(from2, pos);
          const relativeTo = Math.min(to, pos + node.nodeSize);
          const range2 = relativeTo - relativeFrom;
          selectionRange += range2;
          markRanges.push(...node.marks.map((mark) => ({
            mark,
            from: relativeFrom,
            to: relativeTo
          })));
        });
      });
      if (selectionRange === 0) {
        return false;
      }
      const matchedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return type.name === markRange.mark.type.name;
      }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const excludedRange = markRanges.filter((markRange) => {
        if (!type) {
          return true;
        }
        return markRange.mark.type !== type && markRange.mark.type.excludes(type);
      }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
      const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
      return range >= selectionRange;
    }
    function isActive(state, name, attributes = {}) {
      if (!name) {
        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
      }
      const schemaType = getSchemaTypeNameByName(name, state.schema);
      if (schemaType === "node") {
        return isNodeActive(state, name, attributes);
      }
      if (schemaType === "mark") {
        return isMarkActive(state, name, attributes);
      }
      return false;
    }
    function isList(name, extensions) {
      const { nodeExtensions } = splitExtensions(extensions);
      const extension = nodeExtensions.find((item) => item.name === name);
      if (!extension) {
        return false;
      }
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const group = callOrReturn(getExtensionField(extension, "group", context));
      if (typeof group !== "string") {
        return false;
      }
      return group.split(" ").includes("list");
    }
    function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
      var _a;
      if (ignoreWhitespace) {
        if (node.type.name === "hardBreak") {
          return true;
        }
        if (node.isText) {
          return /^\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : "");
        }
      }
      if (node.isText) {
        return !node.text;
      }
      if (node.isAtom || node.isLeaf) {
        return false;
      }
      if (node.content.childCount === 0) {
        return true;
      }
      if (checkChildren) {
        let isContentEmpty = true;
        node.content.forEach((childNode) => {
          if (isContentEmpty === false) {
            return;
          }
          if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
            isContentEmpty = false;
          }
        });
        return isContentEmpty;
      }
      return false;
    }
    function isNodeSelection(value) {
      return value instanceof NodeSelection;
    }
    function canSetMark(state, tr, newMarkType) {
      var _a;
      const { selection } = tr;
      let cursor = null;
      if (isTextSelection(selection)) {
        cursor = selection.$cursor;
      }
      if (cursor) {
        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
        return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
      }
      const { ranges } = selection;
      return ranges.some(({ $from, $to }) => {
        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
          if (someNodeSupportsMark) {
            return false;
          }
          if (node.isInline) {
            const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
            const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
            someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
          }
          return !someNodeSupportsMark;
        });
        return someNodeSupportsMark;
      });
    }
    var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      const { selection } = tr;
      const { empty: empty2, ranges } = selection;
      const type = getMarkType(typeOrName, state.schema);
      if (dispatch) {
        if (empty2) {
          const oldAttributes = getMarkAttributes(state, type);
          tr.addStoredMark(type.create(__spreadValues(__spreadValues({}, oldAttributes), attributes)));
        } else {
          ranges.forEach((range) => {
            const from2 = range.$from.pos;
            const to = range.$to.pos;
            state.doc.nodesBetween(from2, to, (node, pos) => {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const someHasMark = node.marks.find((mark) => mark.type === type);
              if (someHasMark) {
                node.marks.forEach((mark) => {
                  if (type === mark.type) {
                    tr.addMark(trimmedFrom, trimmedTo, type.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
                  }
                });
              } else {
                tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
              }
            });
          });
        }
      }
      return canSetMark(state, tr, type);
    };
    var setMeta = (key, value) => ({ tr }) => {
      tr.setMeta(key, value);
      return true;
    };
    var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
      const type = getNodeType(typeOrName, state.schema);
      let attributesToCopy;
      if (state.selection.$anchor.sameParent(state.selection.$head)) {
        attributesToCopy = state.selection.$anchor.parent.attrs;
      }
      if (!type.isTextblock) {
        console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
        return false;
      }
      return chain().command(({ commands: commands2 }) => {
        const canSetBlock = setBlockType2(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes))(state);
        if (canSetBlock) {
          return true;
        }
        return commands2.clearNodes();
      }).command(({ state: updatedState }) => {
        return setBlockType2(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes))(updatedState, dispatch);
      }).run();
    };
    var setNodeSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc: doc3 } = tr;
        const from2 = minMax(position, 0, doc3.content.size);
        const selection = NodeSelection.create(doc3, from2);
        tr.setSelection(selection);
      }
      return true;
    };
    var setTextSelection = (position) => ({ tr, dispatch }) => {
      if (dispatch) {
        const { doc: doc3 } = tr;
        const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
        const minPos = TextSelection.atStart(doc3).from;
        const maxPos = TextSelection.atEnd(doc3).to;
        const resolvedFrom = minMax(from2, minPos, maxPos);
        const resolvedEnd = minMax(to, minPos, maxPos);
        const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
        tr.setSelection(selection);
      }
      return true;
    };
    var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return sinkListItem(type)(state, dispatch);
    };
    function ensureMarks(state, splittableMarks) {
      const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
      if (marks) {
        const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
        state.tr.ensureMarks(filteredMarks);
      }
    }
    var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
      const { selection, doc: doc3 } = tr;
      const { $from, $to } = selection;
      const extensionAttributes = editor.extensionManager.attributes;
      const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      if (selection instanceof NodeSelection && selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
          return false;
        }
        if (dispatch) {
          if (keepMarks) {
            ensureMarks(state, editor.extensionManager.splittableMarks);
          }
          tr.split($from.pos).scrollIntoView();
        }
        return true;
      }
      if (!$from.parent.isBlock) {
        return false;
      }
      const atEnd = $to.parentOffset === $to.parent.content.size;
      const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      let types = atEnd && deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
      let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
        can = true;
        types = deflt ? [
          {
            type: deflt,
            attrs: newAttributes
          }
        ] : void 0;
      }
      if (dispatch) {
        if (can) {
          if (selection instanceof TextSelection) {
            tr.deleteSelection();
          }
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
            const first2 = tr.mapping.map($from.before());
            const $first = tr.doc.resolve(first2);
            if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
        }
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.scrollIntoView();
      }
      return can;
    };
    var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {
      var _a;
      const type = getNodeType(typeOrName, state.schema);
      const { $from, $to } = state.selection;
      const node = state.selection.node;
      if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
        return false;
      }
      const grandParent = $from.node(-1);
      if (grandParent.type !== type) {
        return false;
      }
      const extensionAttributes = editor.extensionManager.attributes;
      if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
        if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
          return false;
        }
        if (dispatch) {
          let wrap2 = Fragment.empty;
          const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
            wrap2 = Fragment.from($from.node(d).copy(wrap2));
          }
          const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          const newNextTypeAttributes2 = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
          const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
          wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
          const start = $from.before($from.depth - (depthBefore - 1));
          tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
          let sel = -1;
          tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
            if (sel > -1) {
              return false;
            }
            if (n.isTextblock && n.content.size === 0) {
              sel = pos + 1;
            }
          });
          if (sel > -1) {
            tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
          }
          tr.scrollIntoView();
        }
        return true;
      }
      const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      const newTypeAttributes = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs)), overrideAttrs);
      const newNextTypeAttributes = __spreadValues(__spreadValues({}, getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)), overrideAttrs);
      tr.delete($from.pos, $to.pos);
      const types = nextType ? [
        { type, attrs: newTypeAttributes },
        { type: nextType, attrs: newNextTypeAttributes }
      ] : [{ type, attrs: newTypeAttributes }];
      if (!canSplit(tr.doc, $from.pos, 2)) {
        return false;
      }
      if (dispatch) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        tr.split($from.pos, 2, types).scrollIntoView();
        if (!marks || !dispatch) {
          return true;
        }
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr.ensureMarks(filteredMarks);
      }
      return true;
    };
    var joinListBackwards = (tr, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr.selection);
      if (!list) {
        return true;
      }
      const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
      if (before === void 0) {
        return true;
      }
      const nodeBefore = tr.doc.nodeAt(before);
      const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
      if (!canJoinBackwards) {
        return true;
      }
      tr.join(list.pos);
      return true;
    };
    var joinListForwards = (tr, listType) => {
      const list = findParentNode((node) => node.type === listType)(tr.selection);
      if (!list) {
        return true;
      }
      const after = tr.doc.resolve(list.start).after(list.depth);
      if (after === void 0) {
        return true;
      }
      const nodeAfter = tr.doc.nodeAt(after);
      const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
      if (!canJoinForwards) {
        return true;
      }
      tr.join(after);
      return true;
    };
    var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
      const { extensions, splittableMarks } = editor.extensionManager;
      const listType = getNodeType(listTypeOrName, state.schema);
      const itemType = getNodeType(itemTypeOrName, state.schema);
      const { selection, storedMarks } = state;
      const { $from, $to } = selection;
      const range = $from.blockRange($to);
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      if (!range) {
        return false;
      }
      const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
      if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
        if (parentList.node.type === listType) {
          return commands2.liftListItem(itemType);
        }
        if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
          return chain().command(() => {
            tr.setNodeMarkup(parentList.pos, listType);
            return true;
          }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
        }
      }
      if (!keepMarks || !marks || !dispatch) {
        return chain().command(() => {
          const canWrapInList = can().wrapInList(listType, attributes);
          if (canWrapInList) {
            return true;
          }
          return commands2.clearNodes();
        }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
      }
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
        tr.ensureMarks(filteredMarks);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    };
    var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
      const { extendEmptyMarkRange = false } = options;
      const type = getMarkType(typeOrName, state.schema);
      const isActive2 = isMarkActive(state, type, attributes);
      if (isActive2) {
        return commands2.unsetMark(type, { extendEmptyMarkRange });
      }
      return commands2.setMark(type, attributes);
    };
    var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const toggleType = getNodeType(toggleTypeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      let attributesToCopy;
      if (state.selection.$anchor.sameParent(state.selection.$head)) {
        attributesToCopy = state.selection.$anchor.parent.attrs;
      }
      if (isActive2) {
        return commands2.setNode(toggleType, attributesToCopy);
      }
      return commands2.setNode(type, __spreadValues(__spreadValues({}, attributesToCopy), attributes));
    };
    var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
      const type = getNodeType(typeOrName, state.schema);
      const isActive2 = isNodeActive(state, type, attributes);
      if (isActive2) {
        return commands2.lift(type);
      }
      return commands2.wrapIn(type, attributes);
    };
    var undoInputRule = () => ({ state, dispatch }) => {
      const plugins = state.plugins;
      for (let i2 = 0; i2 < plugins.length; i2 += 1) {
        const plugin = plugins[i2];
        let undoable;
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            const tr = state.tr;
            const toUndo = undoable.transform;
            for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
              tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
            }
            if (undoable.text) {
              const marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr.delete(undoable.from, undoable.to);
            }
          }
          return true;
        }
      }
      return false;
    };
    var unsetAllMarks = () => ({ tr, dispatch }) => {
      const { selection } = tr;
      const { empty: empty2, ranges } = selection;
      if (empty2) {
        return true;
      }
      if (dispatch) {
        ranges.forEach((range) => {
          tr.removeMark(range.$from.pos, range.$to.pos);
        });
      }
      return true;
    };
    var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
      var _a;
      const { extendEmptyMarkRange = false } = options;
      const { selection } = tr;
      const type = getMarkType(typeOrName, state.schema);
      const { $from, empty: empty2, ranges } = selection;
      if (!dispatch) {
        return true;
      }
      if (empty2 && extendEmptyMarkRange) {
        let { from: from2, to } = selection;
        const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
        const range = getMarkRange($from, type, attrs);
        if (range) {
          from2 = range.from;
          to = range.to;
        }
        tr.removeMark(from2, to, type);
      } else {
        ranges.forEach((range) => {
          tr.removeMark(range.$from.pos, range.$to.pos, type);
        });
      }
      tr.removeStoredMark(type);
      return true;
    };
    var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
      let nodeType = null;
      let markType = null;
      const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
      if (!schemaType) {
        return false;
      }
      if (schemaType === "node") {
        nodeType = getNodeType(typeOrName, state.schema);
      }
      if (schemaType === "mark") {
        markType = getMarkType(typeOrName, state.schema);
      }
      if (dispatch) {
        tr.selection.ranges.forEach((range) => {
          const from2 = range.$from.pos;
          const to = range.$to.pos;
          let lastPos;
          let lastNode;
          let trimmedFrom;
          let trimmedTo;
          if (tr.selection.empty) {
            state.doc.nodesBetween(from2, to, (node, pos) => {
              if (nodeType && nodeType === node.type) {
                trimmedFrom = Math.max(pos, from2);
                trimmedTo = Math.min(pos + node.nodeSize, to);
                lastPos = pos;
                lastNode = node;
              }
            });
          } else {
            state.doc.nodesBetween(from2, to, (node, pos) => {
              if (pos < from2 && nodeType && nodeType === node.type) {
                trimmedFrom = Math.max(pos, from2);
                trimmedTo = Math.min(pos + node.nodeSize, to);
                lastPos = pos;
                lastNode = node;
              }
              if (pos >= from2 && pos <= to) {
                if (nodeType && nodeType === node.type) {
                  tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, node.attrs), attributes));
                }
                if (markType && node.marks.length) {
                  node.marks.forEach((mark) => {
                    if (markType === mark.type) {
                      const trimmedFrom2 = Math.max(pos, from2);
                      const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                      tr.addMark(trimmedFrom2, trimmedTo2, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
                    }
                  });
                }
              }
            });
          }
          if (lastNode) {
            if (lastPos !== void 0) {
              tr.setNodeMarkup(lastPos, void 0, __spreadValues(__spreadValues({}, lastNode.attrs), attributes));
            }
            if (markType && lastNode.marks.length) {
              lastNode.marks.forEach((mark) => {
                if (markType === mark.type) {
                  tr.addMark(trimmedFrom, trimmedTo, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));
                }
              });
            }
          }
        });
      }
      return true;
    };
    var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapIn(type, attributes)(state, dispatch);
    };
    var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
      const type = getNodeType(typeOrName, state.schema);
      return wrapInList(type, attributes)(state, dispatch);
    };
    var commands = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      blur,
      clearContent,
      clearNodes,
      command,
      createParagraphNear: createParagraphNear2,
      cut,
      deleteCurrentNode,
      deleteNode,
      deleteRange: deleteRange2,
      deleteSelection: deleteSelection2,
      enter,
      exitCode: exitCode2,
      extendMarkRange,
      first,
      focus,
      forEach,
      insertContent,
      insertContentAt,
      joinBackward: joinBackward2,
      joinDown: joinDown2,
      joinForward: joinForward2,
      joinItemBackward,
      joinItemForward,
      joinTextblockBackward: joinTextblockBackward2,
      joinTextblockForward: joinTextblockForward2,
      joinUp: joinUp2,
      keyboardShortcut,
      lift: lift3,
      liftEmptyBlock: liftEmptyBlock2,
      liftListItem: liftListItem2,
      newlineInCode: newlineInCode2,
      resetAttributes,
      scrollIntoView,
      selectAll: selectAll2,
      selectNodeBackward: selectNodeBackward2,
      selectNodeForward: selectNodeForward2,
      selectParentNode: selectParentNode2,
      selectTextblockEnd: selectTextblockEnd2,
      selectTextblockStart: selectTextblockStart2,
      setContent,
      setMark,
      setMeta,
      setNode,
      setNodeSelection,
      setTextSelection,
      sinkListItem: sinkListItem2,
      splitBlock: splitBlock2,
      splitListItem,
      toggleList,
      toggleMark,
      toggleNode,
      toggleWrap,
      undoInputRule,
      unsetAllMarks,
      unsetMark,
      updateAttributes,
      wrapIn: wrapIn2,
      wrapInList: wrapInList2
    });
    var Commands = Extension.create({
      name: "commands",
      addCommands() {
        return __spreadValues({}, commands);
      }
    });
    var Drop = Extension.create({
      name: "drop",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tiptapDrop"),
            props: {
              handleDrop: (_, e, slice2, moved) => {
                this.editor.emit("drop", {
                  editor: this.editor,
                  event: e,
                  slice: slice2,
                  moved
                });
              }
            }
          })
        ];
      }
    });
    var Editable = Extension.create({
      name: "editable",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("editable"),
            props: {
              editable: () => this.editor.options.editable
            }
          })
        ];
      }
    });
    var focusEventsPluginKey = new PluginKey("focusEvents");
    var FocusEvents = Extension.create({
      name: "focusEvents",
      addProseMirrorPlugins() {
        const { editor } = this;
        return [
          new Plugin({
            key: focusEventsPluginKey,
            props: {
              handleDOMEvents: {
                focus: (view, event) => {
                  editor.isFocused = true;
                  const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                },
                blur: (view, event) => {
                  editor.isFocused = false;
                  const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                  view.dispatch(transaction);
                  return false;
                }
              }
            }
          })
        ];
      }
    });
    var Keymap = Extension.create({
      name: "keymap",
      addKeyboardShortcuts() {
        const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.undoInputRule(),
          // maybe convert first text block node to default node
          () => commands2.command(({ tr }) => {
            const { selection, doc: doc3 } = tr;
            const { empty: empty2, $anchor } = selection;
            const { pos, parent } = $anchor;
            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
            const parentIsIsolating = $parentPos.parent.type.spec.isolating;
            const parentPos = $anchor.pos - $anchor.parentOffset;
            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
            if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
              return false;
            }
            return commands2.clearNodes();
          }),
          () => commands2.deleteSelection(),
          () => commands2.joinBackward(),
          () => commands2.selectNodeBackward()
        ]);
        const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.deleteSelection(),
          () => commands2.deleteCurrentNode(),
          () => commands2.joinForward(),
          () => commands2.selectNodeForward()
        ]);
        const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.newlineInCode(),
          () => commands2.createParagraphNear(),
          () => commands2.liftEmptyBlock(),
          () => commands2.splitBlock()
        ]);
        const baseKeymap = {
          Enter: handleEnter,
          "Mod-Enter": () => this.editor.commands.exitCode(),
          Backspace: handleBackspace,
          "Mod-Backspace": handleBackspace,
          "Shift-Backspace": handleBackspace,
          Delete: handleDelete,
          "Mod-Delete": handleDelete,
          "Mod-a": () => this.editor.commands.selectAll()
        };
        const pcKeymap = __spreadValues({}, baseKeymap);
        const macKeymap = __spreadProps(__spreadValues({}, baseKeymap), {
          "Ctrl-h": handleBackspace,
          "Alt-Backspace": handleBackspace,
          "Ctrl-d": handleDelete,
          "Ctrl-Alt-Backspace": handleDelete,
          "Alt-Delete": handleDelete,
          "Alt-d": handleDelete,
          "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
          "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        });
        if (isiOS() || isMacOS()) {
          return macKeymap;
        }
        return pcKeymap;
      },
      addProseMirrorPlugins() {
        return [
          // With this plugin we check if the whole document was selected and deleted.
          // In this case we will additionally call `clearNodes()` to convert e.g. a heading
          // to a paragraph if necessary.
          // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
          // with many other commands.
          new Plugin({
            key: new PluginKey("clearDocument"),
            appendTransaction: (transactions, oldState, newState) => {
              if (transactions.some((tr2) => tr2.getMeta("composition"))) {
                return;
              }
              const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
              const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
              if (!docChanges || ignoreTr) {
                return;
              }
              const { empty: empty2, from: from2, to } = oldState.selection;
              const allFrom = Selection.atStart(oldState.doc).from;
              const allEnd = Selection.atEnd(oldState.doc).to;
              const allWasSelected = from2 === allFrom && to === allEnd;
              if (empty2 || !allWasSelected) {
                return;
              }
              const isEmpty = isNodeEmpty(newState.doc);
              if (!isEmpty) {
                return;
              }
              const tr = newState.tr;
              const state = createChainableState({
                state: newState,
                transaction: tr
              });
              const { commands: commands2 } = new CommandManager({
                editor: this.editor,
                state
              });
              commands2.clearNodes();
              if (!tr.steps.length) {
                return;
              }
              return tr;
            }
          })
        ];
      }
    });
    var Paste = Extension.create({
      name: "paste",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tiptapPaste"),
            props: {
              handlePaste: (_view, e, slice2) => {
                this.editor.emit("paste", {
                  editor: this.editor,
                  event: e,
                  slice: slice2
                });
              }
            }
          })
        ];
      }
    });
    var Tabindex = Extension.create({
      name: "tabindex",
      addProseMirrorPlugins() {
        return [
          new Plugin({
            key: new PluginKey("tabindex"),
            props: {
              attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
            }
          })
        ];
      }
    });
    var NodePos = class _NodePos {
      get name() {
        return this.node.type.name;
      }
      constructor(pos, editor, isBlock = false, node = null) {
        this.currentNode = null;
        this.actualDepth = null;
        this.isBlock = isBlock;
        this.resolvedPos = pos;
        this.editor = editor;
        this.currentNode = node;
      }
      get node() {
        return this.currentNode || this.resolvedPos.node();
      }
      get element() {
        return this.editor.view.domAtPos(this.pos).node;
      }
      get depth() {
        var _a;
        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;
      }
      get pos() {
        return this.resolvedPos.pos;
      }
      get content() {
        return this.node.content;
      }
      set content(content) {
        let from2 = this.from;
        let to = this.to;
        if (this.isBlock) {
          if (this.content.size === 0) {
            console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
            return;
          }
          from2 = this.from + 1;
          to = this.to - 1;
        }
        this.editor.commands.insertContentAt({ from: from2, to }, content);
      }
      get attributes() {
        return this.node.attrs;
      }
      get textContent() {
        return this.node.textContent;
      }
      get size() {
        return this.node.nodeSize;
      }
      get from() {
        if (this.isBlock) {
          return this.pos;
        }
        return this.resolvedPos.start(this.resolvedPos.depth);
      }
      get range() {
        return {
          from: this.from,
          to: this.to
        };
      }
      get to() {
        if (this.isBlock) {
          return this.pos + this.size;
        }
        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
      }
      get parent() {
        if (this.depth === 0) {
          return null;
        }
        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
        const $pos = this.resolvedPos.doc.resolve(parentPos);
        return new _NodePos($pos, this.editor);
      }
      get before() {
        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.from - 3);
        }
        return new _NodePos($pos, this.editor);
      }
      get after() {
        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        if ($pos.depth !== this.depth) {
          $pos = this.resolvedPos.doc.resolve(this.to + 3);
        }
        return new _NodePos($pos, this.editor);
      }
      get children() {
        const children = [];
        this.node.content.forEach((node, offset) => {
          const isBlock = node.isBlock && !node.isTextblock;
          const isNonTextAtom = node.isAtom && !node.isText;
          const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
          const $pos = this.resolvedPos.doc.resolve(targetPos);
          if (!isBlock && $pos.depth <= this.depth) {
            return;
          }
          const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
          if (isBlock) {
            childNodePos.actualDepth = this.depth + 1;
          }
          children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
        });
        return children;
      }
      get firstChild() {
        return this.children[0] || null;
      }
      get lastChild() {
        const children = this.children;
        return children[children.length - 1] || null;
      }
      closest(selector, attributes = {}) {
        let node = null;
        let currentNode = this.parent;
        while (currentNode && !node) {
          if (currentNode.node.type.name === selector) {
            if (Object.keys(attributes).length > 0) {
              const nodeAttributes = currentNode.node.attrs;
              const attrKeys = Object.keys(attributes);
              for (let index = 0; index < attrKeys.length; index += 1) {
                const key = attrKeys[index];
                if (nodeAttributes[key] !== attributes[key]) {
                  break;
                }
              }
            } else {
              node = currentNode;
            }
          }
          currentNode = currentNode.parent;
        }
        return node;
      }
      querySelector(selector, attributes = {}) {
        return this.querySelectorAll(selector, attributes, true)[0] || null;
      }
      querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
        let nodes = [];
        if (!this.children || this.children.length === 0) {
          return nodes;
        }
        const attrKeys = Object.keys(attributes);
        this.children.forEach((childPos) => {
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          if (childPos.node.type.name === selector) {
            const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
            if (doesAllAttributesMatch) {
              nodes.push(childPos);
            }
          }
          if (firstItemOnly && nodes.length > 0) {
            return;
          }
          nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
        });
        return nodes;
      }
      setAttribute(attributes) {
        const { tr } = this.editor.state;
        tr.setNodeMarkup(this.from, void 0, __spreadValues(__spreadValues({}, this.node.attrs), attributes));
        this.editor.view.dispatch(tr);
      }
    };
    var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
    function createStyleTag(style2, nonce, suffix) {
      const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
      if (tiptapStyleTag !== null) {
        return tiptapStyleTag;
      }
      const styleNode = document.createElement("style");
      if (nonce) {
        styleNode.setAttribute("nonce", nonce);
      }
      styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
      styleNode.innerHTML = style2;
      document.getElementsByTagName("head")[0].appendChild(styleNode);
      return styleNode;
    }
    var Editor = class extends EventEmitter {
      constructor(options = {}) {
        super();
        this.isFocused = false;
        this.isInitialized = false;
        this.extensionStorage = {};
        this.options = {
          element: document.createElement("div"),
          content: "",
          injectCSS: true,
          injectNonce: void 0,
          extensions: [],
          autofocus: false,
          editable: true,
          editorProps: {},
          parseOptions: {},
          coreExtensionOptions: {},
          enableInputRules: true,
          enablePasteRules: true,
          enableCoreExtensions: true,
          enableContentCheck: false,
          onBeforeCreate: () => null,
          onCreate: () => null,
          onUpdate: () => null,
          onSelectionUpdate: () => null,
          onTransaction: () => null,
          onFocus: () => null,
          onBlur: () => null,
          onDestroy: () => null,
          onContentError: ({ error }) => {
            throw error;
          },
          onPaste: () => null,
          onDrop: () => null
        };
        this.isCapturingTransaction = false;
        this.capturedTransaction = null;
        this.setOptions(options);
        this.createExtensionManager();
        this.createCommandManager();
        this.createSchema();
        this.on("beforeCreate", this.options.onBeforeCreate);
        this.emit("beforeCreate", { editor: this });
        this.on("contentError", this.options.onContentError);
        this.createView();
        this.injectCSS();
        this.on("create", this.options.onCreate);
        this.on("update", this.options.onUpdate);
        this.on("selectionUpdate", this.options.onSelectionUpdate);
        this.on("transaction", this.options.onTransaction);
        this.on("focus", this.options.onFocus);
        this.on("blur", this.options.onBlur);
        this.on("destroy", this.options.onDestroy);
        this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
        this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
        window.setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.commands.focus(this.options.autofocus);
          this.emit("create", { editor: this });
          this.isInitialized = true;
        }, 0);
      }
      /**
       * Returns the editor storage.
       */
      get storage() {
        return this.extensionStorage;
      }
      /**
       * An object of all registered commands.
       */
      get commands() {
        return this.commandManager.commands;
      }
      /**
       * Create a command chain to call multiple commands at once.
       */
      chain() {
        return this.commandManager.chain();
      }
      /**
       * Check if a command or a command chain can be executed. Without executing it.
       */
      can() {
        return this.commandManager.can();
      }
      /**
       * Inject CSS styles.
       */
      injectCSS() {
        if (this.options.injectCSS && document) {
          this.css = createStyleTag(style, this.options.injectNonce);
        }
      }
      /**
       * Update editor options.
       *
       * @param options A list of options
       */
      setOptions(options = {}) {
        this.options = __spreadValues(__spreadValues({}, this.options), options);
        if (!this.view || !this.state || this.isDestroyed) {
          return;
        }
        if (this.options.editorProps) {
          this.view.setProps(this.options.editorProps);
        }
        this.view.updateState(this.state);
      }
      /**
       * Update editable state of the editor.
       */
      setEditable(editable, emitUpdate = true) {
        this.setOptions({ editable });
        if (emitUpdate) {
          this.emit("update", { editor: this, transaction: this.state.tr });
        }
      }
      /**
       * Returns whether the editor is editable.
       */
      get isEditable() {
        return this.options.editable && this.view && this.view.editable;
      }
      /**
       * Returns the editor state.
       */
      get state() {
        return this.view.state;
      }
      /**
       * Register a ProseMirror plugin.
       *
       * @param plugin A ProseMirror plugin
       * @param handlePlugins Control how to merge the plugin into the existing plugins.
       * @returns The new editor state
       */
      registerPlugin(plugin, handlePlugins) {
        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
        const state = this.state.reconfigure({ plugins });
        this.view.updateState(state);
        return state;
      }
      /**
       * Unregister a ProseMirror plugin.
       *
       * @param nameOrPluginKeyToRemove The plugins name
       * @returns The new editor state or undefined if the editor is destroyed
       */
      unregisterPlugin(nameOrPluginKeyToRemove) {
        if (this.isDestroyed) {
          return void 0;
        }
        const prevPlugins = this.state.plugins;
        let plugins = prevPlugins;
        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
          const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
          plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
        });
        if (prevPlugins.length === plugins.length) {
          return void 0;
        }
        const state = this.state.reconfigure({
          plugins
        });
        this.view.updateState(state);
        return state;
      }
      /**
       * Creates an extension manager.
       */
      createExtensionManager() {
        var _a, _b;
        const coreExtensions = this.options.enableCoreExtensions ? [
          Editable,
          ClipboardTextSerializer.configure({
            blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
          }),
          Commands,
          FocusEvents,
          Keymap,
          Tabindex,
          Drop,
          Paste
        ].filter((ext) => {
          if (typeof this.options.enableCoreExtensions === "object") {
            return this.options.enableCoreExtensions[ext.name] !== false;
          }
          return true;
        }) : [];
        const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
          return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
        });
        this.extensionManager = new ExtensionManager(allExtensions, this);
      }
      /**
       * Creates an command manager.
       */
      createCommandManager() {
        this.commandManager = new CommandManager({
          editor: this
        });
      }
      /**
       * Creates a ProseMirror schema.
       */
      createSchema() {
        this.schema = this.extensionManager.schema;
      }
      /**
       * Creates a ProseMirror view.
       */
      createView() {
        var _a;
        let doc3;
        try {
          doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
        } catch (e) {
          if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
            throw e;
          }
          this.emit("contentError", {
            editor: this,
            error: e,
            disableCollaboration: () => {
              if (this.storage.collaboration) {
                this.storage.collaboration.isDisabled = true;
              }
              this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
              this.createExtensionManager();
            }
          });
          doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
        }
        const selection = resolveFocusPosition(doc3, this.options.autofocus);
        this.view = new EditorView(this.options.element, __spreadProps(__spreadValues({}, this.options.editorProps), {
          attributes: __spreadValues({
            // add `role="textbox"` to the editor element
            role: "textbox"
          }, (_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes),
          dispatchTransaction: this.dispatchTransaction.bind(this),
          state: EditorState.create({
            doc: doc3,
            selection: selection || void 0
          })
        }));
        const newState = this.state.reconfigure({
          plugins: this.extensionManager.plugins
        });
        this.view.updateState(newState);
        this.createNodeViews();
        this.prependClass();
        const dom = this.view.dom;
        dom.editor = this;
      }
      /**
       * Creates all node views.
       */
      createNodeViews() {
        if (this.view.isDestroyed) {
          return;
        }
        this.view.setProps({
          nodeViews: this.extensionManager.nodeViews
        });
      }
      /**
       * Prepend class name to element.
       */
      prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`;
      }
      captureTransaction(fn) {
        this.isCapturingTransaction = true;
        fn();
        this.isCapturingTransaction = false;
        const tr = this.capturedTransaction;
        this.capturedTransaction = null;
        return tr;
      }
      /**
       * The callback over which to send transactions (state updates) produced by the view.
       *
       * @param transaction An editor state transaction
       */
      dispatchTransaction(transaction) {
        if (this.view.isDestroyed) {
          return;
        }
        if (this.isCapturingTransaction) {
          if (!this.capturedTransaction) {
            this.capturedTransaction = transaction;
            return;
          }
          transaction.steps.forEach((step) => {
            var _a;
            return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
          });
          return;
        }
        const state = this.state.apply(transaction);
        const selectionHasChanged = !this.state.selection.eq(state.selection);
        this.emit("beforeTransaction", {
          editor: this,
          transaction,
          nextState: state
        });
        this.view.updateState(state);
        this.emit("transaction", {
          editor: this,
          transaction
        });
        if (selectionHasChanged) {
          this.emit("selectionUpdate", {
            editor: this,
            transaction
          });
        }
        const focus2 = transaction.getMeta("focus");
        const blur2 = transaction.getMeta("blur");
        if (focus2) {
          this.emit("focus", {
            editor: this,
            event: focus2.event,
            transaction
          });
        }
        if (blur2) {
          this.emit("blur", {
            editor: this,
            event: blur2.event,
            transaction
          });
        }
        if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
          return;
        }
        this.emit("update", {
          editor: this,
          transaction
        });
      }
      /**
       * Get attributes of the currently selected node or mark.
       */
      getAttributes(nameOrType) {
        return getAttributes(this.state, nameOrType);
      }
      isActive(nameOrAttributes, attributesOrUndefined) {
        const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
        const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
        return isActive(this.state, name, attributes);
      }
      /**
       * Get the document as JSON.
       */
      getJSON() {
        return this.state.doc.toJSON();
      }
      /**
       * Get the document as HTML.
       */
      getHTML() {
        return getHTMLFromFragment(this.state.doc.content, this.schema);
      }
      /**
       * Get the document as text.
       */
      getText(options) {
        const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
        return getText2(this.state.doc, {
          blockSeparator,
          textSerializers: __spreadValues(__spreadValues({}, getTextSerializersFromSchema(this.schema)), textSerializers)
        });
      }
      /**
       * Check if there is no content.
       */
      get isEmpty() {
        return isNodeEmpty(this.state.doc);
      }
      /**
       * Get the number of characters for the current document.
       *
       * @deprecated
       */
      getCharacterCount() {
        console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
        return this.state.doc.content.size - 2;
      }
      /**
       * Destroy the editor.
       */
      destroy() {
        this.emit("destroy");
        if (this.view) {
          const dom = this.view.dom;
          if (dom && dom.editor) {
            delete dom.editor;
          }
          this.view.destroy();
        }
        this.removeAllListeners();
      }
      /**
       * Check if the editor is already destroyed.
       */
      get isDestroyed() {
        var _a;
        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
      }
      $node(selector, attributes) {
        var _a;
        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;
      }
      $nodes(selector, attributes) {
        var _a;
        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
      }
      $pos(pos) {
        const $pos = this.state.doc.resolve(pos);
        return new NodePos($pos, this);
      }
      get $doc() {
        return this.$pos(0);
      }
    };
    function markInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type) => type === config.type && type !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range.to) {
              tr.delete(textEnd, range.to);
            }
            if (textStart > range.from) {
              tr.delete(range.from + startSpaces, textStart);
            }
            const markEnd = range.from + startSpaces + captureGroup.length;
            tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        }
      });
    }
    function nodeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const { tr } = state;
          const start = range.from;
          let end = range.to;
          const newNode = config.type.create(attributes);
          if (match[1]) {
            const offset = match[0].lastIndexOf(match[1]);
            let matchStart = start + offset;
            if (matchStart > end) {
              matchStart = end;
            } else {
              end = matchStart + match[1].length;
            }
            const lastChar = match[0][match[0].length - 1];
            tr.insertText(lastChar, start + match[0].length - 1);
            tr.replaceWith(matchStart, end, newNode);
          } else if (match[0]) {
            const insertionStart = config.type.isInline ? start : start - 1;
            tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
          }
          tr.scrollIntoView();
        }
      });
    }
    function textblockTypeInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match }) => {
          const $start = state.doc.resolve(range.from);
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
            return null;
          }
          state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
        }
      });
    }
    function wrappingInputRule(config) {
      return new InputRule({
        find: config.find,
        handler: ({ state, range, match, chain }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
          const tr = state.tr.delete(range.from, range.to);
          const $start = tr.doc.resolve(range.from);
          const blockRange = $start.blockRange();
          const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
          if (!wrapping) {
            return null;
          }
          tr.wrap(blockRange, wrapping);
          if (config.keepMarks && config.editor) {
            const { selection, storedMarks } = state;
            const { splittableMarks } = config.editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            if (marks) {
              const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
              tr.ensureMarks(filteredMarks);
            }
          }
          if (config.keepAttributes) {
            const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
            chain().updateAttributes(nodeType, attributes).run();
          }
          const before = tr.doc.resolve(range.from - 1).nodeBefore;
          if (before && before.type === config.type && canJoin(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
            tr.join(range.from - 1);
          }
        }
      });
    }
    var Node2 = class _Node {
      constructor(config = {}) {
        this.type = "node";
        this.name = "node";
        this.parent = null;
        this.child = null;
        this.config = {
          name: this.name,
          defaultOptions: {}
        };
        this.config = __spreadValues(__spreadValues({}, this.config), config);
        this.name = this.config.name;
        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
        }
        this.options = this.config.defaultOptions;
        if (this.config.addOptions) {
          this.options = callOrReturn(getExtensionField(this, "addOptions", {
            name: this.name
          }));
        }
        this.storage = callOrReturn(getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })) || {};
      }
      static create(config = {}) {
        return new _Node(config);
      }
      configure(options = {}) {
        const extension = this.extend(__spreadProps(__spreadValues({}, this.config), {
          addOptions: () => {
            return mergeDeep(this.options, options);
          }
        }));
        extension.name = this.name;
        extension.parent = this.parent;
        return extension;
      }
      extend(extendedConfig = {}) {
        const extension = new _Node(extendedConfig);
        extension.parent = this;
        this.child = extension;
        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
          console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
        }
        extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
          name: extension.name
        }));
        extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
          name: extension.name,
          options: extension.options
        }));
        return extension;
      }
    };
    function markPasteRule(config) {
      return new PasteRule({
        find: config.find,
        handler: ({ state, range, match, pasteEvent }) => {
          const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
          if (attributes === false || attributes === null) {
            return null;
          }
          const { tr } = state;
          const captureGroup = match[match.length - 1];
          const fullMatch = match[0];
          let markEnd = range.to;
          if (captureGroup) {
            const startSpaces = fullMatch.search(/\S/);
            const textStart = range.from + fullMatch.indexOf(captureGroup);
            const textEnd = textStart + captureGroup.length;
            const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
              const excluded = item.mark.type.excluded;
              return excluded.find((type) => type === config.type && type !== item.mark.type);
            }).filter((item) => item.to > textStart);
            if (excludedMarks.length) {
              return null;
            }
            if (textEnd < range.to) {
              tr.delete(textEnd, range.to);
            }
            if (textStart > range.from) {
              tr.delete(range.from + startSpaces, textStart);
            }
            markEnd = range.from + startSpaces + captureGroup.length;
            tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
            tr.removeStoredMark(config.type);
          }
        }
      });
    }
    var import_react = __toESM(require_react(), 1);
    var import_react_dom = __toESM(require_react_dom(), 1);
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var shim = { exports: {} };
    var useSyncExternalStoreShim_development = {};
    var hasRequiredUseSyncExternalStoreShim_development;
    function requireUseSyncExternalStoreShim_development() {
      if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
      hasRequiredUseSyncExternalStoreShim_development = 1;
      if (true) {
        (function() {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React$1 = import_react.default;
          var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useState2 = React$1.useState, useEffect3 = React$1.useEffect, useLayoutEffect2 = React$1.useLayoutEffect, useDebugValue2 = React$1.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React$1.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState2({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect2(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe, value, getSnapshot]);
            useEffect3(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            }, [subscribe]);
            useDebugValue2(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
          var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
          useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
      return useSyncExternalStoreShim_development;
    }
    if (false) {
      shim.exports = requireUseSyncExternalStoreShim_production_min();
    } else {
      shim.exports = requireUseSyncExternalStoreShim_development();
    }
    var shimExports = shim.exports;
    var mergeRefs = (...refs) => {
      return (node) => {
        refs.forEach((ref) => {
          if (typeof ref === "function") {
            ref(node);
          } else if (ref) {
            ref.current = node;
          }
        });
      };
    };
    var Portals = ({ contentComponent }) => {
      const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);
      return import_react.default.createElement(import_react.default.Fragment, null, Object.values(renderers));
    };
    function getInstance() {
      const subscribers = /* @__PURE__ */ new Set();
      let renderers = {};
      return {
        /**
         * Subscribe to the editor instance's changes.
         */
        subscribe(callback) {
          subscribers.add(callback);
          return () => {
            subscribers.delete(callback);
          };
        },
        getSnapshot() {
          return renderers;
        },
        getServerSnapshot() {
          return renderers;
        },
        /**
         * Adds a new NodeView Renderer to the editor.
         */
        setRenderer(id, renderer) {
          renderers = __spreadProps(__spreadValues({}, renderers), {
            [id]: import_react_dom.default.createPortal(renderer.reactElement, renderer.element, id)
          });
          subscribers.forEach((subscriber) => subscriber());
        },
        /**
         * Removes a NodeView Renderer from the editor.
         */
        removeRenderer(id) {
          const nextRenderers = __spreadValues({}, renderers);
          delete nextRenderers[id];
          renderers = nextRenderers;
          subscribers.forEach((subscriber) => subscriber());
        }
      };
    }
    var PureEditorContent = class extends import_react.default.Component {
      constructor(props) {
        var _a;
        super(props);
        this.editorContentRef = import_react.default.createRef();
        this.initialized = false;
        this.state = {
          hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)
        };
      }
      componentDidMount() {
        this.init();
      }
      componentDidUpdate() {
        this.init();
      }
      init() {
        const editor = this.props.editor;
        if (editor && !editor.isDestroyed && editor.options.element) {
          if (editor.contentComponent) {
            return;
          }
          const element = this.editorContentRef.current;
          element.append(...editor.options.element.childNodes);
          editor.setOptions({
            element
          });
          editor.contentComponent = getInstance();
          if (!this.state.hasContentComponentInitialized) {
            this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {
              this.setState((prevState) => {
                if (!prevState.hasContentComponentInitialized) {
                  return {
                    hasContentComponentInitialized: true
                  };
                }
                return prevState;
              });
              if (this.unsubscribeToContentComponent) {
                this.unsubscribeToContentComponent();
              }
            });
          }
          editor.createNodeViews();
          this.initialized = true;
        }
      }
      componentWillUnmount() {
        const editor = this.props.editor;
        if (!editor) {
          return;
        }
        this.initialized = false;
        if (!editor.isDestroyed) {
          editor.view.setProps({
            nodeViews: {}
          });
        }
        if (this.unsubscribeToContentComponent) {
          this.unsubscribeToContentComponent();
        }
        editor.contentComponent = null;
        if (!editor.options.element.firstChild) {
          return;
        }
        const newElement = document.createElement("div");
        newElement.append(...editor.options.element.childNodes);
        editor.setOptions({
          element: newElement
        });
      }
      render() {
        const _a = this.props, { editor, innerRef } = _a, rest = __objRest(_a, ["editor", "innerRef"]);
        return import_react.default.createElement(
          import_react.default.Fragment,
          null,
          import_react.default.createElement("div", __spreadValues({ ref: mergeRefs(innerRef, this.editorContentRef) }, rest)),
          (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && import_react.default.createElement(Portals, { contentComponent: editor.contentComponent })
        );
      }
    };
    var EditorContentWithKey = (0, import_react.forwardRef)((props, ref) => {
      const key = import_react.default.useMemo(() => {
        return Math.floor(Math.random() * 4294967295).toString();
      }, [props.editor]);
      return import_react.default.createElement(PureEditorContent, __spreadValues({
        key,
        innerRef: ref
      }, props));
    });
    var EditorContent = import_react.default.memo(EditorContentWithKey);
    var react = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i2, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a[i2], b[i2])) return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size) return false;
          for (i2 of a.entries())
            if (!b.has(i2[0])) return false;
          for (i2 of a.entries())
            if (!equal(i2[1], b.get(i2[0]))) return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size) return false;
          for (i2 of a.entries())
            if (!b.has(i2[0])) return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (a[i2] !== b[i2]) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys2[i2];
          if (key === "_owner" && a.$$typeof) {
            continue;
          }
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
    var deepEqual = /* @__PURE__ */ getDefaultExportFromCjs(react);
    var withSelector = { exports: {} };
    var withSelector_development = {};
    var hasRequiredWithSelector_development;
    function requireWithSelector_development() {
      if (hasRequiredWithSelector_development) return withSelector_development;
      hasRequiredWithSelector_development = 1;
      if (true) {
        (function() {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React$1 = import_react.default;
          var shim2 = shimExports;
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useSyncExternalStore = shim2.useSyncExternalStore;
          var useRef2 = React$1.useRef, useEffect3 = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue2 = React$1.useDebugValue;
          function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
            var instRef = useRef2(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector(nextSnapshot);
                  if (isEqual !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection2 = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore(subscribe, getSelection2, getServerSelection);
            useEffect3(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue2(value);
            return value;
          }
          withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
      return withSelector_development;
    }
    if (false) {
      withSelector.exports = requireWithSelector_production_min();
    } else {
      withSelector.exports = requireWithSelector_development();
    }
    var withSelectorExports = withSelector.exports;
    var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
    var EditorStateManager = class {
      constructor(initialEditor) {
        this.transactionNumber = 0;
        this.lastTransactionNumber = 0;
        this.subscribers = /* @__PURE__ */ new Set();
        this.editor = initialEditor;
        this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
        this.getSnapshot = this.getSnapshot.bind(this);
        this.getServerSnapshot = this.getServerSnapshot.bind(this);
        this.watch = this.watch.bind(this);
        this.subscribe = this.subscribe.bind(this);
      }
      /**
       * Get the current editor instance.
       */
      getSnapshot() {
        if (this.transactionNumber === this.lastTransactionNumber) {
          return this.lastSnapshot;
        }
        this.lastTransactionNumber = this.transactionNumber;
        this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };
        return this.lastSnapshot;
      }
      /**
       * Always disable the editor on the server-side.
       */
      getServerSnapshot() {
        return { editor: null, transactionNumber: 0 };
      }
      /**
       * Subscribe to the editor instance's changes.
       */
      subscribe(callback) {
        this.subscribers.add(callback);
        return () => {
          this.subscribers.delete(callback);
        };
      }
      /**
       * Watch the editor instance for changes.
       */
      watch(nextEditor) {
        this.editor = nextEditor;
        if (this.editor) {
          const fn = () => {
            this.transactionNumber += 1;
            this.subscribers.forEach((callback) => callback());
          };
          const currentEditor = this.editor;
          currentEditor.on("transaction", fn);
          return () => {
            currentEditor.off("transaction", fn);
          };
        }
        return void 0;
      }
    };
    function useEditorState(options) {
      var _a;
      const [editorStateManager] = (0, import_react.useState)(() => new EditorStateManager(options.editor));
      const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);
      useIsomorphicLayoutEffect(() => {
        return editorStateManager.watch(options.editor);
      }, [options.editor, editorStateManager]);
      (0, import_react.useDebugValue)(selectedState);
      return selectedState;
    }
    var isDev = true;
    var isSSR = typeof window === "undefined";
    var isNext = isSSR || Boolean(typeof window !== "undefined" && window.next);
    var EditorInstanceManager = class _EditorInstanceManager {
      constructor(options) {
        this.editor = null;
        this.subscriptions = /* @__PURE__ */ new Set();
        this.isComponentMounted = false;
        this.previousDeps = null;
        this.instanceId = "";
        this.options = options;
        this.subscriptions = /* @__PURE__ */ new Set();
        this.setEditor(this.getInitialEditor());
        this.scheduleDestroy();
        this.getEditor = this.getEditor.bind(this);
        this.getServerSnapshot = this.getServerSnapshot.bind(this);
        this.subscribe = this.subscribe.bind(this);
        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);
        this.scheduleDestroy = this.scheduleDestroy.bind(this);
        this.onRender = this.onRender.bind(this);
        this.createEditor = this.createEditor.bind(this);
      }
      setEditor(editor) {
        this.editor = editor;
        this.instanceId = Math.random().toString(36).slice(2, 9);
        this.subscriptions.forEach((cb) => cb());
      }
      getInitialEditor() {
        if (this.options.current.immediatelyRender === void 0) {
          if (isSSR || isNext) {
            if (isDev) {
              console.warn("Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.");
            }
            return null;
          }
          return this.createEditor();
        }
        if (this.options.current.immediatelyRender && isSSR && isDev) {
          throw new Error("Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.");
        }
        if (this.options.current.immediatelyRender) {
          return this.createEditor();
        }
        return null;
      }
      /**
       * Create a new editor instance. And attach event listeners.
       */
      createEditor() {
        const optionsToApply = __spreadProps(__spreadValues({}, this.options.current), {
          // Always call the most recent version of the callback function by default
          onBeforeCreate: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onBlur: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onCreate: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onDestroy: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onFocus: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onSelectionUpdate: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onTransaction: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onUpdate: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onContentError: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onDrop: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          },
          onPaste: (...args) => {
            var _a, _b;
            return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);
          }
        });
        const editor = new Editor(optionsToApply);
        return editor;
      }
      /**
       * Get the current editor instance.
       */
      getEditor() {
        return this.editor;
      }
      /**
       * Always disable the editor on the server-side.
       */
      getServerSnapshot() {
        return null;
      }
      /**
       * Subscribe to the editor instance's changes.
       */
      subscribe(onStoreChange) {
        this.subscriptions.add(onStoreChange);
        return () => {
          this.subscriptions.delete(onStoreChange);
        };
      }
      static compareOptions(a, b) {
        return Object.keys(a).every((key) => {
          if (["onCreate", "onBeforeCreate", "onDestroy", "onUpdate", "onTransaction", "onFocus", "onBlur", "onSelectionUpdate", "onContentError", "onDrop", "onPaste"].includes(key)) {
            return true;
          }
          if (key === "extensions" && a.extensions && b.extensions) {
            if (a.extensions.length !== b.extensions.length) {
              return false;
            }
            return a.extensions.every((extension, index) => {
              var _a;
              if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {
                return false;
              }
              return true;
            });
          }
          if (a[key] !== b[key]) {
            return false;
          }
          return true;
        });
      }
      /**
       * On each render, we will create, update, or destroy the editor instance.
       * @param deps The dependencies to watch for changes
       * @returns A cleanup function
       */
      onRender(deps) {
        return () => {
          this.isComponentMounted = true;
          clearTimeout(this.scheduledDestructionTimeout);
          if (this.editor && !this.editor.isDestroyed && deps.length === 0) {
            if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {
              this.editor.setOptions(__spreadProps(__spreadValues({}, this.options.current), {
                editable: this.editor.isEditable
              }));
            }
          } else {
            this.refreshEditorInstance(deps);
          }
          return () => {
            this.isComponentMounted = false;
            this.scheduleDestroy();
          };
        };
      }
      /**
       * Recreate the editor instance if the dependencies have changed.
       */
      refreshEditorInstance(deps) {
        if (this.editor && !this.editor.isDestroyed) {
          if (this.previousDeps === null) {
            this.previousDeps = deps;
            return;
          }
          const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);
          if (depsAreEqual) {
            return;
          }
        }
        if (this.editor && !this.editor.isDestroyed) {
          this.editor.destroy();
        }
        this.setEditor(this.createEditor());
        this.previousDeps = deps;
      }
      /**
       * Schedule the destruction of the editor instance.
       * This will only destroy the editor if it was not mounted on the next tick.
       * This is to avoid destroying the editor instance when it's actually still mounted.
       */
      scheduleDestroy() {
        const currentInstanceId = this.instanceId;
        const currentEditor = this.editor;
        this.scheduledDestructionTimeout = setTimeout(() => {
          if (this.isComponentMounted && this.instanceId === currentInstanceId) {
            if (currentEditor) {
              currentEditor.setOptions(this.options.current);
            }
            return;
          }
          if (currentEditor && !currentEditor.isDestroyed) {
            currentEditor.destroy();
            if (this.instanceId === currentInstanceId) {
              this.setEditor(null);
            }
          }
        }, 1);
      }
    };
    function useEditor(options = {}, deps = []) {
      const mostRecentOptions = (0, import_react.useRef)(options);
      mostRecentOptions.current = options;
      const [instanceManager] = (0, import_react.useState)(() => new EditorInstanceManager(mostRecentOptions));
      const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);
      (0, import_react.useDebugValue)(editor);
      (0, import_react.useEffect)(instanceManager.onRender(deps));
      useEditorState({
        editor,
        selector: ({ transactionNumber }) => {
          if (options.shouldRerenderOnTransaction === false) {
            return null;
          }
          if (options.immediatelyRender && transactionNumber === 0) {
            return 0;
          }
          return transactionNumber + 1;
        }
      });
      return editor;
    }
    var EditorContext = (0, import_react.createContext)({
      editor: null
    });
    var EditorConsumer = EditorContext.Consumer;
    var ReactNodeViewContext = (0, import_react.createContext)({
      onDragStart: void 0
    });
    var useReactNodeView = () => (0, import_react.useContext)(ReactNodeViewContext);
    var NodeViewWrapper = import_react.default.forwardRef((props, ref) => {
      const { onDragStart } = useReactNodeView();
      const Tag = props.as || "div";
      return (
        // @ts-ignore
        import_react.default.createElement(Tag, __spreadProps(__spreadValues({}, props), { ref, "data-node-view-wrapper": "", onDragStart, style: __spreadValues({
          whiteSpace: "normal"
        }, props.style) }))
      );
    });
    var inputRegex = /^\s*>\s$/;
    var Blockquote = Node2.create({
      name: "blockquote",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      content: "block+",
      group: "block",
      defining: true,
      parseHTML() {
        return [
          { tag: "blockquote" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBlockquote: () => ({ commands: commands2 }) => {
            return commands2.wrapIn(this.name);
          },
          toggleBlockquote: () => ({ commands: commands2 }) => {
            return commands2.toggleWrap(this.name);
          },
          unsetBlockquote: () => ({ commands: commands2 }) => {
            return commands2.lift(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        };
      },
      addInputRules() {
        return [
          wrappingInputRule({
            find: inputRegex,
            type: this.type
          })
        ];
      }
    });
    var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
    var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
    var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
    var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
    var Bold = Mark2.create({
      name: "bold",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "strong"
          },
          {
            tag: "b",
            getAttrs: (node) => node.style.fontWeight !== "normal" && null
          },
          {
            style: "font-weight=400",
            clearMark: (mark) => mark.type.name === this.name
          },
          {
            style: "font-weight",
            getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setBold: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleBold: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetBold: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-b": () => this.editor.commands.toggleBold(),
          "Mod-B": () => this.editor.commands.toggleBold()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: starInputRegex,
            type: this.type
          }),
          markInputRule({
            find: underscoreInputRegex,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: starPasteRegex,
            type: this.type
          }),
          markPasteRule({
            find: underscorePasteRegex,
            type: this.type
          })
        ];
      }
    });
    var ListItemName = "listItem";
    var TextStyleName = "textStyle";
    var inputRegex2 = /^\s*([-+*])\s$/;
    var BulletList = Node2.create({
      name: "bulletList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      parseHTML() {
        return [
          { tag: "ul" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleBulletList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        };
      },
      addInputRules() {
        let inputRule = wrappingInputRule({
          find: inputRegex2,
          type: this.type
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = wrappingInputRule({
            find: inputRegex2,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => {
              return this.editor.getAttributes(TextStyleName);
            },
            editor: this.editor
          });
        }
        return [
          inputRule
        ];
      }
    });
    var inputRegex3 = /(^|[^`])`([^`]+)`(?!`)/;
    var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
    var Code = Mark2.create({
      name: "code",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      excludes: "_",
      code: true,
      exitable: true,
      parseHTML() {
        return [
          { tag: "code" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setCode: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleCode: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetCode: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-e": () => this.editor.commands.toggleCode()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: inputRegex3,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: pasteRegex,
            type: this.type
          })
        ];
      }
    });
    var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
    var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
    var CodeBlock = Node2.create({
      name: "codeBlock",
      addOptions() {
        return {
          languageClassPrefix: "language-",
          exitOnTripleEnter: true,
          exitOnArrowDown: true,
          defaultLanguage: null,
          HTMLAttributes: {}
        };
      },
      content: "text*",
      marks: "",
      group: "block",
      code: true,
      defining: true,
      addAttributes() {
        return {
          language: {
            default: this.options.defaultLanguage,
            parseHTML: (element) => {
              var _a;
              const { languageClassPrefix } = this.options;
              const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];
              const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
              const language = languages[0];
              if (!language) {
                return null;
              }
              return language;
            },
            rendered: false
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "pre",
            preserveWhitespace: "full"
          }
        ];
      },
      renderHTML({ node, HTMLAttributes }) {
        return [
          "pre",
          mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
          [
            "code",
            {
              class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
            },
            0
          ]
        ];
      },
      addCommands() {
        return {
          setCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.setNode(this.name, attributes);
          },
          toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
          // remove code block when at start of document or code block is empty
          Backspace: () => {
            const { empty: empty2, $anchor } = this.editor.state.selection;
            const isAtStart = $anchor.pos === 1;
            if (!empty2 || $anchor.parent.type.name !== this.name) {
              return false;
            }
            if (isAtStart || !$anchor.parent.textContent.length) {
              return this.editor.commands.clearNodes();
            }
            return false;
          },
          // exit node on triple enter
          Enter: ({ editor }) => {
            if (!this.options.exitOnTripleEnter) {
              return false;
            }
            const { state } = editor;
            const { selection } = state;
            const { $from, empty: empty2 } = selection;
            if (!empty2 || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
            if (!isAtEnd || !endsWithDoubleNewline) {
              return false;
            }
            return editor.chain().command(({ tr }) => {
              tr.delete($from.pos - 2, $from.pos);
              return true;
            }).exitCode().run();
          },
          // exit node on arrow down
          ArrowDown: ({ editor }) => {
            if (!this.options.exitOnArrowDown) {
              return false;
            }
            const { state } = editor;
            const { selection, doc: doc3 } = state;
            const { $from, empty: empty2 } = selection;
            if (!empty2 || $from.parent.type !== this.type) {
              return false;
            }
            const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
            if (!isAtEnd) {
              return false;
            }
            const after = $from.after();
            if (after === void 0) {
              return false;
            }
            const nodeAfter = doc3.nodeAt(after);
            if (nodeAfter) {
              return editor.commands.command(({ tr }) => {
                tr.setSelection(Selection.near(doc3.resolve(after)));
                return true;
              });
            }
            return editor.commands.exitCode();
          }
        };
      },
      addInputRules() {
        return [
          textblockTypeInputRule({
            find: backtickInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          }),
          textblockTypeInputRule({
            find: tildeInputRegex,
            type: this.type,
            getAttributes: (match) => ({
              language: match[1]
            })
          })
        ];
      },
      addProseMirrorPlugins() {
        return [
          // this plugin creates a code block for pasted content from VS Code
          // we can also detect the copied code language
          new Plugin({
            key: new PluginKey("codeBlockVSCodeHandler"),
            props: {
              handlePaste: (view, event) => {
                if (!event.clipboardData) {
                  return false;
                }
                if (this.editor.isActive(this.type.name)) {
                  return false;
                }
                const text = event.clipboardData.getData("text/plain");
                const vscode = event.clipboardData.getData("vscode-editor-data");
                const vscodeData = vscode ? JSON.parse(vscode) : void 0;
                const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
                if (!text || !language) {
                  return false;
                }
                const { tr, schema } = view.state;
                const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
                tr.replaceSelectionWith(this.type.create({ language }, textNode));
                if (tr.selection.$from.parent.type !== this.type) {
                  tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
                }
                tr.setMeta("paste", true);
                view.dispatch(tr);
                return true;
              }
            }
          })
        ];
      }
    });
    var Document = Node2.create({
      name: "doc",
      topNode: true,
      content: "block+"
    });
    function dropCursor(options = {}) {
      return new Plugin({
        view(editorView) {
          return new DropCursorView(editorView, options);
        }
      });
    }
    var DropCursorView = class {
      constructor(editorView, options) {
        var _a;
        this.editorView = editorView;
        this.cursorPos = null;
        this.element = null;
        this.timeout = -1;
        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
        this.color = options.color === false ? void 0 : options.color || "black";
        this.class = options.class;
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
          let handler = (e) => {
            this[name](e);
          };
          editorView.dom.addEventListener(name, handler);
          return { name, handler };
        });
      }
      destroy() {
        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
      }
      update(editorView, prevState) {
        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
          if (this.cursorPos > editorView.state.doc.content.size)
            this.setCursor(null);
          else
            this.updateOverlay();
        }
      }
      setCursor(pos) {
        if (pos == this.cursorPos)
          return;
        this.cursorPos = pos;
        if (pos == null) {
          this.element.parentNode.removeChild(this.element);
          this.element = null;
        } else {
          this.updateOverlay();
        }
      }
      updateOverlay() {
        let $pos = this.editorView.state.doc.resolve(this.cursorPos);
        let isBlock = !$pos.parent.inlineContent, rect;
        let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
        let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
        if (isBlock) {
          let before = $pos.nodeBefore, after = $pos.nodeAfter;
          if (before || after) {
            let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
            if (node) {
              let nodeRect = node.getBoundingClientRect();
              let top = before ? nodeRect.bottom : nodeRect.top;
              if (before && after)
                top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
              let halfWidth = this.width / 2 * scaleY;
              rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
            }
          }
        }
        if (!rect) {
          let coords = this.editorView.coordsAtPos(this.cursorPos);
          let halfWidth = this.width / 2 * scaleX;
          rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
        }
        let parent = this.editorView.dom.offsetParent;
        if (!this.element) {
          this.element = parent.appendChild(document.createElement("div"));
          if (this.class)
            this.element.className = this.class;
          this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
          if (this.color) {
            this.element.style.backgroundColor = this.color;
          }
        }
        this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
        this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
        let parentLeft, parentTop;
        if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
          parentLeft = -pageXOffset;
          parentTop = -pageYOffset;
        } else {
          let rect2 = parent.getBoundingClientRect();
          let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
          parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
          parentTop = rect2.top - parent.scrollTop * parentScaleY;
        }
        this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
        this.element.style.top = (rect.top - parentTop) / scaleY + "px";
        this.element.style.width = (rect.right - rect.left) / scaleX + "px";
        this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
      }
      scheduleRemoval(timeout) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.setCursor(null), timeout);
      }
      dragover(event) {
        if (!this.editorView.editable)
          return;
        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
        let disableDropCursor = node && node.type.spec.disableDropCursor;
        let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
        if (pos && !disabled) {
          let target = pos.pos;
          if (this.editorView.dragging && this.editorView.dragging.slice) {
            let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
            if (point != null)
              target = point;
          }
          this.setCursor(target);
          this.scheduleRemoval(5e3);
        }
      }
      dragend() {
        this.scheduleRemoval(20);
      }
      drop() {
        this.scheduleRemoval(20);
      }
      dragleave(event) {
        if (!this.editorView.dom.contains(event.relatedTarget))
          this.setCursor(null);
      }
    };
    var Dropcursor = Extension.create({
      name: "dropCursor",
      addOptions() {
        return {
          color: "currentColor",
          width: 1,
          class: void 0
        };
      },
      addProseMirrorPlugins() {
        return [
          dropCursor(this.options)
        ];
      }
    });
    var GapCursor = class _GapCursor extends Selection {
      /**
      Create a gap cursor.
      */
      constructor($pos) {
        super($pos, $pos);
      }
      map(doc3, mapping) {
        let $pos = doc3.resolve(mapping.map(this.head));
        return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
      }
      content() {
        return Slice.empty;
      }
      eq(other) {
        return other instanceof _GapCursor && other.head == this.head;
      }
      toJSON() {
        return { type: "gapcursor", pos: this.head };
      }
      /**
      @internal
      */
      static fromJSON(doc3, json) {
        if (typeof json.pos != "number")
          throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new _GapCursor(doc3.resolve(json.pos));
      }
      /**
      @internal
      */
      getBookmark() {
        return new GapBookmark(this.anchor);
      }
      /**
      @internal
      */
      static valid($pos) {
        let parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
          return false;
        let override = parent.type.spec.allowGapCursor;
        if (override != null)
          return override;
        let deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock;
      }
      /**
      @internal
      */
      static findGapCursorFrom($pos, dir, mustMove = false) {
        search: for (; ; ) {
          if (!mustMove && _GapCursor.valid($pos))
            return $pos;
          let pos = $pos.pos, next = null;
          for (let d = $pos.depth; ; d--) {
            let parent = $pos.node(d);
            if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
              break;
            } else if (d == 0) {
              return null;
            }
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          for (; ; ) {
            let inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search;
              }
              break;
            }
            next = inside;
            pos += dir;
            let $cur = $pos.doc.resolve(pos);
            if (_GapCursor.valid($cur))
              return $cur;
          }
          return null;
        }
      }
    };
    GapCursor.prototype.visible = false;
    GapCursor.findFrom = GapCursor.findGapCursorFrom;
    Selection.jsonID("gapcursor", GapCursor);
    var GapBookmark = class _GapBookmark {
      constructor(pos) {
        this.pos = pos;
      }
      map(mapping) {
        return new _GapBookmark(mapping.map(this.pos));
      }
      resolve(doc3) {
        let $pos = doc3.resolve(this.pos);
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
      }
    };
    function closedBefore($pos) {
      for (let d = $pos.depth; d >= 0; d--) {
        let index = $pos.index(d), parent = $pos.node(d);
        if (index == 0) {
          if (parent.type.spec.isolating)
            return true;
          continue;
        }
        for (let before = parent.child(index - 1); ; before = before.lastChild) {
          if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
            return true;
          if (before.inlineContent)
            return false;
        }
      }
      return true;
    }
    function closedAfter($pos) {
      for (let d = $pos.depth; d >= 0; d--) {
        let index = $pos.indexAfter(d), parent = $pos.node(d);
        if (index == parent.childCount) {
          if (parent.type.spec.isolating)
            return true;
          continue;
        }
        for (let after = parent.child(index); ; after = after.firstChild) {
          if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
            return true;
          if (after.inlineContent)
            return false;
        }
      }
      return true;
    }
    function gapCursor() {
      return new Plugin({
        props: {
          decorations: drawGapCursor,
          createSelectionBetween(_view, $anchor, $head) {
            return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
          },
          handleClick,
          handleKeyDown,
          handleDOMEvents: { beforeinput }
        }
      });
    }
    var handleKeyDown = keydownHandler({
      "ArrowLeft": arrow("horiz", -1),
      "ArrowRight": arrow("horiz", 1),
      "ArrowUp": arrow("vert", -1),
      "ArrowDown": arrow("vert", 1)
    });
    function arrow(axis, dir) {
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return function(state, dispatch, view) {
        let sel = state.selection;
        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
        if (sel instanceof TextSelection) {
          if (!view.endOfTextblock(dirStr) || $start.depth == 0)
            return false;
          mustMove = false;
          $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
        }
        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
        if (!$found)
          return false;
        if (dispatch)
          dispatch(state.tr.setSelection(new GapCursor($found)));
        return true;
      };
    }
    function handleClick(view, pos, event) {
      if (!view || !view.editable)
        return false;
      let $pos = view.state.doc.resolve(pos);
      if (!GapCursor.valid($pos))
        return false;
      let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
      if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
        return false;
      view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
      return true;
    }
    function beforeinput(view, event) {
      if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
        return false;
      let { $from } = view.state.selection;
      let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
      if (!insert)
        return false;
      let frag = Fragment.empty;
      for (let i2 = insert.length - 1; i2 >= 0; i2--)
        frag = Fragment.from(insert[i2].createAndFill(null, frag));
      let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
      tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
      view.dispatch(tr);
      return false;
    }
    function drawGapCursor(state) {
      if (!(state.selection instanceof GapCursor))
        return null;
      let node = document.createElement("div");
      node.className = "ProseMirror-gapcursor";
      return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
    }
    var Gapcursor = Extension.create({
      name: "gapCursor",
      addProseMirrorPlugins() {
        return [
          gapCursor()
        ];
      },
      extendNodeSchema(extension) {
        var _a;
        const context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        return {
          allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a !== void 0 ? _a : null
        };
      }
    });
    var HardBreak = Node2.create({
      name: "hardBreak",
      addOptions() {
        return {
          keepMarks: true,
          HTMLAttributes: {}
        };
      },
      inline: true,
      group: "inline",
      selectable: false,
      linebreakReplacement: true,
      parseHTML() {
        return [
          { tag: "br" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      renderText() {
        return "\n";
      },
      addCommands() {
        return {
          setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
            return commands2.first([
              () => commands2.exitCode(),
              () => commands2.command(() => {
                const { selection, storedMarks } = state;
                if (selection.$from.parent.type.spec.isolating) {
                  return false;
                }
                const { keepMarks } = this.options;
                const { splittableMarks } = editor.extensionManager;
                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
                return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
                  if (dispatch && marks && keepMarks) {
                    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                    tr.ensureMarks(filteredMarks);
                  }
                  return true;
                }).run();
              })
            ]);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Enter": () => this.editor.commands.setHardBreak(),
          "Shift-Enter": () => this.editor.commands.setHardBreak()
        };
      }
    });
    var Heading = Node2.create({
      name: "heading",
      addOptions() {
        return {
          levels: [1, 2, 3, 4, 5, 6],
          HTMLAttributes: {}
        };
      },
      content: "inline*",
      group: "block",
      defining: true,
      addAttributes() {
        return {
          level: {
            default: 1,
            rendered: false
          }
        };
      },
      parseHTML() {
        return this.options.levels.map((level) => ({
          tag: `h${level}`,
          attrs: { level }
        }));
      },
      renderHTML({ node, HTMLAttributes }) {
        const hasLevel = this.options.levels.includes(node.attrs.level);
        const level = hasLevel ? node.attrs.level : this.options.levels[0];
        return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.setNode(this.name, attributes);
          },
          toggleHeading: (attributes) => ({ commands: commands2 }) => {
            if (!this.options.levels.includes(attributes.level)) {
              return false;
            }
            return commands2.toggleNode(this.name, "paragraph", attributes);
          }
        };
      },
      addKeyboardShortcuts() {
        return this.options.levels.reduce((items, level) => __spreadValues(__spreadValues({}, items), {
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }), {});
      },
      addInputRules() {
        return this.options.levels.map((level) => {
          return textblockTypeInputRule({
            find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
            type: this.type,
            getAttributes: {
              level
            }
          });
        });
      }
    });
    var GOOD_LEAF_SIZE = 200;
    var RopeSequence = function RopeSequence2() {
    };
    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);
      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };
    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };
    RopeSequence.prototype.slice = function slice(from2, to) {
      if (from2 === void 0) from2 = 0;
      if (to === void 0) to = this.length;
      if (from2 >= to) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
    };
    RopeSequence.prototype.get = function get(i2) {
      if (i2 < 0 || i2 >= this.length) {
        return void 0;
      }
      return this.getInner(i2);
    };
    RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
      if (from2 === void 0) from2 = 0;
      if (to === void 0) to = this.length;
      if (from2 <= to) {
        this.forEachInner(f, from2, to, 0);
      } else {
        this.forEachInvertedInner(f, from2, to, 0);
      }
    };
    RopeSequence.prototype.map = function map(f, from2, to) {
      if (from2 === void 0) from2 = 0;
      if (to === void 0) to = this.length;
      var result = [];
      this.forEach(function(elt, i2) {
        return result.push(f(elt, i2));
      }, from2, to);
      return result;
    };
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };
    var Leaf = /* @__PURE__ */ function(RopeSequence3) {
      function Leaf2(values) {
        RopeSequence3.call(this);
        this.values = values;
      }
      if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
      Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Leaf2.prototype.constructor = Leaf2;
      var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
      Leaf2.prototype.flatten = function flatten() {
        return this.values;
      };
      Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
        if (from2 == 0 && to == this.length) {
          return this;
        }
        return new Leaf2(this.values.slice(from2, to));
      };
      Leaf2.prototype.getInner = function getInner(i2) {
        return this.values[i2];
      };
      Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
        for (var i2 = from2; i2 < to; i2++) {
          if (f(this.values[i2], start + i2) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
        for (var i2 = from2 - 1; i2 >= to; i2--) {
          if (f(this.values[i2], start + i2) === false) {
            return false;
          }
        }
      };
      Leaf2.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(this.values.concat(other.flatten()));
        }
      };
      Leaf2.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf2(other.flatten().concat(this.values));
        }
      };
      prototypeAccessors.length.get = function() {
        return this.values.length;
      };
      prototypeAccessors.depth.get = function() {
        return 0;
      };
      Object.defineProperties(Leaf2.prototype, prototypeAccessors);
      return Leaf2;
    }(RopeSequence);
    RopeSequence.empty = new Leaf([]);
    var Append = /* @__PURE__ */ function(RopeSequence3) {
      function Append2(left, right) {
        RopeSequence3.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }
      if (RopeSequence3) Append2.__proto__ = RopeSequence3;
      Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
      Append2.prototype.constructor = Append2;
      Append2.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };
      Append2.prototype.getInner = function getInner(i2) {
        return i2 < this.left.length ? this.left.get(i2) : this.right.get(i2 - this.left.length);
      };
      Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
        var leftLen = this.left.length;
        if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
          return false;
        }
        if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
          return false;
        }
      };
      Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
        var leftLen = this.left.length;
        if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
          return false;
        }
      };
      Append2.prototype.sliceInner = function sliceInner(from2, to) {
        if (from2 == 0 && to == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to <= leftLen) {
          return this.left.slice(from2, to);
        }
        if (from2 >= leftLen) {
          return this.right.slice(from2 - leftLen, to - leftLen);
        }
        return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
      };
      Append2.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append2(this.left, inner);
        }
      };
      Append2.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append2(inner, this.right);
        }
      };
      Append2.prototype.appendInner = function appendInner2(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append2(this.left, new Append2(this.right, other));
        }
        return new Append2(this, other);
      };
      return Append2;
    }(RopeSequence);
    var dist_default2 = RopeSequence;
    var max_empty_items = 500;
    var Branch = class _Branch {
      constructor(items, eventCount) {
        this.items = items;
        this.eventCount = eventCount;
      }
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      popEvent(state, preserveItems) {
        if (this.eventCount == 0)
          return null;
        let end = this.items.length;
        for (; ; end--) {
          let next = this.items.get(end - 1);
          if (next.selection) {
            --end;
            break;
          }
        }
        let remap, mapFrom;
        if (preserveItems) {
          remap = this.remapping(end, this.items.length);
          mapFrom = remap.maps.length;
        }
        let transform = state.tr;
        let selection, remaining;
        let addAfter = [], addBefore = [];
        this.items.forEach((item, i2) => {
          if (!item.step) {
            if (!remap) {
              remap = this.remapping(end, i2 + 1);
              mapFrom = remap.maps.length;
            }
            mapFrom--;
            addBefore.push(item);
            return;
          }
          if (remap) {
            addBefore.push(new Item(item.map));
            let step = item.step.map(remap.slice(mapFrom)), map2;
            if (step && transform.maybeStep(step).doc) {
              map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
              addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
            }
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
          } else {
            transform.maybeStep(item.step);
          }
          if (item.selection) {
            selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
            remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
            return false;
          }
        }, this.items.length, 0);
        return { remaining, transform, selection };
      }
      // Create a new branch with the given transform added.
      addTransform(transform, selection, histOptions, preserveItems) {
        let newItems = [], eventCount = this.eventCount;
        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
        for (let i2 = 0; i2 < transform.steps.length; i2++) {
          let step = transform.steps[i2].invert(transform.docs[i2]);
          let item = new Item(transform.mapping.maps[i2], step, selection), merged;
          if (merged = lastItem && lastItem.merge(item)) {
            item = merged;
            if (i2)
              newItems.pop();
            else
              oldItems = oldItems.slice(0, oldItems.length - 1);
          }
          newItems.push(item);
          if (selection) {
            eventCount++;
            selection = void 0;
          }
          if (!preserveItems)
            lastItem = item;
        }
        let overflow = eventCount - histOptions.depth;
        if (overflow > DEPTH_OVERFLOW) {
          oldItems = cutOffEvents(oldItems, overflow);
          eventCount -= overflow;
        }
        return new _Branch(oldItems.append(newItems), eventCount);
      }
      remapping(from2, to) {
        let maps = new Mapping();
        this.items.forEach((item, i2) => {
          let mirrorPos = item.mirrorOffset != null && i2 - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
          maps.appendMap(item.map, mirrorPos);
        }, from2, to);
        return maps;
      }
      addMaps(array) {
        if (this.eventCount == 0)
          return this;
        return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
      }
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      rebased(rebasedTransform, rebasedCount) {
        if (!this.eventCount)
          return this;
        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
        let mapping = rebasedTransform.mapping;
        let newUntil = rebasedTransform.steps.length;
        let eventCount = this.eventCount;
        this.items.forEach((item) => {
          if (item.selection)
            eventCount--;
        }, start);
        let iRebased = rebasedCount;
        this.items.forEach((item) => {
          let pos = mapping.getMirror(--iRebased);
          if (pos == null)
            return;
          newUntil = Math.min(newUntil, pos);
          let map2 = mapping.maps[pos];
          if (item.step) {
            let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
            let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
            if (selection)
              eventCount++;
            rebasedItems.push(new Item(map2, step, selection));
          } else {
            rebasedItems.push(new Item(map2));
          }
        }, start);
        let newMaps = [];
        for (let i2 = rebasedCount; i2 < newUntil; i2++)
          newMaps.push(new Item(mapping.maps[i2]));
        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
        let branch = new _Branch(items, eventCount);
        if (branch.emptyItemCount() > max_empty_items)
          branch = branch.compress(this.items.length - rebasedItems.length);
        return branch;
      }
      emptyItemCount() {
        let count = 0;
        this.items.forEach((item) => {
          if (!item.step)
            count++;
        });
        return count;
      }
      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      compress(upto = this.items.length) {
        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
        let items = [], events = 0;
        this.items.forEach((item, i2) => {
          if (i2 >= upto) {
            items.push(item);
            if (item.selection)
              events++;
          } else if (item.step) {
            let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
            mapFrom--;
            if (map2)
              remap.appendMap(map2, mapFrom);
            if (step) {
              let selection = item.selection && item.selection.map(remap.slice(mapFrom));
              if (selection)
                events++;
              let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
              if (merged = items.length && items[last].merge(newItem))
                items[last] = merged;
              else
                items.push(newItem);
            }
          } else if (item.map) {
            mapFrom--;
          }
        }, this.items.length, 0);
        return new _Branch(dist_default2.from(items.reverse()), events);
      }
    };
    Branch.empty = new Branch(dist_default2.empty, 0);
    function cutOffEvents(items, n) {
      let cutPoint;
      items.forEach((item, i2) => {
        if (item.selection && n-- == 0) {
          cutPoint = i2;
          return false;
        }
      });
      return items.slice(cutPoint);
    }
    var Item = class _Item {
      constructor(map2, step, selection, mirrorOffset) {
        this.map = map2;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
      }
      merge(other) {
        if (this.step && other.step && !other.selection) {
          let step = other.step.merge(this.step);
          if (step)
            return new _Item(step.getMap().invert(), step, this.selection);
        }
      }
    };
    var HistoryState = class {
      constructor(done, undone, prevRanges, prevTime, prevComposition) {
        this.done = done;
        this.undone = undone;
        this.prevRanges = prevRanges;
        this.prevTime = prevTime;
        this.prevComposition = prevComposition;
      }
    };
    var DEPTH_OVERFLOW = 20;
    function applyTransaction(history2, state, tr, options) {
      let historyTr = tr.getMeta(historyKey), rebased;
      if (historyTr)
        return historyTr.historyState;
      if (tr.getMeta(closeHistoryKey))
        history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
      let appended = tr.getMeta("appendedTransaction");
      if (tr.steps.length == 0) {
        return history2;
      } else if (appended && appended.getMeta(historyKey)) {
        if (appended.getMeta(historyKey).redo)
          return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
        else
          return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
      } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
        let composition = tr.getMeta("composition");
        let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
        let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
        return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
      } else if (rebased = tr.getMeta("rebased")) {
        return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
      } else {
        return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
      }
    }
    function isAdjacentTo(transform, prevRanges) {
      if (!prevRanges)
        return false;
      if (!transform.docChanged)
        return true;
      let adjacent = false;
      transform.mapping.maps[0].forEach((start, end) => {
        for (let i2 = 0; i2 < prevRanges.length; i2 += 2)
          if (start <= prevRanges[i2 + 1] && end >= prevRanges[i2])
            adjacent = true;
      });
      return adjacent;
    }
    function rangesFor(maps) {
      let result = [];
      for (let i2 = maps.length - 1; i2 >= 0 && result.length == 0; i2--)
        maps[i2].forEach((_from, _to, from2, to) => result.push(from2, to));
      return result;
    }
    function mapRanges(ranges, mapping) {
      if (!ranges)
        return null;
      let result = [];
      for (let i2 = 0; i2 < ranges.length; i2 += 2) {
        let from2 = mapping.map(ranges[i2], 1), to = mapping.map(ranges[i2 + 1], -1);
        if (from2 <= to)
          result.push(from2, to);
      }
      return result;
    }
    function histTransaction(history2, state, redo2) {
      let preserveItems = mustPreserveItems(state);
      let histOptions = historyKey.get(state).spec.config;
      let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
      if (!pop)
        return null;
      let selection = pop.selection.resolve(pop.transform.doc);
      let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
      let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
      return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
    }
    var cachedPreserveItems = false;
    var cachedPreserveItemsPlugins = null;
    function mustPreserveItems(state) {
      let plugins = state.plugins;
      if (cachedPreserveItemsPlugins != plugins) {
        cachedPreserveItems = false;
        cachedPreserveItemsPlugins = plugins;
        for (let i2 = 0; i2 < plugins.length; i2++)
          if (plugins[i2].spec.historyPreserveItems) {
            cachedPreserveItems = true;
            break;
          }
      }
      return cachedPreserveItems;
    }
    var historyKey = new PluginKey("history");
    var closeHistoryKey = new PluginKey("closeHistory");
    function history(config = {}) {
      config = {
        depth: config.depth || 100,
        newGroupDelay: config.newGroupDelay || 500
      };
      return new Plugin({
        key: historyKey,
        state: {
          init() {
            return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
          },
          apply(tr, hist, state) {
            return applyTransaction(hist, state, tr, config);
          }
        },
        config,
        props: {
          handleDOMEvents: {
            beforeinput(view, e) {
              let inputType = e.inputType;
              let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
              if (!command2)
                return false;
              e.preventDefault();
              return command2(view.state, view.dispatch);
            }
          }
        }
      });
    }
    function buildCommand(redo2, scroll) {
      return (state, dispatch) => {
        let hist = historyKey.getState(state);
        if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
          return false;
        if (dispatch) {
          let tr = histTransaction(hist, state, redo2);
          if (tr)
            dispatch(scroll ? tr.scrollIntoView() : tr);
        }
        return true;
      };
    }
    var undo = buildCommand(false, true);
    var redo = buildCommand(true, true);
    var undoNoScroll = buildCommand(false, false);
    var redoNoScroll = buildCommand(true, false);
    var History = Extension.create({
      name: "history",
      addOptions() {
        return {
          depth: 100,
          newGroupDelay: 500
        };
      },
      addCommands() {
        return {
          undo: () => ({ state, dispatch }) => {
            return undo(state, dispatch);
          },
          redo: () => ({ state, dispatch }) => {
            return redo(state, dispatch);
          }
        };
      },
      addProseMirrorPlugins() {
        return [
          history(this.options)
        ];
      },
      addKeyboardShortcuts() {
        return {
          "Mod-z": () => this.editor.commands.undo(),
          "Shift-Mod-z": () => this.editor.commands.redo(),
          "Mod-y": () => this.editor.commands.redo(),
          // Russian keyboard layouts
          "Mod-\u044F": () => this.editor.commands.undo(),
          "Shift-Mod-\u044F": () => this.editor.commands.redo()
        };
      }
    });
    var HorizontalRule = Node2.create({
      name: "horizontalRule",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      parseHTML() {
        return [{ tag: "hr" }];
      },
      renderHTML({ HTMLAttributes }) {
        return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
      },
      addCommands() {
        return {
          setHorizontalRule: () => ({ chain, state }) => {
            const { selection } = state;
            const { $from: $originFrom, $to: $originTo } = selection;
            const currentChain = chain();
            if ($originFrom.parentOffset === 0) {
              currentChain.insertContentAt({
                from: Math.max($originFrom.pos - 1, 0),
                to: $originTo.pos
              }, {
                type: this.name
              });
            } else if (isNodeSelection(selection)) {
              currentChain.insertContentAt($originTo.pos, {
                type: this.name
              });
            } else {
              currentChain.insertContent({ type: this.name });
            }
            return currentChain.command(({ tr, dispatch }) => {
              var _a;
              if (dispatch) {
                const { $to } = tr.selection;
                const posAfter = $to.end();
                if ($to.nodeAfter) {
                  if ($to.nodeAfter.isTextblock) {
                    tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
                  } else if ($to.nodeAfter.isBlock) {
                    tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
                  } else {
                    tr.setSelection(TextSelection.create(tr.doc, $to.pos));
                  }
                } else {
                  const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                  if (node) {
                    tr.insert(posAfter, node);
                    tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
                  }
                }
                tr.scrollIntoView();
              }
              return true;
            }).run();
          }
        };
      },
      addInputRules() {
        return [
          nodeInputRule({
            find: /^(?:---|-|___\s|\*\*\*\s)$/,
            type: this.type
          })
        ];
      }
    });
    var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
    var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
    var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
    var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
    var Italic = Mark2.create({
      name: "italic",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "em"
          },
          {
            tag: "i",
            getAttrs: (node) => node.style.fontStyle !== "normal" && null
          },
          {
            style: "font-style=normal",
            clearMark: (mark) => mark.type.name === this.name
          },
          {
            style: "font-style=italic"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setItalic: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleItalic: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetItalic: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-i": () => this.editor.commands.toggleItalic(),
          "Mod-I": () => this.editor.commands.toggleItalic()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: starInputRegex2,
            type: this.type
          }),
          markInputRule({
            find: underscoreInputRegex2,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: starPasteRegex2,
            type: this.type
          }),
          markPasteRule({
            find: underscorePasteRegex2,
            type: this.type
          })
        ];
      }
    });
    var ListItem = Node2.create({
      name: "listItem",
      addOptions() {
        return {
          HTMLAttributes: {},
          bulletListTypeName: "bulletList",
          orderedListTypeName: "orderedList"
        };
      },
      content: "paragraph block*",
      defining: true,
      parseHTML() {
        return [
          {
            tag: "li"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addKeyboardShortcuts() {
        return {
          Enter: () => this.editor.commands.splitListItem(this.name),
          Tab: () => this.editor.commands.sinkListItem(this.name),
          "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
      }
    });
    var ListItemName2 = "listItem";
    var TextStyleName2 = "textStyle";
    var inputRegex4 = /^(\d+)\.\s$/;
    var OrderedList = Node2.create({
      name: "orderedList",
      addOptions() {
        return {
          itemTypeName: "listItem",
          HTMLAttributes: {},
          keepMarks: false,
          keepAttributes: false
        };
      },
      group: "block list",
      content() {
        return `${this.options.itemTypeName}+`;
      },
      addAttributes() {
        return {
          start: {
            default: 1,
            parseHTML: (element) => {
              return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
            }
          },
          type: {
            default: null,
            parseHTML: (element) => element.getAttribute("type")
          }
        };
      },
      parseHTML() {
        return [
          {
            tag: "ol"
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        const _a = HTMLAttributes, { start } = _a, attributesWithoutStart = __objRest(_a, ["start"]);
        return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          toggleOrderedList: () => ({ commands: commands2, chain }) => {
            if (this.options.keepAttributes) {
              return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
            }
            return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        };
      },
      addInputRules() {
        let inputRule = wrappingInputRule({
          find: inputRegex4,
          type: this.type,
          getAttributes: (match) => ({ start: +match[1] }),
          joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
        });
        if (this.options.keepMarks || this.options.keepAttributes) {
          inputRule = wrappingInputRule({
            find: inputRegex4,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: (match) => __spreadValues({ start: +match[1] }, this.editor.getAttributes(TextStyleName2)),
            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
            editor: this.editor
          });
        }
        return [
          inputRule
        ];
      }
    });
    var Paragraph = Node2.create({
      name: "paragraph",
      priority: 1e3,
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      group: "block",
      content: "inline*",
      parseHTML() {
        return [
          { tag: "p" }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setParagraph: () => ({ commands: commands2 }) => {
            return commands2.setNode(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Alt-0": () => this.editor.commands.setParagraph()
        };
      }
    });
    var inputRegex5 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
    var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
    var Strike = Mark2.create({
      name: "strike",
      addOptions() {
        return {
          HTMLAttributes: {}
        };
      },
      parseHTML() {
        return [
          {
            tag: "s"
          },
          {
            tag: "del"
          },
          {
            tag: "strike"
          },
          {
            style: "text-decoration",
            consuming: false,
            getAttrs: (style2) => style2.includes("line-through") ? {} : false
          }
        ];
      },
      renderHTML({ HTMLAttributes }) {
        return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
        return {
          setStrike: () => ({ commands: commands2 }) => {
            return commands2.setMark(this.name);
          },
          toggleStrike: () => ({ commands: commands2 }) => {
            return commands2.toggleMark(this.name);
          },
          unsetStrike: () => ({ commands: commands2 }) => {
            return commands2.unsetMark(this.name);
          }
        };
      },
      addKeyboardShortcuts() {
        return {
          "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        };
      },
      addInputRules() {
        return [
          markInputRule({
            find: inputRegex5,
            type: this.type
          })
        ];
      },
      addPasteRules() {
        return [
          markPasteRule({
            find: pasteRegex2,
            type: this.type
          })
        ];
      }
    });
    var Text = Node2.create({
      name: "text",
      group: "inline"
    });
    var StarterKit = Extension.create({
      name: "starterKit",
      addExtensions() {
        const extensions = [];
        if (this.options.bold !== false) {
          extensions.push(Bold.configure(this.options.bold));
        }
        if (this.options.blockquote !== false) {
          extensions.push(Blockquote.configure(this.options.blockquote));
        }
        if (this.options.bulletList !== false) {
          extensions.push(BulletList.configure(this.options.bulletList));
        }
        if (this.options.code !== false) {
          extensions.push(Code.configure(this.options.code));
        }
        if (this.options.codeBlock !== false) {
          extensions.push(CodeBlock.configure(this.options.codeBlock));
        }
        if (this.options.document !== false) {
          extensions.push(Document.configure(this.options.document));
        }
        if (this.options.dropcursor !== false) {
          extensions.push(Dropcursor.configure(this.options.dropcursor));
        }
        if (this.options.gapcursor !== false) {
          extensions.push(Gapcursor.configure(this.options.gapcursor));
        }
        if (this.options.hardBreak !== false) {
          extensions.push(HardBreak.configure(this.options.hardBreak));
        }
        if (this.options.heading !== false) {
          extensions.push(Heading.configure(this.options.heading));
        }
        if (this.options.history !== false) {
          extensions.push(History.configure(this.options.history));
        }
        if (this.options.horizontalRule !== false) {
          extensions.push(HorizontalRule.configure(this.options.horizontalRule));
        }
        if (this.options.italic !== false) {
          extensions.push(Italic.configure(this.options.italic));
        }
        if (this.options.listItem !== false) {
          extensions.push(ListItem.configure(this.options.listItem));
        }
        if (this.options.orderedList !== false) {
          extensions.push(OrderedList.configure(this.options.orderedList));
        }
        if (this.options.paragraph !== false) {
          extensions.push(Paragraph.configure(this.options.paragraph));
        }
        if (this.options.strike !== false) {
          extensions.push(Strike.configure(this.options.strike));
        }
        if (this.options.text !== false) {
          extensions.push(Text.configure(this.options.text));
        }
        return extensions;
      }
    });
    var RichEditor = () => {
      var _a;
      const element = document.getElementById("rich-editor-root");
      const initialContent = ((_a = element == null ? void 0 : element.dataset) == null ? void 0 : _a.initialContent) || "";
      const editor = useEditor({
        extensions: [StarterKit],
        content: initialContent,
        autofocus: true,
        editable: true,
        onUpdate: ({ editor: editor2 }) => {
          const html = editor2.getHTML();
          const hiddenField = document.getElementById("memo_content_input");
          if (hiddenField) hiddenField.value = html;
        }
      });
      (0, import_react2.useEffect)(() => {
        if (!editor) return;
        const hiddenField = document.getElementById("memo_content_input");
        if (hiddenField) hiddenField.value = editor.getHTML();
      }, [editor]);
      if (!editor) return null;
      return /* @__PURE__ */ import_react2.default.createElement("div", null, /* @__PURE__ */ import_react2.default.createElement(
        "div",
        {
          className: "form-control rhodia-grid-bg",
          style: {
            minHeight: "9em",
            overflowY: "auto",
            borderRadius: "0.375rem"
          }
        },
        /* @__PURE__ */ import_react2.default.createElement(EditorContent, { editor, className: "w-100 ProseMirror" })
      ));
    };
    var RichEditor_default = RichEditor;
    document.addEventListener("turbo:load", () => {
      const editorRoot = document.getElementById("rich-editor-root");
      if (editorRoot && !editorRoot.dataset.mounted) {
        editorRoot.dataset.mounted = "true";
        const root = (0, import_client.createRoot)(editorRoot);
        root.render(/* @__PURE__ */ import_react4.default.createElement(RichEditor_default, null));
      }
    });
  })();
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tiptap/react/dist/index.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=rich_editor.js.map
