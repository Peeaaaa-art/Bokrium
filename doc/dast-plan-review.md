# OWASP ZAP を用いた CI 向けミニマム DAST 導入プラン — レビュー

## 1. 総合評価（5段階）

**評価: 4 / 5（良いが、実装前に数点の修正を推奨）**

- **理由**: CI 内テスト環境を対象にしたミニマム DAST という前提が明確で、`--network host` による ZAP 実行方式の選定も妥当。一方で、Rails のバックグラウンド起動の生存保証、ZAP のレポート出力先の指定、起動待ちの判定条件など、そのまま実装すると Agent や初回実行で失敗しやすい箇所がいくつかある。これらをプランに明記してから実装すれば、安定して動作し、役割と限界も適切に定義された「CI 向けミニマム DAST」として成立する。

---

## 2. 良い点（このまま残すべき設計判断）

- **スキャン対象を CI 内テスト環境に限定**: 本番を叩かず、Secrets 不要で、ミニマムの前提に合っている。
- **zaproxy/action-baseline を使わず `docker run --network host` を採用**: コンテナ内の localhost が runner の Rails に届かない問題を正しく理解した上で、公式イメージを直接使う判断は妥当。
- **既存の setup-rspec-env と services: postgres の流用**: RSpec と同じ環境で再現性が高く、設定の重複を避けている。
- **初回は -I と continue-on-error**: レポート確認を優先し、運用が固まってから厳格化する段階的設計になっている。
- **Baseline Scan の位置づけ**: パッシブ中心であることや「本格 DASTの代替ではない」と過大評価していない。

---

## 3. 問題点・改善余地（Agent 実装時に詰まりやすい点）

### 3.1 実装上のリスク

| 項目 | 内容 |
|------|------|
| **Rails サーバーの生存** | `bin/rails server ... &` のみだと、ステップ終了時にシェルが終了し、バックグラウンドプロセスに SIGHUP が送られて終了する可能性がある。次の「Wait for Rails」の時点でサーバーが落ちていると、起動待ちが永遠に失敗する。 |
| **起動待ちの判定** | `curl ... \| grep -q 200` のみだと、ルートが 302（例: 未ログインでログイン画面へリダイレクト）のアプリでは 200 が返らず、起動待ちが失敗する。本プロジェクトは `get "/up"` で 200 を返すので、`/up` を叩くか、200/302 のどちらも成功とみなす必要がある。 |
| **ZAP のレポート出力先** | `-r report.html -J report.json` はコンテナ内の**カレントディレクトリ**に書かれる。ZAP イメージのデフォルト CWD は `/zap` であることが多く、`/zap/wrk` ではない。そのため `-v ${{ github.workspace }}:/zap/wrk` だけでは、レポートが workspace に落ちず、Upload artifact で `report.html` が見つからない可能性が高い。**絶対パスで `/zap/wrk/report.html` と `/zap/wrk/report.json` を指定する**必要がある。 |
| **Rails 起動時間** | CI では Vite ビルド済みでも Rails の初回起動に 30 秒以上かかることがある。30 回 × 2 秒で 60 秒は妥当だが、余裕を持ってリトライ回数や間隔を明記しておくと安心。 |

### 3.2 GitHub Actions 特有の注意点

| 項目 | 内容 |
|------|------|
| **Artifact の path** | 例では `path: report.html` のみ。本文では report.html / report.json の両方を保存するとあるが、ZAP の出力先を `/zap/wrk/` に合わせないと両方とも存在しない。また、両方アップロードするなら `path` を複数指定するか、`report.html` と `report.json` を列挙する必要がある（upload-artifact のバージョンによっては複数 path や glob が可能）。 |
| **continue-on-error の付与先** | ZAP ステップに付けるのは妥当。Upload artifact は `if-no-files-found: ignore` で、ファイルが無くてもジョブは成功になるので、ZAP がターゲット到達失敗でレポートを書かない場合の扱いが明確。 |
| **権限** | `contents: read` のみで Artifact アップロードは可能（書き込み先は GitHub のストレージのため）。問題なし。 |

### 3.3 OWASP ZAP Baseline の特性とプランの整合

- **できること**: パッシブスキャン（ヘッダー・Cookie・Content-Type・XSS 保護など）、約 1 分のスパイダーによる URL 発見。攻撃は送らない。
- **できないこと**: アクティブスキャン（SQLi/XSS 等の攻撃）、認証が必要なエリアの網羅、長時間のクロール。
- **プランの過不足**: 「ミニマム DAST」として Baseline の範囲内で使うという位置づけは適切。ルールファイルや -I の扱いも、初期導入としては問題ない。不足しているのは「レポートの出力先をマウント先に明示する」一点（上記のとおり）。

### 3.4 セキュリティ観点の妥当性

- **過信してはいけない点**: Baseline はパッシブのみ。SQLi・XSS・認証バイパスなどは検出しない。Brakeman や依存関係スキャンの代替ではなく、**ヘッダー・Cookie 設定などの退行検知の補助**として扱うのが正しい。プランはそのように限定されている。
- **CI に入れる意味**: 本番を叩かず、テスト環境だけで実行するため負荷・リスクが小さい。セキュリティヘッダーや Cookie の設定ミスを PR 段階で気づく用途として妥当。

---

## 4. 改善提案（優先度付き）

### 高（実装前に必ず反映すべき）

1. **Rails サーバーをステップ終了後も生存させる**  
   - `nohup bin/rails server -b 0.0.0.0 -p 3000 &` とするか、`( bin/rails server -b 0.0.0.0 -p 3000 & )` のうえで `disown` するなど、シェル終了後もプロセスが残るようにする旨をプランに明記する。
2. **ZAP のレポートをマウント先に必ず出力する**  
   - `zap-baseline.py` の引数を `-r /zap/wrk/report.html -J /zap/wrk/report.json` とする。これで workspace にレポートが確実に残り、Artifact で取得できる。
3. **起動待ちのターゲットを 200 が確実なパスにする**  
   - ルートが 302 になり得る場合は、`http://localhost:3000/up` を叩く（本プロジェクトは `/up` が 200）。または「200 または 302 を成功とする」とプランに書く。

### 中（安定運用のために推奨）

4. **Artifact で report.html と report.json の両方をアップロードする**  
   - `path` に `report.html` と `report.json` を指定する（複数指定可能な形式で）。または `path: 'report.*'` などで両方含める。
5. **起動待ちのリトライ回数・間隔をプランに記載**  
   - 例: 「最大 30 回、2 秒間隔（計 60 秒）」と明記し、Rails が重い場合の調整余地を残す。
6. **「役割と限界」をドキュメントに 1 行追加**  
   - 「Baseline はパッシブのみ。ヘッダー・Cookie 等の退行検知が主な目的であり、SQLi/XSS 等の攻撃検知は行わない」と doc やプランに書く。

### 低（余裕があれば）

7. **ZAP ステップでレポート未生成時の扱いを明記**  
   - ターゲットに到達できなかった場合、ZAP がレポートを書かないことがある。そのときは Artifact が空でもジョブは成功（if-no-files-found: ignore）とする旨をプランに書く。
8. **.zap/rules.tsv の例を後追いでドキュメント化**  
   - 誤検知を IGNORE する際のルールファイルの書き方を、運用メモに簡単に残す。

---

## 5. 改善後の「より良い導入方針」要約

**初期導入**: workflow_dispatch のみで実行。Rails は `nohup`（または disown）でバックグラウンド起動し、起動待ちは `http://localhost:3000/up` で 200 を確認。ZAP は `-r /zap/wrk/report.html -J /zap/wrk/report.json` で workspace にレポートを出力し、report.html と report.json の両方を Artifact で保存。ZAP ステップは `-I` と `continue-on-error: true` のままとし、レポート確認を優先する。

**定常運用**: レポートの傾向を把握したうえで、誤検知には `.zap/rules.tsv` を導入。必要なら push/PR トリガーを追加し、DAST を「必須ではないが実行される」ジョブとして回す。

**厳格化**: ルールで FAIL にしたい項目を決め、`-I` を外すか、特定ルールのみ FAIL にしたうえで、branch protection で DAST を必須チェックに含めるかは、チームの判断に委ねる。

このように、**「Rails の生存・起動判定・レポート出力先」をプランに明示したうえで実装すれば**、Agent 実装時の失敗を減らしつつ、CI 向けミニマム DAST として安定して役割を果たせる。
